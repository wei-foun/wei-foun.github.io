<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JavaScript 基础 | </title><meta name="keywords" content="JavaScript,ES6"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="let 和 constvar​    ES6 中新增的两个声明语法 let 和 const，原本 ES 的声明使用都是用 var，但是 var 的变量会因为声明提前，且 var 声明的变量是全局的，可以被任意修改，导致执行结果不是预期值 123console.log(a)     &#x2F;&#x2F; undefined，var a 声明变量会在最开始去执行，此时 a 没有赋值，执行输出，返回是 undefine">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 基础">
<meta property="og:url" content="http://example.com/882465098/index.html">
<meta property="og:site_name">
<meta property="og:description" content="let 和 constvar​    ES6 中新增的两个声明语法 let 和 const，原本 ES 的声明使用都是用 var，但是 var 的变量会因为声明提前，且 var 声明的变量是全局的，可以被任意修改，导致执行结果不是预期值 123console.log(a)     &#x2F;&#x2F; undefined，var a 声明变量会在最开始去执行，此时 a 没有赋值，执行输出，返回是 undefine">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover32.jpg">
<meta property="article:published_time" content="2021-03-22T08:03:53.000Z">
<meta property="article:modified_time" content="2025-04-01T17:58:07.130Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover32.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/882465098/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-02 01:58:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-22T08:03:53.000Z" title="发表于 2021-03-22 16:03:53">2021-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-01T17:58:07.130Z" title="更新于 2025-04-02 01:58:07">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>​    ES6 中新增的两个声明语法 let 和 const，原本 ES 的声明使用都是用 var，但是 var 的变量会因为声明提前，且 var 声明的变量是全局的，可以被任意修改，导致执行结果不是预期值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)     <span class="comment">// undefined，var a 声明变量会在最开始去执行，此时 a 没有赋值，执行输出，返回是 undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)     <span class="comment">// 1，因为 var 的变量提升，相当于将 var a = 1，拆成了 var a 和 a = 1 两个语句，并将 var a 放置在代码最前部，所以执行完 a = 1，a 就被赋值了</span></span><br></pre></td></tr></table></figure>
<p>​    所以，<strong>使用 var 定义变量，无论在代码的任何位置，最终都会成为一个全局作用域上的变量</strong>，那么在 for 循环语句中就会出现问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>​    在通过 var 变量 i 进行循环遍历后，数组 a 的每一个元素都是一个匿名函数，循环遍历完成后，全局的 i 就是 10，而当调用数组 a 的函数时，函数的输入是此刻全局的 i 的值，而不是循环中预期输出的值</p>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>​    针对 var 的问题，可以使用 ES6 新增的 let 语法来解决，<strong>let 的变量，只在声明的空间内有效，没有变量提升，并且同作用域中不能重复声明</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// 1，let 的变量不会有变量提升的问题 </span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined，全局空间不能访问 let 变量的值</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>​    这里的循环，会输出预期值，因为 let 的 i 变量只对当前这此循环的空间有效，所以数组 a 中的匿名函数对象在各自的空间内，都有一个变量 i，而 i 的值就是当前循环的次数</p>
<p>​    <strong>注意：一个循环语句 for，for 循环语法中的变量其实这个循环的父级作用域，而循环体内部的代码块有着自己单独的子作用域</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;    <span class="comment">// 用于计数的 i 和循环体内的 i 并不是一个作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<p>​    所以在 <strong>不同的空间作用域下，let 的变量名可以相同，并且相互之间不会影响，这就解决了 var 的变量可能存在的变量名污染问题</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>
<p>​    可见在 <strong>同一作用域下 let 的变量不允许重复声明</strong>，而 var 的变量是可以重复声明的，并且后一次会覆盖前一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);   <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    let 的出现为 ES6 带来了 <strong>块级作用域，即 {} 作为一个块，块可以嵌套，每一个块的作用域相互不干扰</strong>，所以更加明确了 let 的变量在不同作用域下，不会出现覆盖</p>
<p>​    <strong>注意：</strong>ES6 里规定了局部中存在 let  和 const 声明，那么这些变量就不能提前使用，即使这个变量在全局中存在，可不会和全局绑定，而是和内部封闭的作用域绑定，如果提前访问，那么直到变量被 let 或 const，都称为 “暂时性死区” temporal dead zone，简称 TDZ </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>​    <strong>const 的变量的特点是 只读，变量一经 const 声明就需要立即完成初始化赋值，这个值在之后就不能被更改</strong>，所以 const 都用来声明固定的值，比如常量</p>
<p>​    const 和 let 有类似的地方，比如都不会有变量提升，都存在自己的块级作用域防止污染，<strong>因为 const 的只读特点，所以 const 自然也不能重复声明</strong></p>
<p>​    <strong>注意：</strong>const 的不可变，本质上是不允许将 const 的值指向的内存地址所保存的数据被更改，但是需要特别注意，如果这个常量的数据类型是一个可变的容器类型，如数组，对象，那么数据的更改依旧是可以操作的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>​    是赋值操作的一种扩展方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c)    <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// ... 可以将剩余元素做解构赋值</span></span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3，数组是空，a 和 b 都匹配得到 undefined，所以触发默认值的赋值</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1，数组有元素 1，所以 a 和 b 的赋值将被 1 覆盖，默认值不生效</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2，数组中有两个元素，所以可以对应赋值给 a 和 b，默认值不生效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;  </span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;   // 对象的结构赋值，可以直接给出 key</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>​    <strong>ES6 在基本数据类型 string，number，boolean，objecct，null，undefined 之外，新增了 symbol</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="title class_">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="title function_">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="title class_">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>​    可见 symbol 类型可以确保每一个值都是不同的，所以可以作为对象的属性名</p>
<h4 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h4><table>
<thead>
<tr>
<th>null</th>
<th>undefined</th>
</tr>
</thead>
<tbody><tr>
<td>可作为赋值的值，表示变量不指向任何对象</td>
<td>也可作为赋值的值，变量未赋值时默认值是 undefined</td>
</tr>
<tr>
<td>使用 typeof 查看类型，会返回 object</td>
<td>使用 typeof 返回还是 undefined</td>
</tr>
<tr>
<td>null 表示的是值为空，或不存在引用</td>
<td>undefined 表示变量对定义或未赋值</td>
</tr>
<tr>
<td><strong>两个值为 null 的变量做 + - / * 时，会返回 0</strong></td>
<td><strong>两个值为 undefined 的变量做 + - / * 时，会返回 NaN</strong></td>
</tr>
</tbody></table>
<h3 id="Map-对象"><a href="#Map-对象" class="headerlink" title="Map 对象"></a>Map 对象</h3><p>​    map 和 object 很类似，都是键值对的形式，但是 <strong>object 的 key 只能是 string 或 symbo 两个类型，而 map 则没有这个限制</strong></p>
<p>​    并且 <strong>map 的键值是有顺序的，默认是 FIFO 的顺序，同时 ，map 对象可以通过 size 获取键值对个数，而 object 对象则需要通过遍历来计数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line">myMap.<span class="title function_">set</span>(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">get</span>(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.<span class="title function_">get</span>(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;;</span><br><span class="line">myMap.<span class="title function_">set</span>(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">get</span>(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot;</span></span><br><span class="line">myMap.<span class="title function_">get</span>(&#123;&#125;); <span class="comment">// undefined, 因为 keyObj !== &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 函数</span></span><br><span class="line">myMap.<span class="title function_">set</span>(keyFunc, <span class="string">&quot;和键 keyFunc 关联的值&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">get</span>(keyFunc); <span class="comment">// &quot;和键 keyFunc 关联的值&quot;</span></span><br><span class="line">myMap.<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;) <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>​    map 可以和 arry 相互转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap)    <span class="comment">// Map &#123; &#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(myMap))   <span class="comment">// [ [ &#x27;key1&#x27;, &#x27;value1&#x27; ], [ &#x27;key2&#x27;, &#x27;value2&#x27; ] ]</span></span><br></pre></td></tr></table></figure>
<h3 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h3><p>​    set 是元素唯一的集合，所以适合用来给数组去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...mySet]; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]); <span class="comment">// &#123;1, 2, 3, 4&#125;   // 并集</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x))); <span class="comment">// &#123;2, 3&#125;   // 交集</span></span><br><span class="line"><span class="keyword">var</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x))); <span class="comment">// &#123;1&#125;    // 差集</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">string.<span class="title function_">includes</span>(<span class="string">&quot;banana&quot;</span>);     <span class="comment">// true     // includes 方法返回参数字符串是否在 string 中出现</span></span><br><span class="line">string.<span class="title function_">startsWith</span>(<span class="string">&quot;apple&quot;</span>);    <span class="comment">// true     // startWith 方法返回参数字符串是否是 string 的头部</span></span><br><span class="line">string.<span class="title function_">endsWith</span>(<span class="string">&quot;apple&quot;</span>);      <span class="comment">// false    // endWith 方法返回参数字符串是否是 string 的尾部</span></span><br><span class="line">string.<span class="title function_">startsWith</span>(<span class="string">&quot;banana&quot;</span>,<span class="number">6</span>)  <span class="comment">// true     // 从索引 6 开始字符串的头部是否是参数字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*&quot;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>));    <span class="comment">// &quot;**&quot;     // repeat 方法接收一个正数，用来重复字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>,<span class="string">&quot;0&quot;</span>));  <span class="comment">// &quot;00001&quot;   // padStart 和 padEnd 都可以接收两个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>,<span class="string">&quot;0&quot;</span>));    <span class="comment">// &quot;10000&quot;   // 第一个参数是补全后字符串的最小长度，补全的字符串超过该值则会被截断</span></span><br><span class="line">                                                <span class="comment">// 第二个参数是补全使用的字符串，默认是空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>)  <span class="comment">// hello ham    // `` 是模板字符串，可以用来当做格式化字符串操作</span></span><br></pre></td></tr></table></figure>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b11</span>   <span class="comment">// 0b 或 0B 表示二进制</span></span><br><span class="line"><span class="number">0o11</span>   <span class="comment">// 0o 或 0O 表示八进制</span></span><br><span class="line"></span><br><span class="line">number.<span class="built_in">parseInt</span>()     <span class="comment">// parseInt 方法从全局方法改为 number 对象的方法，但全局的 parseInt 方法依然保留</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseFloat</span>()   <span class="comment">// 同理 parseInt，也保留了全局方法</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>);   <span class="comment">// 3   // parseInt 的第二个参数，是指定数值的进制，默认 parseInt 是 10 进制</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">0</span>)   <span class="comment">// isInteger 判断是否为整数，如果参数是字符串，返回的是 false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="number">10.2</span>)    <span class="comment">// 10  // math 模块的 trunc 方法返回数字的整数部分，如果参数是字符串会被转为数值类型后操作</span></span><br></pre></td></tr></table></figure>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><p>​    对象的创建是使用 Object 的 create 方法，该方法会通过将原型对象作为参数传递创建一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)      <span class="comment">// 等同于字面量方式 var object = &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>​    js 中还有一种基于函数来创建对象，也就是构造器函数，这种方式在创建对象时需要使用 new 关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;           <span class="comment">// 构造函数 的特点是，函数名的首字母是大写的</span></span><br><span class="line">    <span class="keyword">var</span> object = &#123;&#125;</span><br><span class="line">    object.<span class="property">name</span> = name</span><br><span class="line">    object.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line">    <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ham&#x27;</span>)    <span class="comment">// 注意使用 new 来实例对象</span></span><br></pre></td></tr></table></figure>
<p>​    如果构造器函数中有固定的默认值，也可以在构造器函数的原型上定义属性或方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;ham&#x27;</span>     <span class="comment">// 在构造函数的原型对象上创建 name 属性</span></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ham&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> d2 = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;...d1, ...d2&#125;)   <span class="comment">// &#123; name: &#x27;ham&#x27;, age: 21 &#125;   // 可以用 &#123;&#125; 和 ... 合并多个对象</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(d1, d2)    <span class="comment">// Object.assign 方法同样可以合并多个数组，合并的结果会在第一个参数的对象上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d1)          <span class="comment">// &#123; name: &#x27;ham&#x27;, age: 21 &#125;</span></span><br><span class="line"><span class="comment">// 注意 assign 方法拷贝是浅拷贝，所以原对象中的值改变，合并后的对象的值也会改变</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>]);  <span class="comment">// [5,3]  </span></span><br><span class="line"><span class="comment">// Object.assign 还可以合并数组，但合并时会将 [1,3] 转为 &#123;0:1, 1:3&#125;，[5] 转为 &#123;0:5&#125;，所以合并后就是 &#123;0:5, 1:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">1</span>,<span class="number">1</span>);       <span class="comment">// true  // Object.is 方法判断两个值是否严格相等，类似于 ===</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(d1)     <span class="comment">// freeze 方法接收一个对象，会让该对象变为不可变对象，即无法修改属性和值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(d1)   <span class="comment">// isFrozen 方法接收一个对象，用于判断该对象是否是冻结状态</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(d1)       <span class="comment">// seal 方法同样接收一个对象，不同于 freeze 的是 seal 方法密封对象后，对象属性可修改</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数，原型对象，原型链"><a href="#构造函数，原型对象，原型链" class="headerlink" title="构造函数，原型对象，原型链"></a>构造函数，原型对象，原型链</h4><p>​    构造函数可以看作是一个类，通过使用 <code>new</code> 关键字来创建实例对象</p>
<p>​    对于 <strong>构造函数 来说，它还有个属性 <code>prototype</code>，指向的是构造函数的 原型对象，而对于这个 原型对象，它有一个 <code>constructor</code> 的属性，指向的是这个 构造函数</strong></p>
<p>​    当通过 new 实例出构造函数的实例对象后，这个 <strong>实例对象会有一个隐式属性 <code>__prot__</code>，这个属性同样指向的是构造函数 <code>prototype</code> 所指向的 原型对象 的 <code>prototype</code></strong>，这样一来对于实例对象来说，就可以通过这个隐式属性去原型对象上寻找在构造函数上没有定义的属性或方法</p>
<p>​    对于 构造函数 中 <code>prototype</code> 所指向的 原型对象 并不是最后的对象，这个 原型对象 也拥有一个 <code>__proto__</code> 属性指向上一层的 原型对象，而这个对象其实就是 js 的 Object 对象</p>
<p><img src="https://wei-foun.github.io/img/%E5%8E%9F%E5%9E%8B%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="img"></p>
<p>​    <strong>原型链，就是当一个对象调用的属性/方法自身不存在时，就会去自己 <code>__proto__</code> 关联的前辈 <code>prototype</code> 对象上去找，如果没找到，就会去该原型对象 <code>__proto__</code> 关联的前辈 <code>prototype</code> 去找。依次类推，直到找到属性/方法 undefined 为止</strong></p>
<p>​    <strong>补充：使用 new 实例化对象时，会创建一个 this 变量引用该对象，属性和方法会被加入到 this 引用的对象中</strong></p>
<h4 id="call，apply，bind"><a href="#call，apply，bind" class="headerlink" title="call，apply，bind"></a>call，apply，bind</h4><p>​    这三个函数的作用是类似的，都可以改变 this 的指向问题</p>
<p>​    <strong>call 方法</strong>：<strong>需要满足 this 调用属性，参数也逐个对应</strong>，如果参数没有给值，或者 this 的属性不存在，都返回 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee1 = &#123;<span class="attr">firstName</span>: <span class="string">&#x27;alex&#x27;</span>, <span class="attr">lastName</span>: <span class="string">&#x27;ham&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> employee2 = &#123;<span class="attr">firstName</span>: <span class="string">&#x27;tony&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invite</span>(<span class="params">greeting1, greeting2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting1 + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>+ <span class="string">&#x27;, &#x27;</span>+ greeting2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invite.<span class="title function_">call</span>(employee1, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;How are you?&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello alex ham, How are you?</span></span><br><span class="line">invite.<span class="title function_">call</span>(employee2, <span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello tony undefined, undefined</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>apply 方法</strong>：<strong>和 call 类似，但 apply 允许接收一个数组作为参数</strong>，这样就是省去了用 call 方法需要一个个将参数传递，因此 call 和 apply 方法可以相互转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invite.<span class="title function_">apply</span>(employee1, [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;How are you?&#x27;</span>])</span><br><span class="line"><span class="comment">// Hello alex ham, How are you?</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>bind 方法</strong>：和前两者有所不同，<strong>通过 bind 调用时，实际上会产生一个新函数，bind 会将 this 传递给 bind 方法的第一个参数，而函数原本的参数需要传递给使用 bind 创建的新函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inviteEmployee1 = invite.<span class="title function_">bind</span>(employee1)</span><br><span class="line"><span class="title function_">inviteEmployee1</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;How are you?&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello alex ham, How are you?</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h4><p>​    对于构造函数来说，继承需要通过改变 this 指向来实现，这样实现的好处是拒绝了引用的属性被实例所共享，因为 this 只会指向调用者，但是这种继承存在父类的原型不会被子类继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;parent1&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);<span class="variable language_">this</span>.<span class="property">type</span>=<span class="string">&#x27;child&#x27;</span>&#125;</span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">Child</span>()   <span class="comment">// Child &#123;name: &#x27;parent1&#x27;, type: &#x27;child&#x27;&#125;</span></span><br><span class="line">s1.<span class="property">name</span>=<span class="string">&#x27;child1&#x27;</span></span><br><span class="line">s2 = <span class="keyword">new</span> <span class="title class_">Child</span>()   <span class="comment">// Child &#123;name: &#x27;parent1&#x27;, type: &#x27;child&#x27;&#125;</span></span><br><span class="line">s1.<span class="property">name</span>            <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line">s2.<span class="property">name</span>            <span class="comment">// &#x27;parent1&#x27;</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;    <span class="comment">// ƒ () &#123;&#125;</span></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="title class_">Parent</span>()  <span class="comment">// Parent &#123;name: &#x27;parent1&#x27;&#125;</span></span><br><span class="line">p1.<span class="property">say</span>             <span class="comment">// ƒ () &#123;&#125;</span></span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">Child</span>()   <span class="comment">// Child &#123;name: &#x27;parent1&#x27;, type: &#x27;child&#x27;&#125;</span></span><br><span class="line">s1.<span class="property">say</span>             <span class="comment">// undefined     // 父类原型的方法无法被子类使用</span></span><br></pre></td></tr></table></figure>
<h4 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h4><p>​    利用了实例对象和构造函数都有属性指向原型对象的特点，将子类的 prototype 属性改为父类构造函数的实例对象，这样子类相当于继承了父类所有的属性和方法</p>
<p>​    但是使用原型链继承，如果原型的属性和方法被修改，那么子类的不同实例对象都会共享这个原型的修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;parent1&#x27;</span>;<span class="variable language_">this</span>.<span class="property">list</span>=[<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span>=name&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"></span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;alex&#x27;</span>)    <span class="comment">// Child &#123;name: &#x27;alex&#x27;&#125;</span></span><br><span class="line">s2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;tony&#x27;</span>)    <span class="comment">// Child &#123;name: &#x27;tony&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">s1.<span class="property">list</span>  <span class="comment">// [1, 2]</span></span><br><span class="line">s2.<span class="property">list</span>  <span class="comment">// [1, 2]</span></span><br><span class="line">s1.<span class="property">list</span>.<span class="title function_">push</span>(<span class="number">3</span>)       <span class="comment">// 父类属性修改会影响所有的子类</span></span><br><span class="line">s1.<span class="property">list</span>  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">s2.<span class="property">list</span>  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><h4 id="slice-和-splice"><a href="#slice-和-splice" class="headerlink" title="slice 和 splice"></a>slice 和 splice</h4><p>​    slice 是基本的数组切片操作，<strong>slice 的返回是一个新数组</strong>，所以 slice 操作 <strong>不会对原数组造成修改</strong></p>
<p>​    splice 是根据索引来向数组添加或删除的操作，<strong>会将删除的元素放入数组返回</strong>，同时也 <strong>会对原数组造成修改</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">2</span>)    <span class="comment">// [1,2]</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>(<span class="number">4</span>)      <span class="comment">// [5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">2</span>)             <span class="comment">// [1,2]    arr = [3,4,5]   splice 修改了原数组</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)   <span class="comment">// [4]      arr = [1,2,3,&#x27;a&#x27;,&#x27;b&#x27;,5]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">10</span>)    <span class="comment">// [10,10,10]   // Array(3) 预设一个长度为 3 的数组，fill 方法将参数作为每一个元素的值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)        <span class="comment">// [1,2,3]    // Array.of 方法可以接受多个参数，并全部加入到数组中返回</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)    <span class="comment">// [1,2,3]    // Array.from 方法可以将可迭代对象转为数组</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;)  <span class="comment">// [1,2]   // Array.from 方法可以接受类数组对象，但必须要要有 length 属性，否则就会返回空数组 []，注意类数组对象的 key 必须是数值，否则数组的元素会是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n * <span class="number">2</span>))   <span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="comment">// Array.from 方法的第二个参数 mapFn，map 函数会将数组每一个元素代入 map 函数做操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="attr">do</span>: <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrayLike = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="keyword">function</span> (<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">do</span>(n);      <span class="comment">// Array.from 方法的第三个参数是 map，可以指定 this 用来做更加复杂的操作</span></span><br><span class="line">&#125;, map)); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">keys</span>())   <span class="comment">// [0,1,2]   // 组合使用 Array 和 from 创建 0-2 的数组</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)          <span class="comment">// 3   // find 方法可以返回符合条件的第一个元素</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)    <span class="comment">// 1   // findIndex 方法返回符合条件的第一个元素的索引</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)   <span class="comment">// true    // includes 方法和 string 的一致，是否包含参数元素</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span> ,[<span class="number">2</span>, <span class="number">3</span>]].<span class="title function_">flat</span>()    <span class="comment">// [1, 2, 3]    // flat 方法可以将嵌套的多为数组拉平成一维数组，flat 方法参数为 Infinity 则无视原数组有多少嵌套，元素都会在一个一维数组</span></span><br></pre></td></tr></table></figure>
<p>​    数组的遍历，有点像是对象的遍历，数组的索引为 key，而 value 则是索引对应的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 方法遍历</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">return</span> e**<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><p>​    ES-6 中函数有一种新的写法，就是箭头函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;     <span class="comment">// 参数部分 v，如果有多个，可以使用 () 包起来，函数体 v，如果有多行，需要使用 &#123;&#125; 包起来</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span>(<span class="params">v</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>需要注意的是 =&gt; 箭头函数适用于非方法的函数，因为箭头函数中没有 this，super</strong></p>
<p>​    <strong>箭头函数的内部的 this 指向的是全局的 window，但是可以用 call 或 apply 去改变 this 指向</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义时，this 绑定的是 fn 中的 this 对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// fn 的 this 对象为 &#123;a: 18&#125;</span></span><br><span class="line">fn.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">18</span>&#125;);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>​    立即调用函数，立即执行调用的函数表达式，就是说函数的定义和调用是在一起的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>​    <strong>立即调用函数的一个主要目的是实现数据隐私，在 IIFE 中定义的任何变量，在外部都无法直接访问</strong>，如果访问则会抛出异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;IIFE&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line"><span class="comment">// Error: message is not defined</span></span><br></pre></td></tr></table></figure>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>​    回调函数首先本身是一个函数，不同普通函数的是触发方式不同，回调函数做将自己作为一个函数的参数，换句话说就是将自己放入到函数内部，由外部函数才执行触发完成</p>
<p>​    由于 js 是一种事件驱动的语言，当使用 js 在侦听事件时，通常不会是等待响应而是要继续执行后续的操作或事件，所以回调是非常有必要的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callbackFunction</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="title function_">prompt</span>(<span class="string">&#x27;Please enter your name.&#x27;</span>)</span><br><span class="line">  <span class="title function_">callback</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">outerFunction</span>(callbackFunction)</span><br></pre></td></tr></table></figure>
<h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><p>​    <strong>回调地狱是一种包含多层嵌套回调函数</strong> 的情况，通常来说会出现回调地狱的一种情况是需要让异步函数按照顺序逐个执行，随着可能的层级越多，回调地狱的代码在可读性上会很复杂</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">async1</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async3</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">async4</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                ....</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​    <strong>ES6 新增了 class 关键字来使得类的定义更加清晰</strong>，使用 class 去定义类，本质上其实是 function，<strong>内部要定义初始化方法 constructor</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Example</span> = <span class="keyword">class</span> &#123;     <span class="comment">// Example.name 返回 Example</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a</span>) &#123;      <span class="comment">// constructor 方法是类的默认方法，创建实例对象时会自动调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;       <span class="comment">// constructor 中可以定义实例属性或实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Example</span> = <span class="keyword">class</span> <span class="title class_">Exam</span> &#123;   <span class="comment">// Example.name 返回 Exam </span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    使用 class 去定义类的方法时，实际上是定义在了原型上，class 创建的类保留了 prototype 属性，另外对于类而言，没有静态属性，只有静态方法，静态方法前需要加上关键字 static</p>
<p>​    同时，实例属性是在定义类时，在内部定义的变量，可以通过 this 去访问变量</p>
<p>​    当创建实例对象时，需要使用 new 关键字，这和构造函数创建对象一致</p>
<h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>​    装饰器的作用其实就是修改类的行为，本身实际上是一个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">target</span>) &#123;     <span class="comment">// 定义 testable 的装饰器函数，函数的第一个参数实际上就是类</span></span><br><span class="line">    target.<span class="property">isTestable</span> = <span class="literal">true</span>;   <span class="comment">// 给被装饰的类，添加一个属性 isTestable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Example</span>.<span class="property">isTestable</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>​    当然装饰器既然作为函数，自然就可以接受参数，当需定义装饰器参数时，就要创建一个嵌套函数，闭包函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">isTestable</span>) &#123;     <span class="comment">// isTestable 作为装饰器函数 testable 的参数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;       <span class="comment">// target 是被装饰的类，这里需要另外使用给一个函数接收这个类，形成闭包</span></span><br><span class="line">        target.<span class="property">isTestable</span>=isTestable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Example</span>.<span class="property">isTestable</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>​    装饰器是可以定义多个的，当一个函数或类装饰了多个装饰器，执行的顺序是由外向内进入， 即从上外下进入代码，执行的返回由内向外，即最下面的装饰器会最先返回，将结果给到上一层装饰器</p>
<h4 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h4><p>​    在默认的构造方法 constructor 里，使用 this 去初始化属性时，会默认调用 set 方法，使用实例对象去调用属性时，会调用 get  方法，setter 和 getter 必须同时存在，否则实例化对象时会抛出异常，并且 set 和 get 两个方法要在同一层中，如果因为继承，将两个方法分开也会出现问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">b</span> = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">a</span>()&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_a</span> = a;  <span class="comment">// 注意，这里如果写 this.a = a，存在递归调用，不断输出 setter，最后触发 RangeError</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> <span class="title class_">Example1</span>(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(exam1.<span class="property">_a</span>);           <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​    继承的关键字是 <strong>extends</strong>，另外要注意在子类中的 constructor 方法里还需要使用 super 方法，因为对于子类来说它没有自己的 this 属性，使用的是父类的 this 对象，如果不调用 super 方法在实例化时会报错</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father1</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_a</span> = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father1</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>();     <span class="comment">// 子类中，constrictor 构造方法必须要使用 super()，且要在使用初始化 this 进行赋值前调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> <span class="title class_">Child1</span>();</span><br><span class="line">test1.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test1.<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>​    是在 DOM 结构中，事件捕获会从上往下依次去捕获对应的触发事件，例如父层 div 元素设置有点击事件，子层同样有点击事件，当对子层触发点击时，事件会一级级向内触发捕获</p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>​    和事件捕获的顺序正好相反，<strong>事件冒泡是从下往上触发，点击事件会先从最内部对应的事件函数触发，然后一层层向外部触发对应的函数</strong></p>
<p>​    如果要 <strong>阻止事件在事件链的向上冒泡，可以使用事件的 stopProPagation 方法</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;secondFunc()&quot;</span>&gt;</span>DIV 2</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;firstFunc(event)&quot;</span>&gt;</span>DIV 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">firstFunc</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;DIV 1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  event.<span class="title function_">stopPropagation</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">secondFunc</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;DIV 2&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>​    是一种侦听事件的方式，<strong>可以在父级元素上绑定事件侦听，这样子级元素的事件都会被父级侦听到，可以有效减少事件 的注册和绑定</strong></p>
<p>​    addEventListener 方法接收三个参数，第一个参数是事件名称，名称无需写前缀 on，第二个参数是事件执行函数，第三个参数是布尔类型的值，true 表示在事件捕获阶段触发，false 表示在事件冒泡阶段触发，默认是 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#registration-form&#x27;</span>);</span><br><span class="line"><span class="comment">// 听从表单内字段的更改</span></span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="comment">// 记录已更改的字段</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="异步-promise"><a href="#异步-promise" class="headerlink" title="异步 promise"></a>异步 promise</h3><p>​    js 中通过 promise 对象来获取异步操作的消息，<strong>promise 有三个状态：pending（未完成态），fulfilled（完成态），rejected（失败态），而对于 promise 的最后状态就只有成功或失败</strong></p>
<p>​    promise 一旦创建执行，就无法进行取消只能等它执行完成，<strong>如果 promise 中没有设置回调，那么 promise 内部会抛出异常，而这个异常不会冒泡到外部</strong></p>
<p>​    <strong>promise 函数内部有两个回调参数，第一个是 resolve 即执行完成，第二个是 reject，即执行出现错误失败。promise 执行后，可以通过 then 方法去获取返回信息</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>promise 的 then 方法最后返回其实还是一个 promise 的对象，因此 promise 还可以继续调用 then 方法，也就说 promise 是支持链式调用的</strong></p>
<p>​    <strong>补充：promise 的 then 方法在 js 中 event loop 中是微任务（Microtask），所以会被加入到微任务的队列中进行处理，对于微任务的处理来说，也不同于宏任务队列，微任务的处理会在执行栈执行完成，清空后执行微任务队列中所有的微任务，而对于宏任务来说，宏任务的队列会有回栈操作</strong></p>
<p>​    除了 then 之外，<strong>promise 还有 all 的方法，all 方法可以接受一个数组参数，数组中每一个元素都是 promise</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3])</span><br></pre></td></tr></table></figure>
<p>​    <strong>当 p1，p2，p3 的状态全部都成功 fulfilled 时，p 的状态也会是 fulfilled，p1，p2，p3 的返回结果会以数组形式给到 p 的回调函数 then</strong></p>
<p>​    <strong>当 p1，p2，p3 的状态其中任意一个为 rejected 时，p 也会为 rejected，第一个状态为 rejected 的结果会给到 p 的回调函数</strong></p>
<p>​    和 all 方法正好相反的方法是 <strong>race 方法，参数同样是元素为 promise 的数组，但是只会将最先成功或拒绝的 promise 的结果返回给 p 的回调函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1,p2,p3])</span><br></pre></td></tr></table></figure>
<h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h3><p>​    生成器中可以使用 yield 关键，将函数的执行挂起，从而提供了改变程序执行流程的可能，为异步编程提供了解决方案</p>
<p>​    js 中的生成器函数会在关键字 function 后面加上 *，然后在需要挂起的地方之前，需要使用 yield 关键字，当执行获取返回时，需要使用 next 方法来开始或者回到上一次挂载的位置继续执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">func</span>(<span class="params"></span>)&#123;     <span class="comment">// function* 表示该函数是一个生成器函数</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    注意，生成器的执行机制和普通函数不太相同，虽然调用上都是直接加上 ()  就可以调用，但是生成器不会立即返回第一个结果，生成器函数调用后返回的是指向内部状态对象的指针，因此需要使用可迭代器对象的 next 方法，由 next 去操作指针的走动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title function_">func</span>()</span><br><span class="line">f.<span class="title function_">next</span>()    <span class="comment">// one       // &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>()    <span class="comment">// two       // &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>()    <span class="comment">// three     // &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>()                 <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>​    由此可见，第一次调用 next 方法后，输出了字符串 one，然后执行到 yield 关键字就停止了，yield 后的值作为了返回向的 value 的值，表示当前执行位置的状态是 1，且 done 属性是 false，表示生成器函数还没有执行结束</p>
<p>​    第二，三次调用 next 方法也是同理，不同的是第三次调用 next 后，输出了字符串 three 后，没有了 yield 的关键字，而是使用 return 来返回，意味着生成器函数到此已执行结束，所以 done 的值是 true。第四次调用 next 由于生成器已经结束，所以不会有任何输出</p>
<h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><p>​    关于 <strong>next 的调用有两种形式，一种是传参，一种是不传参。不传参的时候，yield 的返回是 undefined，而传参时，这个参数会作为 yield 的返回，也就是说下一次的 next 可以使用本次 next 所传递的参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">sendParameter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one:&quot;</span> + x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two:&quot;</span> + y);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;total:&quot;</span> + (x + y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp1 = <span class="title function_">sendParameter</span>();</span><br><span class="line">sendp1.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp1.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// one:undefined</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp1.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// two:undefined</span></span><br><span class="line"><span class="comment">// total:NaN</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp2 = <span class="title function_">sendParameter</span>();</span><br><span class="line">sendp2.<span class="title function_">next</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp2.<span class="title function_">next</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// one:20</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp2.<span class="title function_">next</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// two:30</span></span><br><span class="line"><span class="comment">// total:50</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="ES-7-的异步补充-async"><a href="#ES-7-的异步补充-async" class="headerlink" title="ES-7 的异步补充 async"></a>ES-7 的异步补充 async</h3><p>​    增加了关键字 async，当这个关键字出现在函数前，表示这个函数会返回一个 promise，async 简化了异步的编写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">helloAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">helloAsync</span>())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">helloAsync</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>​    与 async 对应的关键字是 await，如果 async 函数中出现 await 关键字，那么执行到 await 时会进行等待，等待 await 后返回的结果，await 关键字后面可以跟随 promise，这样的话就是表示在 async 异步函数中，需要等待内部 promise 的执行完成</p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/882465098/">http://example.com/882465098/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/ES6/">ES6</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover32.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2201923992/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover33.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Celery-整理</div></div></a></div><div class="next-post pull-right"><a href="/1674812330/"><img class="next-cover" src="https://wei-foun.github.io/img/cover31.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mysql-整理-三</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/3274678850/" title="JavaScript 逆向爬取实例(上)"><img class="cover" src="https://wei-foun.github.io/img/cover15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-06</div><div class="title">JavaScript 逆向爬取实例(上)</div></div></a></div><div><a href="/3660878595/" title="JavaScript 逆向爬取实例(下)"><img class="cover" src="https://wei-foun.github.io/img/cover16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-07</div><div class="title">JavaScript 逆向爬取实例(下)</div></div></a></div><div><a href="/2586209473/" title="JavaScript 混淆技术"><img class="cover" src="https://wei-foun.github.io/img/cover14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">JavaScript 混淆技术</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#let-%E5%92%8C-const"><span class="toc-number">1.</span> <span class="toc-text">let 和 const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#var"><span class="toc-number">1.1.</span> <span class="toc-text">var</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#let"><span class="toc-number">1.2.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">1.3.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">原始数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null-%E5%92%8C-undefined"><span class="toc-number">3.1.</span> <span class="toc-text">null 和 undefined</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">Map 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">Set 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95"><span class="toc-number">6.</span> <span class="toc-text">字符串扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95"><span class="toc-number">7.</span> <span class="toc-text">数值扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95"><span class="toc-number">8.</span> <span class="toc-text">对象扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">8.1.</span> <span class="toc-text">构造函数，原型对象，原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call%EF%BC%8Capply%EF%BC%8Cbind"><span class="toc-number">8.2.</span> <span class="toc-text">call，apply，bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">8.3.</span> <span class="toc-text">构造函数的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.</span> <span class="toc-text">原型链的继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95"><span class="toc-number">9.</span> <span class="toc-text">数组扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#slice-%E5%92%8C-splice"><span class="toc-number">9.1.</span> <span class="toc-text">slice 和 splice</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95"><span class="toc-number">10.</span> <span class="toc-text">函数扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IIFE"><span class="toc-number">10.1.</span> <span class="toc-text">IIFE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">10.3.</span> <span class="toc-text">回调地狱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">类装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getter-%E5%92%8C-setter"><span class="toc-number">11.2.</span> <span class="toc-text">getter 和 setter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">11.3.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">12.1.</span> <span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">12.2.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">12.3.</span> <span class="toc-text">事件委托</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-promise"><span class="toc-number">13.</span> <span class="toc-text">异步 promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generator"><span class="toc-number">14.</span> <span class="toc-text">生成器 Generator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#next"><span class="toc-number">14.1.</span> <span class="toc-text">next</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES-7-%E7%9A%84%E5%BC%82%E6%AD%A5%E8%A1%A5%E5%85%85-async"><span class="toc-number">15.</span> <span class="toc-text">ES-7 的异步补充 async</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1213981086/" title="k8s-调度"><img src="https://wei-foun.github.io/img/cover49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s-调度"/></a><div class="content"><a class="title" href="/1213981086/" title="k8s-调度">k8s-调度</a><time datetime="2025-08-02T07:25:30.000Z" title="发表于 2025-08-02 15:25:30">2025-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/558590641/" title="k8s整理"><img src="https://wei-foun.github.io/img/cover48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s整理"/></a><div class="content"><a class="title" href="/558590641/" title="k8s整理">k8s整理</a><time datetime="2025-07-31T07:24:29.000Z" title="发表于 2025-07-31 15:24:29">2025-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/466764255/" title="airflow整理"><img src="https://wei-foun.github.io/img/cover47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="airflow整理"/></a><div class="content"><a class="title" href="/466764255/" title="airflow整理">airflow整理</a><time datetime="2025-07-12T07:04:30.000Z" title="发表于 2025-07-12 15:04:30">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux再学习"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux再学习"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux再学习">Linux再学习</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4075015966/" title="GO 基础"><img src="https://wei-foun.github.io/img/cover45.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO 基础"/></a><div class="content"><a class="title" href="/4075015966/" title="GO 基础">GO 基础</a><time datetime="2025-07-04T16:26:58.000Z" title="发表于 2025-07-05 00:26:58">2025-07-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover32.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>