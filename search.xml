<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s-pod发布部署</title>
      <link href="/2938300177/"/>
      <url>/2938300177/</url>
      
        <content type="html"><![CDATA[<h3 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h3><h4 id="重建发布（recreate）"><a href="#重建发布（recreate）" class="headerlink" title="重建发布（recreate）"></a>重建发布（recreate）</h4><ul><li>优点：可以 <strong>一次性将所有 pod 重建</strong>，比如在测试中同一服务的 pod 分散在不同 node，想要快速更新时就可以使用这种方式</li><li>缺点：<strong>升级过程中，服务将无法访问，会造成业务中断</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-recreate</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span>            <span class="comment"># 相比普通 deployment，增加了 strategy 字段配置部署策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span>     <span class="comment"># type = recreate 表示使用重建发布方式</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-recreate</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-recreate</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-recreate</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.mooc.com/kubernetes/web:v1</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><h4 id="滚动更新（rolling-update）"><a href="#滚动更新（rolling-update）" class="headerlink" title="滚动更新（rolling-update）"></a>滚动更新（rolling-update）</h4><ul><li>优点：<strong>逐台滚动升级</strong>，例如三台设备的 v1 pod 升级，会先一台上创建 v2 pod，然后 v1 pod -= 1，v2 pod += 1，<strong>需要冗余设备协助升级，这个可以根据需要调整</strong></li><li>缺点：<strong>v1 到 v2 的升级过程中，流量是同时接入到 v1 与 v2 两个版本，会导致问题定位可能要复杂一点</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-rollingupdate</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span>          <span class="comment"># rollingUpdate 字段是配置滚动更新的具体配置</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span>         <span class="comment"># maxSurge 表示升级过程中最大可用实例数，值可以是百分比，也可是整数值，1 就表示发布时允许增加一个实例</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span>   <span class="comment"># maxunavailable 表示升级过程最大不可以用实例数，为 1 则表示发布时最多允许 1 个实例处于不可用状态</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span>     <span class="comment"># type 为 rollingupdate 就是使用滚动更新发布</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-rollingupdate</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-rollingupdate</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-rollingupdate</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.mooc.com/kubernetes/web:v1</span></span><br><span class="line">      <span class="string">...</span></span><br></pre></td></tr></table></figure><h4 id="蓝绿发布（blue-green）"><a href="#蓝绿发布（blue-green）" class="headerlink" title="蓝绿发布（blue-green）"></a>蓝绿发布（blue-green）</h4><ul><li>优点：<strong>升级切换和回退速度会更快，因为新旧版本的 pod 都是运行的，整个过程中保留所有旧 pod</strong></li><li>缺点：<strong>需要更多资源冗余，三台 v1 升级，需要创建三台 v2 全部完成后，将通过 service 将流量一刀切到 v2；故障影响范围大，v2 版本有 bug，可能会导致整个服务不可用</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-bluegreen</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-bluegreen</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-bluegreen</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1.0</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-bluegreen</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.mooc.com/kubernetes/web:v1</span></span><br><span class="line">      <span class="string">....</span></span><br></pre></td></tr></table></figure><p>​    使用蓝绿发布时，其实就是通过 label 来修改 svc，将 svc 的选择从篮色的 pod 改为绿色的 pod，所以蓝绿两个 deployment，上面的 yaml 中在 pod 的 label 上设置了 version 的标签，v1 表示篮色。在另外一样的 deployment 中，将 version 改为 v2 表示绿色，apply 后就会同时拥有蓝绿两个版本的 pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-bluegreen</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web-bluegreen</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0</span>    <span class="comment"># 使用蓝绿部署，创建新版本 pod 后，需要通过修改 service 来切流量</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><p>​    这个 svc 中，目前通过 selector 标签选择器，使用的是 v1 版本的绿色 pod，要改为蓝色的 v2 pod，只需将这里的 version 修改后重新 apply 即可</p><p>​    注意，并不是一定需要按照这个实例使用 version 的标签来区分蓝绿，只要 pod 的 label 可以区分蓝绿让 svc 可以切换就行</p><h4 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h4><ul><li>优点：<strong>在滚动发布之上，加入了流量控制实现灰度发布，当 v2 就绪后，会有小部分流量接入 v2，这样新版本出现故障后可以也能方便定位</strong></li><li>缺点：<strong>发布策略的复杂程度更高，整体的发布周期也更长</strong></li></ul><p>​    金丝雀的部署配置和蓝绿的一模一样，只是对于金丝雀部署来说，因为允许流量同时接入 v1 和 v2，所以 service 的配置中 selector 没有了 version 字段。而对于流量控制，则需要配合 istio 等使用</p>]]></content>
      
      
      <categories>
          
          <category> kuberbetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuberbetes </tag>
            
            <tag> pod 发布部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-调度</title>
      <link href="/1213981086/"/>
      <url>/1213981086/</url>
      
        <content type="html"><![CDATA[<h3 id="k8s-调度设计"><a href="#k8s-调度设计" class="headerlink" title="k8s 调度设计"></a>k8s 调度设计</h3><p>​    k8s 中一个重要的基本知识就是调度器，就是负责将 pod 调度到 node 上，调度器的整个设计又涉及到 k8s 中一些组件，例如 etcd，apiserver 的交互，etcd 存储集群核心数据，apiserver 是整个调度的控制中心</p><p>​    调度器大致工作流程如下图：</p><p><img src="http://wei-foun.github.io/img/k8s-schedule.jpg" alt=" "></p><p>​    图中的 informer，它用于对 apiserver 进行监听，其中有两个核心方法，一个是 list，用于全量和周期性对集群信息查询，另一个是 watch，通过 http 长连接对资源变化做监听</p><p>​    除了 informer 之外，还存在一个优先级队列，这个队列存放着由 informer 监听得到的等待调度的 pod，之所以是优先级队列，是因为本身对于 pod 而言，有的 pod 会相对重要，自然需要被提前进行调度</p><p>​    另外，scheduler 内还有一个缓存，这个缓存存储着 node 的信息，例如节点当前资源的使用情况，标签等等</p><p>​    有了队列里待调度的 pod 和 缓存里的 node 信息后，就可以准备进行调度了。整个调度过程涉及到两个策略：<strong>预选策略（predicate），优选策略（priority）</strong></p><p>​    <strong>预选策略：</strong>包含一些 node 基本信息的筛选得出能够调度的节点，例如 node 是否 ready，node 上端口是否被占用，是否有挂载，是否有污点等等</p><p><img src="http://wei-foun.github.io/img/k8s-predicate.jpg" alt=" "></p><p>​    <strong>优选策略：</strong>主要是对通过预选策略的 node 来打分，例如各 node 是资源使用情况，亲和性等等，然后选择最优的 node 和 pod 进行绑定</p><p>​    <img src="http://wei-foun.github.io/img/k8s-priority.jpg" alt=" "></p><p>​    最后绑定信息发送给 apiserver，去更新 pod 中 spec 的信息，添加上 nodeName 的字段为 node 的名字，最后 apiserver 会将 pod 的信息发送给 node 上 kubelet 服务，将 pod 运行起来</p><p>​    Pod 的最简单的两种指定 node 方式，一个是 spec 下指定 nodeName，另一个是通过 nodeSelector 字段通过 label 的 key:value 来指定</p><h4 id="无状态-pod-创建流程"><a href="#无状态-pod-创建流程" class="headerlink" title="无状态 pod 创建流程"></a>无状态 pod 创建流程</h4><p><img src="http://wei-foun.github.io/img/%E6%97%A0%E7%8A%B6%E6%80%81pod%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.jpg" alt=" "></p><p>​    图中有三个 List-Watch，分别是 Controller Manager（运行在 Master），Scheduler（运行在 Master）以及 kubelet（运行在 Node），它们在进程一启动就会监听（Watch）API Server</p><ol><li>用户通过 kubectl 或其他 API 客户端，提交请求给 API Server 来建立一个 Pod 对象副本（ReplicaSet）</li><li>API Server 将 Pod 对象的相关元信息存入 etcd 中，待写入操作执行完成，会返回信息到客户端</li><li>etcd 收到创建新 Pod 信息后，会发送一个 Create 事件给 API Server</li><li>由于 Controller Manager 一直在监听 API Server 中的事件。此时 API Server 接收到了 Create 事件，又会发送给 Controller Manager</li><li>Controller Manager 在接到 Create 事件以后，调用其中的 ReplicaSet 来保证需要创建的副本数量，总之它是保证副本数量的 Controller（扩容缩容的担当）</li><li>在 Controller Manager 创建 Pod 副本以后，API Server 会在 etcd 中记录这个 Pod 的详细信息。例如 Pod 的副本数，Container 内容是什么</li><li>同样， etcd 会将创建 Pod 的信息通过事件发送给 API Server</li><li>由于 Scheduler 在监听 API Server，并且它在系统中起到了 “承上启下” 的作用，“承上” 是指它负责接收创建的 Pod 事件，为其安排 Node；“启下” 是指安置工作完成后，Node 上的 kubelet 进程会接管后继工作，负责 Pod 生命周期</li><li>Scheduler 调度完毕以后会更新 Pod 的信息，此时的信息更加丰富了。除了知道 Pod 的副本数量，副本内容，还知道部署到哪个 Node 上面了。并将上面的 Pod 信息更新至 API Server，由 API Server 更新至 etcd 中，保存起来</li><li>etcd 将更新成功的事件发送给 API Server，API Server 也开始反映此 Pod 对象的调度结果</li><li>kubelet 是在 Node 上面运行的进程，也通过 List-Watch 的方式监听（https 的 6443 端口）API Server 发送的 Pod 更新的事件。kubelet 会尝试在当前节点上调用容器运行时启动容器，并将 Pod 以及容器的结果状态回送至 API Server</li><li>API Server 将 Pod 状态信息存入 etcd 中，在 etcd 写入操作成功完成后，API Server 将确认信息发送至相关的 kubelet，</li><li>Pod 完成调度创建后，计算平面的 Node 上的 kubelet 会继续监听 Api server，来实现当修改 pod 副本数或镜像时可以自动完成更新</li></ol><p>​    更多参考：</p><ul><li><a href="https://mutoulazy.github.io/2019/08/13/kubernetes/framework/what-happens-k8s-createPod/#kubernetes创建pod流程图">https://mutoulazy.github.io/2019/08/13/kubernetes/framework/what-happens-k8s-createPod/#kubernetes%E5%88%9B%E5%BB%BApod%E6%B5%81%E7%A8%8B%E5%9B%BE</a></li><li><a href="https://dbwu.tech/posts/k8s/source_code/pod_create/">https://dbwu.tech/posts/k8s/source_code/pod_create/</a></li><li><a href="https://arthurchiao.art/blog/what-happens-when-k8s-creates-pods-2-zh/">https://arthurchiao.art/blog/what-happens-when-k8s-creates-pods-2-zh/</a></li></ul><h4 id="taints-与-tolerations"><a href="#taints-与-tolerations" class="headerlink" title="taints 与 tolerations"></a>taints 与 tolerations</h4><p>​    Taints 污点用于在 node 上设置，它有三种类型：</p><ul><li>NoSchedule，即不允许任何 pod 调度上来</li><li>PreferNoSchedule，表示尽可能不调度，除非最后没选出最优 node 的情况才允许</li><li>NoExecute，是限制程度最高的，表示 pod 不能在该 node 上运行，对于 node 已运行的 pod 会被直接驱逐</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点污点</span></span><br><span class="line">kubectl describe node master | grep Taint</span><br><span class="line"><span class="comment"># 添加污点</span></span><br><span class="line">kubectl taint node node01 &lt;taintKey&gt;=&lt;taintValue&gt;:&lt;taintType&gt;</span><br><span class="line">kubectl taint node node01 app=<span class="built_in">test</span>:NoSchedule</span><br><span class="line"><span class="comment"># 去掉污点</span></span><br><span class="line">kubectl taint node node01 &lt;taintKey&gt;-</span><br><span class="line">kubectl taint node node01 app=<span class="built_in">test</span>:NoSchedule-</span><br></pre></td></tr></table></figure><p>​    在 pod 上，设置对 taint 的容忍，使用 tolerations 字段去配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">    <span class="comment"># 这里表示 pod 可以容忍污点是 app=test:NoExecute 的 node 上调度</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;app&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span></span><br><span class="line">      <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span></span><br><span class="line">      <span class="attr">tolerationSeconds:</span> <span class="number">100</span>    </span><br><span class="line">      <span class="comment"># tolerationSeconds 是当指定 NoExecute，并非立即将 pod 驱逐，而是容忍时间 100 秒，通常是配合容器优雅退出使用</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo hello; sleep 10; done&quot;</span>]</span><br></pre></td></tr></table></figure><p>​    taints 和 tolerations 的污点与容忍，可以看作是对 NodeName，NodeSelector 调度的一种补充，可以灵活的控制 pod 和 node 调度关系，而不至于添加一大堆的 label 来实现，再配合上驱逐，能够实现 node 出现问题时，避免 pod 被无调度上去</p><p>​    在生产环境上，还有另一种常用的调度方式，就是亲和调度（Affinity）。亲和调度可以分为 node 亲和，pod 亲和，pod 反亲和</p><p>​    每种亲和调度，还要两种亲和策略，分别是软亲和与硬亲和。软亲和，是一种优先选择策略，硬亲和，是一种强制选择策略</p><h4 id="node-硬亲和"><a href="#node-硬亲和" class="headerlink" title="node 硬亲和"></a>node 硬亲和</h4><p>​    对于硬亲和的 affinity 的配置关键字段是 requiredDuringSchedulingIgnoredDuringExecution</p><p>​    拆开这个字段：requiredDuringScheduling 表示定义的规则必须强制满足（require）才会调度 Pod 到节点上，IgnoredDuringExecution 表示已经在节点上运行的 Pod 不需要满足定义的规则，即去除节点上的某个标签，那些需要节点包含该标签的 Pod 不会被重新调度</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span>  <span class="comment"># nodeSelectorTerms 是一个数组，也就是允许配置多个匹配，这些匹配之间是 or 的关系</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span>  <span class="comment"># matchExpressions 也是数组，配置多个匹配时，它是 and 的关系</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span>    <span class="comment"># key 就是 label 的 key</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><h4 id="node-软亲和"><a href="#node-软亲和" class="headerlink" title="node 软亲和"></a>node 软亲和</h4><p>​    软亲和是一种权重优选的策略，配置的关键字段是 preferredDuringSchedulingIgnoredDuringExecution</p><p>​    <strong>软亲和可以按照设计，去配置多个不同标签的满足，并设置权重值，调度器会根据权重值大小来优先选择满足匹配的 node</strong></p><p>​    <strong>如果 pod 同时设置了硬亲和与软亲和，如果硬亲和不满足，那么会直接无法调度起来</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">80</span> </span><br><span class="line">        <span class="attr">preference:</span> </span><br><span class="line">          <span class="attr">matchExpressions:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span> </span><br><span class="line">            <span class="attr">values:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">20</span> </span><br><span class="line">        <span class="attr">preference:</span> </span><br><span class="line">          <span class="attr">matchExpressions:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span> </span><br><span class="line">            <span class="attr">values:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">test2</span></span><br></pre></td></tr></table></figure><h4 id="pod-硬亲和"><a href="#pod-硬亲和" class="headerlink" title="pod 硬亲和"></a>pod 硬亲和</h4><p>​    对于 node 亲和性调度，其设计某种程度上和 label 选择是类似的，都是作用在 node 上限制 pod 调度。对 pod 亲和性调度来说，其目的就是希望最后可以实现 pod 之间能形成绑定或是排斥关系，也就是 pod 亲和（podAffinity ）与 pod 反亲和（podAntiAffinity）</p><p>​    例如当 podB 要被调度时，如果设计与 podA 亲和，那么 podB 调度到 podA 所在的 node，如果设计与 podA 反亲和，那就是说 podB 最后一定不会调度到 podA 所在 node</p><p>​    Pod 的硬亲和，例如想要部署后端服务，希望能和前端服务可以部署在一个 node，就可以配置 pod 硬亲和。下面 topologyKey 表示的 pod 亲和的作用域（拓扑域），表示的就是将 pod 调度到 pod 的 label 里 app 这个值是 frontend 或 web 的所在节点 kubernetes.io/hostname 上</p><p>​    topologyKey 的值也可以是其他标签，用来实现不同作用域的 pod 亲和。topologyKey 是一个范围的表示，hostname 来表示指定 node 作为范围，也可以是例如机房，地区等标签</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span>   <span class="comment"># topologyKey 是一个关键配置，表示 pod 亲和的作用域</span></span><br><span class="line">        <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span> </span><br><span class="line">            <span class="attr">values:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">web</span></span><br></pre></td></tr></table></figure><h4 id="pod-软亲和"><a href="#pod-软亲和" class="headerlink" title="pod 软亲和"></a>pod 软亲和</h4><p>​    pod 的软亲和也是通过权重来进行优选</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">affinity:</span></span><br><span class="line">  <span class="attr">podAffinity:</span></span><br><span class="line">    <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">podAffinityTerm:</span></span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">        <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">security</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">S2</span></span><br></pre></td></tr></table></figure><h4 id="Pod-反亲和-硬亲和-amp-Pod-反亲和-软亲和"><a href="#Pod-反亲和-硬亲和-amp-Pod-反亲和-软亲和" class="headerlink" title="Pod 反亲和+硬亲和 &amp; Pod 反亲和+软亲和"></a>Pod 反亲和+硬亲和 &amp; Pod 反亲和+软亲和</h4><p>​    Pod 亲和调度，还有一种是反亲和调度，即希望 pod 不要和满足匹配的 pod 调度在一起，以此来实现多地区部署</p><p>​    Pod 反亲和配置的字段是 <strong>podAntiAffinity</strong>，其他配置和 pod 亲和配置是一致的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pod 反亲和+硬亲和</span></span><br><span class="line"><span class="attr">affinity:</span></span><br><span class="line">  <span class="attr">podAntiAffinity:</span></span><br><span class="line">    <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">      <span class="attr">labelSelector:</span></span><br><span class="line">        <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pod 反亲和+软亲和</span></span><br><span class="line"><span class="attr">podAntiAffinity:</span></span><br><span class="line">  <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">podAffinityTerm:</span></span><br><span class="line">      <span class="attr">labelSelector:</span></span><br><span class="line">        <span class="attr">matchExpressions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">security</span></span><br><span class="line">          <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">          <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">S2</span></span><br><span class="line">      <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>​    是 k8s 1.8 版本之后支持的配置 PriorityClass，并从 1.11 版本开始默认开启。设置优先级调度需要先创建 PriorityClass 设置优先等级，然后在 pod 的 spec 设置 priorityClassName</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">env:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">high-priority</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kuberbetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuberbetes </tag>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s整理</title>
      <link href="/558590641/"/>
      <url>/558590641/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-k8s"><a href="#什么是-k8s" class="headerlink" title="什么是 k8s"></a>什么是 k8s</h3><p>​    Kubernetes 是谷歌开源的容器集群管理系统，是 Google 多年大规模容器管理技术 Borg 的开源版本，主要功能包括：</p><ul><li>基于容器的应用部署、维护和滚动升级</li><li>负载均衡和服务发现</li><li>跨机器和跨地区的集群调度</li><li>自动伸缩</li><li>无状态服务和有状态服务</li><li>广泛的 Volume 支持</li><li>插件机制保证扩展性</li></ul><p>​    Kubernetes 基于 API 管理一切的思想，采用声明式即 “面向结果” 的API，围绕 etcd（分布式存储与协调数据库）构建出来的一套 “面向终态” 的编排体系</p><p>​    当用户向 Kubernetes 提交了一个 API 对象（Kubernetes Object）的期望状态（Spec）之后，Kubernetes 会负责保证整个集群里各项资源的当前状态（Status），都与 API 对象描述的需求相一致</p><p>​    这个保证是一项 “无条件的”、“没有期限” 的承诺：对于每个保存在 etcd 里的 API 对象，Kubernetes 都通过启动一种叫做 “控制器模式”（Controller Pattern）的无限循环，不断对 etcd 里的 API 对象的变化进行监视（Watch），然后执行控制器（Controller）里定义的编排动作的响应逻辑，进行调谐，最后确保整个集群的状态与 API 对象的描述一致</p><h3 id="k8s-架构"><a href="#k8s-架构" class="headerlink" title="k8s 架构"></a>k8s 架构</h3><p>​    Kubernetes采用了控制平面和计算平面分离的架构：</p><ul><li>控制平面（Master）是整个集群的大脑，负责控制、调度集群资源，包含四个主要组件：API Server、Controller Manager、Scheduler 及 Etcd；</li><li>计算平面（Node）负责运行容器化应用，是控制平面调度的对象，通过增加或减少工作节点实现容器集群处理能力的扩缩，包含三个组件：kubelet、kube-proxy、container runtime</li></ul><p>​    <img src="https://wei-foun.github.io/img/k8s%E6%9E%B6%E6%9E%84.jpg" alt=""></p><h4 id="各组件功能"><a href="#各组件功能" class="headerlink" title="各组件功能"></a>各组件功能</h4><ul><li>etcd 保存了整个集群的状态</li><li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li><li>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</li><li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li><li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理</li><li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）</li><li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡</li></ul><h3 id="API-对象"><a href="#API-对象" class="headerlink" title="API 对象"></a>API 对象</h3><p>​    是 kubernetes 集群中的操作管理单元，kubernetes 中每一个新功能都对应一个 API 对象。<strong>每个 API 对象都有三大属性：metadata 元数据，spec 规范，status 状态</strong></p><p>​    元数据 metadata：用于标识 API 对象，可配置 namespace 、name 、uid 或是 labels 标签来进行标识</p><p>​    规范 spec：API 设计的重要部分，所有的配置都是声明式的，可以更好地在分布式系统中稳定执行，而不会丢操作或重复操作</p><p>​    状态 status：用于描述实际期望达到的状态，例如需要确保有多少 pod 必须 ready 等</p><h4 id="对象管理的声明式和命令式"><a href="#对象管理的声明式和命令式" class="headerlink" title="对象管理的声明式和命令式"></a>对象管理的声明式和命令式</h4><p>​    声明式 api，例如 apply ，其目的是希望最后结果满足要求，并不需要关注操作的过程</p><p>​    命令式 api，例如 create，delete，replace 等等，这些操作是被明确的，也就是行说最后的结果需要明确按照给出的指令完成对应的结果</p><p>​    kubectl apply 的优势：</p><ul><li>使用 apply 更新资源，会自动对比差异字段，实现部分更新</li><li>apply 支持同时配置多个文件，适合批量操作管理资源</li></ul><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>​    是<strong>部署和管理应用的最小单元，也是节点上的一个进程，一个 pod 允许同时运行多个容器</strong>，并且 <strong>pod 允许这些容器共享网络地址与文件系统</strong>，这就使得使用 pod 可以非常方便的部署管理多容器组成的微服务</p><p>​    它的功能有点像 docker-compose，都可以编排多容器部署运行，但是 docker 的范围更多的使用在单机节点上，k8s 则是广泛应用在分布式的微服务上</p><p>​    <strong>Kubernetes 就是一个操作系统，就像 Linux；Pod 就是一个进程组，就像 Linux 线程组；容器就是一个进程，就像 Linux 线程</strong></p><p>​    pod 中应用容器的 hostname 会被设置为 pod 的名字，且应用容器可以共享卷，通过持久化卷能让 pod 重启时数据不会丢失，以下是一个单容器 my_pod.yaml 的 Pod 声明</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span>     <span class="comment"># 定义创建出来的 pod 的名字，不定义的话 k8s 会使用文件名同时后缀会加上数字和字母作为唯一标识</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span>   <span class="comment"># 声明 pod 所在的 namespace </span></span><br><span class="line">  <span class="attr">labels:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br></pre></td></tr></table></figure><p>​    可以通过 <code>kubectl apply -f ./my_pod.yaml</code> 来创建这个 pod，注意在 yaml 中定义了这个 pod 的 namespace，需要先创建该 namespace，否则运行将报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: error validating <span class="string">&quot;my_pod.yaml&quot;</span>: error validating data: [ValidationError(Pod.metadata): unknown field <span class="string">&quot;namespce&quot;</span> <span class="keyword">in</span> io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta, ValidationError(Pod.spec): unknown field <span class="string">&quot;container&quot;</span> <span class="keyword">in</span> io.k8s.api.core.v1.PodSpec, ValidationError(Pod.spec): missing required field <span class="string">&quot;containers&quot;</span> <span class="keyword">in</span> io.k8s.api.core.v1.PodSpec]; <span class="keyword">if</span> you choose to ignore these errors, turn validation off with --validate=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>​    用命令创建 namespace 并部署 busybox 应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create namespace <span class="built_in">test</span></span><br><span class="line">namespace/test created</span><br><span class="line">$ kubectl apply -f my_pod.yaml</span><br><span class="line">pod/busybox created</span><br><span class="line">$ kubectl get pod -n <span class="built_in">test</span></span><br><span class="line">NAME      READY   STATUS              RESTARTS   AGE</span><br><span class="line">busybox   0/1     ContainerCreating   0          31s   <span class="comment"># 显示容器创建中</span></span><br></pre></td></tr></table></figure><p>​    上面这个应用最后其实是运行不起来的，因为这个应用没有使用 <code>-it</code> 的模式去运行，<strong>对于 docker 来说会认为这个容器是一个不活跃的容器进程所以会自动将其关闭</strong>，k8s 提供和 docker 命令行 <code>-it</code> 运行的配置，下面是对上面 busybox 的 pod 进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span>              <span class="comment"># 通过终端交互运行，类似 docker run -it</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span>     <span class="comment"># 使容器有 root 权限</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">/test</span>      <span class="comment"># 定义容器工作目录，类似</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;while true; do echo hello; sleep 10; done&quot;</span>]</span><br></pre></td></tr></table></figure><p>​    修改完成后，重新部署，这里可以选择先 <code>delete -f</code> ，然后再 <code>apply -f</code> ，或者可以使用 <code>repleace -f</code>。这次通过 <code>get pod -n test</code> 就可以看到 pod 是 Running 状态了</p><p>​    可以通过 <code>describe pod busybox -n test</code> 查看日志，能够看到 busybox 容器被部署到哪一个节点上，通过登录该节点，执行 <code>docker ps</code> 查看到 busybox 的应用，通过 logs 可以查看到容器正在执行 yaml 里定义的 args 的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep busybox</span><br><span class="line">a1d60a562a7a   ba5dc23f65d4                                        <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   34 minut es ago   Up 34 minutes             k8s_busybox_busybox_test_e06dxsbd-d640-403a-808d-c948bd9497e1_0</span><br><span class="line">07fae6d6b02c   registry.aliyuncs.com/google_containers/pause:3.6   <span class="string">&quot;/pause&quot;</span>                 34 minutes ago   Up 34 minutes             k8s_POD_busybox_test_e06dxsbd-d640-403a-808d-c948bd9497e1_0</span><br><span class="line">$ docker logs a1d</span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>​    可是为什么 pod 里只定义了 busybox 的容器，在节点上却出现了两个和 busybox 有关的容器，pause 的容器是怎么来的？</p><h4 id="pause-容器"><a href="#pause-容器" class="headerlink" title="pause 容器"></a>pause 容器</h4><p>​    pause 容器，也可以叫 infra 容器，是 pod 中非常关键的一个容器，<strong>是 pod 中第一个启动的容器，它的生命周期和整个 pod 的生命周期一致。这个 pause 实际在 kubelet 中就已经定义了，可以通过 ps 查看到最后定义了</strong> <strong><code>pod-infra-container-image</code></strong> <strong>这个 pause 的镜像非常小不到 1 M，并且启动后永远是 pause 状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep kubelet</span><br><span class="line">root       36989       1  2 Mar29 ?        02:11:27 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.6</span><br></pre></td></tr></table></figure><p>​    <em>如果是 <code>crictl ls</code> 是不会看到 pause 容器，但并不是不存在而是被隐藏了</em></p><p>​    pod 本身是一个逻辑上的概念，对于 pod 中的容器，实际上是被 linux 的 namespace 和 cgroups 隔离的，但 pod 又允许了内部的容器可以共享网络和文件系统，这和 pause 容器有着密切的关系</p><p> <strong>pause 容器的作用：</strong></p><p>​    <strong>pause 容器会为 pod 建立和维护自己的网络命名空间，内部容器可以 join pasue 的 network namespace 实现共享这个网络设备路由（即 pod 内容器可以通过 localhost 相互发现），通过 join pause 的 ipc namespace 来实现共享内存以及进程间通信，这种内部共享外部隔离的方式可以让 pod 之间不会产生冲突</strong></p><p>​    对于 <strong>pod 中每个容器，内部 etc/hosts 的文件也是由 pause 容器去创建管理的</strong>，所以如果存在自定义 hosts 的需求，需要从 pod 层面修改，这个修改会对 pod 的每个容器生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: <span class="string">&quot;xx.x.xx.x&quot;</span></span><br><span class="line">    hostnams:</span><br><span class="line">    - <span class="string">&quot;www.fw.com&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>​    同时如果 pod 需要使用宿主机的网络，或是主机的进程空间，也是在 pod 层面设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  hostNetwork: <span class="literal">true</span>   <span class="comment"># 可以用 netstat 去查看</span></span><br><span class="line">  hostPID: <span class="literal">true</span>       <span class="comment"># 可以用 ps -ef 去查看</span></span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: <span class="string">&quot;xx.x.xx.x&quot;</span></span><br><span class="line">    hostnams:</span><br><span class="line">    - <span class="string">&quot;www.fw.com&quot;</span></span><br><span class="line">  containers:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>​    pause 容器非常轻量，它的存在可以防止即使 pod 中没有容器在运行也不会 k8s 删除。同时 pause 容器在 pod 中是第一个运行的容器，会开启 PID 命名空间，且 pause 将作为 pid=1 的进程存在，所以 pause 容器伴随着 pod 整个生命周期，和 pod 中其他容器无关，因此当修改 pod 中某个镜像时，并不让 pod 重建和重启</p><p>​    同时 pause 容器作为 pod 进程树的根结点，可以实现对僵尸进程的接管回收</p><p>​    可以通过 <code>docker inspect</code> 去查看 busybox 的容器，能够看到 <code>Networkmode</code> 和 <code>Ipcmode</code> 都是指定了为了 busybox 的 <code>pasue</code> 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect a1d</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;a1d60a562a7aa7bdd6ea1ffc13582c29036bfa9cb0c90d57518f815450b98144&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-04-01T10:30:18.705562982Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/sh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">            <span class="string">&quot;while true; do echo hello; sleep 10; done&quot;</span></span><br><span class="line">        ],</span><br><span class="line">       ....</span><br><span class="line">        <span class="string">&quot;ExecIDs&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;HostConfig&quot;</span>: &#123;</span><br><span class="line">            ....</span><br><span class="line">            <span class="string">&quot;NetworkMode&quot;</span>: <span class="string">&quot;container:07fae6d6b02cc8d734528e84858d555abca274f97ddd9afc932a971661c58393&quot;</span>,</span><br><span class="line">            ....</span><br><span class="line">            <span class="string">&quot;IpcMode&quot;</span>: <span class="string">&quot;container:07fae6d6b02cc8d734528e84858d555abca274f97ddd9afc932a971661c58393&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Cgroup&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">&quot;PidMode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           ...</span><br><span class="line">        &#125;,</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​    但是这里 <code>Pidmode</code> 可以看到是空字符，那可以猜测 k8s 里这个 busybox 的 pod 的 pid=1 的进程应该不是 pause，可以在 master 上通过执行 <code>kubectl exec -it busybox -- ps aux</code> 查看 pod 的进程列表，从执行返回可以确认 pid=1 的确不是 pause</p><p>​    <strong>在 pod 中要实现进程命名空间的共享，需要在 spec 中配置</strong> <strong><code>shareProcessNamespace: true</code></strong> <strong>来实现</strong>，这样创建 pod 后，pod 中的容器就会将 <code>Pidmode</code> 指向 pause，此时 pod 中容器 pid=1 的进程就指定为了 pause 容器。<strong>共享进程命名空间下，pod 中的容器可以看到 pod 里其他的容器进程，以及其他容器的文件系统</strong> <strong><code>/proc/$pid/root</code></strong></p><h4 id="init-容器"><a href="#init-容器" class="headerlink" title="init 容器"></a>init 容器</h4><p>​    init 容器是 pod 中除 pause 和应用容器之外的另一种容器，和 pause 容器不同的是，init 容器不是系统定义的，和用户定义的应用容器是一致的，只是配置中负责定义的字段名不同</p><p>​    init 容器的主要作用是就是和其名称类似做一些初始化的操作，所以 <strong>init 容器的启动会在应用容器之前，当网络和数据卷初始化完成后，init 容器会按照顺序执行，只有一个 init 容器完成后才可执行下一个，因此多个 init 容器是单线性的顺序</strong></p><p>​    一般情况下，<strong>init 容器如果失败，pod 会不断地进行重启直到所有 init 完成</strong>。同理重启 pod 也会导致所有 init 容器被重新执行，对于 init 容器来说，当 image 被修改表示这 pod 的重启</p><p>​      init 容器由用户根据需要定义，声明使用的是 <code>spec.initContainers</code>。因为 init 容器是逐个完成才依次执行，所以 <strong>init 容器不能像普通应用容器那样定义 startup porbe 启动探针，liveness probe 存活探针，readiness probe 就绪探针</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;echo The app is running! &amp;&amp; sleep 3600&#x27;</span>]</span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-myservice</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><p>​    当用户给应用容器配置资源使用的限制后，k8s 的调度器组件会根据每个节点上 pod 中容器使用的资源，例如 cpu，内存等，来做统计和打分来进行过滤和选择后续 pod 应该调度到那个节点上</p><p>​    在无 init 容器时，pod 使用资源就是内部应用容器定义的使用资源大小总和，但是当用户有定义 init 容器时，使用资源的统计会有一点小变化，最后 pod 使用资源的取值是 <code>max(所有应用容器请求资源总和, max(所有 init 容器请求资源总和))</code></p><h4 id="pod-生命周期"><a href="#pod-生命周期" class="headerlink" title="pod 生命周期"></a>pod 生命周期</h4><p>​    <img src="https://wei-foun.github.io/img/pod-life-cycle.jpg" alt=""></p><p>​    Pod 也支持对容器生命周期的管理，通过 lifecycle 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xxxx.xx/xx/xxxx:v1</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span>    <span class="comment"># postStart 是容器启动时，同时执行的命令</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo web starting  ... &gt;&gt; /var/log/messages&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span>      <span class="comment"># preStop 是容器结束前，执行这个命令直到完成才会结束容器，如果执行超时，则会跳过后结束容器</span></span><br><span class="line">        <span class="attr">exec:</span>       <span class="comment"># preStop 通常是用于容器的优雅退出</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo web stopping  ... &gt;&gt; /var/log/messages&quot;</span>]</span><br><span class="line">      </span><br></pre></td></tr></table></figure><h4 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h4><pre><code>pod 的健康检查有三种探针检测策略：**启动探针（startupProbe），存活探针（livenessProbe），就绪探针（readinessProbe），如果有启动探针，只有启动探针检查成功后才会执行就绪探针和存活探针**</code></pre><p>​    k8s 的 <strong>每种探针又支持三种形式设置：exec，httpGet，tcpSocket</strong></p><p>​    健康检查的三种探针可以在一个文件里配置多个，比如同时配置 livenessProbe 和 readinessProbe</p><p>​    livenessProbe 通常用于轮询检查应用是否正常服务，失败的话就进行重启（即重新创建新的容器替换到死掉的容器）</p><p>​    readinessProbe 用于检查服务是否就绪提供服务，探测通过则会将状态标记为就绪，并接入 service 的流量</p><p>​    startupProbe 是 1.16 版本引入，用于检查容器是否初始化创建完成，所以启动探针在声明周期的时间线上提前于就绪和存活探针，启动探针只有成功后才会执行就绪探针</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 cmd 的存活探针</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-demo</span></span><br><span class="line">  <span class="attr">namespace: devspec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-demo</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-demo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.mooc.com/kubernetes/web:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ps</span> <span class="string">-ef|grep</span> <span class="string">java|grep</span> <span class="string">-v</span> <span class="string">grep</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">10</span>   <span class="comment"># 设置探针延迟检查，即 10s 后再进行存活检查，目的是留出时间启动容器</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span>         <span class="comment"># 设置检查间隔为 10s，重要的应用通常间隔会较短，但过短也会带来一点性能消耗</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">2</span>       <span class="comment"># 连续 2 次存活检查失败，就认为 pod 彻底失败，就会进行重启</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span>       <span class="comment"># 只要出现 1 次存活检查成功，就认为应用恢复正常</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span>         <span class="comment"># 设置每次存活检查的超时时间，一旦超时也认为检查失败</span></span><br><span class="line"><span class="string">---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 基于 http 的存活探针</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/api/v1/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">httpHeaders:</span>    <span class="comment"># http 方式，还可以添加自定义的请求头</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Custom-Header</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">Awesome</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="string">---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 基于 tcp 的存活探针</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">failureThreshold:</span> <span class="number">2</span></span><br><span class="line">          <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="pod-状态"><a href="#pod-状态" class="headerlink" title="pod 状态"></a>pod 状态</h4><p>​    Pendding：当 node 资源不足还未完成调度，或匹配不到 node，或是没有指定的镜像时，都会处于 pendding</p><p>​    ContainerCreating：pod 成功被调度后，就会开始创建容器进行初始化，这个状态的持续事件相对较短</p><p>​    Running：容器创建完成并运行后，pod 就会进入到 running 状态</p><p>​    Succeeded：当 pod 调度完成，并成功运行结束，就会是 succeeded 状态，通常用于 cronjob 的任务</p><p>​    Failed：和 succeeded 状态是一对，即 job 执行失败</p><p>​    Ready：对于长期运行的服务，pod 通过健康检查的话，就会处于 Ready 状态</p><p>​    CrashLoopBackOff：而如果 pod 没有通过健康检查，则会进入 crashloopbackoff 状态，并持续进行检查，失败次数越多，等待的时间也会随之变长</p><p>​    Unknown：未知状态，通常会是 api-server 与 kubelet 的通讯出现异常等</p><h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p>​    对于 pod 本身设计而言，就是一个临时实体，并不是持久化的，所以当 pod 调度失败、节点故障、缺少资源、节点处于维护状态下都会死掉被驱逐</p><p>​    当 pod 被某种原因进行删除或是应用发布产生新的相同 pod 被取代，那么当前 pod 的附属产物例如临时卷，也会被销毁和重新创建</p><p>​    当用户要终止删除一个 pod，这个 pod 在能被强制删除前会有一个宽限期，同时会发送一个 TREM 请求到每个容器的主进程。如果发生超时，则会发送 Kill 信号到容器主进程并从 api server 进行删除</p><p>​    <strong>pod 删除流程：</strong></p><ul><li>用户发送删除 pod 的命令，默认宽限期是 30 秒</li><li>在 Pod 超过该宽限期后 api server 就会更新 Pod 的状态为 “dead”</li><li>在客户端命令行上显示 Pod 状态为 “terminating”<ul><li>当 kubelet 发现 pod 被标记为 “terminating” 状态时，开始停止 pod 进程</li><li>如果在 Pod 中定义了 preStop hook，在停止 pod 前会进行调用。如果在宽限期过后，preStop hook 依然在运行，第二步会再增加 2 秒的宽限期</li><li>向 Pod 中的进程发送 TERM 信号</li><li>该 Pod 将从该 service 的端点列表中删除，关闭慢的 Pod 将继续处理 load balancer 转发的流量</li></ul></li><li>如果过了宽限期，将向 Pod 中依然运行的进程发送 SIGKILL 信号而杀掉进程</li><li>最后 kubelet 会在 api server 中完成 Pod 的删除</li></ul><p>​    默认的宽限期，可以在使用 <code>kubectl delete</code> 时用参数 <code>—grace-period=&lt;seconds&gt;</code> 来设置，或则在 yaml 中设置 <code>.spec.spec.terminationGracePeriodSeconds</code></p><p>​    pod 的强删是通过在集群和 etcd 中定义为删除状态，需要使用 <code>--force</code> 和 <code>--grace-period=0</code> 来强制删除 pod，执行强删时，API server 不会等待该 pod 所在节点上的 kubelet 确认，而立即将 pod 从 API server 中移除</p><h3 id="SVC"><a href="#SVC" class="headerlink" title="SVC"></a>SVC</h3><p>​    Service 是对一组提供相同功能的 Pods 的抽象，为它们提供一个统一的入口。借助 Service 的服务发现与负载均衡，可以实现应用的零宕机升级</p><p>​    Service 通过标签来选取服务后端，这些匹配标签的 <strong>Pod IP 和端口列表组成 endpoints 会被记录在 ipvs 列表中</strong>，最终由 kube-proxy 负责将 svc 请求负载均衡到这些 endpoints 上</p><p>​    所以 svc 目的是为了给 pod 提供稳定的访问入口，<strong>svc 创建后 k8s 会给它分配一个全局唯一的虚拟 ip，默认情况下在 svc 生命周期内这个 ip 不会发生变化</strong></p><p>​    svc 创建后还会分配到一个集群内的 dns 域名 <code>&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local.</code></p><p><img src="http://wei-foun.github.io/img/k8s-svc.jpg" alt=" "></p><h4 id="负载均衡过程"><a href="#负载均衡过程" class="headerlink" title="负载均衡过程"></a>负载均衡过程</h4><p>​    Service 的负载均衡实现的过程，如下：</p><ol><li>运行在每个 Node 节点的 kube-proxy 会实时的 watch Service 和 Endpoints（IP+端口）对象， 当用户在 Kubernetes 集群中创建了含有 Label 的 Service 之后，<strong>同时会在集群中创建出一个同名的 Endpoints 对象</strong>，用于存储应用服务 Pod 的 ip 和 port</li><li>当每个 Node 节点的 kube-proxy 感知到 Service 和 Endpoints 的变化之后，会在各自的 Node 节点上打开代理端口，并设置相关的 iptables 或 ipvs 规则</li><li>客户端访问 Service 的 ClusterIP，客户端请求会经过 iptables/ipvs，会被重定向到 kube-proxy 的代理端口。如果 proxy 设置了 ipvs 模式，调度由 ipvs 完成，其他功能仍是 iptables 实现</li><li>kube-proxy 将请求发送到真实的后端 Pod</li></ol><p><img src="http://wei-foun.github.io/img/k8s-svc-proxy.jpg" alt=" "></p><h4 id="svc-的四种类型"><a href="#svc-的四种类型" class="headerlink" title="svc 的四种类型"></a>svc 的四种类型</h4><ul><li>ClusterIP：是默认类型，<strong>会为 service 自动分配一个集群内部的 VIP</strong>。svc 的监听会动态根据 pod 的是否可用来负载均衡流量到 app 的 pod 上</li></ul><p>​        <strong>补充：spec.ClusterIP 如果指定为 None 则会创建 Headless Service，这个 svc 不会被分配 clusterip，客户端请求将会直接和 pod 进行 tcp 连接通信，这种方式的通信性能更接近 “原生网络”</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">myapp-clusterip</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">ClusterIP</span>     <span class="comment"># 不写，默认就是 ClusterIP</span></span><br><span class="line"> <span class="attr">selector:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"> <span class="attr">ports:</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>        <span class="comment"># 可有可无，这个 name 可用来区分 ports 下不同端口</span></span><br><span class="line">   <span class="attr">port:</span> <span class="number">80</span>          <span class="comment"># svc 的端口</span></span><br><span class="line">   <span class="attr">targetPort:</span> <span class="number">80</span>    <span class="comment"># 应用服务 pod 的端口</span></span><br></pre></td></tr></table></figure><ul><li>NodePort：是在 clusterip 基础上，增加了给 <strong>svc 绑定到 node 的端口上</strong>，这样就集群外部可以通过 node ip 和端口访问到真实服务的 pod。<strong>此模式下 k8s 会给 node 上所有的网卡设备都增加一条规则来向外暴露指定的 nodeport 端口，因此可以通过集群内任意一个 node 的 ip 都可以从此端口访问</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">myapp-nodeport</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"> <span class="attr">selector:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">   <span class="attr">release:</span> <span class="string">stabel</span></span><br><span class="line">   <span class="attr">svc:</span> <span class="string">nodeport</span> </span><br><span class="line"> <span class="attr">ports:</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>        </span><br><span class="line">   <span class="attr">port:</span> <span class="number">80</span>          <span class="comment"># svc 的端口，用于集群内通过 svc 的 ip 和 port 进行负载均衡访问</span></span><br><span class="line">   <span class="attr">targetPort:</span> <span class="number">80</span>    <span class="comment"># 应用服务 pod 的端口</span></span><br><span class="line">   <span class="attr">nodePort:</span> <span class="number">33080</span>   <span class="comment"># node 上端口，用于暴露给集群外访问</span></span><br></pre></td></tr></table></figure><ul><li>LoadBalancer：通过 cloud provider 云厂商的负载均衡器在基于 NodePort 实现多节点高可用访问。由于 <strong>Service 只提供了四层服务，若要通过 Http/Https 的七层访问方式访问服务，则需要通过 LoadBalancer 的方式，将访问流量转发到 Service 上来实现</strong></li><li>ExternalName：通过 DNS CNAME 实现外部域名和 svc 内部域名的转发，这种类型和前三者不同不需要经过 ipvs 来负载均衡</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">mysvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">www.baidu.com</span>   </span><br><span class="line">  <span class="comment"># 集群内部通过访问 mysvc.default.svc.cluster.local 时</span></span><br><span class="line">  <span class="comment"># ExternalName 的 svc 会将 www.baidu.com 域名的结果给到内部域名</span></span><br></pre></td></tr></table></figure><h4 id="endpoints"><a href="#endpoints" class="headerlink" title="endpoints"></a>endpoints</h4><p>​    svc 创建后，k8s 中会同时创建一个同名的 endpoints 资源，用于存储 svc 关联的 pod 的 ip 和 port，这些信息最后会被写入到 node 的 ipvs 哈希表中</p><p>​    当 pod 发生移除或新增，endpoints 会自动获取到最新的地址和端口并更新</p><p>​    当然除了有带有标签选择器的 svc 之外，不设置 svc 的标签选择，endpoints 也可以手动来指定代理的后端 ip 和 port，这种方式可以实现灵活的操作，svc 可以代理集群外的应用服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">ports:</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>     </span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span>     <span class="comment"># 这里的 name 必须要和 svc 的 name 对应</span></span><br><span class="line"><span class="attr">subsets:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span>      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>    </span><br><span class="line">    <span class="attr">ports:</span>      </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="RC-与-RS"><a href="#RC-与-RS" class="headerlink" title="RC 与 RS"></a>RC 与 RS</h4><p>​    副本控制器 rc（Replication controller），目的是为了方便对创建相同应用的副本数量，当容器异常退出或是因异常问题创建了超出副本数的 pod，rc 会自动创建新的 pod 或删除最新创建的 pod 来维持趋近预期 pod 副本数量</p><p>​    在新版本 kubernetes 中，replicationcontroller 被 replicaset（rs）去掉，两者本质是一样的，不同的是 replicationcontroller 是 core 组件 v1，replicaset 是 app 组下 v1 提供，且 <strong>replicaset 的 selector 选择器支持了 matchLabels 和 matchExpressions 两种选择方式</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rc 结构</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">rs-demo</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> </span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">rs-demo</span> </span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">rs-demo</span> </span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rs-dem</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">       </span><br><span class="line"> <span class="comment"># rs  matchlabels 结构</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">app/v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">rs-demo</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span>       <span class="comment"># matchLabels 和 rc 中 selector 功能一致，会去按照当前设定的标签 kv 作为子集去 pod 标签的集合中查看满足的资源对象</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">rs-demo</span> </span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">rs-demo</span> </span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rs-dem</span></span><br><span class="line">        <span class="string">...</span></span><br><span class="line">        </span><br><span class="line"> <span class="comment"># rc matchexpressions 的 selector 结构</span></span><br><span class="line"> <span class="attr">spec:</span> </span><br><span class="line"> <span class="attr">selector:</span> </span><br><span class="line">   <span class="attr">matchExpressions:</span> </span><br><span class="line">     <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span> </span><br><span class="line">       <span class="attr">operator:</span> <span class="string">Exists</span></span><br></pre></td></tr></table></figure><p>​    k8s 支持手动通过 scale 参数去控制 rs 副本数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale rs &lt;rs-name&gt; --replicas=5</span><br></pre></td></tr></table></figure><h4 id="HPA-与-VPA"><a href="#HPA-与-VPA" class="headerlink" title="HPA 与 VPA"></a>HPA 与 VPA</h4><p>​    k8s的 自动扩容机制分为 HPA（horizontal pod autoscaler，水平扩缩）和 VPA（vertical pod autoscaler，垂直扩缩）</p><p>​    HPA 是根据 pod 的负载情况来水平层面控制 pod 的数量实现水平的扩容和缩容，例如根据 pod 的 cpu 利用率，或是自定义的指标来实现 hpa</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-nginx-dp</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">70</span>    <span class="comment"># cpu 使用率超 70 时就自动扩容</span></span><br></pre></td></tr></table></figure><p>​    VPA 是根据容器的资源使用率来动态控制 pod 的 cpu 和 mem 需求</p><h4 id="Deployent"><a href="#Deployent" class="headerlink" title="Deployent"></a>Deployent</h4><p>​    是基于 pod 和 rs 提供的声明式定义控制器，用来替代 rc。<strong>deployment 的创建实际上会先创建出 rs，再由 rs 去按照预期来创建 pod</strong></p><p>​    deployment 中 spec 下有一个 replicas 项，如果没有定义则默认为 1，最后就只会有一个 pod</p><p>​    另外，deployment 和其对应 rs 都会在 etcd 中保存，以此来实现回退。当然直接修改 yaml 文件也可以实现灵活的回退</p><p>​    deployment 的常见命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f demo.yaml --record</span><br><span class="line"></span><br><span class="line">kubectl scale deployment demo --replicas 10</span><br><span class="line"></span><br><span class="line">kubectl autoscale deployment demo --min=5 --max15 --cpu-percent=70</span><br><span class="line"># node cpu 使用超过 80% 进行自动扩容，小于则自动缩容</span><br><span class="line"></span><br><span class="line">kubectl set image deployment/demo  &lt;container-name&gt;=&lt;image-name&gt;</span><br><span class="line"># 修改 pod 镜像会以滚动更新的方式去完成</span><br><span class="line"></span><br><span class="line">kubectl rollout pause deploy demo</span><br><span class="line"># rollout pause 暂停滚动更新 demo 的 deployment</span><br><span class="line"></span><br><span class="line">kubectl rollout resume deploy demo</span><br><span class="line"># rollout resume 恢复滚动更新</span><br><span class="line"></span><br><span class="line">kubectl rollout undo deployment/demo</span><br><span class="line"># rollout undo 回退 demo 的 deployment 版本</span><br><span class="line"># 回退的底层是根据 deployment 的 rs 创建时间，来操作恢复到上一个</span><br><span class="line"># 如果连续执行两次 rollout undo，相当于没有操作，因为第一次回退后，当前版本就成为第一次回退的上一版本</span><br><span class="line"></span><br><span class="line">kubectl rollout status deployment demo</span><br><span class="line"># rollout status 可以回滚的结果</span><br><span class="line"># rollout undo ... 结合上 rollout status 可以动态查看回滚的操作状态</span><br><span class="line"># rollout status 命令会返回 0 的退出码，可以通过 echo $? 查看退出码</span><br></pre></td></tr></table></figure><p>​    滚动更新策略，从 1.16 之后从 1-1 更改为 25%-25%，就是更新时允许在副本数上新增超过 25% 的 pod，也允许 25% 的 pod 不可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 patch 补丁方式调整 deployment 的滚动更新策略</span></span><br><span class="line">kubectl patch deployment demo -p <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;strategy&quot;: &#123;&quot;rollingUpdate&quot;:&#123;&quot;maxSurge&quot;: 1, &quot;maxUnavailable&quot;: 0&#125;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h4><p>​    可以实现集群中每个 node 上都运行一个 pod 副本，当 node 加入或移除时会自行动态的创建或删除这个 pod 副本。使用场景例如：日志收集（logstash），系统监控（Prometheus node exporter），系统程序（kube-proxy），集群存储（ceph）</p><p>​    比如下面这个使用 Fluentd 收集日志的 daemonset</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gcr.io/google-containers/fluentd-elasticsearch:1.20</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure><h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><p>​    通常 deployment 来编排无状态的应用，statefulset 编排有状态的应用或是不对等的中间件集群（如 mysql 集群，kafka 集群）</p><p>​    <strong>statefulset 的特点：</strong></p><ul><li><strong>稳定的数据持久化</strong>。当相同 pod 被重建时，原先 pod 的 pvc 会重新绑定到新 pod 上，这样对于同一个 pod 来说，访问持久化数据是完全一致的</li><li><strong>稳定的网络访问</strong>。基于 headless service（无 cluster ip）暴露 pod 的 dns 访问，在 pod 重建后，即使 pod ip 变化，但集群内通过前面无头 service 通过 pod 名的 dns 可以实现稳定访问，不会访问到其他 pod</li><li><strong>逐个顺序部署</strong>。pod 会根据 statefulset 的 name 以及 pod 名加上顺序编号来创建，默认的序号是从 0 开始，只有上一个 pod 起来后才会去创建下一个，并且对于 pv 和 pvc 也是根据编号关联的</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>   <span class="comment"># 使用无头模式</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure><p>​    apply 上面这个 yaml 文件，后创建一个 headless 的 svc，然后会根据 metadata 的 web 名字加上编号构建 pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@LostStars:~/my-k8s<span class="comment"># k get pod,svc</span></span><br><span class="line">NAME                                    READY   STATUS    RESTARTS      AGE</span><br><span class="line">pod/web-0                               1/1     Running   0             2m32s</span><br><span class="line">pod/web-1                               1/1     Running   0             2m31s</span><br><span class="line"></span><br><span class="line">NAME                             TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes               ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP        5d15h</span><br><span class="line">service/my-app-cluster-service   NodePort    10.96.28.21   &lt;none&gt;        80:30000/TCP   5d15h</span><br><span class="line">service/nginx                    ClusterIP   None          &lt;none&gt;        80/TCP         2m32s</span><br></pre></td></tr></table></figure><p>​    此时，进入 web-0 的 pod，可以使用 web-1 的 dns 名称去访问 web-1，dns 名字和 svc 的 dns 大部分一致，支持最前面需要加上 web-1 这个 pod 名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@web-0:/<span class="comment"># curl web-1.nginx.default.svc.cluster.local./index.html</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>​    statefulset 的更新可以通过 spec.updateStrategy 设置：</p><ul><li>默认为 OnDelete，表示只有手动删除旧的 pod 才会自动创建新 pod</li><li>RollingUpdate，表示更新时自动删除旧 pod，新的 pod 会按照编号的逆序方式进行创建。这个配置还支持通过 Partition 来设置一个数值，表示更新时只有 pod 编号超过这个 partition 值的才会滚动更新，之前的则保持不变</li></ul><h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>​    job 用于实现批处理的任务，默认 job 是一次性的，也就是 job controller 会检查 job 运行直到成功运行结束（退出码是 0），就是 completion 是 1</p><p>​    除此之外 k8s 还支持其他的 job 策略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: myjob</span><br><span class="line"><span class="comment"># 依次按照队列创建 pod 执行 job</span></span><br><span class="line">spec:</span><br><span class="line">  completions: 2    <span class="comment"># 将会逐个 pod 创建直到出现 2 次完成</span></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  <span class="comment"># 固定并发 pod 执行 job</span></span><br><span class="line">  parallelism: 5    <span class="comment"># 同时启动 5 个 pod 执行 job 任务</span></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  <span class="comment"># 固定并发按照队列依次创建 pod 运行 job</span></span><br><span class="line">  parallelism: 5</span><br><span class="line">  completions: 10   <span class="comment"># 按照 5 的并发创建 pod，且最后需要有 10 次是成功退出</span></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">  activeDeadlineSeconds: 120     <span class="comment"># 标志失败 Pod 的重试最大时间，超过这个时间不会继续重试</span></span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: myjob</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: job</span><br><span class="line">        image: xxxxxxxxx</span><br><span class="line">      restartPolicy: Never   <span class="comment"># job 的重启策略只有 Never 和 OnFailure</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h4 id="CornJob"><a href="#CornJob" class="headerlink" title="CornJob"></a>CornJob</h4><p>​    和 Linux 的 crontab 类似，通过分时日月周的表达式来实现定期任务执行</p><p>​    Cronjob 也有并发支持，但是与 job 的 parallelism 的不同，cronjob 的 <code>.spec.concurrencyPolicy</code> 并发不是具体数值而是一个字符串类型的并发策略：</p><ul><li><code>Allow</code> 是默认值允许定时任务可以并发执行；</li><li><code>Forbid</code> 是当周期任务间隔很近，前一个任务没有完成时禁止任务在下一个时间启动；</li><li><code>Replace</code> 是指下一个时间启动任务的上一个定时任务如果还没完成就被结束，正常执行下一个时间的定时任务</li></ul><p>​    <code>.spec.startingDeadlineSeconds</code> 可以设置定时任务的启动期限，如果 cronjob 因一些原因没有在这个期限时间内启动运行，就认为此次任务失败</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mycronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xxxxx</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">xxxxx</span></span><br></pre></td></tr></table></figure><h3 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h3><p>​    Custom Resource Definition，是对 k8s api 的一种扩展机制，允许用户定义自己的资源对象实现对不同需求的资源管理</p><p>​    但是只声明 CRD 资源对象还不够，通常还需要创建一个该资源对象的 controller 来与 k8s 核心功能交互，来实现对 CRD 内部的业务逻辑支持</p><h3 id="Project-Volume"><a href="#Project-Volume" class="headerlink" title="Project Volume"></a>Project Volume</h3><p>​    这类 volume 并不用来做 pod 中容器数据持久化的，而是用作给容器应用提供配置信息的读取，k8s 会将配置的这些 volume 投射到容器中</p><h4 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><p>​    ConfigMap 通常用于应用和配置的分离，避免因为配置修改导致需要重新构建新镜像，可以通过 yaml 申明创建也可以用命令创建</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my-configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configs</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">JAVA_OPTS:</span> <span class="string">-Xms1024m</span></span><br><span class="line">  <span class="attr">LOG_LEVEL:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>​    通过命令创建，或是通过现有文件也可以构建 ConfigMap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create configmap special-config --from-literal=mykey=myvalue</span><br><span class="line">configmap <span class="string">&quot;special-config&quot;</span> created</span><br><span class="line">$ kubectl get configmap special-config -o go-template=<span class="string">&#x27;&#123;&#123;.data&#125;&#125;&#x27;</span></span><br><span class="line">map[mykey:myvalue]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 使用 -from-env-file 参数指定 k=v 内容格式 env 文件</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;a=b\nc=d&quot;</span> | <span class="built_in">tee</span> config.env</span><br><span class="line">a=b</span><br><span class="line">c=d</span><br><span class="line"></span><br><span class="line">$ kubectl create configmap special-config --from-env-file=config.env</span><br><span class="line">configmap <span class="string">&quot;special-config&quot;</span> created</span><br><span class="line">$ kubectl get configmap special-config -o go-template=<span class="string">&#x27;&#123;&#123;.data&#125;&#125;&#x27;</span></span><br><span class="line">map[a:b c:d]</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 使用 -from-file 参数指定目录文件</span></span><br><span class="line">kubectl create configmap my-configmap --from-file=config.file</span><br><span class="line"><span class="comment"># config.file 中，每行都是 k=v 的格式可以用来作为环境变量写入 pod</span></span><br><span class="line"><span class="comment"># 如果每行不是 k=v 格式，会将文件名作为 key，文件内容作为 value</span></span><br></pre></td></tr></table></figure><p>​    通过 ConfigMap 引入环境变量，可以 containers 的 env 字段下通过自定义环境变量名，然后使用 valueFrom 和 configMapKeyRef 去关联指定的 configmap 和对应的 key</p><p>​    在使用 envFrom 和 configMapKeyRef 去指定要投射进容器的 configmap </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xxxx.xx/xx/xxxx:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LOG_LEVEL_CONFIG</span></span><br><span class="line">      <span class="comment"># configmap 中 LOG_LEVEL 的值将会赋值给 LOG_LEVEL_CONFIG 环境变量</span></span><br><span class="line">        <span class="attr">valueFrom:</span></span><br><span class="line">          <span class="attr">configMapKeyRef:</span>   <span class="comment"># valueFrom 可以使用 configMapKeyRef 去使用之前定义的 configMap</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">configs</span></span><br><span class="line">            <span class="attr">key:</span> <span class="string">LOG_LEVEL</span>   </span><br><span class="line">            <span class="comment"># 这里就是将定义的 configs 这个 configMap 里的 LOG_LEVEL 属性值写入到容器环境变量</span></span><br><span class="line">            <span class="comment"># 这里写入的 env，还可以在 command 字段的命令里直接使用</span></span><br><span class="line">    <span class="attr">envFrom:</span></span><br><span class="line">    <span class="comment"># 使用 envFrom 会自动忽略文件中无效的 key</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">configs</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：</strong></p><p>​    <strong>configmap 更新后，不会触发关联的 pod 滚动更新，即如果 configmap 是一个 kv 的用于 env 配置文件，在修改这个 cm 后，挂载这个 cm 的 pod 不会同步更新修改，可以通过修改 deploy 里 pod 的 annotation 来触发滚动更新</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过 patch 命令来设置 deployment 里 spce.metadata.annotations，完成后 deploy 的 pod 会重建</span></span><br><span class="line">k patch deployment nginx-deployment --patch <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;template&quot;:&#123;&quot;metadata&quot;:&#123;&quot;annotations&quot;: &#123;&quot;version&quot;: &quot;1&quot;&#125;&#125;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>​    通过 volume 方式挂载 ConfigMap，会在 pod 中指定的挂载目录下，创建一个 key 为名的文件，而内容就是 ConfigMap 中 key 对应的 value</p><p>​    如果只是指定 configmap 中某些 key 以文件形式挂载，还可以通过 items 去指定</p><p>​    volume 挂载方式在后期 ConfigMap 内容修改后，pod 会在一小段时间之后同步 ConfigMap 的修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xxxx.xx/xx/xxxx:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-vonfigs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-configs</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">configs</span></span><br><span class="line"><span class="string">----------------------------------------------------</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xxxx.xx/xx/xxxx:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080 </span><span class="number">3</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-vonfigs</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol-configs</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">configs</span></span><br><span class="line">        <span class="attr">items:</span>      <span class="comment"># 只将 configs 这个 cm 里的 logger_level 以文件挂载到容器 /data</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">logger_level</span></span><br><span class="line">           <span class="attr">path:</span> <span class="string">keys/logger_level</span></span><br></pre></td></tr></table></figure><p>​    <em>补充：如果要设定 ConfigMap 对象后期不可修改，在 yaml 中 kind 同层级下可添加 <code>immutable: true</code> 来禁止后续修改操作</em></p><h4 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h4><p>​    <strong>Secret 只会在 pod 需要时才会分发到节点，且这个 secret 是会存储在节点的内存中</strong>，它用于存储比 ConfigMap 更敏感的配置信息，比如应用调用其他服务需要的 token</p><p>​    <strong>使用 secret 时值需要通过 base64 编码后才可配置，不然 k8s 在使用这个 secret 是会自动通过 base64 解码就会导致错误</strong></p><p>​    比如，可以查看 k8s 中一个默认的 serviceaccount 类型的 secret <code>k get secret default-token-sw4r8 -n kube-system -o yaml</code>，其中 data 下配置了包含：ca.crt，namespace，token 三个内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">ca.crt:</span> <span class="string">LS0tLS1RUdTiBDRVJUSakNDQWVhZ0F3SUJBZ0lCQURBTna3Foa2lHOXcwQkFc0ZBREFWTNd0VRWURWUVFEZWUTluendTeFIyTnphaHNTTS9wWnJLV1hxcWxKWDRPak5uUjZiTk1hTlA3dmNmekV2WEVlcUZzblBJZnMKMEtJPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ZGVmYXVsdA==</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">ZXlKJHY2lJMU5SXNJbXRwWknRUbEpFVDJsc12xsWVVT0dNaWZRLV5SnBjM01pT2lcmRXSmxjbTsZdWekwzdVNRekp4eGg1UmpXN04yX0xFM3ZEWkRhUU5EVWxEaTJYaFAtMWdRLWcxdUdn</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure><p>​    上面三个配置会对应为三个文件，被挂载到容器中的 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 的这个目录，具体可以通过 pod 的 yaml 中的 <code>Volumes</code> 和 <code>volumeMounts</code> 两个配置查看，进入容器就可以验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node-2 ~]<span class="comment"># docker exec -it df4 /bin/sh</span></span><br><span class="line">/go/src/mygin/server <span class="comment"># cd //var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">/var/run/secrets/kubernetes.io/serviceaccount <span class="comment"># ls</span></span><br><span class="line">ca.crt     namespace  token</span><br><span class="line">/var/run/secrets/kubernetes.io/serviceaccount <span class="comment"># cat namespace</span></span><br><span class="line">default</span><br></pre></td></tr></table></figure><p>​    <strong>Secret 常见的三种类型：</strong></p><ul><li>Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；但数据也通过 base64 –decode 解码得到原始数据，所有加密性很弱</li><li><code>kubernetes.io/dockerconfigjson</code>：用来存储私有 docker registry 的认证信息</li><li><code>kubernetes.io/service-account-token</code>： 用于被 serviceaccount 引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的 secret 会自动挂载到 Pod 的 <code>/run/secrets/kubernetes.io/serviceaccount</code> 目录中</li></ul><p>​    <strong>实践：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my-secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dbpass</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span>    <span class="comment"># 这个类型还有其他多个</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">aW1vb2M=</span>       <span class="comment"># 注意，secret 里的值必须是 base64 编码之后的</span></span><br><span class="line">  <span class="attr">passwd:</span>  <span class="string">aW1vb2MxMjM=</span>    <span class="comment"># 假如后期密码发生变更，只需要修改这个 secret 的 yaml，apply 之后容器内会自动同步修改</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#pod-secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">springboot-web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xxxx.xx/xx/xxxx:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db-secret</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/db-secret</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db-secret</span>        <span class="comment"># 定义 Volume 的名字</span></span><br><span class="line">    <span class="attr">projected:</span>             <span class="comment"># 表示的就是 projectvolume</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">secret:</span>            <span class="comment"># 表示要投射挂载的 secret 类型</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">dbpass</span>     <span class="comment"># 这个名字是上面定义 secret 的 name</span></span><br></pre></td></tr></table></figure><h4 id="DownwardApi"><a href="#DownwardApi" class="headerlink" title="DownwardApi"></a>DownwardApi</h4><p>​    主要用途是可以将 pod 的一些原信息（metadata）通过挂载方式给到容器，比如分布式部署下，容器可能会需要 pod 的名字来标注日志，可以方面后期定位</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node-1</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">env:</span>    <span class="comment"># 对于容器来说，如果要将非 metadata 的信息引入容器，可以在 env 里使用 valueFrom</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MY_NODE_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">workdir</span></span><br><span class="line">      <span class="attr">downwardAPI:</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">podname.html</span></span><br><span class="line">            <span class="attr">fieldRef:</span>   <span class="comment"># 原信息获取需要使用 fieldref 字段</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span>   <span class="comment"># fieldpath 按照 yaml 字段路径，这个字段值会被写入 podname.html</span></span><br></pre></td></tr></table></figure><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>​    Kubernetes 中的 Volume 与 Docker 的 Volume 相似，但不完全相同：</p><ul><li>Kubernetes 的 Volume 定义在 Pod 上，然后被一个 Pod 中的多个容器挂载到具体的文件目录下</li><li>Kubernetes 的 Volume 与 Pod 生命周期相关，而与容器的生命周期无关，即容器挂掉，数据不会丢失。但是 Pod 挂掉，数据则会丢失</li></ul><p>​    在 k8s 中支持很多类型的卷，比如 hostPath，emptyDir 等，以及网络存储 nfs，glusterfs，ceph，rbd 等等</p><h4 id="Emptydir"><a href="#Emptydir" class="headerlink" title="Emptydir"></a>Emptydir</h4><p>​    emptyDir 是在 Pod 分配到 Node 时创建的，初始内容为空，无须自己指定宿主机上对应的目录文件，Kubernetes 会自动分配一个目录，当 Pod 被删除时，对应的 emptyDir 数据会永久删除</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line"><span class="attr">name:</span> <span class="string">test-emptydir</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/google_containers/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">  <span class="attr">volumes:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h4><p>​    hostPath 是在 Pod 上挂载宿主机上的文件或目录，不会因 Pod 的销毁而删除。另外也可以用 hostPath 来模拟网络存储通过 PV 和 PVC 实现 pod 与存储的绑定挂载，但几乎不会这么使用</p><p>​    hostpath 有多种类型，作用是在使用前可以实现检查的功能。默认不设置类型时，表示 pod 不会检查 hostpath 的挂载是否成功。DirectoryOrCreate，FileOrCreate，这两种类型分别表示指定的目录或文件如果不存在，将会由节点上的 kubelet 去创建目录（权限755）或文件（权限644）。还有 Directory 和 File，分别表示挂载的是目录或文件，如果不匹配不会进行创建，且不匹配时 pod 也将无法 running</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line"><span class="attr">name:</span> <span class="string">test-hostpath</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/google_containers/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cache</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">hostpath-volume</span></span><br><span class="line">  <span class="attr">volumes:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hostpath-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br></pre></td></tr></table></figure><h3 id="PV-与-PVC"><a href="#PV-与-PVC" class="headerlink" title="PV 与 PVC"></a>PV 与 PVC</h3><p>​    所谓持久卷，是指宿主机的卷目录内容不会因容器清理被删除，也不和宿主机绑定，这样 pod 漂移到其他节点后依然可以挂载到卷，所以大部分来说持久化卷都是提供了网络能力的存储</p><p>​    PV（PersistentVolume - 持久化卷），是对底层共享存储的一种抽象，PV 由管理员进行创建和配置，<strong>它和具体的底层共享存储技术的实现方式有关，比如 Ceph、GlusterFs、NFS、云盘等，都是通过插件机制完成与共享存储的对接</strong></p><p>​    PVC（PersistentVolumeClaim - 持久化卷声明），PVC 是用户存储的一种声明，对使用者来说无需关注底层存储实现直接声明就可使用，PVC 和 Pod 比较类似，Pod 消耗的是节点，PVC 消耗的是 PV 资源，Pod 可以请求 CPU 和内存，PVC 可以请求特定的存储空间和访问模式</p><p>​    通过 hostpath 模拟网络存储的 PV 是直接使用节点宿主机的目录来模拟带网络能力的存储，这种 PV 对应 PVC 只能在 PV 所在节点申请</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-hostpath</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">capacity:</span>     <span class="comment"># capacity 存储能力配置有很多配置项，这里只配置了一个存储的大小</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span>  <span class="comment"># accessModes 访问模式有 </span></span><br><span class="line">                <span class="comment">#  ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</span></span><br><span class="line">                <span class="comment">#  ReadOnlyMany（ROX）：只读权限，可以被多个节点挂载</span></span><br><span class="line">                <span class="comment">#  ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/data/k8s/test/hostpath&quot;</span>   <span class="comment"># 提前在宿主机上创建好目录，目录内包含一个自定义的 index.html  &lt;h1&gt;hello world&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure><p>​    apply 这个 pv 后，去 get pv 可以看到这个 pv 的 status 是 available 的状态。等创建 pvc 后，就会自行绑定上，变为 bound 状态。除此之外还有 released 状态，表示 pvc 被删除但是资源还没重新声明，failed 状态，表示该 pv 自动回收失败</p><p>​    <strong>补充：当 pv 的 pvc 已建立了绑定关系，pvc 被删除重新创建新的 pvc 后，pv 不会自动复用，此时新的 pvc 是会处于 pending 状态的。可以删除 pv 重新创建，然后 pv 和 pvc 就会重新进行绑定</strong></p><p>​    create 下面这个 pvc 后，k8s 会查找满足这个 pvc 需求的 pv 然后进行绑定。然后就可以创建一个 pod 去挂载这个 pvc 卷</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc-hostpath</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">manual</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span>    <span class="comment"># 这个 pvc 申请了一个 3G 空间的存储</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-hostpath-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span>     <span class="comment"># 通过 volumes 配置需要的 pvc</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pv-hostpath</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">pvc-hostpath</span></span><br><span class="line">  <span class="attr">nodeSelector:</span>   <span class="comment"># 因为前面的 pv 使用的是 master 节点的目录，所以这里要指定调度到 master</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">task-pv-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>   <span class="comment"># 通过 volumeMounts 进行容器挂载配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">&quot;/usr/share/nginx/html&quot;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pv-hostpath</span>   <span class="comment"># 将前面的 volume 挂载到 nginx 容器 /usr/share/nginx/html 这个目录</span></span><br></pre></td></tr></table></figure><p>​    apply 这个 pod 并 running 后，就可以进入容器查看是否有效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master k8s-learn]<span class="comment"># k exec -it pv-hostpath-pod -- /bin/bash</span></span><br><span class="line">root@pv-hostpath-pod:/<span class="comment">#</span></span><br><span class="line">root@pv-hostpath-pod:/<span class="comment"># ls /usr/share/nginx/html/</span></span><br><span class="line">index.html</span><br><span class="line">root@pv-hostpath-pod:/<span class="comment"># curl localhost</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>​    通常情况下，除非是固定 node 的 pod 才可能会使用 hostpath 的 pv，但本地目录这种方式是完全不可控的，因为目录随时可能会被写满，严重的话还会导致宿主机宕机。且如果 nodeSelector 的 pod 使用的 pv 不在一个节点上，最后就会导致 pod 调度失败</p><p>​    与 hostpath 类似的还有一个是 local pv，local pv 能保证 pod 始终能调度到请求 local pv 所在的节点，其功能类似于 hostpath + nodeaffinity，另外由于不是使用本地目录，所以 local pv 通常都是一个挂载到宿主机的磁盘设备，就是一个 pv 表示一个盘</p><p>​    因为 pv 和 pvc 会自动进行绑定，所以使用 local pv 的话，需要指定调度节点的 node 亲和性，并让 pv 和 pvc 的绑定延迟，这就需要用到 StorageClass，延迟绑定会将绑定的时机放到 pod 第一次在调度器进行调度的过程中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">local-storage</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/no-provisioner</span>  <span class="comment"># no-provisioner 表示不自动创建 pv，因为这里 local pv 是本地用目录模拟的</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">WaitForFirstConsumer</span>    <span class="comment"># WaitForFirstConsumer 表示延迟绑定 pv 和 pvc</span></span><br></pre></td></tr></table></figure><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>​    k8s 中 namespace 的隔离，主要针对两类，一类是资源对象，即 pod，deployment，service；另一类是资源配额，即 cpu，memory 的隔离</p><p>​    在相同 namespace 下，不同 pod 可以相互访问，也能通过 service ip 和 dns 相互访问</p><p>​    而在不同 namespace 下的两个 pod，则不能通过名字访问，因为 pod 内 dns 的配置都是根据 namespace 设置，例如 default 的 namespace 的 pod 其 dns 配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line">nameserver 10.96.0.10</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure><p>​    但是对于 service ip 和 pod ip，则允许相互访问，所以 namespace 除了使用名字访问外不会限制 service 和 pod ip 的访问</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>​    k8s 中的资源管理包括 cpu，memory，gpu，持久化存储。在集群中不同的节点可能资源也是不同的，节点会将自己的资源上报给 apiserver，这样在调度时 apiserver 就根据 pod 需要的资源来筛选满足的节点从而调度</p><p>​    例如 cpu 和 memory，在 k8s 的配置中主要使用的就是 requests 和 limits 两个配置项，requests 可以配置 pod 需要的资源大小，limits 配置的是资源最大限制大小，对 k8s 调度来说起到影响的是 requests 的设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-demo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mygin:v1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span>    <span class="comment"># memory 单位常见就是 Mi 和 Gi</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span>        <span class="comment"># cpu 的单位 m，1c = 1000m，这里 100m 表示 0.1 核</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">200m</span></span><br></pre></td></tr></table></figure><p>​    当 pod 已经被调度到节点后，修改 resources 的 requests 时重新 apply，如果节点剩余资源不满足 cpu 或 memory 设置，则 pod 将会处于 pending 状态</p><p>​    另外，容器的 memory 设置比较小时，此时如果出现内存飙升，当内存使用达到了 limits 的 memory 限制，k8s 其实不会将 pod 重启，而是会将消耗内存最大的进程给杀掉，可以用一个简单的 shell 脚本测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">str=<span class="string">&quot;this is test of memory limit&quot;</span></span><br><span class="line"><span class="keyword">while</span> [ TRUE ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  str=<span class="string">&quot;$str<span class="variable">$str</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;++++++++++&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> 0.1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>​    如果容器设置了 cpu 的 limits，那么容器运行使用 cpu 资源就会被限制到指定大小，可以用 dd 命令模拟进程占用，不同于 memory 的 limits，cpu 只会控制到指定限制，但不会杀死进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/null &amp;</span><br></pre></td></tr></table></figure><p>​    因为对于 cpu 资源来说，它是可压缩的的资源，如果容器超出 cpu 的限制，仅仅是无法得到更多 cpu 时间。对于 mem 来说，它是不可压缩资源，容器使用一旦超过 mem 限制就会导致 oom</p><p>​    <strong>补充：</strong></p><p>​    如果使用的是 docker 作为运行时，那么 k8s 的 requests 和 limits 的设置其实对应到 docker 容器中配置是 cpushares 和 memory，可以通过 <code>docker inspect &lt;id&gt;</code> 查看</p><p>​    Cpushares 的值是根据 requests 中 cpu 的配置得到的，docker 会将配置的 requests 的 cpu 100m，即 0.1 核 * 1024 得到一个整数值 102 设置。cpushares 其实是一个分配比例的设置，当节点上运行多个容器时，不同容器可能 cpushares 也不同，最后 docker 在分配 cpu 资源时就按照 cpushare 的比例来进行分配</p><p>​    Memory 的值与 k8s 中设置的 limits 的 memory 是一致的，不过表现上是 limits 的 memory 的值 * 1024 * 1024 后的值</p><p>​    另外有关 cpu 的配置，docker 里还有 cpuperiod 和 cpuquota，cpuperiod 是 docker 默认值 100000，单位是纳秒，cpuquota 的值则是和 limits 的 cpu 设置一样，但同样表现不同，是 limits 的 cpu 200mi=0.2 核 * 100000 = 20000 纳核。cpuquota 和 cpuperiod 是一对出现，表示每 100 毫秒内最大分配 cpu 资源是 0.2 核</p><p>​    Pod 通常可能会有多个容器运行，要尽可能保证服务运行稳定，容器的可靠就会需要设置 resource 的使用限制，最简单的一种方式，按照前述所说的 reques 和 limits 设置，可以分为三类：</p><ul><li>requests = limits，则表示为 pod 可靠</li><li>limits &gt; requests，表示 pod 为基本可靠</li><li>无 requests 和 limits，表示 pod 不可靠</li></ul><p>​    一旦 node 资源紧缺发生问题，k8s 会优先停止掉不可靠的 pod</p><p>​    k8s 中对资源的限制，还提供一个 limitrange 对象统一对 pod 和 container 进行资源控制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-limits</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span>    <span class="comment"># 注意对于 pod 对象，是无法设置 default 的，因为 pod 通常有多个 container，不同容器本身需要的资源也回不一样</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pod</span></span><br><span class="line">    <span class="attr">max:</span>     <span class="comment"># 这个 max 是设置 pod 中所有容器的 limits 上限</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">4000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">2Gi</span></span><br><span class="line">    <span class="attr">min:</span>     <span class="comment"># 这个 min 是设置 pod 中所有容器的 requests 的下限</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">    <span class="attr">maxLimitRequestRatio:</span>  <span class="comment"># maxLimitRequestRatio 用于配置最大 limit 与 request 比例</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="number">3</span>     <span class="comment"># 允许 limit 使用是 request 的 3 倍，一旦超过则表示 pod 不可靠</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="number">2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Container</span></span><br><span class="line">    <span class="attr">default:</span>    <span class="comment"># 如果 container 无配置，则使用该设置作为 limits</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">300m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">    <span class="attr">defaultRequest:</span>   <span class="comment"># 同理 default，配置 container 默认的 requests</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">200m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">    <span class="attr">max:</span>        <span class="comment"># 同理 pod 的 max，不过这个 max 不是总和</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">1Gi</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">100Mi</span></span><br><span class="line">    <span class="attr">maxLimitRequestRatio:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>​    创建这个 limitrange 后，可以通过命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master k8s-learn]<span class="comment"># k describe limits -n test</span></span><br><span class="line">Name:       test-limits</span><br><span class="line">Namespace:  <span class="built_in">test</span></span><br><span class="line">Type        Resource  Min    Max  Default Request  Default Limit  Max Limit/Request Ratio</span><br><span class="line">----        --------  ---    ---  ---------------  -------------  -----------------------</span><br><span class="line">Pod         cpu       100m   4    -                -              3</span><br><span class="line">Pod         memory    100Mi  2Gi  -                -              2</span><br><span class="line">Container   cpu       100m   2    200m             300m           5</span><br><span class="line">Container   memory    100Mi  1Gi  100Mi            200Mi          4</span><br></pre></td></tr></table></figure><p>​    k8s 中除了 pod 之外，还有很多资源都可以做限制或数量限制，提供了一个 ResourceQuota 的配置来设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">resource-quota</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hard:</span></span><br><span class="line">    <span class="attr">pods:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">requests.cpu:</span> <span class="string">2000m</span></span><br><span class="line">    <span class="attr">requests.memory:</span> <span class="string">4Gi</span></span><br><span class="line">    <span class="attr">limits.cpu:</span> <span class="string">4000m</span></span><br><span class="line">    <span class="attr">limits.memory:</span> <span class="string">8Gi</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">object-counts</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hard:</span></span><br><span class="line">    <span class="attr">configmap:</span> <span class="number">4</span></span><br><span class="line">    <span class="attr">secrets:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">services:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">replicationcontrollers:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>​    虽然 k8s 提供了不同的方式来作资源使用限制，但是依然不可能完全保证 pod 绝对可以稳定运行。所以 k8s 中引入了 pod 驱逐，pod 驱逐常见策略的配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--eviction-soft=memory.available&lt;1.5Gi</span><br><span class="line">--eviction-soft-grace-period=memory.available=1m30s</span><br><span class="line"><span class="comment"># eviction-soft 的驱逐表示出现资源不足时，并不会立即就将 pod 驱逐，上面两个配置是结合使用：</span></span><br><span class="line"><span class="comment"># 当节点内存不足 1.5 Gi，且超过 1m30s 后才会将 pod 驱逐</span></span><br><span class="line"></span><br><span class="line">--eviction-hard=memory.available&lt;100Mi,nodefs.available&lt;1Gi,nodefs.inodesFree&lt;5%</span><br><span class="line"><span class="comment"># eviction-hard 的驱逐就是立即性的，当节点出现配置中的一个情况就会立即驱逐 pod</span></span><br></pre></td></tr></table></figure><p>​    当磁盘资源不足时，k8s 会先删除死掉的 pod 和容器，然后会删除无用的镜像，以上检测都没有的话，会按照优先级（不可靠&gt;基本可靠&gt;可靠的），资源占用的情况对 pod 进行驱逐（比如同级别下的 pod，则驱逐 inode 使用最多的 pod）</p><p>​    当内存资源不足时，也会先驱逐不可靠的 pod，再会是基本可靠的 pod，以上驱逐依然无法处理内存不足，则会驱逐可靠级别的 pod</p><h4 id="Pod-服务质量-Qos"><a href="#Pod-服务质量-Qos" class="headerlink" title="Pod 服务质量 Qos"></a>Pod 服务质量 Qos</h4><p>​    Quality of service（Qos）在 k8s 中可以分为三个等级，用于定义在 node 资源不足时按照什么策略对 pod 进行驱逐</p><p>​    按照优先级低到高分别是：besteffort，burstable，guaranteed</p><ul><li><strong>BestEffort 是优先级最低的 Qos 等级，针对的目标是没有设置任何资源请求 (requests) 和资源限制 (limits) 的 Pod，资源不足时会优先驱逐这类等级的 pod</strong></li><li><strong>Guaranteed 是优先级最高的 Qos 等级，针对的目标是已经设置了资源请求(requests) 和资源限制 (limits) 的 Pod，要求是 pod 中的容器必须设置了 requests 和 limits，且 requests 和 limits 的限制值分别是要一致的</strong></li><li><strong>Burstable 是上述两个的中间等级，正对单容器的 pod，cpu 和 mem 的 requests 和 limits 的值可以不一致，对于多容器的 pod，允许可以有容器不设置 requests 和 limits，或者两个值允许不一样</strong></li></ul><table><thead><tr><th>CPU (requests + limits)</th><th>内存 (requests + limits)</th><th>QoS 等级</th></tr></thead><tbody><tr><td>未设置</td><td>未设置</td><td>BestEffort</td></tr><tr><td>未设置</td><td>requests &lt;= limits</td><td>Burstable</td></tr><tr><td>requests &lt;= limits</td><td>未设置</td><td>Burstable</td></tr><tr><td>requests = limits</td><td>requests &lt; limits</td><td>Burstable</td></tr><tr><td>requests &lt; limits</td><td>requests = limits</td><td>Burstable</td></tr><tr><td>requests = limits</td><td>requests = limits</td><td>Guaranteed</td></tr></tbody></table><h3 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h3><p>​    可以对资源进行标签，例如 pod，deployment，service，node，来标识资源属于，类型等，方便进行管理</p><p>​    在 k8s 的 label 是一个 key:value 的形式，所以自定义程度非常高，可以根据实际场景定制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#deploy</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-demo</span>   <span class="comment"># 这个 web-demo 是定义这个 deployment 的</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span>        <span class="comment"># selector 就是定义标签选择器，它作用于 replicate-controller，用于控制实例数</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-demo</span>   <span class="comment"># 这里表示去选择 label 中有 app=web-demo 的 pod</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span>        <span class="comment"># 使用 deployment 创建 pod，就是基于这个 template 来实现</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span>      <span class="comment"># 给这个 deployment 的 pod 添加 label</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-demo</span>   <span class="comment"># 注意，这里的 label 要与 selector 中 label 一致，否则将会报错</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.mooc.com/kubernetes/web:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodeSelector:</span>     <span class="comment"># 可以使用 nodeSelector 来设置 pod 根据 label 来调度到指定节点</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">node-1</span>    <span class="comment"># 如果没匹配到这个 label，这个 pod 就会处于 pending</span></span><br></pre></td></tr></table></figure><p>​    以这个 deployment 为例，其实不同的 deployment 允许使用相同的 selector 来作标签匹配，因为 deployment 相互是隔离的，这样当一个服务存在多个版本给不同用户访问时，就能利用相同 selector 的不同 deployment 来部署不同版本的服务</p><p>​    <code>matchLabels</code> 的设置是固定的 key:value 的 lables 满足子集匹配。除此之外，<code>matchExpressions</code> 还有一些操作符，来允许实现 in，not in 等方式选择满足 label 的 pod</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-demo</span></span><br><span class="line">    <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">group</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">dev</span>, <span class="string">test</span>]&#125;</span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span>  </span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-demo</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-demo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hub.mooc.com/kubernetes/web:v1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span>  </span><br></pre></td></tr></table></figure><p>​    标签选择的操作符，在命令行中也是支持的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l <span class="string">&#x27;group notin (dev, test)&#x27;</span> -n <span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kuberbetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuberbetes </tag>
            
            <tag> pod </tag>
            
            <tag> volume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>airflow整理</title>
      <link href="/466764255/"/>
      <url>/466764255/</url>
      
        <content type="html"><![CDATA[<h4 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h4><ul><li>WebServer：提供交互界面和监控，让开发者调试和监控所有 Task 的运行</li><li>Scheduler：负责解析和调度 Task 任务提交到 Execution 中运行</li><li>Executor：执行组件，负责运行 Scheduler 分配的 Task，运行在 Worker</li><li>MetaData DataBase：AirFlow 的元数据存储数据库，记录所有 DAG 程序的信息</li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>dag：有向无环图，airflow 中有三种任务的定义来描述一个系任务，分别是 operators，sensors，taskflow 装饰器，taskflow 本质上也是 operator，他们都基于 baseoperator，可以将 Operator 理解为一个任务单元</li><li>dagrun：dag 的运行实例，由解析程序解析 dag 的 starttime、endtime、schedule_interval 等，根据定时时间生成 dagrun</li><li>task instance：是 dagrun 中每个 task 的运行实例，每个任务都有一个状态的生命周期。task 的运行将根据 dag 中定义的依赖关系去判断执行</li><li>hook：提供 airflow 与外部平台或数据库交互的访问入口</li><li>connection：有了 hook 来访问，就需要有 connection 来设置 hook 需要的例如访问地址，端口，账号密码等等，这些都允许 admin 账号在 ui 上设置</li><li>job：airflow 对 Job 的提及不多，且这个 Job 和 dag 的 task 是不同的概念，Job 是一系列调度 Task 实例组成，有自己的运行状态和开始、结束时间，每个 Task 通过 job_id 关联一个 Job 实例。job 有 ScheduleJob、LocalTaskJob、BackfillJob 以及 DagProcessJob 等等<ul><li>ScheduleJob 以守护进程运行，负责解析目录，并根据调度计划生成任务实例，判断任务之间的依赖和发送到 executor</li><li>LocalTaskJob 负责监控和管理任务的进程，其中 TaskRunner 会创建子进程来运行任务</li><li>TriggererJob 也是守护进程运行，会根据触发条件来触发 dag</li><li>DagProcessJob 是用于处理 dag 文件解析和加载的任务</li></ul></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol><li>Scheduler 定期扫描 DAG 文件目录，检查 Metadata Database 中是否已经有 DAG Run 实例</li><li>Scheduler 查看 DAG 的 dependencies，将关联的任务加到 queue 中，更新 Database 中 Taskinstance 的状态为 <code>queue</code></li><li>Scheduler 将 queue 中的任务分配给 Executor，Executor 接收到后启动 worker 来执行 task，Worker 开始执行时，Taskinstance 的状态 <code>running</code></li><li>根据任务执行的结果 Taskinstance 的状态会发生变化例如 <code>failed</code>、<code>success</code> 等</li><li>一旦所有 queued 的 task 全部完成，Scheduler 会查看目前 DAG Run 所有 task 的结果，最后将 DAG Run 状态设置为 <code>failed</code> 或 <code>success</code></li></ol><p>​     <strong>！！注意 ！！</strong> worker 组件是 dag 的真正执行者，所以 worker 必然需要 dag 目录</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=NGM1MjU5ZjFhNjZmYjMzMmE2NGEyZTU2ZTFlMmJkNzVfbUlSTEVZNlhsaFNIZEs4ZXUzQnpiVG9ISGxlUGZ0c3JfVG9rZW46Qm1Fc2JkbzlKb2pZOTR4RVd4MWNGSjc4bm5SXzE3NTIzMDQwNjA6MTc1MjMwNzY2MF9WNA" alt="img"></p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZmOTA2OTRjNWEyOTRiZTM2NjcxZWY3NzZlNGRjOThfSk1nMThOVjg3ZUlmZjJjVEhZek10bTlUdTdrRDNhQ0xfVG9rZW46TjZFbGJZTVQ0b2JUUk94SzVmTWNxcjR5bk1jXzE3NTIzMDQwNjA6MTc1MjMwNzY2MF9WNA" alt="img"></p><h4 id="角色权限"><a href="#角色权限" class="headerlink" title="角色权限"></a>角色权限</h4><p>​        airflow 的 ui 操作通过 flask appbuilder（FAB）进行实现，其中默认有 5 类角色，public，viewer，user，op，admin（权限大小按照从左至右排序）</p><ul><li><strong>public：</strong>表示的是匿名用户，没有任何权限，所以也无法通过登录进入到内部进行查看和操作</li><li><strong>viewer：</strong>拥有了很多基础的查看的能力，包括 dag 以及一些菜单栏中和 dag 相关的数据查看，但是没有 dag 的激活，触发执行，编辑，删除能力</li><li><strong>user：</strong> 基于 viewer 之上，增加 viewer 没有的 dag 相关的操作能力和 datasets 的创建</li><li><strong>op：</strong>在基于 user 之上，增加 airflow 的一些配置相关的操作和修改，例如，变量，连接，并发池 等等</li><li><strong>admin：</strong>基于 op 之上，增加安全性与审计相关的配置操作，例如，对添加用户，用户赋权，日志审计</li></ul><h5 id="自定义-role-和权限"><a href="#自定义-role-和权限" class="headerlink" title="自定义 role 和权限"></a>自定义 role 和权限</h5><p>Admin 角色管理可以在 webserver ui 上 security 下进行 user 和 role 的编辑管理操作</p><p>​      需要能够访问 ui，添加：can read on Website</p><p>​      需要能够访问 dag 菜单，和指定 dag，添加：menu access on DAGs，can read on DAG:host_demo。如果需要编辑，删除就是对应的 edit 和 delete</p><p>​      更多内容：<a href="https://airflow.apache.org/docs/apache-airflow-providers-fab/stable/auth-manager/access-control.html#resource-based-permissions">https://airflow.apache.org/docs/apache-airflow-providers-fab/stable/auth-manager/access-control.html#resource-based-permissions</a></p><h5 id="api-认证"><a href="#api-认证" class="headerlink" title="api 认证"></a>api 认证</h5><p>​        默认 airflow 的 RESTful api，支持 basic 和 session 两种认证，basic 是基于 base64 的 <code>username:passwd</code> 之后放到请求头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic xxxxxxxx==</span><br></pre></td></tr></table></figure><p>​        当 user 设定了特定的 dag 权限后，无法访问的 dag 使用 api 调用会自动 forbidden</p><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>​        airflow 中 admin 面板下可以设置 connections，其中可以配置各种例如，数据库，云服务，ssh 等连接配置</p><p>​        其中一个重要字段是 extra，它的存储类型是 text，也就是 extra 可以配置一个 json 的字符串数据，通过键值对的方式实现对连接参数的补充。另外，connection 中的 password 是不会显示的</p><p>​        所有的 connection 都允许进行 test，默认是不开启的，需要在配置文件中 <code>AIRFLOW__CORE__TEST_CONNECTION = enabled</code> 来设置，如果 connection 配置的简单的 RESTful api，可以开启连接测试</p><h5 id="connection-和-hook"><a href="#connection-和-hook" class="headerlink" title="connection 和 hook"></a>connection 和 hook</h5><p>​        连接配置完成后，使用时需要通过 hook 来执行。以 http 的 conn 为例，文件表单的数据，使用 files。当然如果需要修改请求参数，run 方法内可以根据需要设置</p><p>对于一些 api 的认证 token 或秘钥，可以配置在 extra 中，然后使用 get_connection 方法获取连接，通过 extra_dejson 属性就能拿到 extra 的 json 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow.providers.http.hooks.http <span class="keyword">import</span> HttpHook</span><br><span class="line"></span><br><span class="line">conn = HttpHook.get_hook(<span class="string">&quot;piper_conn&quot;</span>)</span><br><span class="line">conn.method = <span class="string">&quot;POST&quot;</span></span><br><span class="line">conn.run(files=multipart_form_data)</span><br><span class="line"></span><br><span class="line">conn.run(endpoint=<span class="string">f&#x27;xxxx/api/v1/vm&#x27;</span>, data=&#123;<span class="string">&quot;provider&quot;</span>: provider, <span class="string">&quot;region&quot;</span>: region&#125;)</span><br></pre></td></tr></table></figure><p>Connection 也可以直接在代码里定义，本质上和在 webserver 上创建 connection 没有差别</p><p>具体使用感受，对于普通的 RESTful api 或许可以不用这个 hook 去发起请求，requests 或其他请求模块可能更方便一些</p><h4 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h4><p>​        目前看下来有三种方法：</p><ul><li>使用 mysql 的 hook，然后通过 sql 语句查询</li><li>使用 airflow 的 models 可以直接用 find 方法查询</li><li>使用 airflow 的 session，通过 query 指定 model，用 filter 方法可以进行过滤，类似 ORM</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment"># 也可以用下面的 create_session，这个是在 settings.session 封装的，会更好一些</span></span><br><span class="line"><span class="keyword">from</span> airflow.utils.session <span class="keyword">import</span> create_session</span><br><span class="line"></span><br><span class="line"><span class="meta">@task(<span class="params">task_id=<span class="string">&quot;get_succeed_migrate_dagrun&quot;</span>, task_display_name=<span class="string">&quot;获取已完成迁移任务的参数&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_succeed_migrate_dagrun</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="keyword">with</span> create_session() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="comment"># session = settings.Session()</span></span><br><span class="line">        dagruns = session.query(DagRun).<span class="built_in">filter</span>(DagRun.state==<span class="string">&#x27;success&#x27;</span>, DagRun.dag_id==<span class="string">&#x27;vm_migration_test&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dagruns:</span><br><span class="line">            res.append(item.conf)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;succeed_migrate_vm_params&quot;</span>: res&#125;</span><br></pre></td></tr></table></figure><h4 id="任务流"><a href="#任务流" class="headerlink" title="任务流"></a>任务流</h4><p>dag 中的 task 流表现形式有两种，一种使用 <code>&gt;&gt;</code> 这种语法糖的形式，另一种是直接基于 task 返回传参的方式，前者通常会需要通过 xcom 来获取前一步的 task 的返回，后者相对简便一些，但如果多个任务都接收一个任务的返回，会增加很多流的依赖</p><p>还有一种方式是通过 chain 或 chain_liner 函数，将 ti 实例按照顺序传入，airflow 会自动将任务串联起来</p><p>dag 的声明，也有两种方式，一种是使用 model 的 DAG，通过 with 语法来声明，另一种使用 decorators 的 dag 装饰器来声明 dag 函数，同时使用 task 装饰器来声明每个 task 函数</p><p>补充：</p><p>airlfow 中所有的 task 函数中，都可以从 <code>**kwargs</code> （有些例子会写成 <code>**context</code>）中获取 dagrun 实例的参数，也就是定义 dag 的 params 属性触发时填入的对应参数</p><p>如果 dag 的参数需要在其中多个 task 使用，除了最基本的使用 task return 的 xcom，也可以在一开始将初始参数全部整理完成，覆盖到 <code>kwargs[&quot;params&quot;]</code> 或 <code>kwargs[&quot;dag_run&quot;].conf</code>，这两个某种程度上来说是相似的，dag_run 的 conf 可以来自 UI 或 api 触发时提交的数据</p><p> 但是 <strong>由于 kwargs 会携带整个 dagrun 上下文，所以在任务运行性能上会有轻微的损失</strong></p><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><p>​        airflow.cfg 配置文件中，<code>_folder =</code> 这几个配置项例如 dags_folder，plugins_folder 都会被加载到 airflow python 包搜索路径中</p><h4 id="任务依赖关系"><a href="#任务依赖关系" class="headerlink" title="任务依赖关系"></a>任务依赖关系</h4><p>​        通常下使用基础的 taskflow 传递和分支有时不一定能满足较为复杂的 dag 流程，所以会使用到 af 中提供的其他模块支持：</p><p>​        关于 trigger，sensor，dataset，api 方式的使用示例描述：<a href="https://medium.com/datamindedbe/cross-dag-dependencies-in-apache-airflow-a-comprehensive-guide-88cbc0bc68d0">https://medium.com/datamindedbe/cross-dag-dependencies-in-apache-airflow-a-comprehensive-guide-88cbc0bc68d0</a></p><p>​        trigger 触发器：可以实现在 dag 中触发其他 dag，来实现跨 dag 的触发以及延迟任务的触发</p><p>​        sensor 传感器：可以实现基于时间线的延迟任务来等待某个任务发生，和 trigger 的不同感觉是 sensor 属于被动</p><p>​        datasets 数据集：除了时间调度 dag 外，也支持根据数据集更新来触发 dag 运行</p><h4 id="dag-管理"><a href="#dag-管理" class="headerlink" title="dag 管理"></a>dag 管理</h4><p>​        dag 文件管理，官方文档中给了几个示例：</p><p>​        <a href="https://airflow.apache.org/docs/helm-chart/stable/manage-dags-files.html#">https://airflow.apache.org/docs/helm-chart/stable/manage-dags-files.html#</a></p><p>​        对于 docker 安装，官方的 docker-compose 文件中是在 env 中设置了目录挂载，dag 目录被挂在 webserver，triggerer，scheduler，worker 四个容器上。官方建议分布式结构下处于安全考虑 webserver 不应该可以访问 dag 文件</p><p>​        但是目录挂载方式，会直接覆盖掉设置的容器内对应的 /opt/airflow/dags 目录，导致构建的镜像中已存在的 dag 被覆盖掉，可以用数据卷挂载的方式，这样镜像里的 dag 将会写到宿主机上</p><p>​        对于 k8s 安装，则可以使用网络存储或 git-sync 来采取不同的方案</p><h5 id="dag-文件解析"><a href="#dag-文件解析" class="headerlink" title="dag 文件解析"></a>dag 文件解析</h5><p>​        参考文档：<a href="https://blog.terrace.ink/article/77d23126-f6e1-4e48-9c75-41630dc139a6#7cf79b5df32f4ae8b0cbdedda2cc9e94">https://blog.terrace.ink/article/77d23126-f6e1-4e48-9c75-41630dc139a6#7cf79b5df32f4ae8b0cbdedda2cc9e94</a></p><p>​        默认 airflow 对 dags folder 目录每 300 秒 <code>dag_dir_list_interval</code> 进行新文件的检查，同时会启动两个解析进程每 30 秒会对 dag 文件进行解析来更新，每 60 秒会对源文件不存在的机器标记 inactive 取消显示</p><p>​        如果在 dags folder 添加或删除 dag 的 py 文件，除非正好进入新的轮询期，那么这些文件将需要等到 5 分钟才会被更新。删除 dag py 文件后，解析器会检查到文件不存在跳过解析</p><p>​        另外，需要注意，避免在 dag 源文件中引入大体量的包，或是一些复杂代码的顶层函数，因为 dag 解析程序会执行每一个 dag 文件，因此可能会导致解析时间变长，这在官方文档的最佳实践中有明确提到</p><h4 id="k8s-executor"><a href="#k8s-executor" class="headerlink" title="k8s executor"></a>k8s executor</h4><p>​        k8s 部署环境中，由于每个 task 将会以 pod 的形式被调度执行，因此 k8s 部署环境下，worker pod 需要使用 pod 的模版文件 pod_template_file，其中明确需要的两个字段是 image 和 name</p><p>​        有关模版文件的示例可以见：<a href="https://airflow.apache.org/docs/apache-airflow-providers-cncf-kubernetes/stable/kubernetes_executor.html#example-pod-templates">https://airflow.apache.org/docs/apache-airflow-providers-cncf-kubernetes/stable/kubernetes_executor.html#example-pod-templates</a></p><p>​        除了可以定制自定义的 pod 模版文件外，也可以直接配置 airflow 上设置 <code>AIRFLOW__KUBERNETES__WORKER_CONTAINER_REPOSITORY</code> 和 <code>AIRFLOW__KUBERNETES__WORKER_CONTAINER_TAG</code>，这两个配置也是给 worker pod 设置镜像仓库和版本标签</p><p>​        补充：使用 k8s executor 执行 task 相对而言可能会增加 task 整体时间，因为 pod 的初始化可能会增加一小部分时间</p><h4 id="变量安全"><a href="#变量安全" class="headerlink" title="变量安全"></a>变量安全</h4><p>​        admin 角色可以对 variable 进行管理，ui 默认会对敏感的 variable 名字进行 value 隐藏，包括 connection 中的 password，目前看 variable 的 key 名称中包含 secret、private、token 字符的 value 都会进行 * 符号替换</p><p>​        除此之外，还可以通过 <code>sensitive_var_conn_names</code> 配置项来自定义要隐藏的 key 列表</p><p>​        core 配置中设置 fernet_key，目的是对 variable 数据保存做加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from cryptography.fernet import Fernet</span><br><span class="line">&gt;&gt;&gt; fernet_key = Fernet.generate_key()</span><br><span class="line">&gt;&gt;&gt; print(fernet_key.decode())</span><br></pre></td></tr></table></figure><h4 id="Task-分支"><a href="#Task-分支" class="headerlink" title="Task 分支"></a>Task 分支</h4><p>airflow 有两个基于 PythonOperator 的 Operator 来支持逻辑分支功能</p><ul><li>ShortCircuitOperator：用来实现流程执行判断<ul><li>Task 基于 ShortCircuitOperator，如果本 Task 返回为 False 的话，其下游 Task 将被 skip；如果返回为 True 的话，其下游 Task 将会被正常执行。适合用在下游都是单线任务流的场景，注意 task_group 中使用会因为一个跳过导致整个任务组被跳过</li></ul></li><li>BranchPythonOperator：用来实现 Case 分支<ul><li>Task 基于 BranchPythonOperator，airflow 会根据本 task 的返回值（返回值是某个下游 task 的 id）来确定哪个下游 Task 将被执行，而同级下游 Task 将被 skip</li></ul></li></ul><h4 id="动态任务"><a href="#动态任务" class="headerlink" title="动态任务"></a>动态任务</h4><p>Dag 可以根据参数数组动态创建 task 执行，airlfow 中 task 和 task_group 都允许使用 expand 来构建动态 task</p><p>在 airflow 的 dag 中也可以有多条 chain，在触发 dagrun 后，这些 chain 会并发执行，expand 动态构建的 task 会在 map 里同样也会并发执行</p><p>在 task_group 后的任务如果要得到 group 中最后一个任务的返回，需要在 task_group 里 return 最后的 task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@task_group</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_map</span>(<span class="params">cicode</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t1</span>(<span class="params">cicode</span>):</span><br><span class="line">        <span class="built_in">print</span>(cicode)</span><br><span class="line">        <span class="keyword">if</span> cicode == <span class="string">&quot;123&quot;</span>:</span><br><span class="line">            <span class="keyword">raise</span> AirflowSkipException()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t2</span>(<span class="params">cicode</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;t2&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cicode)</span><br><span class="line">        <span class="keyword">return</span> cicode</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t3</span>(<span class="params">cicode</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;t3&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cicode)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;t3 - <span class="subst">&#123;cicode&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    task1 = t1(cicode)</span><br><span class="line">    task2 = t2(cicode)</span><br><span class="line">    task3 = t3(cicode)</span><br><span class="line"></span><br><span class="line">    chain(task1, task2, task3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task3</span><br><span class="line">    </span><br><span class="line"><span class="meta">@task(<span class="params">trigger_rule=<span class="string">&quot;none_failed&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">collect_result</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">80</span>)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">80</span>) </span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">LazySelectSequence([<span class="number">2</span> items])</span><br><span class="line">t3 - <span class="number">234</span></span><br><span class="line">t3 - <span class="number">345</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还会见到另外一种调用方式 check_vm_data.partial(a=10).expand(region=regions)</span></span><br><span class="line">check_vm_data(region=regions[<span class="number">0</span>], a=<span class="number">10</span>)</span><br><span class="line">check_vm_data(region=regions[<span class="number">1</span>], a=<span class="number">10</span>)</span><br><span class="line">check_vm_data(region=regions[<span class="number">2</span>], a=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># expand 也可以处理多个数组参数, 例如：</span></span><br><span class="line">added_values = add.expand(x=[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>], y=[<span class="number">5</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># add(x=2, y=5)</span></span><br><span class="line"><span class="comment"># add(x=2, y=10)</span></span><br><span class="line"><span class="comment"># add(x=4, y=5)</span></span><br><span class="line"><span class="comment"># add(x=4, y=10)</span></span><br><span class="line"><span class="comment"># add(x=8, y=5)</span></span><br><span class="line"><span class="comment"># add(x=8, y=10)</span></span><br></pre></td></tr></table></figure><h4 id="Trigger-Rules"><a href="#Trigger-Rules" class="headerlink" title="Trigger Rules"></a>Trigger Rules</h4><p>默认 task 的触发规则是 all-success，也就是当前任务的所有上游任务的状态必须是完成时，才会运行自己</p><p>但是在并发执行任务中，例如 expand 根据参数动态构建的一组任务，其中某个任务执行异常失败时，这个组最后的状态也会是失败的，从而导致下游任务将无法执行</p><p>所以可以通过修改 task 的 trigger rule 来改变任务执行前对上游检查判断的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">all_success (default): All upstream tasks have succeeded</span><br><span class="line"></span><br><span class="line">all_failed: All upstream tasks are in a failed or upstream_failed state</span><br><span class="line"></span><br><span class="line">all_done: All upstream tasks are done with their execution</span><br><span class="line"></span><br><span class="line">all_skipped: All upstream tasks are in a skipped state</span><br><span class="line"></span><br><span class="line">one_failed: At least one upstream task has failed (does not wait for all upstream tasks to be done)</span><br><span class="line"></span><br><span class="line">one_success: At least one upstream task has succeeded (does not wait for all upstream tasks to be done)</span><br><span class="line"></span><br><span class="line">one_done: At least one upstream task succeeded or failed</span><br><span class="line"></span><br><span class="line">none_failed: All upstream tasks have not failed or upstream_failed - that is, all upstream tasks have succeeded or been skipped</span><br><span class="line"></span><br><span class="line">none_failed_min_one_success: All upstream tasks have not failed or upstream_failed, and at least one upstream task has succeeded.</span><br><span class="line"></span><br><span class="line">none_skipped: No upstream task is in a skipped state - that is, all upstream tasks are in a success, failed, or upstream_failed state</span><br><span class="line"></span><br><span class="line">always: No dependencies at all, run this task at any time</span><br></pre></td></tr></table></figure><h4 id="Setup-and-teardown"><a href="#Setup-and-teardown" class="headerlink" title="Setup and teardown"></a>Setup and teardown</h4><p>简单来看这两个装饰器和普通线性 dag 的 task 装饰器执行逻辑不同，在 setup 和 teardown 中的任务如果出现失败，不会影响最后 teardown 任务执行</p><p>因此这两个装饰器的作用看起来有点像是 try except 和 finally，所以可以用来对任务使用到的资源做清理，释放连接等</p><p> 其余补充：</p><ul><li>teardown 任务当作为 dag 中最后一个任务，其状态会被 airlfow 忽略，也就是说当 <strong>teardown 任务执行失败，且没有依赖的下游任务，dagrun 的状态也会是 success，前提是 setup 任务需要至少有一个是完成的</strong></li><li>在 task_group 中，teardown 任务如果执行失败，这个 task_group 的状态也会被设置为 failed。如果 teardown 任务是 task_group 中最后一个，那 task_group 的下游普通 task 任务默认的上游是 teardown 的上游任务，如果 teardown 失败了，同样不会影响到这个普通 task 的执行</li><li>在 <strong>setup 和 teardown 中的任务被 rerun 的话，这两个 setup 和 teardown 任务同样会被重新执行</strong>。如果 setup 和 teardown 中有并行的任务链，其中一条任务链上的 ti rerun 不会让并行的其他任务链上的 ti 也重新执行</li></ul><h4 id="Sensor"><a href="#Sensor" class="headerlink" title="Sensor"></a>Sensor</h4><p>部分任务可能并不需要立即完成后就释放资源，可以使用了 timedeltasensorasync 这个触发器来做延时执行，这些延时任务的状态会被设置为 defer，但是这些任务依然会占用 pool 中的 slots</p><p>所以应该将这些又需要的延时执行任务，设定到专门的 pool 中，避免在突然大量任务执行时，这些 defer 任务占用 slots 导致其他可能优先级较高的任务阻塞一直在排队等待执行</p><h4 id="Xcom"><a href="#Xcom" class="headerlink" title="Xcom"></a>Xcom</h4><p>Task 的 return 默认会写入到 xcom，这个 xcom 可以作为参数传递给下一个 task，或者通过 <code>context[&quot;ti&quot;].xcom_pull(task_ids=&quot;&quot;)</code> 去获取指定任务返回的 xcom</p><p>如果是在 expand 的动态 task 中要使用 xcom_pull 获取上游任务的返回，还需要加上 map_indexes 参数。注意这些参数都是复数的，因此可以在一次 xcom_pull 中获取多个任务结果</p><p><strong>注意，这个 xcom 是明文的，所以作为参数传递时，task template 的 opargs 也是明文</strong></p><h4 id="Ti-的状态"><a href="#Ti-的状态" class="headerlink" title="Ti 的状态"></a>Ti 的状态</h4><p>none：任务尚未排队等待执行（尚未满足其依赖性）</p><p>scheduled：调度程序已确定满足任务的依赖关系并且应该运行</p><p>queued：任务已分配给执行者并正在等待工作人员</p><p>running：任务正在 worker 上运行（或在 local/synchronous executor）</p><p>success：任务完成运行没有错误</p><p>shutdown：任务运行时被外部请求关闭</p><p>restarting：任务在运行时被外部请求重启</p><p>failed：任务在执行过程中出错，未能运行</p><p>skipped：由于分支、LatestOnly 或类似原因，任务被跳过</p><p>upstream_failed：上游任务失败，触发规则说我们需要它</p><p>up_for_retry：任务失败，但还有重试次数，将重新安排</p><p>up_for_reschedule：任务是一个处于重新调度模式的传感器</p><p>deferred：任务已被推迟到触发器</p><p>removed：任务自运行开始后已从 DAG 中消失</p><h3 id="Dag-demo"><a href="#Dag-demo" class="headerlink" title="Dag demo"></a>Dag demo</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> airflow.decorators <span class="keyword">import</span> dag, task, task_group</span><br><span class="line"><span class="keyword">from</span> airflow.models.baseoperator <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">from</span> airflow.models.param <span class="keyword">import</span> Param</span><br><span class="line"><span class="keyword">from</span> airflow.operators.python <span class="keyword">import</span> get_current_context</span><br><span class="line"><span class="keyword">from</span> airflow.exceptions <span class="keyword">import</span> AirflowSkipException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;airflow.task&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dag(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="comment"># dag_id=&quot;&quot;, # 默认是装饰的函数名称作为 dag id</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="comment"># schedule_interval=None,    # 支持 cron 表达式，可以用 timedelta(days=1) 设置定时间隔</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    schedule=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="comment"># &quot;hourly&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="comment"># &quot;00 10 * * *&quot;   # 默认是 utc 时间，也就是按照当前时区，实际执行时间 18:00</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    <span class="comment"># CronDataIntervalTimetable(&quot;0 0 * * *&quot;, timezone=&quot;Asia/Shanghai&quot;)   # 可以自定义时区</span></span></span></span><br><span class="line"><span class="params"><span class="meta">    description=<span class="string">&quot;dev dag template&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">    tags=[<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;template&quot;</span>],</span></span></span><br><span class="line"><span class="params"><span class="meta">    params=&#123;</span></span></span><br><span class="line"><span class="params"><span class="meta">        <span class="string">&quot;cicodes&quot;</span>: Param(<span class="params"></span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta">            <span class="built_in">type</span>=<span class="string">&quot;array&quot;</span>,</span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta">            description=<span class="string">&quot;cicode of list&quot;</span>,</span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta">        </span>),</span></span></span><br><span class="line"><span class="params"><span class="meta">        <span class="string">&quot;operator&quot;</span>: Param(<span class="params"></span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta">            default=<span class="string">&quot;fw&quot;</span>,</span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta">            <span class="built_in">type</span>=<span class="string">&quot;string&quot;</span></span></span></span></span><br><span class="line"><span class="params"><span class="params"><span class="meta">        </span>)</span></span></span><br><span class="line"><span class="params"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="meta"></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dag_template</span>():</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task2</span>(<span class="params">num</span>):</span><br><span class="line">        logger.info(<span class="string">f&quot;current task get num: <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">        name = <span class="string">f&quot;task2_<span class="subst">&#123;num&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;task2_2&quot;</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;oops! <span class="subst">&#123;name&#125;</span> task have error&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span> AirflowSkipException(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> task will skipped&quot;</span>)</span><br><span class="line">            <span class="comment"># map 中的某个任务发生错误时设置 skip，map 任务最后状态将是 success，避免因为一个异常导致整个 map 的任务都无法继续执行下游</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task.branch(<span class="params">trigger_rule=<span class="string">&quot;none_failed&quot;</span></span>)  </span><span class="comment"># 上游任务没有错误时触发，如果上游有 skip 状态任务也依然可以执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">branch</span>(<span class="params">**context</span>):</span><br><span class="line">        params = context[<span class="string">&quot;params&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> params[<span class="string">&quot;operator&quot;</span>] != <span class="string">&quot;fw&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task4&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task3</span>():</span><br><span class="line">        ctx = get_current_context()</span><br><span class="line">        data = ctx[<span class="string">&quot;ti&quot;</span>].xcom_pull(task_ids=[<span class="string">&quot;task2&quot;</span>])</span><br><span class="line">        logger.info(<span class="string">f&quot;task have data: <span class="subst">&#123;<span class="built_in">list</span>(data)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task4</span>():</span><br><span class="line">        ctx = get_current_context()</span><br><span class="line">        data = ctx[<span class="string">&quot;ti&quot;</span>].xcom_pull(task_ids=[<span class="string">&quot;task2&quot;</span>])</span><br><span class="line">        logger.info(<span class="string">f&quot;task have data: <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task_group</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task5</span>():    <span class="comment"># task_group 接收的参数是 xcom 对象，因此不能使用 context</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @task(<span class="params">trigger_rule=<span class="string">&quot;none_failed&quot;</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">task5_1</span>():</span><br><span class="line">            logger.info(<span class="string">&quot;task5_1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @task</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">task5_2</span>():</span><br><span class="line">            logger.info(<span class="string">&quot;task5_2&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        chain(task5_1(), task5_2())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task6</span>():</span><br><span class="line">        ctx = get_current_context()</span><br><span class="line">        data = ctx[<span class="string">&quot;ti&quot;</span>].xcom_pull(task_ids=[<span class="string">&quot;task2&quot;</span>, <span class="string">&quot;task5.task5_2&quot;</span>])</span><br><span class="line">        <span class="built_in">print</span>(data)  <span class="comment">#  LazySelectSequence([3 items])</span></span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">1</span>]:</span><br><span class="line">            logger.info(<span class="string">f&quot;data is <span class="subst">&#123;<span class="built_in">list</span>(data)&#125;</span>&quot;</span>)   </span><br><span class="line">            <span class="comment"># data is [&#x27;task2_1&#x27;, &#x27;task2_3&#x27;, True]</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;done&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t1 = task1()</span><br><span class="line">    t2 = task2.expand(num=t1)</span><br><span class="line">    t2 &gt;&gt; branch() &gt;&gt; (task3(), task4()) &gt;&gt; task5() &gt;&gt; task6()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dag_template()</span><br></pre></td></tr></table></figure><h3 id="Scheduler-工作流源码分析-——-纯文字版"><a href="#Scheduler-工作流源码分析-——-纯文字版" class="headerlink" title="Scheduler 工作流源码分析 —— 纯文字版"></a>Scheduler 工作流源码分析 —— 纯文字版</h3><p>调度器的主要内部逻辑就是一个 loop 的循环，通过 <code>airflow scheduler</code> 命令会启动实例化一个 SchedulerJobRunner（SchedulerJobRunner 继承了 BaseJobRuner 和 LoggingMixin），此时会创建一个 job  记录，然后通过 run_job 函数内 execute_job 运行这个对象的 _execute 方法，这个执行只要正常完成，或是正确退出，就会将 job 状态设置为 success，否则就为 failed</p><p>_execute 方法会判断是否开启独立 dag-processor 的配置，默认是 False，然后实例化 DagFileProcessorAgent，然后会 start 启动一个子进程 DagFileProcessorManager 负责解析 dags 目录的文件，在此之前还会调用 executor 的 start 方法来初始化使用的 executor</p><p>在 DagFileProcessorManager  中会有一个 DagFileProcessor 子进程单独负责解析，默认配置下会按照 300 秒来对 dags-folder 的目录做一次检查来判断是否有新的 dag，同时每 30 秒会对每个文件进行处理。airflow 支持将 DagFileProcessor 进行独立部署，配置文件中将 standalone_dag_processor 设为 True 接口单独运行解析进程</p><p>然后在 _execute 会运行整个调度的核心方法 _run_scheduler_loop，这里会根据调度计划，来执行需要运行的 dag。对于定时任务，解析进程会自动创建对应的 dagrun 和 ti 写入数据库，而手动触发或 API 调用则会直接创建对应数据</p><p>_run_scheduler_loop 会有一个 timers 的时间调度器，来按照配置周期检查孤儿任务，触发超时，pool 指标，僵尸任务等等</p><p>然后就是主体循环，_do_scheduling 方法是决定调度的任务，首先会根据设计调度时间，来创建出定时任务的 dagrun，在 _start_queued_dagruns 方法将数据库中 dagrun 状态更新为 running，通过 _schedule_all_dag_runs 方法将更新 tis 的状态为 scheduled，如果 ti 是 emptyOperator 则会将状态改为 success。一开始这些在数据库中的 ti 的 state 是空值，然后会遍历返回 ti 及其 callback，_send_dag_callbacks_to_processor 会检查 cache 中的 dagrun 是否超过 SLA 设置</p><p>再往下走进入到 _critical_section_enqueue_task_instances 方法，会查找 scheduled 的 ti 并将其转为 queued 状态，然后将 ti 发送给 executor。这个方法内有两个方法，_executable_task_instances_to_queued 和 _enqueue_task_instances_with_queued_state，前者会根据一些条件查询 scheduled 的 ti，后者是这些等待执行的 ti 的相关信息写入到 executor 的 queue_task 字典中</p><p><strong>_executable_task_instances_to_queued 里主要是会通过</strong> <strong><code>select .... For update</code></strong> <strong>来对查询结果加上锁，目的是实现多个 scheduler 运行时保证 ti 运行一致性</strong>，然后还有一些就是配置上一些参数的检查</p><p>_enqueue_task_instances_with_queued_state 方法里面遍历前面得到准备执行的 ti，将这些 ti 和其 command 以及执行队列 queue ，还有优先级通过 job 的 executor 的 queu_command 方法将这些数据写到 queue_task 中</p><p>以上是 _do_scheduling 主要内容，接着回到 _run_scheduler_loop 方法里，执行 self.job.executor.heartbeat 方法，heartbeat 方法里 trigger_tasks 会根据当前 pool 里可用 slots 数量从之前的 queue_task 里把数据放入到 task_tuples 里，在将这个元组作为参数给 _process_tasks 方法。这里根据所使用的 executor 不同，会有一些不太一样的地方。以使用 celeryexecutor 为例，_process_tasks 方法内会通过_send_tasks_to_celery 将任务异步发送给到 celery broker，然后就是 celery worker 通过监听到任务后去执行 task 的 command</p><p>当 worker 执行完成任务后，会通过事件告知 scheduler 关于 ti 的状态和信息，scheduler 的 _process_executor_events 会从 event-buffer 得到 worker 发送的信息在日志上显示。ti 离开 broker 进入 worker 后，ti 的状态从 queued 变为 running</p><p> DR 和 TI 执行状态变化大致如下：</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFiOTU1MDJhYjA3NGE4MmUyODQyMzViNTYwNzg1NjZfV2JCUE9uM2pjQUtpZGd1ZHFpcTNqUFF3WDdTVlFqVDZfVG9rZW46SjVWZGJzSzRab2VOSVl4TTg0S2NaeHRqbnFoXzE3NTIzMDQyODE6MTc1MjMwNzg4MV9WNA" alt="img"></p><p> Dagrun 的整个状态周期：</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=OGRiMjgzODY0NzQyODgxM2JhZTU5OGIxNTNmYTBjN2ZfSnEycHJQMUlPeDJKQWNyUWZXOEFlNzU3WEtUYThFN3ZfVG9rZW46V0RsWWIxUkFHb1p6S1J4bHBvWGMyeWk2bnlZXzE3NTIzMDQyODE6MTc1MjMwNzg4MV9WNA" alt="img"></p><h3 id="Celeryexecutor-工作流程"><a href="#Celeryexecutor-工作流程" class="headerlink" title="Celeryexecutor 工作流程"></a>Celeryexecutor 工作流程</h3><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JkYTdmMDZjZGJmYjA1NTY0NTE4Y2FkYzdkNzU0ZjNfUVRqMVc5bEdZMW9HZFZOMTJsMXdaVElKcEQ0ZGxsZ2dfVG9rZW46RDQ1RGJ1Mm9Qb3Nla1J4ckpWamNoV3FrbnljXzE3NTIzMDQyODE6MTc1MjMwNzg4MV9WNA" alt="img"></p><p> [1] SchedulerProcess 处理任务，当它发现需要完成的任务时，将其发送到 QueueBroker。</p><p> [2] SchedulerProcess 也会周期性的查询 ResultBackend 以获取任务的状态。</p><p> [3] QueueBroker 当它意识到有新任务产生时，会将有关它的信息发送到 WorkerProcess </p><p> [4] WorkerProcess 将单个任务分配给一个 WorkerChildProcess。</p><p> [5] WorkerChildProcess 执行适当的任务处理功能 - 关键方法：execute_command()。并创建个新的进程 - LocalTaskJobProcess。</p><p> [6] LocalTaskJobProcess 逻辑由 LocalTaskJob 类描述。它使用 TaskRunner 启动的新进程。</p><p> [7] RowTaskProcess 执行用户实际的代码，这一步是最底层真正执行 task 的操作</p><p> [8][9] Process RawTaskProcess 和 LocalTaskJobProcess 在完成task后停止。</p><p> [10] WorkerChildProcess 通知主进程 - WorkerProcess 任务结束以及后续任务的可用性。</p><p> [11] WorkerProcess 将状态信息保存在 ResultBackend 中。</p><p> [12] 当 SchedulerProcess 再次询问 ResultBackend 状态时，将会获取到任务状态的信息。</p><p><strong>手动触发和 api 触发 dag，会创建 dagrun 和关联的 ti 保存到数据库，且 dagrun 的状态是 queued，ti 则是无状态，此时这些任务并不会发送给 celery 的 broker，而是等待 scheduler 的 loop 中 executor.heartbeat() 方法将 queued 的 ti 发送到 celeryexecutor，然后其 _process_tasks 方法来进行处理</strong></p><h3 id="参考引线"><a href="#参考引线" class="headerlink" title="参考引线"></a>参考引线</h3><ul><li><a href="https://airflow.apache.org/docs/apache-airflow/2.9.2/start.html#">https://airflow.apache.org/docs/apache-airflow/2.9.2/start.html#</a> - 官方文档</li><li><a href="https://www.astronomer.io/docs/learn/intro-to-airflow">https://www.astronomer.io/docs/learn/intro-to-airflow</a> - astronomer airflow 文档</li><li><a href="https://workflow-engine-book.shuwoom.com/">https://workflow-engine-book.shuwoom.com/</a> - <strong>流程引擎原理与实践</strong></li><li><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=103092651">https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=103092651</a> - airflow confluence</li><li><a href="https://airflow.apache.org/docs/apache-airflow-providers-celery/stable/celery_executor.html">https://airflow.apache.org/docs/apache-airflow-providers-celery/stable/celery_executor.html</a> - celery-executor</li><li><a href="https://github.com/jghoman/awesome-apache-airflow?tab=readme-ov-file#best-practices-lessons-learned-and-cool-use-cases">https://github.com/jghoman/awesome-apache-airflow?tab=readme-ov-file#best-practices-lessons-learned-and-cool-use-cases</a> - awesome-airflow</li><li><a href="https://medium.com/datamindedbe/cross-dag-dependencies-in-apache-airflow-a-comprehensive-guide-88cbc0bc68d0">https://medium.com/datamindedbe/cross-dag-dependencies-in-apache-airflow-a-comprehensive-guide-88cbc0bc68d0</a> - trigger，sensor，dataset，api 描述和应用</li><li><a href="http://viplao.com/index.php/2024/10/26/%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%BF%90%E8%A1%8C-apache-airflow-%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%92%8C%E6%95%99%E8%AE%AD/">http://viplao.com/index.php/2024/10/26/%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%BF%90%E8%A1%8C-apache-airflow-%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%92%8C%E6%95%99%E8%AE%AD/</a> - 经验分享</li><li><a href="https://yylives.cc/2024/02/08/what-we-learned-after-running-airflow-on-kubernetes-for-2-years/">https://yylives.cc/2024/02/08/what-we-learned-after-running-airflow-on-kubernetes-for-2-years/</a> - 经验分享</li></ul>]]></content>
      
      
      <categories>
          
          <category> airflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> airflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础</title>
      <link href="/2133446919/"/>
      <url>/2133446919/</url>
      
        <content type="html"><![CDATA[<h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>终端可以分为：tty，pts</p><p>Tty（<strong>Teletype</strong>）传统物理终端的抽象，可以分物理 tty，虚拟 tty（<code>/dev/tty1</code>~<code>/dev/tty6</code>），一般本地登录都是使用 tty </p><p>Pts （<strong>Pseudo Terminal Slave</strong>）伪终端，最常见的比如 ssh 远程连接，pts 是动态创建，如 <code>/dev/pts/0</code></p><p>通过输入 <code>tty</code> 命令，可以查看当前是哪个终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@LostStars:~<span class="comment"># tty</span></span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure><h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>常见的 linux 包管理系统有 redhat 的 rpm（包后缀是 .rpm），debian 的 dpkg（包后缀是 .deb）</p><p>使用 rpm 安装安装 rpm 包，<code>rpm -i xxxx.rpm</code>，注意使用 rpm 命令安装 rpm 包时无法处理有依赖关系的包</p><p>所以就有了 yum/dnf（centos） 和 apt（ubuntu）这种高级的包管理工具，他们可以在安装包的时候自动处理相关的依赖包安装。补充：dnf 是 yum 的继任者，在处理性能上高于 yum</p><p>yum/dnf 属于 C/S 架构，yum 服务器存放着 rpm 包和相关包的元数据（存放在特定目录的 repodata 中），linux 客户端使用 yum 安装包时会从服务器的 yum 仓库里得到 repodata 的信息，然后去查找依赖进行下载安装</p><p>在机器上有一个仓库的配置目录 <code>/etc/yum.repos.d/</code>，这下面存放着许多以 .repo 结尾的配置文件，每个配置文件里可以配置多个仓库信息， 例如下面的 baseos</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仓库id</span></span><br><span class="line">[baseos]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仓库1的名字</span></span><br><span class="line">name=CCLinux <span class="variable">$releasever</span> - BaseOS</span><br><span class="line"></span><br><span class="line"><span class="comment"># mirrorlist用于指定镜像服务器的地址列表 </span></span><br><span class="line">mirrorlist=http://mirrorlist.centos.org/?release=<span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=os&amp;infra=<span class="variable">$infra</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指明软件下载路径，其中支持的协议有 http:// ftp:// file:// 三种</span></span><br><span class="line">baseurl=http://yum.bandaoyu.cn/repo/cclinux/lcx/BaseOS/x86_64/os/ </span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-cclinuxofficial </span><br><span class="line"></span><br><span class="line">gpgcheck=1           <span class="comment"># 分别代表是否进行gpg校验，如果没有这一项，默认是检查</span></span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">metadata_expire=6h</span><br><span class="line">countme=1</span><br><span class="line">enabled=1            <span class="comment"># 启用或禁用软件仓库。0表不启用baseurl，为1表启用baseurl路径</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>补充：repo 文件中通常还有 <code>[extras]</code> 和 <code>[epel]</code> 两个仓库 id，前者是用作对没找到的包的补充，后者是对接国外 repo 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum repolist   <span class="comment"># 查看启用的 repo id， -v 可以查看具体配置信息</span></span><br><span class="line">yum list       <span class="comment"># 查看所有包</span></span><br><span class="line">yum list installed    <span class="comment"># 查看已安装的包， available 可安装，update 可更新</span></span><br><span class="line">yum install xxx       <span class="comment"># 安装指定的包，-y 全部确认安装避免交互</span></span><br><span class="line">yum remove  xxx       <span class="comment"># 卸载指定的包</span></span><br><span class="line">yum update  xxx       <span class="comment"># 更新指定的包</span></span><br><span class="line">yum search  xxx       <span class="comment"># 搜索是否有指定的包</span></span><br><span class="line">yum providers  /etc/scp    <span class="comment"># 查看指定目录是由什么包生成的</span></span><br></pre></td></tr></table></figure><h3 id="系统相关命令"><a href="#系统相关命令" class="headerlink" title="系统相关命令"></a>系统相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 cpu 信息，可以查看核数，架构，型号等</span></span><br><span class="line">lscpu             <span class="comment"># 信息来自 cat/proc/cpuinfo</span></span><br><span class="line"><span class="built_in">arch</span>              <span class="comment"># 查看系统架构</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内容空间，可以查看总体内存使用率</span></span><br><span class="line">free -h           <span class="comment"># 信息来自 cat /proc/meminfo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看硬盘和分区</span></span><br><span class="line">lsblk -f          <span class="comment"># 查看各硬盘分区和文件系统类型</span></span><br><span class="line"></span><br><span class="line">sudo fdisk -l     <span class="comment"># 列出所有磁盘分区表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1   <span class="comment"># 查看当前目录的所有文件夹的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看操作系统发行版本</span></span><br><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br><span class="line"><span class="built_in">cat</span> /etc/os-release(非红帽系统，例如 ubuntu)</span><br></pre></td></tr></table></figure><h4 id="系统内核参数"><a href="#系统内核参数" class="headerlink" title="系统内核参数"></a>系统内核参数</h4><p>​    通过 <code>sysctl -a</code> 可以列出所有内核相关的参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@myk8s-control-plane:/<span class="comment"># sysctl -a | grep &quot;icmp&quot;</span></span><br><span class="line">net.ipv4.icmp_echo_enable_probe = 0</span><br><span class="line">net.ipv4.icmp_echo_ignore_all = 0</span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line">net.ipv4.icmp_errors_use_inbound_ifaddr = 0</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line">net.ipv4.icmp_ratelimit = 1000</span><br><span class="line">net.ipv4.icmp_ratemask = 6168</span><br><span class="line">net.ipv4.vs.nat_icmp_send = 0</span><br><span class="line">net.ipv4.vs.schedule_icmp = 0</span><br><span class="line">net.ipv6.icmp.echo_ignore_all = 0</span><br><span class="line">net.ipv6.icmp.echo_ignore_anycast = 0</span><br><span class="line">net.ipv6.icmp.echo_ignore_multicast = 0</span><br><span class="line">net.ipv6.icmp.ratelimit = 1000</span><br><span class="line">net.ipv6.icmp.ratemask = 0-1,3-127</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_icmpv6_timeout = 30</span><br></pre></td></tr></table></figure><p>​    举个栗子，net.ipv4.icmp_echo_ignore_all 的参数就是设置是否允许本机可以被其他网络 ping，默认是 0 表示允许，设置为 1 表示拒绝</p><p>​    所有的参数设置，可以在 <code>/etc/sysctl.conf</code> 这个文件中配置，然后使用 <code>sysctl -p</code> 重载配置来生效</p><p>​    <strong>补充：</strong>这个内核参数其实对应到的是一个个文件，这些文件都在 <code>/proc/sys/</code> 这个目录下，以上面 net.ipv4.icmp_echo_ignore_all 参数来说，其文件路径就是 <code>/proc/sys/net/ipv4/icmp_echo_ignore_all</code></p><h4 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h4><p>主要有两个命令：dmesg 和 journalctl，另外还有一个 syslog</p><ul><li>dmesg：主要记录内核和硬件相关的日志，这些信息存储在 <strong>内存缓冲区</strong>（<code>/dev/kmsg</code>），所以一旦重启就无法再看到故障信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dmesg                      <span class="comment"># 查看完整内核日志</span></span><br><span class="line">dmesg -T                   <span class="comment"># 显示人类可读时间戳</span></span><br><span class="line">dmesg | grep <span class="string">&quot;error&quot;</span>       <span class="comment"># 过滤错误信息</span></span><br><span class="line">dmesg -w                   <span class="comment"># 实时监控内核日志</span></span><br></pre></td></tr></table></figure><ul><li>journalctl：会记录所有 systemd 管理的日志（包括内核、系统服务、应用程序），且数据会持久化存储在 <strong>二进制文件中</strong>（<code>/var/log/journal/</code>）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">journalctl                 <span class="comment"># 查看所有日志</span></span><br><span class="line">journalctl -k              <span class="comment"># 仅内核日志（等效于 dmesg）</span></span><br><span class="line">journalctl -u nginx        <span class="comment"># 查看 nginx 服务日志</span></span><br><span class="line">journalctl --since <span class="string">&quot;2024-01-01&quot;</span> --until <span class="string">&quot;2024-01-02&quot;</span>  <span class="comment"># 按时间筛选</span></span><br><span class="line">journalctl -p err          <span class="comment"># 仅显示错误日志</span></span><br><span class="line">journalctl -f              <span class="comment"># 实时跟踪日志</span></span><br></pre></td></tr></table></figure><ul><li>syslog：是 Linux 系统的传统日志记录机制，许多系统和应用程序都会使用 <code>syslog</code> 记录日志信息。日志文件通常存储在 <code>/var/log</code> 目录下，默认 systemd-journald 会将日志准发给 rsyslog，所以 syslog 也能查看</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/syslog           <span class="comment"># 查看通用系统日志</span></span><br><span class="line">grep <span class="string">&quot;error&quot;</span> /var/log/syslog  <span class="comment"># 文本过滤</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/auth.log     <span class="comment"># 实时监控认证日志</span></span><br></pre></td></tr></table></figure><h3 id="Iptabels"><a href="#Iptabels" class="headerlink" title="Iptabels"></a>Iptabels</h3><p>​    Linux 防火墙主要是工作在网络层，用于实现网络包的过滤。防火墙的功能是以 nftables 框架嵌入在 linux 内核中（即内核态），iptables 是属于管理者对防火墙规则配置管理工具（即用户态）</p><h4 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h4><p>​    Iptables 防火墙规则的配置常常会提到四表五链，四表分别是：filter，nat，raw，mangle（<strong>数据进入防火墙后，会按照 raw→mangle→nat→filter 顺序依次应用各表内的规则</strong>），五链分别是：PREROUTING、POSTROUTING、INPUT、OUTPUT 和 FORWARD</p><p><strong>四表的作用：</strong></p><ul><li>Filter 表：用于实现包，端口过滤</li><li>Nat 表：用于地址转发，实现共享地址</li><li>Raw 表：允许数据包进行连接跟踪，或绕开连接跟踪时进行自定义的包处理</li><li>Mangle 表：用于负责进行封装、拆解包</li></ul><p><strong>五链的功能：</strong></p><p>​    各个链中的默认规则都是 ACCEPT 表示接受数据包，DROP 表示直接丢弃数据包不返回响应，REJECT 表示拒绝数据包但会返回信息。每个链都会有一条默认规则，用来处理该链所有规则都不匹配的情况</p><ul><li>PREROUTING 链：在数据包进行路由选择前，应用该链的规则</li><li>POSTROUTING 链：在数据包返回前，应用该链的规则</li><li>INPUT 链：数据包访问防火墙本机入站，会应用该链的规则</li><li>OUTPUT 链：防火墙本机应用完成返回数据包出站，会应用该链的规则</li><li>FORWARD 链：数据包需要通过进行转发时，会应用该链的规则</li></ul><p><strong>数据包在防火墙中的处理流程：</strong></p><p><img src="https://wei-foun.github.io/img/iptables.jpg" alt=""></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>Iptables 常用的参数描述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">-L  列出所有规则</span><br><span class="line">-n  以数字形式显示</span><br><span class="line">-t  可以指定查看哪个表的规则，例如 -t nat</span><br><span class="line">--line（--line-number） 列出规则的序号</span><br><span class="line">-s  表示 <span class="built_in">source</span>，访问来源 ip 或 网段</span><br><span class="line">-d  表示 destination，访问目标的 ip 或 网段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-A  追加规则到最后一行</span><br><span class="line">-I  插入一条规则到第一行</span><br><span class="line"></span><br><span class="line">-D  删除指定序号的规则</span><br><span class="line">-F  清空所有规则</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前节点的 iptables 规则</span></span><br><span class="line">iptables -nL </span><br><span class="line"></span><br><span class="line"><span class="comment"># 屏蔽具体原地址 172.18.0.4 访问本机</span></span><br><span class="line">iptables -I INPUT -s 172.18.0.4 -j REJECT  <span class="comment"># 拒绝访问，返回信息，使用 DROP 也可以</span></span><br><span class="line">iptables -nL</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">REJECT     0    --  172.18.0.4           0.0.0.0/0            reject-with icmp-port-unreachable   </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 屏蔽指定网段的 ip 访问</span></span><br><span class="line">iptables -I INPUT -s 172.18.0.0/16 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝指定网段访问本机 8081 的端口</span></span><br><span class="line">iptables -I INPUT -s 172.18.0.0/16 --dport 8081 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝访问本机多个网段，可以用 -m 使用 multiport 模块去实现</span></span><br><span class="line">iptables -I INPUT -m multiport -p tcp --dport 8081,8082 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只允许指定 172.18.0.0/16 网段访问</span></span><br><span class="line">iptables -I INPUT ! -s 172.18.0.0/16 -j REJECT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据包频率限制，使用 -m limit 模块，--limit 参数设定速率，--limit-burst 设置并发处理数</span></span><br><span class="line">iptables -I INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/minute --limit-busrt 5 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 INPUT 链中序号为 1 的规则</span></span><br><span class="line">iptables -D INPUT 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改指定链的默认规则，这里是拒绝所有数据包进入，修改默认前一定需要检查允许的规则是否正确</span></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 nat 表，设置 snat，将内网地址转为公网地址</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 172.16.1.0/24 --to-source &lt;公网 ip&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 nat 表，设置 dnat，同时将用户公网访问端口映射得到内网服务的端口</span></span><br><span class="line">iptables -t nat -A PREROUTING -d &lt;网关或nginx的公网 ip&gt; -p tcp --dport 8080 -j DNAT --to-destnation 172.16.1.2:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前配置的所有规则</span></span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件恢复规则</span></span><br><span class="line">iptables-restore &lt; /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><h3 id="I-O-重定向"><a href="#I-O-重定向" class="headerlink" title="I/O 重定向"></a>I/O 重定向</h3><p>分为输入 <code>&lt;，&lt;&lt;</code> 和输出 <code>&gt;，&gt;&gt;</code> 重定向，注意 <code>&gt;</code> 覆盖有时是比较危险的操作，可以通过 <code>set -C</code> 命令禁止覆盖重定向</p><p>标准输入 stdin，标准输出 stdout，标准错误输出 stderr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; fw.txt &lt;&lt; <span class="string">EOF       # EOF</span> 标准输入重定向，通常用于非编辑下写入到数据到文件</span><br><span class="line">&gt; 12</span><br><span class="line">&gt; 23</span><br><span class="line">&gt; EOF</span><br><span class="line"><span class="built_in">cat</span> fw.txt</span><br><span class="line">12</span><br><span class="line">23</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;name:fw\nage:27&quot;</span> &gt; info.txt   </span><br><span class="line"><span class="comment"># echo -e 参数可以对特殊字符转移，例如这里的 \n</span></span><br><span class="line"><span class="comment"># echo -n 参数表示不换行输出</span></span><br><span class="line"></span><br><span class="line">LS 2&gt; err.txt            <span class="comment"># 将 LS 的错误信息覆盖到 err 文件</span></span><br><span class="line"><span class="comment"># 0 标准输入文件描述符</span></span><br><span class="line"><span class="comment"># 1 标准输出文件描述符</span></span><br><span class="line"><span class="comment"># 2 标准错误输出文件描述符</span></span><br><span class="line"></span><br><span class="line">LS &amp;&gt; info.txt           <span class="comment"># 将 LS 的任何输出信息都覆盖到 info 文件</span></span><br><span class="line"></span><br><span class="line">LS &amp;&gt; /dev/null          <span class="comment"># 将输出信息丢入 &quot;垃圾桶&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./data.txt bs=1 count=10</span><br><span class="line"><span class="comment"># 从 /dev/zero 设备读取 10 次，每次 1 个字节，写入 data.txt</span></span><br><span class="line"><span class="comment"># 注意，这个 data.txt 的类型是 data，不是文本文件类型</span></span><br><span class="line"><span class="comment"># dd 通常用于磁盘清洗和测试</span></span><br></pre></td></tr></table></figure><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>Redundant Array of Independent Disks，独立磁盘冗余阵列。是一种通过组合多个物理磁盘来提升性能、可靠性或两者兼顾的存储技术</p><p>RAID 主要利用数据条带、镜像和数据校验技术来获取高性能、可靠性、容错能力和扩展性，根据运用或组合运用这三种技术的策略和架构，可以把 RAID 分为不同的等级，以满足不同数据应用的需求</p><p>RAID 0：通过数据条带（Data Stripping），将数据分块后存储在不同磁盘上，拥有非常高效的写入性能，但是并不具备冗余和恢复能力，<strong>可用空间是：最小磁盘 * 磁盘数 n（&gt;=2）</strong></p><p><img src="https://wei-foun.github.io/img/raid0.jpg" alt="img"></p><p>RAID 1：镜像（Mirror），磁盘写入数据时，会将数据无差异写入两块磁盘上，实现在 RAID 0 基础上拥有了冗余和恢复能力，但是磁盘使用率也降低了一半，且成本非常高，<strong>可用空间是：最小磁盘 * 磁盘数/n（n&gt;=2）</strong></p><p><img src="https://wei-foun.github.io/img/raid1.jpg" alt="img"></p><p>RAID 5：在 RAID 3 和 RAID 4 的数据校验（Data parity）的升级，数据分块写入多块磁盘时，会有一块磁盘用于存储数据的校验信息，这样在故障时通过正常的数据和奇偶校验码来计算出故障磁盘上的数据，兼顾了存储性能、数据安全和存储成本等各个方面因素，<strong>可用空间是：最小磁盘 * 磁盘数 n-1（n&gt;=3）</strong></p><p><img src="https://wei-foun.github.io/img/raid5.jpg" alt="img"></p><p>RAID 6：可以看做是 RAID 5 的扩展版，通过增加一块磁盘和双重校验技术来存储两份校验信息，允许出现两块磁盘故障也能够保持阵列继续正常工作，虽然读取性能和可用性更高，但是写入和成本也比 RAID 5 要更高，<strong>可用空间是：最小磁盘 * 磁盘数 n-2（n&gt;=4）</strong></p><p><img src="https://wei-foun.github.io/img/raid6.jpg" alt="img"></p><p>RAID 01：RIAD 级别都各自有优缺点，因此也出现将各级别组合起来的使用，RAID 01，即结合条带化和镜像，数据写入将会同时写两份到非底层组合的两块磁盘上，实现在上层组合的镜像达到数据冗余和恢复，<strong>可用空间是：最小磁盘 * 磁盘数（n&gt;=4）</strong></p><p><img src="https://wei-foun.github.io/img/raid01.jpg" alt="img"></p><p>RAID 10：和 RAID 01 的组合模式相反，数据分块写入到非底层组合的两块磁盘，同时底层组合的 RAID 1 将会利用镜像实现冗余，<strong>可用空间是：最小磁盘 * 磁盘数/2（&gt;=4）</strong></p><p><img src="https://wei-foun.github.io/img/raid10.jpg" alt="img"></p><p><img src="https://wei-foun.github.io/img/raid%E5%AF%B9%E6%AF%94.jpg" alt="img"></p><h3 id="快捷操作"><a href="#快捷操作" class="headerlink" title="快捷操作"></a>快捷操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份当前目录中指定文件</span></span><br><span class="line"><span class="built_in">cp</span> home/cdosapi/docker-compose.yaml&#123;,.bak&#125;</span><br><span class="line"><span class="comment"># 等同于 cp home/cdosapi/docker-compose.yaml home/cdosapi/docker-compose.yaml.bak</span></span><br></pre></td></tr></table></figure><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>Linux 上对于 shell，python 这种解释型语言，可以使用 <code>./test.sh</code> 这种当前方式执行，当然也可以使用绝对路径。这种方式会检查是否有文件执行权，只有满足才能执行，否则会报错 <code>Permission denied</code></p><p>还有一种方式是通过 <code>bash test.sh</code> 执行，这种方式不需要执行权</p><p>另外，通过 <code>bash -x test.sh</code> 可以将脚本内的每个命令单步执行输出，通常用于脚本调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@LostStars:~<span class="comment"># bash -x test.sh</span></span><br><span class="line">+ <span class="built_in">pwd</span></span><br><span class="line">/root</span><br><span class="line">+ <span class="built_in">ls</span> -al</span><br><span class="line">total 44</span><br><span class="line">drwx------  5 root root 4096 Mar 30 20:52 .</span><br><span class="line">drwxr-xr-x 19 root root 4096 Mar 30 20:02 ..</span><br><span class="line">-rw-------  1 root root 4526 Mar 29 03:20 .bash_history</span><br><span class="line">-rw-r--r--  1 root root 3106 Oct 15  2021 .bashrc</span><br><span class="line">drwx------  2 root root 4096 Dec  8 14:20 .cache</span><br><span class="line">-rw-r--r--  1 root root    0 Mar 30 20:02 .motd_shown</span><br><span class="line">-rw-r--r--  1 root root  161 Jul  9  2019 .profile</span><br><span class="line">-rw-------  1 root root 1822 Mar 30 20:52 .viminfo</span><br><span class="line">drwxr-xr-x  2 root root 4096 Feb  2 13:13 docker</span><br><span class="line">drwxr-xr-x  2 root root 4096 Feb  2 12:39 feng_wei</span><br><span class="line">-rw-r--r--  1 root root   23 Mar 30 20:52 test.sh</span><br></pre></td></tr></table></figure><p>在执行脚本前，还可以使用 <code>bash -n test.sh</code> 来检查脚本是否有语法错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@LostStars:~<span class="comment"># bash -n test.sh</span></span><br><span class="line">test.sh: line 4: unexpected EOF <span class="keyword">while</span> looking <span class="keyword">for</span> matching `<span class="string">&quot;&#x27;</span></span><br><span class="line"><span class="string">test.sh: line 5: syntax error: unexpected end of file</span></span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>通常变量输出使用 echo 打印变量，一般都是 <code>echo $name</code>，如果是要格式化打印输出，例如对字符串变量做拼接等，就需要使用 <code>echo $&#123;exec_time&#125;s</code></p><p>另外，linux 中单引号和双引号也是有区别的。单引号是强引用，如果变量在单引号内，则不会替换得到变量值；而双引号是弱引用，会自动替换得到变量值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@LostStars</span>:<span class="operator">~</span># exec_time<span class="operator">=</span><span class="number">10</span></span><br><span class="line">root<span class="variable">@LostStars</span>:<span class="operator">~</span># echo $&#123;exec_time&#125;s</span><br><span class="line"><span class="number">10</span>s</span><br><span class="line">root<span class="variable">@LostStars</span>:<span class="operator">~</span>#</span><br><span class="line">root<span class="variable">@LostStars</span>:<span class="operator">~</span># echo &quot;$&#123;exec_time&#125;s&quot;</span><br><span class="line"><span class="number">10</span>s</span><br><span class="line">root<span class="variable">@LostStars</span>:<span class="operator">~</span># echo <span class="string">&#x27;$&#123;exec_time&#125;s&#x27;</span></span><br><span class="line">$&#123;exec_time&#125;s</span><br></pre></td></tr></table></figure><p>还有反引号，这种用于引用反引号内命令执行的结果，有时候也会是 <code>$()</code> 这种形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@LostStars:~<span class="comment"># cp test.sh test.sh.`date +%F`  # 等同于 test.sh.$(date +%F)</span></span><br><span class="line">root@LostStars:~<span class="comment"># ll</span></span><br><span class="line">-rw-r--r--  1 root root   33 Mar 30 20:56 test.sh</span><br><span class="line">-rw-r--r--  1 root root   33 Mar 30 21:08 test.sh.2025-03-30</span><br></pre></td></tr></table></figure><p>注意，shell 中变量是区分大小写，且复制时等号两边不能有空格</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>创建一个临时环境变量，可以通过 <code>export admin=fw</code> 去设定，这只对当前窗口有效。通过是修改系统 env 变量中定义的环境变量，也只会在当前窗口终端有效</p><p>系统环境变量根据登录方式有两类：</p><p>交互式登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile --&gt; /etc/profile.d/xxxx.sh --&gt; home 目录下 .bash_profile --&gt; 当前登录用户的.bashrc --&gt; /etc/bashrc</span><br></pre></td></tr></table></figure><p>非交互登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">home 目录下 .bashrc --&gt; /etc/bashrc --&gt; /etc/profile.d/xxx.sh</span><br></pre></td></tr></table></figure><h4 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h4><p>有时执行一个 shell 脚本会需要传递参数，这时脚本内可用 $1 , $2 这种方式来分别接收指定位置的参数。如果参数很多，超过 9 个参数时，第十个参数在 shell 脚本内需要使用 <code>param_10=$&#123;10&#125;</code> 来表示</p><p>对于 $0 来说，这是一个特殊变量，在执行脚本时 $0 就是脚本文件名</p><p><strong>补充几个关于 $ 的特殊用法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$?   <span class="comment"># 用于显示上一条命令的执行状态，0 表示成功</span></span><br><span class="line"><span class="variable">$#</span>   <span class="comment"># 显示所有参数的总个数</span></span><br><span class="line">$*   <span class="comment"># 依次显示每一个参数</span></span><br></pre></td></tr></table></figure><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>Linux 的 if 分支逻辑结构如下，if 开头 fi 结尾，除了 else 之外的逻辑分支结尾需要有 <code>; then</code> 并换行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -gt 5 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;value <span class="variable">$a</span> &gt; 5&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (( <span class="variable">$a</span> &lt; 0 )); <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;error: vale less than zero&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> (( <span class="variable">$a</span> &gt;= 0 || <span class="variable">$a</span> &lt;= 5 )); <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;correct: value is valid&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>if [ condition ]</code> 和 <code>if (( expression ))</code> 都是支持运算逻辑的判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]` 支持 `-eq, -ne, -le, -lt, -ge, -gt` 运算符比较，字符串比较可以使用 `=, !=</span><br></pre></td></tr></table></figure><p><code>if (( expression ))</code> 支持 <code>&lt;, &gt;, &lt;=, &gt;=, ==, !=</code> 运算符更类似平常代码，但不能用来比较字符串</p><p>If 分支还有另外两种形式：<code>if command</code> 和 <code>if [[ condition ]]</code></p><p><code>if command</code> 即可以直接以命令的退出码来进行判断，正确执行退出是 0，异常退出就是非 0</p><p><code>if [[ condition ]]</code> 是 bash shelll 的扩展形式，支持正则，通配符这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">keys=(<span class="string">&quot;name&quot;</span> <span class="string">&quot;age&quot;</span> <span class="string">&quot;address&quot;</span>)</span><br><span class="line"><span class="comment"># 一般见到的数组格式都是 (&quot;name&quot; &quot;age&quot; &quot;address&quot;)，使用空格做分割</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot; <span class="variable">$&#123;keys[@]&#125;</span> &quot;</span> =~ <span class="string">&quot; <span class="variable">$a</span> &quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># $&#123;keys[@]&#125; 依次拿到 name 和 age 以及 address </span></span><br><span class="line">    <span class="comment"># =~ 表示使用正则判断，只能在 if 或 case 中使用</span></span><br><span class="line">    <span class="comment"># =~ 的左边是变量，右边是正则表达式</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> in&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> not in&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>除了 if 分支，还有一种是确定值选择的分支 case</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name=fw</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$name</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;wf&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;not find user&quot;</span></span><br><span class="line">        ;;      <span class="comment"># 每个 case 块最后都需要 ;; </span></span><br><span class="line">    <span class="string">&quot;fw&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;find user&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;exit&quot;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span>       <span class="comment"># 循环 1 到 10</span></span><br><span class="line">    useradd user<span class="variable">$i</span> &amp;&gt; /dev/null    </span><br><span class="line">    <span class="comment"># 创建 user1 - user10，并将 stdout 和 stderr 输出重定向到 /dev/null 即丢弃输出信息</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">ls</span> -l /var/log/cdosapi/access.log*`; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># for 循环的列表也是是来自命令的结果</span></span><br><span class="line">    <span class="built_in">basename</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">count=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -lt 10 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n -e <span class="string">&quot;<span class="variable">$count</span>\t&quot;</span></span><br><span class="line">    <span class="built_in">let</span> count+=1</span><br><span class="line">    <span class="comment"># while 中也支持使用 continue 和 break</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>补充：seq 命令可以用来遍历元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@LostStars:~<span class="comment"># seq -s+ 0 10        # -s 参数后面的支持 +， -， *， /， % </span></span><br><span class="line">0+1+2+3+4+5+6+7+8+9+10</span><br><span class="line">root@LostStars:~<span class="comment"># seq -s+ 0 10 | bc</span></span><br><span class="line">55</span><br></pre></td></tr></table></figure><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 ## 删除最长前缀</span></span><br><span class="line">➜  ~ url=http://10.62.214.27:80/api/v3/vm/mybase_remedydata</span><br><span class="line">➜  ~ <span class="built_in">echo</span> <span class="variable">$&#123;url##*$&#x27;/&#x27;&#125;</span></span><br><span class="line">mybase_remedydata</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 # 删除最短前缀</span></span><br><span class="line">➜  ~ <span class="built_in">echo</span> <span class="variable">$&#123;url#*$&#x27;/&#x27;&#125;</span></span><br><span class="line">/10.62.214.27:80/api/v3/vm/mybase_remedydata</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 %% 删除最长前缀</span></span><br><span class="line">➜  ~ <span class="built_in">echo</span> <span class="variable">$&#123;url%%$&#x27;/&#x27;*&#125;</span></span><br><span class="line">http:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 % 删除最短后缀</span></span><br><span class="line">➜  ~ <span class="built_in">echo</span> <span class="variable">$&#123;url%$&#x27;/&#x27;*&#125;</span></span><br><span class="line">http://10.62.214.27:80/api/v3/vm</span><br></pre></td></tr></table></figure><h4 id="正则匹配文件内容进行替换"><a href="#正则匹配文件内容进行替换" class="headerlink" title="正则匹配文件内容进行替换"></a>正则匹配文件内容进行替换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cicode=<span class="variable">$1</span></span><br><span class="line">ip=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">vms_regex=<span class="string">&#x27;(VMSALI|VMSAWS)[0-9]&#123;8&#125;&#x27;</span></span><br><span class="line">ip_regex=<span class="string">&#x27;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sed -Ei \</span><br><span class="line">  -e <span class="string">&quot;s/(VMSALI|VMSAWS)[0-9]&#123;8&#125;/<span class="variable">$cicode</span>/g&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;s/([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;/<span class="variable">$ip</span>/g&quot;</span> \</span><br><span class="line">  /home/fw/inventory.yaml</span><br></pre></td></tr></table></figure><h3 id="base64-编解码"><a href="#base64-编解码" class="headerlink" title="base64 编解码"></a>base64 编解码</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编码</span></span><br><span class="line"><span class="string">root@LostStars:~#</span> <span class="string">echo</span> <span class="string">-n</span> <span class="string">&quot;founwei&quot;</span> <span class="string">|</span> <span class="string">base64</span></span><br><span class="line"><span class="string">Zm91bndlaQ==</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码</span></span><br><span class="line"><span class="string">root@LostStars:~#</span> <span class="string">echo</span> <span class="string">-n</span> <span class="string">&quot;Zm91bndlaQ==&quot;</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-d</span></span><br><span class="line"><span class="string">founweiroot@LostStars:~#</span></span><br></pre></td></tr></table></figure><h3 id="Repo-变量查看"><a href="#Repo-变量查看" class="headerlink" title="Repo 变量查看"></a>Repo 变量查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VMSALI01832180 ~]<span class="comment"># yum config-manager --dump-variables</span></span><br><span class="line"><span class="built_in">arch</span> = x86_64</span><br><span class="line">basearch = x86_64</span><br><span class="line">stream = 9-stream</span><br><span class="line">ops_mirror = 10.29.194.239</span><br><span class="line">ctrip_release = 9.2</span><br><span class="line">ctrip_custom = custom</span><br><span class="line">releasever = 9</span><br></pre></td></tr></table></figure><h3 id="Linux-启动过程"><a href="#Linux-启动过程" class="headerlink" title="Linux 启动过程"></a>Linux 启动过程</h3><p><a href="https://blog.csdn.net/m0_67794241/article/details/144076667">https://blog.csdn.net/m0_67794241/article/details/144076667</a></p><h3 id="Ssh-相关"><a href="#Ssh-相关" class="headerlink" title="Ssh 相关"></a>Ssh 相关</h3><h4 id="Home-目录下的-config"><a href="#Home-目录下的-config" class="headerlink" title="Home 目录下的 config"></a>Home 目录下的 config</h4><p>这个配置文件是用于简化 ssh  命令以及配置多 ssh 连接管理的</p><p>例如，配置个人和公司不同代码仓库的 shh 认证信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  .ssh$ <span class="built_in">cat</span> config</span><br><span class="line">Host gogs.com</span><br><span class="line">    HostName 192.168.56.11</span><br><span class="line">    Port 10022</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile /home/fw/.ssh/id_ed25519</span><br><span class="line"></span><br><span class="line">Host gitlab.com</span><br><span class="line">    HostName git.dev.sh.ctripcorp.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile /home/fw/.ssh/id_rsa</span><br><span class="line">    </span><br><span class="line">➜  .ssh$ ssh -T git@gogs.com</span><br><span class="line">Hi there, You<span class="string">&#x27;ve successfully authenticated, but Gogs does not provide shell access.</span></span><br><span class="line"><span class="string">If this is unexpected, please log in with password and setup Gogs under another user.</span></span><br><span class="line"><span class="string">➜  .ssh</span></span><br><span class="line"><span class="string">➜  .ssh ssh -T git@git.dev.sh.ctripcorp.com</span></span><br><span class="line"><span class="string">Welcome to GitLab, @xxx!</span></span><br></pre></td></tr></table></figure><p>还有最常用的就是，公司内多环境的跳板机登录配置，配置后就可以用简化的命令 <code>ssh uat</code> 或 <code>ssh prod</code> 来访问跳板机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Host uat</span><br><span class="line">  ControlMaster auto</span><br><span class="line">  ControlPath ~/.ssh/master-%r@%h:%p</span><br><span class="line">  ControlPersist <span class="built_in">yes</span></span><br><span class="line">  User fw</span><br><span class="line">  HostName ssh.fws.jumpserver.sys.ctripcorp.com</span><br><span class="line"></span><br><span class="line">Host prod</span><br><span class="line">  ControlMaster auto</span><br><span class="line">  ControlPath ~/.ssh/master-%r@%h:%p</span><br><span class="line">  ControlPersist <span class="built_in">yes</span></span><br><span class="line">  User fw</span><br><span class="line">  HostName ssh.jumpserver.sys.ctripcorp.com</span><br></pre></td></tr></table></figure><h4 id="通过私钥生成公钥"><a href="#通过私钥生成公钥" class="headerlink" title="通过私钥生成公钥"></a>通过私钥生成公钥</h4><p>如果没有公钥文件，可以用该命令去生成公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -y -f id_rsa &gt; id_rsa.pub</span><br></pre></td></tr></table></figure><h4 id="Ssh-远程连接错误"><a href="#Ssh-远程连接错误" class="headerlink" title="Ssh 远程连接错误"></a>Ssh 远程连接错误</h4><ol><li>验证失败，报错信息类似如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint <span class="keyword">for</span> the RSA key sent by the remote host is</span><br><span class="line">ae:6e:68:4c:97:a6:91:81:11:38:8d:64:ff:92:13:50.Please contact your system administrator.</span><br><span class="line">Add correct host key <span class="keyword">in</span> /root/.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending key <span class="keyword">in</span> /root/.ssh/known_hosts:70RSA host key <span class="keyword">for</span> x.x.x.x has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure><p>该 ECS 实例可能进行过重装系统、账户信息变更等操作，导致 ECS 实例 SSH 公钥变更，造成本地客户端保存的公钥指纹与服务器端不一致，出现该提示信息</p><p>解决方法：<code>vim ~/.ssh/known_hosts</code> 这个文件，找到要远程登录的机器 ip，然后删除并保存，再重新使用 ssh 连接</p><ol><li>如果远程机器公钥配置正确，但是 ssh 连接报错 <code>Permission denied</code> 例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is a private network server, <span class="keyword">in</span> monitoring state.</span><br><span class="line">It is strictly prohibited to unauthorized access and used.</span><br><span class="line">cdosapi@10.25.226.208: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).</span><br></pre></td></tr></table></figure><p><strong>SSH 对公钥、私钥的权限和所有权的要求是非常严格的</strong>，总结如下：</p><ul><li>下面两个目录的所有权必须是 user，所属组也应该是 user，前者权限不能是 777，后者权限必须为 700<ul><li>\home\user</li><li>\home\user.ssh</li></ul></li><li>公钥文件的所有权必须是 user，所属组也应该是 user，权限必须是 644<ul><li>\home\user.ssh\authorized_keys</li></ul></li><li>私钥文件的所有权必须是 user，所属组也应该是 user，权限必须是 600<ul><li>\home\user.ssh\id_rsa</li></ul></li></ul><ol><li>通过 -v 参数可以查看 ssh 连接过程中的日志信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -v user@hostname      <span class="comment"># 基础详细模式</span></span><br><span class="line">ssh -vv user@hostname     <span class="comment"># 更详细（二级）</span></span><br><span class="line">ssh -vvv user@hostname    <span class="comment"># 最高详细度（三级）</span></span><br></pre></td></tr></table></figure><ol><li>其他一些 ssh 连接问题参考：<ol><li><a href="https://help.aliyun.com/zh/ecs/user-guide/ssh-remote-connection-problems/?spm=a2c4g.11186623.0.0.442f3efejiSLus">https://help.aliyun.com/zh/ecs/user-guide/ssh-remote-connection-problems/?spm=a2c4g.11186623.0.0.442f3efejiSLus</a></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 基础</title>
      <link href="/4075015966/"/>
      <url>/4075015966/</url>
      
        <content type="html"><![CDATA[<h3 id="基础整理"><a href="#基础整理" class="headerlink" title="基础整理"></a>基础整理</h3><h4 id="初始化和依赖管理"><a href="#初始化和依赖管理" class="headerlink" title="初始化和依赖管理"></a>初始化和依赖管理</h4><p>创建 go 项目目录后，进入目录用<code>go mod init</code> 命令初始化项目生成一个 go.mod 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init mygin</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> go.mod</span><br><span class="line">module mygin</span><br><span class="line"></span><br><span class="line">go 1.20</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/gin-gonic/gin v1.9.1</span><br><span class="line">  k8s.io/apimachinery v0.25.2</span><br><span class="line">  k8s.io/client-go v0.25.2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/PuerkitoBio/purell v1.1.1 // indirect</span><br><span class="line">  ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当项目中要使用到第三方库，可以用 <code>go get</code> 去下载安装，然后就可以在文件中导入。同时目录下的 go.mod 和 go.sum 文件会有对应的修改</p><ul><li><code>go.mod</code> 文件列出了项目的模块名和它直接依赖的模块及其版本</li><li><code>go.sum</code> 文件包含了所有依赖包的校验和，用于确保下载的包没有被篡改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin</span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment"># mytest.go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于 go.mod 中记录的三方包，go 也提供了对应的命令 <code>go mod tidy</code>来进行管理，例如清理未使用依赖，解决有冲突的依赖，更新依赖版本等</p><p>如果要清除一个依赖，可以使用 <code>go clean -i 依赖包地址</code></p><p>当从 github 上 clone 一个 golang 项目，且包含了 go.mod 文件，可以使用 <code>go mod download</code> 下载依赖包到本地缓存</p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go 中变量声明的方式有多种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">name = <span class="string">&quot;fw&quot;</span></span><br><span class="line"><span class="comment">// var name string = &quot;fw&quot;</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age  <span class="type">uint8</span>     </span><br><span class="line">  <span class="comment">// 无符号的 int8类型，即 2^8，值范围是 0 ~ 255，int8 -128 ~ 127</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;fw&quot;</span></span><br><span class="line"><span class="comment">// go 会给根据声明的值自动判断 name 变量类型</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line">name := <span class="string">&quot;fw&quot;</span></span><br><span class="line"><span class="comment">// := 短赋值方式只能在函数中使用，用来定义局部变量</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line">name := <span class="built_in">new</span>(<span class="type">string</span>)</span><br><span class="line">*name = <span class="string">&quot;stark&quot;</span></span><br><span class="line"><span class="comment">// new 函数声明一个 T 类型的匿名变量，返回的是这个 T 类型变量的指针 *T</span></span><br></pre></td></tr></table></figure><p>当使用 var 关键字声明变量后，go 会自动给变量赋值，而这个值被称为零值，不同的数据类型，零值是不同的</p><h5 id="基本数据类型和零值"><a href="#基本数据类型和零值" class="headerlink" title="基本数据类型和零值"></a>基本数据类型和零值</h5><ul><li>数值类型，就是 0，go 中数值类型有很多种，表示不同的取值范围，根据使用需求使用不同类型可以控制内存占用：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr   <span class="comment"># 无符号数值类型取值范围从 0 开始</span></span><br><span class="line">float32 float64</span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure><p>这里 int 类型，会根据当前操作系统位数来设定，例如是 64 的机器，var num int，这个 num 的的范围就是 -9223372036854775808 到 9223372036854775807</p><ul><li>布尔类型，就是 false</li><li>字符串类型，就是空字符</li><li><strong>接口或应用类型（slice，指针，map，chan，函数），就是 nil</strong></li><li>数组或结构体等聚合类型，每个元素或字段是对应类型的零值</li></ul><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>Go 中常量使用 const 关键字定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><h5 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h5><p>自定义数据类型可以基于现有的基本数据类型或复合数据类型，为其赋予一个新的类型名称，并可以为其添加方法，从而实现类型的功能扩展</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 类型名称 底层类型</span></span><br><span class="line"><span class="keyword">type</span> Name <span class="type">string</span>              <span class="comment">// 定义底层类型是 string 的数据类型 Name</span></span><br><span class="line"><span class="keyword">const</span> myName Name = <span class="string">&quot;stark&quot;</span>   <span class="comment">// 声明 Name 类型的 myName 常量并赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Name)</span></span> SayName() <span class="type">string</span> &#123;     </span><br><span class="line">  <span class="comment">// 定义 Name 类型的 SayName 方法，接收 Name 类型变量，并返回一个 string 类型的值</span></span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;what&#x27;s your name man!, my name is %s&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name.SayName()</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go 中字符串是 utf-8 存储的，使用 len 函数获取长度时，其实是字符串的 byte 个数，所以如果是中文字符串，直接使用下标截取的话会有误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的 string 操作</span></span><br><span class="line">newString = strings.Replace(<span class="string">&quot;go go&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;hello&quot;</span>, n=<span class="number">-1</span>)  <span class="comment">// 字符串替换，n 为 -1 表示替换所有匹配，1 就表示替换一个匹配</span></span><br><span class="line">stringList := strings.Split(<span class="string">&quot;1 2 3&quot;</span>, <span class="string">&quot; &quot;</span>)    <span class="comment">// [1 2 3]</span></span><br><span class="line">s := strings.TrimSpace(<span class="string">&quot;  123  &quot;</span>)            <span class="comment">// 清除左右空白字符</span></span><br><span class="line">s1 := strings.Trim(<span class="string">&quot; ! 123  &quot;</span>, <span class="string">&quot;! &quot;</span>)         <span class="comment">// 去除左右满足的指定移除字符</span></span><br><span class="line">strings.HasPrefix(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;http&quot;</span>)         <span class="comment">// 是否满足前缀</span></span><br><span class="line">strings.HasSuffix(<span class="string">&quot;filename.go&quot;</span>, <span class="string">&quot;go&quot;</span>)       <span class="comment">// 是否满足后缀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串本质是 byte 切片，go 中字符的存储使用 byte 类型（0-255），go 中 byte 属于整数数据类型</span></span><br><span class="line">s := <span class="string">&quot;123&quot;</span></span><br><span class="line">bs := []<span class="type">byte</span>(s)         <span class="comment">// []byte() 将接收的字符串分割成数组，每个元素字符被转为 ascii 码</span></span><br><span class="line">fmt.Println(bs)         <span class="comment">// [49 50 51]</span></span><br><span class="line">fmt.Print(<span class="type">string</span>(bs))   <span class="comment">// 123%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类型转字符串，Sprintf 格式化字符串，或者用 strconv 模块的方法</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, <span class="number">12</span>)</span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, <span class="number">12.12</span>)</span><br><span class="line"><span class="comment">// Printf 和 Sprintf 在是使用上是一致的，但是 Sprintf 会有返回格式化的字符串，Printf 只是标准输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转其他类型，可以用 strconv 模块对应 Parse 方法</span></span><br><span class="line">strconv.Itoa(<span class="number">12</span>)                   <span class="comment">// Itoa 只接收 int 类型</span></span><br><span class="line">num := strconv.FormatInt(<span class="number">26</span>, <span class="number">2</span>)    <span class="comment">// FormatInt 只接受 int64 类型，且需要传转换进制数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %v&quot;</span>, num, num)     <span class="comment">// string, 11010</span></span><br><span class="line"></span><br><span class="line">b, err := strconv.ParseBool(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">s, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)      <span class="comment">// strconv 包转 int 类型</span></span><br><span class="line">bytes := []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)           <span class="comment">// 字符串转字节数组，每个元素都是 ASCII 的编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换失败</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int64</span> = <span class="number">11</span></span><br><span class="line">n1, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)    <span class="comment">// 将 s 转为 10 进制的 int64 类型</span></span><br><span class="line">fmt.Println(n1, err)</span><br><span class="line"><span class="comment">// 如果 string 转类型失败，那变量的值会是类型的默认值</span></span><br><span class="line"><span class="comment">// 0  strconv.ParseInt: parsing &quot;hello&quot;: invalid syntax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是要操作一个中文的字符串，例如截取</span></span><br><span class="line"><span class="comment">// 需要转为 []rune 类型，rune 代表的 unicode 码点是固定的 4 个字节长度(等同于 int32)</span></span><br><span class="line">s := <span class="string">&quot;世界和平&quot;</span></span><br><span class="line">s1 := s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s1 == <span class="string">&quot;世界&quot;</span>)     <span class="comment">// false</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))          <span class="comment">// 12</span></span><br><span class="line">s2 := s[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="type">string</span>(s2))      <span class="comment">// 世界</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;世界和平&quot;</span></span><br><span class="line">s1 := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1))         <span class="comment">// 4</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(s1[:<span class="number">2</span>]))  <span class="comment">// 世界</span></span><br></pre></td></tr></table></figure><p>字符串拼接，除了使用最基础的 += 的方式，如果是需要循环的话，可以使用 <code>string.Builder</code> 类型的 <code>WriteString</code> 方法，这种性能上比 += 要更高</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(str.String())   <span class="comment">// aaaaa</span></span><br></pre></td></tr></table></figure><h5 id="string-与-byte"><a href="#string-与-byte" class="headerlink" title="string 与 []byte"></a>string 与 []byte</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 的底层结构体</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="type">uintptr</span></span><br><span class="line">  Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 的底层结构体</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="type">uintptr</span></span><br><span class="line">  Len  <span class="type">int</span></span><br><span class="line">  Cap  <span class="type">int</span>      <span class="comment">// string 类型只是比 slice 少一个 cap 容量的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 string 的底层结构体和 slice 的底层结构体只有一个 cap 容量属性的差异，string 和 byte 切片可以相互转换，go 中可以把字符串类型看成是一个只读的 <code>[]byte</code> 切片</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJkY2MwNDg1NjYzYzU0MDEyMDc1YjM1ZWVjN2VlYWVfUlFQRjZTVVpMcUNSYnlrRmxWSm9JNVZCZnA3NHN0UkRfVG9rZW46RkxUamJzQlFVb2YzNTN4QjZBSmNNTzlKbmplXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><p>String 转为 byte 切片后就可以通过 index 下标来进行修改，但类型转换是会有性能影响的，字符串越长性能损耗也会越大</p><p>因为字符串是不可变类型，任何字符串的操作，都会需要通过 copy 来拷贝到新的内存空间中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 和 []byte 的转换和修改</span></span><br><span class="line">s := <span class="string">&quot;fw&quot;</span></span><br><span class="line">bs := []<span class="type">byte</span>(s)  <span class="comment">// 注意 []byte 切片无法处理中文，中文字更改可以转为 []rune 切片</span></span><br><span class="line">bs[<span class="number">0</span>] = <span class="string">&#x27;w&#x27;</span></span><br><span class="line">s = <span class="type">string</span>(bs)</span><br><span class="line">fmt.Println(s)   <span class="comment">// ww</span></span><br></pre></td></tr></table></figure><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>当整数进行类型转换时，大范围类型转为小小范围类型，会按照溢出处理。这个溢出处理，就是将二进制数值的溢出部分进行截断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int8</span> = <span class="type">int8</span>(num1)   <span class="comment">// 63</span></span><br><span class="line"><span class="comment">// 999999 - 转二进制 &gt; 11110100001000111111 </span></span><br><span class="line"><span class="comment">// 11110100001000111111 - 按照 int8 存储 8位做截断，得到最后 8 位 &gt; 00111111</span></span><br><span class="line"><span class="comment">// 00111111 - 转十进制 &gt; 63</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int32</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int8</span></span><br><span class="line">n2 = <span class="type">int8</span>(n1) + <span class="number">128</span>     <span class="comment">// 这里会直接报错，因为 128 已经超出了 int8 范围</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一旦初始化数组之后，数组的大小就无法改变了，所以无法后续往数组中增加元素，只允许通过 index 去修改元素</p><p>Go 中数组的每一个元素都是同一种类型，但如果是声明时定义为 <strong>interface{} 这种接口，就可以存储不同类型的元素</strong></p><p>另外，数组是值传递，当一个数组赋值给另一个变量，两个变量之间没有引用关系，其中一个变量修改某个元素后，另一变量的数组对应元素不会发生改变</p><p>长度 len 和 容量 cap，初始化一个数组后，会自动得到长度和容量的值，长度就是数组中元素的个数，但是容量会有点区别，容量的值是数组第一个元素到最后一个元素的个数</p><p>比如初始化一个 5 个元素的数组，使用切片 [2:] 获取其中部分元素的数组时，这个新的数组其长度就是 3 个元素，其容量也是 3，因为 3 - 5 是 3 个元素</p><p>如果是切片 [:3] 获取部分元素的数组，其长度是 3，容量是 5，因为新切片对应的底层数组上是第一个元素到数组最后一个元素，所以容量是 5</p><p>也就是容量，是从截取位置对应到底层数组上后，从截取位置计算到数组最后一个元素的个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">li := [<span class="number">10</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 长度为 10 的 int 类型数组，此时没有给每个元素赋值，每个 int 类型零值是 0</span></span><br><span class="line"><span class="comment">// [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">li := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">2</span>&#125;      <span class="comment">// 指定 index 赋值来初始化数组</span></span><br><span class="line"><span class="comment">// [1 0 0 0 2]</span></span><br><span class="line"></span><br><span class="line">li := [<span class="number">5</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// [&lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;]</span></span><br><span class="line">li := [<span class="number">5</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line"><span class="comment">// [0 1 123 &lt;nil&gt; &lt;nil&gt;]</span></span><br><span class="line"></span><br><span class="line">li := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 初始化大小的同时给每一个元素赋值</span></span><br><span class="line">li := [][]<span class="type">int</span>&#123;[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;, []<span class="type">int</span>&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 创建一个二维数组，[[1 2 3] [4 5 6] [7 8 9]]</span></span><br><span class="line"></span><br><span class="line">li := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// [...]T 这种数组声明时，go 会自动根据初始化的元素个数推到该数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li [<span class="number">3</span>]<span class="type">int</span>      <span class="comment">// 本机是 64位，所以 int 类型变量占 64 位即 8个字节</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;li pointer: %p \n&quot;</span>, &amp;li)</span><br><span class="line">fmt.Printf(<span class="string">&quot;li[0] pointer: %p \n&quot;</span>, &amp;li[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;li[1] pointer: %p \n&quot;</span>, &amp;li[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// li pointer: 0x824d90 </span></span><br><span class="line"><span class="comment">// li[0] pointer: 0x824d90 </span></span><br><span class="line"><span class="comment">// li[1] pointer: 0x824d98   </span></span><br><span class="line"><span class="comment">// 所以下标位 1 的元素，地址是下标位 0 的地址上自增 8 字节</span></span><br><span class="line"><span class="comment">// 如果是 int8 类型数组，那么最后两个元素地址序号上则是相差为 1，即 8 位 1 字节</span></span><br></pre></td></tr></table></figure><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>golang 的 bool 与 int 不会自动转换，所以在判断上无法使用 0 和 1 来作为 bool 判断</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>Slice 和数组不同的是，slice 是动态的，允许增加元素，且 slice 的底层数组类型是引用了数组，因此将一个数组赋值给另一个 slice 变量，其中一个 slice 的 index 对应元素更改的话，另一个 slice 也会更改</p><p>初始化一个空的 slice 切片，其零值是 nil，然后长度和容量都是 0</p><p>slice 支持通过 make 构建，当因不确定数组时，无法用切片操作获取切片，就可以使用 make 创建切片</p><p>slice 的扩容机制：</p><ul><li>当长度小于 1024 时，每次发生扩容将按照容量 * 2 来扩容</li><li>当长度大于 1024 时，每次发生扩容将以增加 25 % 容量来扩容</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;   </span><br><span class="line"><span class="comment">// 直接声明 slice，这里不用像数组一样在 [] 中设置 bounds 个数</span></span><br><span class="line"></span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice = arr1[:<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 直接在数组上使用切片操作获取切片</span></span><br><span class="line"></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 使用 make 函数构建切片，会同时构建底层数组</span></span><br><span class="line"><span class="comment">// [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"><span class="comment">// make 函数构建的切片，底层的数组是非可见的，只有切片自己可以使用来修改</span></span><br><span class="line"><span class="comment">// 因此 make 构建的切片，主要是构建一个切片空间，其元素需要一一赋予</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// append 函数可以追加多个元素，也可以追加切片，追加切片需要在后面加 ... 来解构</span></span><br><span class="line">x := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>,<span class="number">2</span>)   <span class="comment">// 将 1 和 2 分别追加到 x 中</span></span><br><span class="line">fmt.Println(x)    <span class="comment">// [1 2]</span></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">append</span>(x, x...)</span><br><span class="line"><span class="comment">// append 函数会自动对切片扩容，然后将元数引用到新的切片后返回</span></span><br><span class="line">fmt.Println(x)    <span class="comment">// [1 2 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.22 版本 slices 库的 Concat 方法同样可以完成多个切片合并，内部其实也是通过 append 方法实现</span></span><br><span class="line">li1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">li2 := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">li3 := slices.Concat(li1, li2)    <span class="comment">//  [1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)      <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice[:<span class="number">3</span>], slice[<span class="number">4</span>:]...)    <span class="comment">// 使用 append 来删除切片元素</span></span><br><span class="line"><span class="comment">// 这个省略号是用于表示将 a[4:] 中的元素逐个作为参数传递给 append 函数</span></span><br><span class="line"><span class="comment">// 如果不加省略号，那么 append 函数会把 a[4:] 整个子切片当作一个元素追加到 a[:3] 后面</span></span><br><span class="line"><span class="comment">// 而加上省略号后，就会把 a[4:] 中的每个元素分别追加</span></span><br><span class="line">fmt.Println(slice)      <span class="comment">// [1 2 3 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy 函数接收两个切片参数，将第二个参数切片的值，复制给第一个参数目标切片</span></span><br><span class="line"><span class="comment">// 每个元素的 copy 会按照索引逐个覆盖目标切片元素</span></span><br><span class="line"><span class="comment">// !!! 注意这需要看本身 slice 的容量，如果本身 cap 是 1，那么将拷贝到本身的元素就只会拷贝目标被拷贝切片的第一个元素</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">copy</span>(s[<span class="number">2</span>:], s[<span class="number">2</span>+<span class="number">1</span>:]))   <span class="comment">// copy 函数没有返回，是对第一个参数做更改</span></span><br><span class="line">fmt.Println(s)   <span class="comment">// [5 6 8 9 9]</span></span><br></pre></td></tr></table></figure><h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicateElement</span><span class="params">(languages []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//针对 string 类型的切片去重</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(languages))</span><br><span class="line">    temp := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// 构建一个 map，每个 value 是 struct 类型，go 中空的 struct 不会占用空间</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> languages &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := temp[item]; !ok &#123;</span><br><span class="line">            temp[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            result = <span class="built_in">append</span>(result, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distinct</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(input []T)</span></span> []T &#123;</span><br><span class="line">  <span class="comment">// 泛型去重</span></span><br><span class="line">  set := <span class="built_in">make</span>(<span class="keyword">map</span>[T]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  res := <span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="built_in">len</span>(set))</span><br><span class="line">  <span class="keyword">for</span> _, value := <span class="keyword">range</span> input &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := set[value]; !ok &#123;</span><br><span class="line">      set[value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      res = <span class="built_in">append</span>(res, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>也就是 hash 表，通过 k-v 结构存储数据，go 中 map 类型的零值是 nil，且 map 是引用类型</p><p>注意：如果是声明 map 的变量，需要使用 make 函数来构建，否则声明的 map 不指向任何内存地址是 nil，是不能进行 k-v 写入的</p><p>在 go 的 map 中获取一个不存在的 key 操作是安全的，并不会报错，而是返回设定 value 类型的零值，但是 <strong>map 并不是写入安全的，并发写入会有问题</strong></p><p>另外 go 的 map 是无序的，如果想要有序的 map，需要将 map 的值保存到切片，进行排序后通过遍历写入到新的 map 中</p><p><strong><em>关联补充：</em></strong></p><ul><li>Go 中 slice 空切片且零值也是 nil，为什么却能用 append 来追加元素。因为 append 方法在底层会为 slice 分配相关数组引用，让 nil 的 slice 从而指向具体内存地址</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">people := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)   <span class="comment">// make(map[string]int) == map[string]int&#123;&#125;</span></span><br><span class="line">people[<span class="string">&quot;stark&quot;</span>] = <span class="number">42</span></span><br><span class="line">people[<span class="string">&quot;alex&quot;</span>] = <span class="number">26</span></span><br><span class="line">fmt.Println(people)              <span class="comment">// map[alex:26 stark:42]</span></span><br><span class="line"></span><br><span class="line">people1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d&quot;</span>, people1)        <span class="comment">// map[]</span></span><br><span class="line">people1[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, people1)        <span class="comment">// map[one:1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">people[<span class="string">&quot;stark&quot;</span>] = <span class="number">42</span></span><br><span class="line">people[<span class="string">&quot;alex&quot;</span>] = <span class="number">26</span></span><br><span class="line">fmt.Println(test1)               <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> graph = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>  </span><br><span class="line"><span class="comment">// 表示一个嵌套 map 结构  &#123;&quot;&quot;: &#123; &quot;&quot;: true &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">val, ok := people[<span class="string">&quot;messi&quot;</span>]  </span><br><span class="line"><span class="comment">// key 存在，val 就是对应 map 中存储的值，ok 就是 true</span></span><br><span class="line"><span class="comment">// key 不存在，val 就是 map 定义时 val 的零值，ok 就是 false</span></span><br><span class="line">fmt.Println(val, ok)        </span><br><span class="line"><span class="comment">// 0 false，所以对于 key 是否存在可以判断取值时返回的第二个值是否为 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(people, <span class="string">&quot;alex&quot;</span>)</span><br><span class="line"><span class="comment">// 删除一个 key，使用内置函数 delete(map, key)，这个删除 key 如果 key 不存在也不会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := people[<span class="string">&quot;messi&quot;</span>]; !ok &#123;    <span class="comment">// _, ok := people[&quot;messi&quot;]</span></span><br><span class="line">    people[<span class="string">&quot;messi&quot;</span>] = <span class="number">36</span>              <span class="comment">// if !ok &#123;                                        </span></span><br><span class="line">&#125;                                     <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// !!注意!! 在循环比较两个 map 的键值对时</span></span><br><span class="line"><span class="comment">// 不能单一用 xv != y[key]，因为 y 的 map 中 value 本身可能就是 0 值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mymap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  sum := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=num; i++ &#123;</span><br><span class="line">    sum *= i</span><br><span class="line">  &#125;</span><br><span class="line">  mymap[num] = sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>; i&lt;=<span class="number">5</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> myfunc(i)    <span class="comment">// fatal error: concurrent map writes</span></span><br><span class="line">  <span class="comment">// 使用协程并发对 map 进行写入操作时，因为 map 非线程安全，所以结果是非预期的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>类比 python 的话，就是 class 类这个类型，但 go 并不是纯粹的面向对象</p><p>Go 通过结构体（<code>struct</code>）、方法（<code>method</code>）和接口（<code>interface</code>）实现了类似面向对象编程的功能</p><p><strong>Go 的面向对象编程更注重组合（Composition）而非继承（Inheritance），并且是通过接口实现了强大的多态性</strong></p><p>一般结构体名称和内部属性都是首字母大写，这样被外部导入时，外部才可以实例化这个结构体，以及访问结构体的属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;    </span><br><span class="line">    <span class="comment">// 声明 Employee 类型的结构体</span></span><br><span class="line">    ID  <span class="type">int</span>        <span class="comment">// 结构体的属性名首字母也是大写，才可以在被外部导入后查看属性</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    list []<span class="type">int</span>     <span class="comment">// 结构体中属性是 指针，slice，map 的类型，其默认零值为 nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people Employee</span><br><span class="line">people.ID = <span class="number">1</span></span><br><span class="line">people.Name = <span class="string">&quot;stark&quot;</span></span><br><span class="line"><span class="comment">// people := Employee&#123;ID：1, Name: &quot;stark&quot;&#125;    // 实例化结构体时直接对属性赋值</span></span><br><span class="line"><span class="comment">// people := &amp;Employee&#123;ID：1, Name: &quot;stark&quot;&#125;   // 返回一个结构体指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people *Employee = <span class="built_in">new</span>(Employee)   <span class="comment">// var people *Employee = &amp;Employee&#123;&#125;</span></span><br><span class="line"><span class="comment">// new 函数会创建结构体指针，所以这个 people 是一个 Employee 的指针</span></span><br><span class="line">(*people).Name = <span class="string">&quot;tony&quot;</span>   <span class="comment">// == people.Name = &quot;tony&quot;</span></span><br></pre></td></tr></table></figure><p>注意，go 是强类型语言，所以两个结构体如果字段不一致的情况，是无法进行转换的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">int</span></span><br><span class="line">  <span class="comment">// Address string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">int</span></span><br><span class="line">  Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p People = People&#123;Name: <span class="string">&quot;alex&quot;</span>, Age: <span class="number">12</span>, Phone: <span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> e Employee = Employee(p)   </span><br><span class="line"><span class="comment">// cannot convert p (variable of type People) to type Employee</span></span><br></pre></td></tr></table></figure><p>对于一个 struct 结构体，它的属性值在内存上是连续存储的，但是如果属性类型是指针类型，虽然指针是连续的，但实际指向的内存空间并不连续</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Phone <span class="type">int</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p People = People&#123;Name: <span class="string">&quot;alex&quot;</span>, Age: <span class="number">12</span>, Phone: <span class="number">123</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %p, age: %p, phone: %p&quot;</span>, &amp;p.Name, &amp;p.Age, &amp;p.Phone)</span><br><span class="line"><span class="comment">// name: 0xc00005e3c0, age: 0xc00005e3d0, phone: 0xc00005e3d8</span></span><br></pre></td></tr></table></figure><p>声明结构体如果没有给名称，那就是匿名结构体，适合在结构体对象只是单次使用，例如下面 UserCouponResponse 中的 Data 字段就是匿名结构体，因为 Data 数组中每一个结构体都是单独一次直接构建初始化，没有其他地方会用到就可以定义成匿名结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserCouponResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">  Code <span class="type">int64</span>  <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">  Msg  <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">  Data []*<span class="keyword">struct</span> &#123;</span><br><span class="line">    CouponId           <span class="type">int</span>    <span class="string">`json:&quot;couponId&quot;`</span></span><br><span class="line">    ProdCode           <span class="type">string</span> <span class="string">`json:&quot;prodCode&quot;`</span></span><br><span class="line">    UserId             <span class="type">int64</span>  <span class="string">`json:&quot;userId&quot;`</span></span><br><span class="line">    CouponStatus       <span class="type">int</span>    <span class="string">`json:&quot;couponStatus&quot;`</span></span><br><span class="line">    DiscountPercentage <span class="type">int</span>    <span class="string">`json:&quot;discount&quot;`</span></span><br><span class="line">  &#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的匿名结构体的每一个字段后都带有一个 json 的 tag，这个标识的作用是实现 json 数据和结构体字段的自动映射转换，因为通常 json 传递的数据字段都是小写的，所以结构体的 json tag 内的字段相当于是结构体在 json 数据格式中的别名</p><p>对于上面的代码，其实也是嵌套结构体，data 字段是一个匿名结构体的嵌入，通常嵌套结构体可以实现代码的复用和继承</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  Person       <span class="comment">// Person 作为匿名成员嵌入到 Employee 结构体中</span></span><br><span class="line">  EmployeeID   <span class="type">int</span></span><br><span class="line">  Department   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  emp := Employee&#123;</span><br><span class="line">    Person: Person&#123;</span><br><span class="line">      Name: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">      Age:  <span class="number">30</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    EmployeeID: <span class="number">12345</span>,</span><br><span class="line">    Department: <span class="string">&quot;Engineering&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体嵌入无疑会增加对字段赋值和访问的复杂性，例如上面的嵌套结构体，想修改 emp 的 Name 属性，就需要 <code>emp.Person.Name = &quot;alex&quot;</code> 的方式，所以 go 进行了简化，可以通过 <code>emp.Name</code> 来进行匿名访问</p><p><strong>需要注意，如果结构体的属性与匿名嵌入结构体的属性存在重复时，比如上面 Employee 结构体也有 Name 字段时，并不会报错，因为两者所在作用域不一致，因此匿名访问时是按照就近原则去访问</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  Person</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  EmployeeID   <span class="type">int</span></span><br><span class="line">  Department   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  emp := Employee&#123;</span><br><span class="line">    Person: Person&#123;</span><br><span class="line">      Name: <span class="string">&quot;fw&quot;</span>,</span><br><span class="line">      Age:  <span class="number">30</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    EmployeeID: <span class="number">12345</span>,</span><br><span class="line">    Department: <span class="string">&quot;Engineering&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(emp.Name)            <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">  fmt.Println(emp.Person.Name)     <span class="comment">// fw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>结构体的方法和 go 函数的声明很相似，只是多了一个接收器，这个接收器还支持指针类型，所以能在一个结构体上看到有普通值类型的接收器声明的方法，以及指针类型接收器的方法</p><p><code>func (接收器名称  结构体类型) 方法名(形参)  (返回值列表，多个值需要使用例如：(a int, b int)) &#123;&#125;</code>，方法如果没有 return，则不需要定义返回值列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(people Employee)</span></span> getInfo() &#123;</span><br><span class="line">  <span class="comment">// 注意这里的 people 变量，它是结构体实例的值拷贝</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;ID:%d ; Name:%s&quot;</span>, people.ID, people.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通的值接收器方法来说，如果修改了结构体的属性，这个操作只在该方法内局部空间生效</p><p>而如果是指针接收器的方法，在方法内修改结构体属性，将会产生全局修改。另外 <strong>如果结构体属性是引用类型，例如 slice 切片，那么普通方法访问修改的话，也会影响到全局上</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> method1() &#123;</span><br><span class="line">  t.name = <span class="string">&quot;new name1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> method2() &#123;</span><br><span class="line">  t.name = <span class="string">&quot;new name2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  t := T&#123;<span class="string">&quot;old name&quot;</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;method1 调用前 &quot;</span>, t.name)</span><br><span class="line">  t.method1()</span><br><span class="line">  fmt.Println(<span class="string">&quot;method1 调用后 &quot;</span>, t.name)</span><br><span class="line">  fmt.Println(<span class="string">&quot;method2 调用前 &quot;</span>, t.name)</span><br><span class="line">  t.method2()</span><br><span class="line">  fmt.Println(<span class="string">&quot;method2 调用后 &quot;</span>, t.name)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// method1 调用前  old name</span></span><br><span class="line"><span class="comment">// method1 调用后  old name </span></span><br><span class="line"><span class="comment">// method2 调用前  old name </span></span><br><span class="line"><span class="comment">// method2 调用后  new name2</span></span><br></pre></td></tr></table></figure><p>注意，go 中结构体实例的两种方式，一种就是直接实例化，例如上面的 t := T{“old name”}，还有一种先通过 new 函数在内存中创建 T 结构体的实例，然后逐个属性赋值，当然可以是 t1 := &amp;T{“old name”}</p><p>如果是直接实例化方式，这种结构体值（对象）是无法使用指针来访问属性，而通过 new 和指针实例的结构体指针，则可以通过指针访问属性，例如 (*t).name</p><p>另外，使用结构体指针访问属性 t.name 时，其实 go 内部最后也是通过 (*t).name 去进行访问，只是前者的书写会更简便一些</p><p>关于结构体方法的接收器，可以理解成 python class 类的方法的 self 参数，在 go 中这个接收器是一个值拷贝，即使定义的结构体方式是指针类型的接收器，在调用时这个接收器传递的是指针地址的值拷贝</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针也是一个变量，它存储的不是变量的值，而是值的内存地址，比如类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针，其零值为 <code>nil</code></p><p>因为 go 函数默认都是值传递，也就是说函数的形参变量，其值是拷贝了执行的参数的值，但并非是引用关系，所以在函数中修改了变量的值后，函数外部调用函数传入的变量却不会有任何修改</p><p>当使用指针时，在函数内部对指针变量修改后，外部的全局变量将会一样被修改，对于结构体变量很常用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value: %v, pointer: %v&quot;</span>, num, &amp;num)      <span class="comment">// 使用 &amp; 可以访问一个变量的内存地址</span></span><br><span class="line"><span class="comment">// value: 10, pointer: 0xc00001a098</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>     <span class="comment">// 变量 p 是一个 int 类型的指针</span></span><br><span class="line"></span><br><span class="line">age := <span class="number">20</span></span><br><span class="line">p = &amp;age       </span><br><span class="line"><span class="built_in">println</span>(p)     <span class="comment">// 0xc00007df40</span></span><br><span class="line">*p = <span class="number">22</span>        <span class="comment">// *p 将 p 指针的值修改为 22</span></span><br><span class="line"><span class="built_in">println</span>(age)   <span class="comment">// 22，因 p = &amp;age 将 p 指向了 age 的内存地址，*p 修改了指针的值，也就修改了 age</span></span><br></pre></td></tr></table></figure><p>Golang 指针的三个限制：</p><ul><li>指针不能参与计算</li><li>不同类型的指针不能相互转换</li><li>不同类型的指针不能进行比较和赋值</li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数切片排序</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">fmt.Println(nums)           <span class="comment">// [1 2 5 5 6 9]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串切片排序</span></span><br><span class="line">strings := []<span class="type">string</span>&#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>&#125;</span><br><span class="line">sort.Strings(strings)</span><br><span class="line">fmt.Println(strings)        <span class="comment">// [apple banana cherry date]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型排序</span></span><br><span class="line"><span class="comment">// 需要实现 sort.Interface 接口的 Len()、Less(i, j int) bool 和 Swap(i, j int) 三个方法</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"></span><br><span class="line">people := []Person&#123;&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>&#125;,&#123;<span class="string">&quot;John&quot;</span>, <span class="number">42</span>&#125;,&#123;<span class="string">&quot;Michael&quot;</span>, <span class="number">17</span>&#125;,&#123;<span class="string">&quot;Jenny&quot;</span>, <span class="number">26</span>&#125;,&#125;</span><br><span class="line">sort.Sort(ByAge(people))</span><br><span class="line">fmt.Println(people)         <span class="comment">// [&#123;Michael 17&#125; &#123;Jenny 26&#125; &#123;Bob 31&#125; &#123;John 42&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.18 sort 提供了 sort.Slice 方法，通过内部自定义 Less 的匿名函数来排序 </span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(people)         <span class="comment">// [&#123;Michael 17&#125; &#123;Jenny 26&#125; &#123;Bob 31&#125; &#123;John 42&#125;]</span></span><br></pre></td></tr></table></figure><p>补充：sort.Ints 内部其实调用的是 Sort(IntSlice(x)) ，IntSlice 接口就是实现了 len，less，swap 三个方法，同时还另外实现了一个 sort 方法来直接链式操作，这个 sort 方法也是调用的 sort.Sort 方法，所以 sort.IntSlice 和 sort.Ints 本身都是对 int 切片进行原地排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intslice := sort.IntSlice&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;</span><br><span class="line">sort.Sort(intslice)</span><br><span class="line">fmt.Println(intslice)      <span class="comment">// [1 2 3 5 6]</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>补充：init 函数，<strong>go 中每个源文件都可以有一个 init 函数，该函数会在 main 函数执行前被执行</strong> 当一个包被引入时，会执行该包的 init 函数，这个 init 优先于引入程序的 init</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>)</span></span> (sum, sub <span class="type">int</span>) &#123;  </span><br><span class="line">  <span class="comment">// go 支持返回值命名，在函数体内可以无需声明或是使用 := ，且最后只需写 return</span></span><br><span class="line">  sum = a + b</span><br><span class="line">  sub = a - b</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printParams</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;    </span><br><span class="line">  <span class="comment">// 可变形参，使用 ...T 表示（用于接收 0 或到 n 个参数）</span></span><br><span class="line">  <span class="comment">// 类似 python 的 *agrs</span></span><br><span class="line">  <span class="comment">// go 没有 python 中的关键字参数 kwargs，可以使用 strcut 结构体来传入</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">  <span class="comment">// go 中使用 ...int 的形参，是一个 slice 切片，可以进行遍历</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">printParams(params...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变参数接收不同类型的参数可以使用空接口: ...interface&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorf</span><span class="params">(lineNum <span class="type">int</span>, formart <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 上面这个形参表示就是函数需要接受至少 2 或到 n 个参数</span></span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数同样可以接受指针类型参数，依次实现对全局外部变量进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">        a, b = b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">10</span></span><br><span class="line">y := <span class="number">20</span></span><br><span class="line">swap(x, y)</span><br><span class="line">fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">fmt.Println(y)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递，使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">10</span></span><br><span class="line">y := <span class="number">20</span></span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line">fmt.Println(x)  <span class="comment">// 20</span></span><br><span class="line">fmt.Println(y)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>函数本身也可以作为参数，go 中函数的零值是 nil，函数值是不可进行比较的，所以也无法作为 map 中的 key，有了函数值就可以通过行为的方式调用函数，例如下面的 strings.Map 会将第二个参数的每个字符给 add1 函数调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">rune</span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;HAL-9000&quot;</span>)) <span class="comment">// &quot;IBM.:111&quot;</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;VMS&quot;</span>))      <span class="comment">// &quot;WNT&quot;</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;Admix&quot;</span>))    <span class="comment">// &quot;Benjy&quot;</span></span><br></pre></td></tr></table></figure><h5 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;    </span><br><span class="line">  <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;    <span class="comment">// 匿名函数</span></span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := squares            <span class="comment">// 函数值赋值，但是这里 squares 函数内部 x 不会被保留</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, f())   <span class="comment">// func() int%</span></span><br><span class="line">fmt.Println(f)          <span class="comment">// 0x4804c0</span></span><br><span class="line">fmt.Println(f())        <span class="comment">// 0x480660</span></span><br><span class="line">fmt.Println(f()())      <span class="comment">// 1</span></span><br><span class="line">fmt.Println(f()())      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">f := squares()          <span class="comment">// 函数结果赋值，f 变量中的匿名函数 x 引用了 squares 的变量</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, f())   <span class="comment">// int%</span></span><br><span class="line">fmt.Println(f())        <span class="comment">// 1  squares 函数中的 x 变量会常驻内存，且作用域是在 squares 内，所以不会对全局造成污染</span></span><br><span class="line">fmt.Println(f())        <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码需要在 1.22 版本之前才会复现  https://antonz.org/go-1-22/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">  values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;foo5 val = %v\n&quot;</span>, val)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo5()</span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 range 遍历来说，每次得到的 val 变量是同一个地址，并不是 slice 里每个元素的引用</span></span><br><span class="line"><span class="comment">// 由于闭包的延迟绑定，这里 go func()() 会开启 routine</span></span><br><span class="line"><span class="comment">// 这会使得这个匿名函数的真正执行要晚于 for 循环，所以当这个匿名函数执行时</span></span><br><span class="line"><span class="comment">// for 循环的 val 由于被闭包引用，所以延长了生命周期，但是 for 已经完成了</span></span><br><span class="line"><span class="comment">// 所以 val 最后的值就是 5，只会得到 for 结束后 val 存储的值</span></span><br></pre></td></tr></table></figure><h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>defer 关键字可以产生延迟执行，defer 的函数会在 return 语句更新返回值后再执行，这使得 defer 函数可以访问到返回值</p><p>defer 通常用来在主函数结束之前对资源进行释放，如关闭文件句柄、断开连接、释放锁等。有了 defer 语句就可以轻松地的在函数中统一处理释放，和省去重复的判断逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span>(res <span class="type">int</span>)&#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1 n1=&quot;</span>, n1)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1 n2=&quot;</span>, n2)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;res =&quot;</span>, res)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;fmt.Println(<span class="string">&quot;res =&quot;</span>, res)&#125;()</span><br><span class="line">  res = n1 + n2</span><br><span class="line">  fmt.Println(<span class="string">&quot;ok1 res=&quot;</span>, res)</span><br><span class="line">  <span class="comment">// 注意 defer 函数不受 panic 的影响，假设在这行手动抛出 panic，这个 sum 函数中 defer 也会运行</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// ok1 res= 30</span></span><br><span class="line"><span class="comment">// res = 30</span></span><br><span class="line"><span class="comment">// res = 0</span></span><br><span class="line"><span class="comment">// ok1 n2= 20</span></span><br><span class="line"><span class="comment">// ok1 n1= 10</span></span><br></pre></td></tr></table></figure><p>需要注意 defer 执行机制，在 defer 关键字执行时，会立即拷贝 defer 函数所引用的外部变量，并不是在 defer 函数执行的时候才去获取，所以上面的 <code>defer func () &#123;fmt.Println(&quot;res =&quot;, res)&#125;()</code> 在 defer 关键字后使用了一个匿名函数，这样匿名函数被延后执行时，res 已经完成计算，所以返回的计算后的值，如果没有使用匿名函数，而是直接 fmt 打印 res，则 defer 关键字执行时，就已经获取了 res 的值，但此时 res 还没有计算，所以会打印默认零值，也就是 0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 defer 计算函数执行时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  startedAt := time.Now()</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;()</span><br><span class="line">    </span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：defer 数据结构是一个链表，每当有一个新 defer 函数都会被追加到 defer 链表的最前端，在 go 运行时执行时这个延时调用链的时候，会从前向后执行 defer</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=OTczNDMzMDljNDhhM2Y1NmVkNzU1Yjk1MDc0YWZiMzJfYzlOU0FUczc3TVlGanVNdlF5eERNaTF4SEJLanRWeDJfVG9rZW46RlAzRmJlWnJXb09SbDd4V0JFNGM1THhjblFJXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><h5 id="panic-与-recover"><a href="#panic-与-recover" class="headerlink" title="panic 与 recover"></a>panic 与 recover</h5><p>Panic 可以改变程序控制流，调用 panic 会立即停止执行当前函数，并在当前 goroutine 递归执行调用方的 defer</p><p>Recover 则可以用终止 panic 造成的程序崩溃，需要在 defer 中去使用来捕获 panic </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;run f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;   <span class="comment">// recover 的捕获需要结合 defer 函数来得到捕获到的错误</span></span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;detect error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;oops! f2 error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f1()</span><br><span class="line">  f2()</span><br><span class="line">  fmt.Println(<span class="string">&quot;run main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// run f1</span></span><br><span class="line"><span class="comment">// detect error: oops! f2 error   // 注意 defer 执行时会在 f2 堆栈释放前</span></span><br><span class="line"><span class="comment">// run main</span></span><br></pre></td></tr></table></figure><h5 id="Time-模块基本使用"><a href="#Time-模块基本使用" class="headerlink" title="Time 模块基本使用"></a>Time 模块基本使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  now := time.Now()</span><br><span class="line">  fmt.Println(<span class="string">&quot;Current time:&quot;</span>, now)  </span><br><span class="line">  <span class="comment">// Current time: 2025-07-09 14:18:02.28202441 +0800 CST m=+0.000029936</span></span><br><span class="line"></span><br><span class="line">  timeStr := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">  <span class="comment">// go 中将时间对象转为字符串时间的格式化格式，很奇特使用特定数字表示</span></span><br><span class="line">  <span class="comment">// 上面这个 format 是固定的，表示将当前时间对象转为 年-月-日 时:分:秒 的格式</span></span><br><span class="line">  <span class="comment">// 15 表示的是 24 小时值的 hour，03 表示 12 小时制的 hour</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Formatted time:&quot;</span>, timeStr)  </span><br><span class="line">  <span class="comment">// Formatted time: 2025-07-09 14:18:02</span></span><br><span class="line"></span><br><span class="line">  timeStamp := now.Unix()</span><br><span class="line">  <span class="comment">// Unix 时间戳是从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的秒数</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Unix timestamp:&quot;</span>, timeStamp) </span><br><span class="line">  <span class="comment">// Unix timestamp: 1720501082</span></span><br><span class="line"></span><br><span class="line">  timeObj := time.Unix(timeStamp, <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 将 Unix 时间戳转换为 time.Time 对象</span></span><br><span class="line">  <span class="comment">// Unix 接受两个参数，第一个 秒 单位的时间戳，第二个 纳秒 单位的时间戳</span></span><br><span class="line">  <span class="comment">// 将 秒 单位时间戳转为时间对象，第二个参数就是 0，反之亦然</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Time object from timestamp:&quot;</span>, timeObj)  </span><br><span class="line">  <span class="comment">// Time object from timestamp: 2025-07-09 14:18:02 +0800 CST</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Time object Formatted time:&quot;</span>, timeObj.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))  </span><br><span class="line">  <span class="comment">// Time object Formatted time: 2025-07-09 14:18:02</span></span><br><span class="line"></span><br><span class="line">  timeObj, err := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, timeStr, time.Local)</span><br><span class="line">  <span class="comment">// ParseInLocation 用于将字符串时间解析为 time.Time 对象，会返回 time 对象和 error</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error parsing time:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Parsed time object:&quot;</span>, timeObj)  </span><br><span class="line">  <span class="comment">// Parsed time object: 2025-07-09 14:18:02 +0800 CST</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Interface 接口类型具体描述了一系列方法的集合，所以<strong>接口中不需要定义方法体以及变量，在 go 中都是隐式实现接口，只要结构体实现了接口中所有的方法就表示为实现了接口</strong></p><p><strong>interface 可以理解为是 struct 的更高级抽象，可以实现多态和解耦</strong></p><p>io.Writer 类型是用得最广泛的接口之一，因为它提供了所有类型的写入 bytes 的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Requests <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="comment">// 自定义类型需要实现接口中所有的方法，才能算是实现了接口方法</span></span><br><span class="line">  <span class="comment">// 如果少一个没实现，那么对接口赋值时会报错说没有实现是接口中的方法</span></span><br><span class="line">  SendRequest()</span><br><span class="line">  GetResponse()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接口中也可以嵌套其他接口，但同样在最后给接口赋值时都需要将内部所有接口方法实现</span></span><br><span class="line">  <span class="comment">// 注意，嵌套的其他接口中，不能有重名的接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc Computer)</span></span> SendRequest() &#123;</span><br><span class="line">  <span class="comment">// 表示 Computer 类型实现了 Requests 接口的 SendRequest 方法</span></span><br><span class="line">  <span class="comment">// go 中没有 implements 关键字，所以不需要显式声明接口实现</span></span><br><span class="line">  <span class="comment">// 隐式声明的方式让 go 可以更加符合高内聚低耦合</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;pc send request&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc Computer)</span></span> GetResponse() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;pc get response&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> myrequests Requests</span><br><span class="line">  <span class="keyword">var</span> pc Computer = Computer&#123;&#125;</span><br><span class="line"></span><br><span class="line">  myrequests = pc             <span class="comment">// 表示 pc 这个结构体实现了 Requests 这个接口</span></span><br><span class="line">  myrequests.GetResponse()    <span class="comment">// pc get response</span></span><br><span class="line">  myrequests.SendRequest()    <span class="comment">// pc send request</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 表示一个空接口，空接口允许接受任何类型的值</span></span><br><span class="line">  <span class="comment">// 所以有些函数的形参可以看到会是一个空接口类型，这样函数调用时就可以传入任何类型的值</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v&quot;</span>, i2)</span><br><span class="line">  <span class="comment">// 接口是属于引用类型，所以接口底层值是 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和结构体很相似，接口同样可以设定接收者, 例如下面的 Cat 和 <em>Cat 两种类型的 Quack 方法，他们都实现了接口中的方法，但是在 *</em>go 接口中不允许同时存在，值接收者和指针接受者只能二选一**</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">  Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Quack() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span></span> Quack() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口同样可以作为值传递或返回，接口值的内部可以看做是一个元素（底层类型，底层值），接口的零值是 nil，但需要非常注意，一个包含 nil 指针的接口和 nil 接口是不同的两种东西</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...do something...</span></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">    &#125;</span><br><span class="line">    f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...use buf...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 debug 为 false 是，buf 的类型是一个 nil 的指针，这个 nil 指针在 f 中调用 Write 很显然会报错，但这个 out 接口本身并不是一个 nil 接口，它的底层类型是 <em>bytes.Buffer，而值为 nil 指针。所以 *</em>要避免将空指针值的给到一个非空接口**，上面的 buf 变量一开始就应该定义为 io.Writer 类型</p><p><strong>空接口通常可以用来保存任何类型的值，可以用在函数形参上以表示接收任何类型的参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 为 IPAddr 添加一个 &quot;String() string&quot; 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IPAddr)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, ip[<span class="number">0</span>], ip[<span class="number">1</span>], ip[<span class="number">2</span>], ip[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line">    <span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loopback: 127.0.0.1</span></span><br><span class="line"><span class="comment">// googleDNS: 8.8.8.8</span></span><br></pre></td></tr></table></figure><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>类型断言提供对接口类型底层数据类型的访问，例如 i 这个空接口，可以接受任何类型 假设有一个多态数组，其类型是空接口，当进行遍历调用接口时，就需要使用断言，和 map 获取 key 一样，<code>i.(T)</code> 去断言 i 的类型时会返回一个变量表示断言是否成功，这样可以避免因为 i 不是 T 类型时引发的 panic</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)          <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)      <span class="comment">// hello true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型选择，和 switch 语法很像，用于支持多种类型的判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;二倍的 %v 是 %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q 长度为 %v 字节\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;我不知道类型 %T!\n&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  do(<span class="number">21</span>)</span><br><span class="line">  do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>Go 中通过 error 接口类型的值表示错误，这个 error 接口中定义了一个返回字符串的 Error 方法，所以如果要自定义错误，需要实现 error 接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="type">float64</span>    <span class="comment">// 定义一个负数平方根的错误类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="comment">// 实现负数平方根的 Error 方法</span></span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;cannot Sqrt negative number: &quot;</span>, <span class="type">float64</span>(e))</span><br><span class="line">  <span class="comment">// 注意这里的 e 需要通过 float64 进行转换，</span></span><br><span class="line">  <span class="comment">// 否则 Sprintf 函数会调用 e 的 Error 方法得到格式化字符串</span></span><br><span class="line">  <span class="comment">// 而当前这个 e 的 Error 方法中又调用了 Sprintf，这就变成死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> math.Sqrt(x), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))    <span class="comment">// 0 cannot Sqrt negative number: -2</span></span><br></pre></td></tr></table></figure><p>关于错误的处理，如果直接使用打印或是 log 记录 error ，当 error 传递时，就会出现重复信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  _, err := w.Write(buf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;unable to write:&quot;</span>, err) <span class="comment">// annotated error goes to log file</span></span><br><span class="line">    <span class="keyword">return</span> err                           <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := WriteConfig(f, &amp;conf)</span><br><span class="line">  fmt.Println(err) <span class="comment">// io.EOF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unable to write: io.EOF</span></span><br><span class="line"><span class="comment">// could not write config: io.EOF</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>所以可以给错误加上一些上下文信息，并将错误直接返回给上层，由上层判断处理，通过 <code>fmt.Errorf</code> 可以给错误加上上下文信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果想要获取错误更多信息，可以使用 <code>github.com/pkg/errors</code> 这个包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只附加新的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只附加调用堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同时附加堆栈和信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归解包得到原始错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;open failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  buf, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;read failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  home := os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">  config, err := ReadFile(filepath.Join(home, <span class="string">&quot;.settings.xml&quot;</span>))</span><br><span class="line">  <span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">&quot;could not read config&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _, err := ReadConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;original error: %T %v\n&quot;</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;stack trace:\n%+v\n&quot;</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="make-与-new"><a href="#make-与-new" class="headerlink" title="make 与 new"></a>make 与 new</h4><p>Go 中在对类型初始化时，通常会使用到这两个函数，但两者还是有些区别的</p><p><strong>new：</strong></p><ul><li><strong>用途</strong>：<strong><code>new</code></strong> <strong>用于分配内存</strong>，为变量分配零值（<code>zero value</code>）</li><li><strong>返回值</strong>：<strong><code>new</code></strong> <strong>返回一个指向分配内存的指针</strong></li><li><strong>语法</strong>：<code>new(Type)</code>，其中 <code>Type</code> 是要分配内存的类型</li><li><strong>行为</strong>：<ul><li><code>new</code> 分配的内存大小由类型决定</li><li>分配的内存会被初始化为该类型的零值（例如，<code>int</code> 的零值是 <code>0</code>，<code>string</code> 的零值是 <code>&quot;&quot;</code>，<code>struct</code> 的零值是所有字段为零值的实例）</li><li><code>new</code> 返回的是一个指针，指向分配的内存</li></ul></li></ul><p>make：</p><ul><li><strong>用途</strong>：<code>make</code> 用于初始化内置的引用类型（如 <code>slice</code>、<code>map</code> 和 <code>channel</code>）</li><li><strong>返回值</strong>：<strong><code>make</code></strong> <strong>返回一个初始化后的引用类型的值，而不是指针</strong></li><li><strong>语法</strong>：<code>make(Type, size)</code> 或 <code>make(Type, size1, size2)</code>，其中：<ul><li><code>Type</code> 是要初始化的类型（必须是 <code>slice</code>、<code>map</code> 或 <code>channel</code>）</li><li><code>size</code> 是初始化的大小</li><li><code>size1</code> 和 <code>size2</code> 用于 <code>slice</code> 的长度和容量</li></ul></li><li><strong>行为</strong>：<ul><li><strong><code>make</code></strong> <strong>只能用于初始化内置的引用类型</strong>，不能用于普通类型（如 <code>int</code>、<code>struct</code> 等）</li><li>初始化后的类型已经准备好使用，且内部数据结构被正确初始化</li><li>对于 <code>slice</code>，<code>make</code> 返回一个指向底层数组的切片</li><li>对于 <code>map</code>，<code>make</code> 返回一个空的哈希表</li><li>对于 <code>channel</code>，<code>make</code> 返回一个通道</li></ul></li></ul><h4 id="循环与分支"><a href="#循环与分支" class="headerlink" title="循环与分支"></a>循环与分支</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的循环写法</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用条件的循环，代替了 while，golang 里没有 while 循环</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i&lt;<span class="number">10</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环，使用 break 退出，或 return 退出函数</span></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for range 可以用来遍历数组，或是 map，也可是是 strings</span></span><br><span class="line">names := []<span class="type">string</span>&#123;<span class="string">&quot;messi&quot;</span>, <span class="string">&quot;stark&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> names &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，go 的字符串 string，是由一系列 rune 组成，每个 rune 都是一个 unicode 码</span></span><br><span class="line"><span class="comment">// 所以遍历字符串时，打印每一个字符，得到的是一个数字，可以通过fmt.Printf(&quot;%c\n&quot;,v)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// go 的 if 判断表达式前，允许增加一个语句用来声明判断变量</span></span><br><span class="line">mymap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;age&quot;</span>: <span class="string">&quot;fw&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := mymap[<span class="string">&quot;name&quot;</span>]; ok &#123;</span><br><span class="line">  fmt.Println(val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Print(<span class="string">&quot;no name key in mymap&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 也支持 switch</span></span><br><span class="line"><span class="comment">// switch &lt;表达式，可以是变量，指针，函数&gt; &#123;</span></span><br><span class="line"><span class="comment">//  case 表达式1，表达式2，... :       // 注意每个 case 最后都要有 :  </span></span><br><span class="line"><span class="comment">//     block1                        // 如果 case 代码块里没有 break，则会继续往后执行 case</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//  case 表达式3，表达式4，... :</span></span><br><span class="line"><span class="comment">//     block2</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//     block3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;macOS.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;                  <span class="comment">// switch 也支持无表达式的</span></span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;早上好！&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;下午好！&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;晚上好！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：</p><p>switch 穿透，如果想要一个满足的 case 被执行后，可以将下一个 case 的代码块执行，可以使用 falllthrough 关键字，但需要谨慎使用 一个 fallthrough 只允许继续做一次 case 穿透</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射允许在程序运行期间动态获取变量或结构体的信息，并支持修改</p><p>Go 通过自带的 reflect 包实现了运行时的反射能力，来让程序操作不同类型的对象，其中主要的两个函数是：</p><ul><li><code>reflect.TypeOf</code> 能获取类型信息，就是反射后变量的底层类型，返回的是 <code>reflect.Type</code>，</li><li><code>reflect.ValueOf</code> 能获取数据的运行时表示，就是反射后变量的底层值，通过返回 <code>reflect.Value</code> 表示</li></ul><p>reflect.Type 是一个接口类型，而 reflect.Value 则被定义为 struct，这两个反射对象都可以用 Name 方法查看类型名，Kind 方法查看底层类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;i)</span><br><span class="line">  </span><br><span class="line">  v := reflect.ValueOf(&amp;i)  <span class="comment">// 获取 i 指针的反射对象</span></span><br><span class="line">  fmt.Println(v.Type())     <span class="comment">// 查看反射对象的类型</span></span><br><span class="line">  fmt.Println(v.Elem().Addr())    <span class="comment">// Elem 可以得到指针指向的对象</span></span><br><span class="line">  fmt.Println(v.Pointer())  <span class="comment">// 查看反射对象指针的值</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;v)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// v.SetInt(10)           // 反射对象不能直接修改值，因为 go 的函数调用是值传递，这个 v 和 i 并没有直接关系</span></span><br><span class="line">  v.Elem().SetInt(<span class="number">10</span>)       <span class="comment">// 通过反射更新值</span></span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0xc00001a098</span></span><br><span class="line"><span class="comment">// *int</span></span><br><span class="line"><span class="comment">// 0xc00001a098</span></span><br><span class="line"><span class="comment">// 0xc000008078</span></span><br><span class="line"><span class="comment">// 824633827480</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>反射的特性在处理结构体时非常有用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">  </span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  v := reflect.ValueOf(p)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历结构体字段</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">    f := v.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d: %s %s = %v\n&quot;</span>, i, t.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0: Name string = Alice</span></span><br><span class="line"><span class="comment">// 1: Age int = 25</span></span><br></pre></td></tr></table></figure><p>大多数应用和服务一般不太会过多使用反射，因为反射会一定程度降低代码可读性，主要是一些框架中会使用反射来简化代码</p><p>通常 ORM 框架，序列化和反序列化等会使用反射特性</p><p>反射也可以对方法进行调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  A <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyStruct)</span></span> Add(b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.A + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  m := &amp;MyStruct&#123;A: <span class="number">10</span>&#125;</span><br><span class="line">  </span><br><span class="line">  v := reflect.ValueOf(m)</span><br><span class="line">  method := v.MethodByName(<span class="string">&quot;Add&quot;</span>)   <span class="comment">// MethodByName 可以名字得到结构体反射的方法</span></span><br><span class="line">  </span><br><span class="line">  args := []reflect.Value&#123;reflect.ValueOf(<span class="number">5</span>)&#125;</span><br><span class="line">  result := method.Call(args)       <span class="comment">// 反射的方法需要使用 Call 来调用，参数 []reflect.Value 切片</span></span><br><span class="line">  </span><br><span class="line">  fmt.Println(result[<span class="number">0</span>].Int())      <span class="comment">// 输出 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三法则"><a href="#三法则" class="headerlink" title="三法则"></a>三法则</h4><p>Go 反射的三个法则是：</p><ul><li>从接口值可以反射出反射对象</li><li>从反射对象可以反射接口值</li><li>要求改反射对象，其值必须可设置</li></ul><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>go 最大的优势特点就是通过 goroutine 进行并发编程，goroutine 可以理解为 golang 的协程，是并发执行的工作单元</p><p>goroutine 非常轻量级，运行一个协程只需要 4-5 kb，所以 go 中可以非常容易地创建上万个协程实现并发。对于 goroutine 的调度全部由 go 的运行时来管理，而不是通过操作系统，go 的运行时会在用户态进行调度，避免了上下文切换需要的消耗</p><p>当一个程序开始运行，主函数会在一个叫 main routine 中运行，其中要开启一个 go 协程，只需在函数调用前加上关键字 go ，即 <code>go func()</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)    <span class="comment">// 开启 spinner 函数的协程</span></span><br><span class="line">  <span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">  fibN := fib(n)       <span class="comment">// fib 函数会一直计算直到 return 结果，此时 spinner 也在一起执行</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">  <span class="comment">// 主函数上最后 Printf 结束时，内部 spinner 协程会被终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">          time.Sleep(delay)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 goroutine 中想要手动终止执行，可以使用 runtime 包中的 <code>runtime.Goexit()</code>，<strong>goroutine 被终止时，调度器会确保已经注册 defer 被延时执行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">      <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">      runtime.Goexit()</span><br><span class="line">      fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B.defer</span></span><br><span class="line"><span class="comment">// A.defer</span></span><br></pre></td></tr></table></figure><h4 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h4><p>go 语言调度器通过 GMP 模型来实现并发执行和管理，GMP模型由三个核心组件组成：G（Goroutine）、M（Machine）、P（Processor）</p><p>G：Goroutine 代表一个独立的执行单元，Goroutine 的调度由 Go 运行时在用户态进行</p><p>M：Machine 代表操作系统的线程，一个 M 可以执行多个 Goroutine，但同一时间只能执行一个 Goroutine。M 与操作系统的线程直接对应，Go 运行时通过 M 来利用多核 CPU 的并行计算能力，</p><p>P：Processor 被看做运行在线程上的本地调度器，它可以维持一个容纳最多 256 个 G 的队列，是 M 与 G 的中间层，为线程 M 提供上下文，通过 GOMAXPROCS 可以设置最大的活跃线程数，默认这个值是当前机器的核数</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=MWNjMWEzOTQ1OGI4ZGVmOTQ2ZmJiOWYzZDVkMjJmZGZfekJ2aGtWMDlUbFhpRjJJUHJSeWE1VFBUZm9NUTQyS0JfVG9rZW46Q1RaT2JHcnVPb1ZhM0Z4UU8ybGMxNmU3bjJlXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><p>Go 调度器的设计：</p><ul><li><strong>复用线程的两个策略</strong>：<ul><li><strong>Work Stealing 机制</strong>：当本线程没有可执行的 G，会从全局 G 队列中获取。如果全局队列中没有，则尝试从其他 P 的队列中偷取 G</li><li><strong>Hand Off 机制</strong>：当本线程因 G 进行系统调用等阻塞时，线程会释放绑定的P，把 P 转移给其他空闲的 M 执行</li></ul></li><li><strong>抢占式调度</strong>：Goroutine 是协作式的，一个协程只有让出 CPU 才能让下一个协程执行，而 Goroutine 执行超过 10ms 就会强制让出 CPU，防止其他协程饿死</li><li><strong>G0 和 M0</strong>：<ul><li><strong>G0</strong>：每次启动一个 M 都会创建的第一个 Goroutine，仅用于调度，不指向任何可执行的函数。每个 M 都有一个 G0，在调度或系统调用时使用 G0 的栈空间</li><li><strong>M0</strong>：启动程序后的第一个主线程，负责执行初始化操作和启动第一个Goroutine，此后与其他 M 一样</li></ul></li></ul><p>Goroutine 的生命周期，大致可以分为：</p><ul><li><p>创建（Creation），即通过 go 关键期启动函数，此时 goroutine 会初始化，加入到运行时的调度队列中</p></li><li><p>运行（Running），goroutine 调度到内核态 M 线程上执行</p></li><li><p>阻塞（Bolcking）, goroutine 执行过程遇到 IO ，channel 或同步操作，调度器 P 会挂起它，执行下一个 goroutine</p></li><li><p>就绪（Runable），goroutine 阻塞解除后，会进入就绪状态等待重新调度</p></li><li><p>完成（Finished），goroutine 执行结束，go 运行时会清理 goroutine 的资源</p><p>整个生命周期，包含了以下一些状态：</p></li></ul><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>_Gidle</td><td>刚刚被分配并且还没有被初始化</td></tr><tr><td>_Grunnable</td><td>没有执行代码，没有栈的所有权，存储在运行队列中</td></tr><tr><td>_Grunning</td><td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td></tr><tr><td>_Gsyscall</td><td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td></tr><tr><td>_Gwaiting</td><td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td></tr><tr><td>_Gdead</td><td>没有被使用，没有执行代码，可能有分配的栈</td></tr><tr><td>_Gcopystack</td><td>栈正在被拷贝，没有执行代码，不在运行队列上</td></tr><tr><td>_Gpreempted</td><td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td></tr><tr><td>_Gscan</td><td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td></tr></tbody></table><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>虽然 goroutine 是共享内存空间的，但在 go 中推荐<strong>使用 channel 来实现 goroutine 的通信，而不是使用共享内存来通信</strong></p><p>Channel 管道就是 FIFO 的先进先出队列，使用 make 函数来构建管道类型，以及设置管道的容量，<strong>如果管道已满再写入，或管道为空再读取，都会引发 deadlock 错误</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type)             <span class="comment">// 等价于 make(chan Type, 0)</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)     <span class="comment">// 创建一个存储 int 类型的管道，管道容量为 5</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>                     <span class="comment">// 写入数据到管道</span></span><br><span class="line">x := &lt;-channel              <span class="comment">// 从管道读取</span></span><br><span class="line">x, ok := &lt;-channel          <span class="comment">// 功能同上，同时检查通道是否已关闭或者是否为空</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)                <span class="comment">// 关闭 channel</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;     <span class="comment">// range 可以代替 for 或 while 来逐个从 channel 中持续读取数据</span></span><br><span class="line">    fmt.Println(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 channel 没有设置 capacity 容量，就是无缓冲阻塞读写的，也就是写入一个元素到 channel 中后，必须要有 goroutine 去读取这个值，否则 channel 就会阻止其他 goroutine 的数据写入，所以使用无缓冲管道时需要发送和接收方同时都准备好通信，不然就会导致两边的通信等待</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=NzAxYTRiYjNmNGM2MGE0M2JiMDBiODY0YmQ4YTAyYjhfV0lnR0hvbmFCWTZ1VkxKQ1NwUEhCQ3dTaDFnemNEcVRfVG9rZW46RHk1cmJXT0d5b2J6bEd4UHhjMGNqZ0liblFoXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><p>有设置 capacity 则表示有缓冲非阻塞的管道，允许将管道写入多个数据，直到容量已满为止无法写入，也允许从管道获取多个数据，直到没有数据继续等待 channel 的数据</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU0N2QxMTdkZmRiN2FjZDVjNGRiOTUwMTZmNzg4ZTJfb2dXYWp1azZJREZDS1NaRktKQ1JOem5GanhlZ1JUVzZfVG9rZW46TUd6UGI0TFRBb2dDSGR4cmY1WWMwSmVSbjhxXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>在 go 中还提供了一个 select 关键字来对多个 channel 进行监听，select 的编写和 switch 几乎一样，只是 <strong>select 的 case 必须都是 channel 的收发操作</strong></p><p>使用 select 可以实现 channel 的非阻塞收发，当 select 中没有任何匹配的 channel 操作 case，会执行其中 default 语句，而当 select 里有多个满足的 case 时，会随机选择一个进行执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞收发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// default</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机 case 执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Second) &#123;</span><br><span class="line">      <span class="comment">//  time.TicK 会返回一个定时的通道，这个通道会按照设定间隔时间，发送一个时间值</span></span><br><span class="line">      ch &lt;- <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;case1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;case2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="comment">// case2</span></span><br></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题</p><p>Go 语言在 <code>sync</code> 包中提供了用于同步的一些基本原语，包括常见的 <code>sync.Mutex</code>、<code>sync.RWMutex</code>、<code>sync.WaitGroup</code>、<code>sync.Once</code> 和 <code>sync.Cond</code>，这些基本原语提供了相对原始的同步机制</p><h5 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SafeCounter 是并发安全的</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex        <span class="comment">// Mutex 是互斥锁</span></span><br><span class="line">  v  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 对给定键的计数加一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="comment">// Lock 和 Unlock 一定是成对出现，否则会引发死锁</span></span><br><span class="line">  <span class="comment">// 锁定使得一次只有一个 Go 协程可以访问映射 c.v。</span></span><br><span class="line">  c.v[key]++</span><br><span class="line">  c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定键的计数的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="comment">// 锁定使得一次只有一个 Go 协程可以访问映射 c.v。</span></span><br><span class="line">  <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Mutex</code> 是互斥锁，互斥锁有正常模式和饥饿模式：</p><ul><li>正常模式，锁的等待者按照 FIFO 顺序等待获取锁，这会导致刚被唤起的 goroutine 在和新创建的 goroutine 竞争时，可能就会无法得到锁，导致延迟增加</li><li>饥饿模式，锁会优先给等待队列中最前面的获取锁，新创建的 goroutine 不会竞争锁，也不会进入自旋</li></ul><p>Go 会自动在互斥锁的这两种模式下进行转换以保证性能。正常模式下，新的 goroutine 超过 1ms 没有得到锁，互斥锁就会转为饥饿模式；饥饿模式下，一个在队列尾部的 goroutine 得到锁时，或者是得到锁的等待时间小于 1 ms ，则会转为正常模式</p><p>互斥锁的数据结构如下，整体空间只有 8 个字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  state <span class="type">int32</span>    <span class="comment">// 当前互斥锁的状态</span></span><br><span class="line">  sema  <span class="type">uint32</span>   <span class="comment">// 用于控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>互斥锁 Metux 的使用需要注意：</em></strong></p><ul><li>Lock 和 Unlock 一定需要成对使用</li><li>如果函数调用传递了互斥锁，函数参数应该为指针，否则函数的值传递特性，函数内再次进行加锁解锁，将会导致死锁</li></ul><h5 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h5><p><code>sync.RWMutex</code> 是读写互斥锁，是从互斥锁上演变的，颗粒度更新的锁，即允许并发读操作，但是不允许并发读写，并发写写操作，因此 <strong>RWMetux 更加适合读多写少的场景使用</strong></p><p>RWMutex 结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  w           Mutex       <span class="comment">// 复用互斥锁提供的能力</span></span><br><span class="line">  writerSem   <span class="type">uint32</span>      <span class="comment">// 写等待读</span></span><br><span class="line">  readerSem   <span class="type">uint32</span>      <span class="comment">// 读等待写</span></span><br><span class="line">  readerCount <span class="type">int32</span>       <span class="comment">// 存储了当前正在执行的读操作数量</span></span><br><span class="line">  readerWait  <span class="type">int32</span>       <span class="comment">// 当写操作被阻塞时等待的读操作个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h5><p><code>sync.WaitGroup</code> 可以等待一组 Goroutine 的返回，比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line"></span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">  &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group 检查点，检查所有 goroutine 是否全部完成</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>WaitGroup 提供了三个方法 Add，Done，Wait：</p><ul><li><p>Add，用来设置 WaitGroup 的计数值</p></li><li><p>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)</p></li><li><p>Wait，调用这个方法后会一直阻塞，直到 WaitGroup 的计数值变为 0</p><p>注意事项：</p></li><li><p>Waitgroup 的所有 Add 都都必须在 Wait 之前设置</p></li><li><p>虽然 Add 可以传负数来将计数器做减法，但还是要用 Done 来处理完成</p></li><li><p>不同于 Add 和 Wait，Done 方法需要在每一个 goroutine 中使用，否则会死锁</p></li></ul><h6 id="ErrorGroup"><a href="#ErrorGroup" class="headerlink" title="ErrorGroup"></a>ErrorGroup</h6><p>Waitgroup 的协同等待在并发原语中使用频率非常高，但是 waitgroup 无法传播这一批 goroutine 中发生错误后的消息，和上下文取消的功能</p><p>所以 go 的扩展库 <code>golang.org/x/sync/errgroup</code> 提供了 ErrorGroup 这个原语，可以看做是 waitgroup 的增强版，适用于需要有错误处理需求的协同场景</p><p>ErrorGroup 会将执行的 goroutine 遇到的第一个错误返回，并在出现错误时会自动调用 context 的 cancel 方法取消同步信号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  eg, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    i := i</span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">      time.Sleep(<span class="number">2</span> * time.Second) </span><br><span class="line"></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 监听 context 信号</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;Canceled:&quot;</span>, i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">90</span> &#123;</span><br><span class="line">          fmt.Println(<span class="string">&quot;Error:&quot;</span>, i)</span><br><span class="line">          <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Error: %d&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;End:&quot;</span>, i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := eg.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h5><p><code>sync.Once</code>可以保证在 Go 程序运行期间的某段代码只会执行一次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  o := &amp;sync.Once&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h5><p><code>sync.Cond</code>可以让一组的 Goroutine 都在满足特定条件时被唤醒，<strong>每一个</strong> <strong><code>sync.Cond</code></strong> <strong>结构体在初始化时都需要传入一个互斥锁</strong></p><p>Cond 条件锁提供的方法：</p><ul><li><code>sync.Cond.Wait</code> 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃</li><li><code>sync.Cond.Signal</code> 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine</li><li><code>sync.Cond.Broadcast</code> 会按照一定顺序广播通知等待的全部 Goroutine</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status <span class="type">int64</span>     <span class="comment">// 创建一个条件判断变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)     <span class="comment">// 通过互斥锁创建一个 cond 条件锁</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> listen(c)                       <span class="comment">// 开启 10 个协程，每个都执行 listen 方法监听条件变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)          <span class="comment">// 延迟 1 秒后，启动 broadcast 协程</span></span><br><span class="line">  <span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)        <span class="comment">// 创建一个系统信号的通道</span></span><br><span class="line">  signal.Notify(ch, os.Interrupt)      <span class="comment">// 通知系统将 os.Interrupt 信号（通常是 Ctrl+C）发送到这个通道</span></span><br><span class="line">  &lt;-ch                                 <span class="comment">// 没有 Ctrl+C 时，主 goroutine 会阻塞在这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">  c.L.Lock()                           <span class="comment">// 锁定条件互斥锁，使 broadcast 是线程安全</span></span><br><span class="line">  atomic.StoreInt64(&amp;status, <span class="number">1</span>)        <span class="comment">// 通过原子操作，设置 status 条件变量的值为 1</span></span><br><span class="line">  c.Broadcast()                        <span class="comment">// 条件锁发送广播信号，唤醒所有等待条件的 goroutine</span></span><br><span class="line">  c.L.Unlock()                         <span class="comment">// 释放条件互斥锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">  c.L.Lock()                           <span class="comment">// 锁定条件互斥锁，使 listen 是线程安全</span></span><br><span class="line">  <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123; <span class="comment">// 原子操作，读取 status 变量值</span></span><br><span class="line">    c.Wait()                           <span class="comment">// status 不等于 1，则继续等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;listen&quot;</span>)                <span class="comment">// status 条件变量确认通过，10 个 goroutine 执行打印</span></span><br><span class="line">  c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h3><p>应用程序运行会有堆（Heap）和栈（Stack）两种内存，GC 的作用是回收堆内存，栈内存则用于存储函数中局部变量和调用栈，这些内存使用完就可以被释放，所以由编译器通过指令自动清理</p><p>在 py 中垃圾回收机制是引用计数，标记-清除，分代回收三种。在 go 中主要是三色标记清除算法</p><h4 id="三色标记清除"><a href="#三色标记清除" class="headerlink" title="三色标记清除"></a>三色标记清除</h4><p><strong>标记-清除算法有个非常明显的问题，就是需要 STW（stop the world）暂停所有线程来实现安全地标记和清除。且每次 STW 期间，需要完整遍历 heap 来得到不可达的需清理垃圾，每次清理后还会造成一定的碎片</strong></p><p>Go 经过历代优化，在 1.5 版本开始使用三色标记清除来并发处理垃圾回收，三色标记是将程序中的对象分为白色，黑色和灰色</p><p><strong>白色：潜在垃圾</strong></p><p><strong>黑色：活跃对象，从根节点可达，以及没有其他引用指针的对象</strong></p><p><strong>灰色：活跃对象，存在对白色对象的引用</strong></p><p>初始阶段，所有对象都会被标记为白色。然后会从根节点遍历所有对象，将从根节点直接可达的对象标记成灰色，加入到灰色对象集合，接着遍历灰色对象集合，将其中一个灰色对象放置到黑色对象集合中，同时将该黑色对象所指向的对象加入到灰色对象集合，然后就是重复此步骤直到没有灰色对象</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgyODcxM2EyMGFmNzRmN2QyZmFkYzYxYzFkN2ExYTFfTjZlOWwza0xOOHBBZ2s1aTF4TVpUSk1peGt0RUVzWk1fVG9rZW46SUdoOGJPUlEzb1BCMGp4N3RmemNETDVXbjVkXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><p>然后垃圾回收器就会对白色的垃圾对象进行回收，因为这些对象程序没有引用，程序不存在依赖可以被回收，例如下图的 D 对象</p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E1NGU1YzA4NTFkYWU2NWY1NzFlMTJhOGUzOTdlYWNfQ2tpVDlTVkFla2VMWHppdlFMRVpHRmRsRGRrUjVubzJfVG9rZW46TFJwSWJsYU1kb2kwUGp4dkJ0RmMzTUl0bnhiXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><p>但是三色标记清除本身并不能并发执行，需要依赖 STW 来确保安全，因为假设程序在垃圾回收处理过程中，并发处理将 A 对象指向 D 对象，此时三色标记中已经没有灰色对象，这个 D 对象就会被错误回收</p><p>因此 go 在三色标记清除基础上增加屏障技术，来实行并发和增量的标记对象，要达到这个需要达成强三色不变性或弱三色不变性</p><p><strong>强三色不变性：黑色对象不能指向白色对象，只能指向灰色或黑色对象</strong></p><p><strong>弱三色不变性：黑色对象所指向的白色对象，必须要包含一个灰色对象经过的（多个）白色对象的路径</strong></p><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=YjliMTE0ZWYwZDg1NWMxMjMxMWRlNGQ4M2EwNTNkZjZfcXFUSEdrYXhSNGM3OFNMSlllTEVDNmtPbXVxZWMyT2lfVG9rZW46R2NLQWI3WTBZb0ZpRXV4SXdRamNTbkdQbmNlXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><p><strong>Go 分被引入了插入写屏障和删除写屏障两种技术来大大缩短 STW 的时间</strong></p><h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h4><ul><li>插入写屏障，简单来说就是在并发过程中，对象指向发生改变后，依然确保能将原先的对象保留，例如下图的 B 对象，在 A 将指向触发写屏障指到 C 上后，C 对象按照强三色逻辑会被标记灰色，而 B 对象按照三色标记逻辑遍历 B 对象后将 B 变为黑色<ul><li>插入写屏障，只作用在堆空间，如果是函数调用栈，最会需要再次通过 STW 暂停保护，对栈空间进行三色标记清楚逻辑的遍历，依次来确保栈空间下对象不会被错误回收</li></ul></li></ul><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJhNWE2MDc5MTUyNmU4MTYwNjE5MzJkNmRiZDdlYThfcHBtZWZkYVE3SUlsU1huTTVkS2hXdzF1ZlNxbzk3Y25fVG9rZW46VVQzcWJBbmlFb2NJRnF4SzZYNmMwUWVubnlkXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h4><ul><li>删除写屏障，能够保留住对象避免并发下被错误回收，例如下图 B 到 C 的指向被删除，A 将指针指向了 C，B 为删除对象则 B 会被标记为灰色，C 对象得到 A 指向被标会灰色，进行下一轮遍历 C 对象变为黑色，B 对象没有下游，但 B 是灰色所以按照逻辑被保留并标记为黑色，在进入到下一轮后会重新按照三色逻辑将 B 回收</li></ul><p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FkYmIyOTcyMTE4ZDc2MTg4NzNjZDYyNmM2NGJmZGVfME1qQVdEREYxQlNlZFlobVhRVFp5elpOYmxtaVJ4SjRfVG9rZW46VDhpZGJHVlhWb051TjR4M2VJQ2MxQlFlbnhjXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p><h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><p>由于插入和删除写屏障都有各自的一些问题，在 1.8 版本 go 的 GC 改为三色标记清除 + 混合写屏障。混合写屏障结合了插入和删除写屏障：</p><ul><li>GC 开始时，优先将栈空间上所有可达对象标记黑色（避免栈的二次遍历）</li><li>GC 过程中，栈上新创建的对象同样会标记为黑色</li><li>被删除的对象会被标记为灰色</li><li>被添加的对象会被标记为灰色</li></ul><h3 id="Gin-框架"><a href="#Gin-框架" class="headerlink" title="Gin 框架"></a>Gin 框架</h3><h4 id="初始化服务"><a href="#初始化服务" class="headerlink" title="初始化服务"></a>初始化服务</h4><p>通常创建一个 gin 的 server，都是使用 gin.Default() 去构建默认的 gin 服务，这其中会调用 New 方法创建，然后会再使用 Use 方法去加上  Logger 和 Recovery 这两个 middleware</p><p>所以其实也可以直接使用 New 去出初始化，不过一般都是使用 Default</p><h4 id="请求结构体绑定"><a href="#请求结构体绑定" class="headerlink" title="请求结构体绑定"></a>请求结构体绑定</h4><p>以常见 json 数据格式为例，gin 中 gin.Context 提供的请求体序列化的方法是 ShouldBind 和 ShouldBindBodyWith 两个方法</p><p><strong>ShouldBind 方法只允许 context 调用一次进行结构体绑定，第二次调用该方法则会得到 EOF</strong></p><p>ShouldBindBodyWith 方法会都多一个参数来指定序列化请求体的格式，例如：binding.JSON，不同于 ShouldBind 方法的是 bindbodywith 允许在请求处理函数中多次调用，来实现将请求中的数据序列化到不同的结构体中</p><p>补充：除了 Shouldbind，还有 Bind，对应的是 MustBind 方法，和 should 的区别是 must 的绑定方法，如果出现字段无法匹配绑定则会直接中断处理请求，返回 400 的错误响应</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ShouldBind（手动处理错误）</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(<span class="number">400</span>, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="number">1001</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Invalid input&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Bind（自动处理错误）</span></span><br><span class="line"><span class="keyword">if</span> err := c.BindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 自动返回 400 + 默认错误格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：请求的 json 数据中包含的时间类型的话，结构体中可以指定时间值的格式，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  Birthday time.Time <span class="string">`form:&quot;birthday&quot; time_format:&quot;20060102&quot; time_utc:&quot;1&quot;`</span>  </span><br><span class="line">  <span class="comment">// time_utc:&quot;1&quot; 表示将 Birthday 的值转为 utc 事件，不设置这个 tag 就是本地时间</span></span><br><span class="line">  <span class="comment">// 注意，如果前端请求参数的格式不是 20060102，在使用 bind 方法时是会报错的</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：对于动态路由的参数，可以使用 context 的 Param 方法去获取路由上动态参数的值，也可以使用 ShouldBindUri 的方法将路由上的动态参数直接绑定到结构体上</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Person <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ID   <span class="type">string</span> `uri:<span class="string">&quot;id&quot;</span> binding:<span class="string">&quot;required,uuid&quot;</span>`</span><br><span class="line">  Name <span class="type">string</span> `uri:<span class="string">&quot;name&quot;</span> binding:<span class="string">&quot;required&quot;</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件的设置位置可以有三种，他们的作用范围是逐个减少的：</p><ul><li><p>全局中间件</p></li><li><p>路由组中间件</p></li><li><p>路由中间件</p><p>全局中间件，就是在服务入口初始化后，可以通过 Use 去设置，和使用 Default 创建 gin 里的默认的两个中间件一样</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e := gin.Default()</span><br><span class="line"></span><br><span class="line">e.Use(middlewares.RequestMiddleware())  <span class="comment">// 全局中间件</span></span><br><span class="line"></span><br><span class="line">e.GET(<span class="string">&quot;/health&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;server is health&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由组中间件的设置其实也是一样的，但还有另一种写法，就是在 Group 方法的第二参数开始就是中间件的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRouterMiddleware1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;in AdminRouterMiddleware1&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;out AdminRouterMiddleware1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRouterMiddleware2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;in AdminRouterMiddleware2&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;out AdminRouterMiddleware2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRouterInit</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">  AdminRouters := e.Group(<span class="string">&quot;/admin&quot;</span>, AdminRouterMiddleware1)</span><br><span class="line">  AdminController := &amp;controllers.AdminController&#123;&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    AdminRouters.GET(<span class="string">&quot;/users&quot;</span>, AdminRouterMiddleware2, AdminController.GetUsers)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在中间件的函数中，可以使用 context 的 Set 设置可以在其他中间件或路由 controller 函数内使用的全局变量，通过 context 的 Get 方法可以读取，这个方法会返回两个值，第一个是要获取的值，第二个值是 key 是否存在</p><p><strong>补充：中间件函数中如果需要使用 go routine 的话，这个协程内需要使用 context 的副本，也就是需要先进行 context 的 Copy 方法来拷贝副本</strong></p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>调用 context 的 SetCookie 方法可以设置 cookie，分别有以下这些参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetCookie(</span><br><span class="line">  name, </span><br><span class="line">  value <span class="type">string</span>, </span><br><span class="line">  maxAge <span class="type">int</span>,        <span class="comment">// 如果要删除一个 cookie，需要通过 setcookie 将过期时间设置为负数</span></span><br><span class="line">  path,              <span class="comment">// 表示 cookie 生效路径，一般都是 &quot;/&quot; 表示全站有效，也可以是某一个路由路径</span></span><br><span class="line">  domain <span class="type">string</span>,     <span class="comment">// 表示 cookie 生效域名，默认是当前域名，设为 .example.com 时，所有子域名（如 api.example.com）均可访问</span></span><br><span class="line">  secure,            <span class="comment">// 设置为 true 时，表示只有 https 请求才会携带此 cookie</span></span><br><span class="line">  httpOnly <span class="type">bool</span>) &#123;   <span class="comment">// 设置为 true 时，表示允许 js 去操作该 cookie</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>非常流程的应该是 logrus 和 zap，后者是非常适合高并发的项目，在性能上要比 logrus 高出几倍，而 logrus 虽然性能不及 zap，但简单易用，只是目前此项目已经不再维护</p><p>搭配 lumberjack 可以实现日志轮转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccessLogger</span><span class="params">()</span></span> *logrus.Logger &#123;</span><br><span class="line">  accessLogger := logrus.New()</span><br><span class="line">  accessLogger.SetOutput(&amp;lumberjack.Logger&#123;</span><br><span class="line">    Filename:   <span class="string">&quot;logs/access.log&quot;</span>, <span class="comment">// 日志文件路径</span></span><br><span class="line">    MaxSize:    <span class="number">100</span>,               <span class="comment">// 每个日志文件的最大大小（MB）</span></span><br><span class="line">    MaxBackups: <span class="number">5</span>,                 <span class="comment">// 保留旧日志文件的最大数量</span></span><br><span class="line">    MaxAge:     <span class="number">5</span>,                 <span class="comment">// 保留旧日志文件的最大天数（优先于 MaxBackups）</span></span><br><span class="line">    Compress:   <span class="literal">true</span>,              <span class="comment">// 是否压缩旧日志文件</span></span><br><span class="line">    LocalTime:  <span class="literal">true</span>,              <span class="comment">// 使用本地时间命名日志文件</span></span><br><span class="line">  &#125;)</span><br><span class="line">  accessLogger.SetFormatter(&amp;logrus.JSONFormatter&#123;</span><br><span class="line">    TimestampFormat: <span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="comment">// 设置时间格式</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accessLogger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>浏览器的同源策略是禁止进行 A 向 B 跨域请求的，同源策略包含：</p><ul><li>A 和 B 的域名不同，不允许跨源</li><li>A 和 B 的服务端口不同，不允许跨源</li><li>A 和 B 的协议不同，一个是 http ，一个是 https，同样不允许跨源</li></ul><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以浏览器访问百度，然后在控制台中使用以下 js 发起请求</span></span><br><span class="line"><span class="keyword">var</span> jq = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">jq.<span class="property">src</span> = <span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(jq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $=jQuery.<span class="title function_">noConflict</span>();</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8080/api&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Gin 中没有设置 CORS 的情况下，会得到这样的错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span> to <span class="title class_">XMLHttpRequest</span> at <span class="string">&#x27;http://127.0.0.1:8080/api&#x27;</span> <span class="keyword">from</span> origin <span class="string">&#x27;https://www.baidu.com&#x27;</span> has been blocked by <span class="variable constant_">CORS</span> <span class="attr">policy</span>: <span class="title class_">No</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>所以实际情况下，这个功能是需要在服务端开启 CORS 来允许跨域资源共享，这其中又分为简单请求和非简单请求</p><p>简单请求：即 GET，POST，HEAD，且请求头不包含自定义头部标签，那服务端只需在响应头设置 Access-Control-Allow-Origin 为 *，来表示允许互联网任何域名访问</p><p>非简单请求：例如 PUT，DELETE，请求头包含自定义标签，请求中 Content-Type 是 application/json 这类情况，那么客户端请求服务端时，会先发送一个 OPTIONS 的预检请求，来获取服务端允许哪些请求方法，哪些请求源，以及哪些请求头</p><p>Gin 中开启 CORS，是通过 <code>github.com/gin-contrib/cors</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-contrib/cors&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  e := gin.Default()</span><br><span class="line">  e.Use(cors.New(cors.Config&#123;</span><br><span class="line">    AllowOrigins:     []<span class="type">string</span>&#123;<span class="string">&quot;*&quot;</span>&#125;, <span class="comment">// 明确允许访问的域名</span></span><br><span class="line">    AllowMethods:     []<span class="type">string</span>&#123;<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;PATCH&quot;</span>&#125;,    <span class="comment">// 允许的http方法</span></span><br><span class="line">    AllowHeaders:     []<span class="type">string</span>&#123;<span class="string">&quot;Origin&quot;</span>&#125;,          <span class="comment">// 允许客户端在请求中携带的头部字段</span></span><br><span class="line">    ExposeHeaders:    []<span class="type">string</span>&#123;<span class="string">&quot;Content-Length&quot;</span>&#125;,  <span class="comment">// 允许客户端访问的额外响应头（默认只能访问简单头，如 Cache-Control、Content-Language 等）</span></span><br><span class="line">    AllowCredentials: <span class="literal">true</span>,                        <span class="comment">// 允许跨域请求携带凭据</span></span><br><span class="line">    MaxAge: <span class="number">12</span> * time.Hour,                        <span class="comment">// 预检请求（OPTIONS）的缓存时间</span></span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 是一种进程间<strong>通信协议</strong>。它允许程序调用另一台机器（或同一台机器的其他进程）上的 <strong>函数/过程</strong>，实现像在调用本地函数一样，隐藏了网络通信的细节</p><p><strong>核心思想：</strong></p><ul><li>调用者像调用本地函数一样调用远程函数</li><li>底层通过序列化（编码）请求、网络传输、远程反序列化得到请求参数并调用执行，再将结果返回</li></ul><h4 id="用-go-写一个-rpc-服务-demo"><a href="#用-go-写一个-rpc-服务-demo" class="headerlink" title="用 go 写一个 rpc 服务 demo"></a>用 go 写一个 rpc 服务 demo</h4><p>服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net&quot;</span></span><br><span class="line">  <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明远程调用的函数，一般都是放在结构体中</span></span><br><span class="line"><span class="keyword">type</span> Users <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 rpc 服务的请求和响应的结构体   注意，这个结构体在客户端和服务端都需要定义</span></span><br><span class="line"><span class="keyword">type</span> UserReq <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id  <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRes <span class="keyword">struct</span> &#123;</span><br><span class="line">  Success <span class="type">bool</span></span><br><span class="line">  Data []UserReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Users)</span></span> ListUsers (req UserReq, res *UserRes) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 模拟查询用户列表</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;查询用户列表&quot;</span>, req)   <span class="comment">// 查询用户列表 &#123;0 李四 0 &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟数据库数据</span></span><br><span class="line">  userData := []UserReq&#123;</span><br><span class="line">    &#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;张三&quot;</span>, Age: <span class="number">18</span>, Phone: <span class="string">&quot;12345678901&quot;</span>&#125;,</span><br><span class="line">    &#123;Id: <span class="number">2</span>, Name: <span class="string">&quot;李四&quot;</span>, Age: <span class="number">20</span>, Phone: <span class="string">&quot;12345678902&quot;</span>&#125;,</span><br><span class="line">    &#123;Id: <span class="number">3</span>, Name: <span class="string">&quot;王五&quot;</span>, Age: <span class="number">22</span>, Phone: <span class="string">&quot;12345678903&quot;</span>&#125;,</span><br><span class="line">    &#123;Id: <span class="number">4</span>, Name: <span class="string">&quot;李六&quot;</span>, Age: <span class="number">22</span>, Phone: <span class="string">&quot;12345678904&quot;</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 声明 rpc 服务的响应数据</span></span><br><span class="line">  userList := []UserReq&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟查询条件</span></span><br><span class="line">  <span class="keyword">if</span> req.Id &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入了 Id，则只返回该用户</span></span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> userData &#123;</span><br><span class="line">      <span class="keyword">if</span> user.Id == req.Id &#123;</span><br><span class="line">        userList = <span class="built_in">append</span>(userList, user)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入了 Name，则返回所有匹配的用户</span></span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> userData &#123;</span><br><span class="line">      <span class="keyword">if</span> user.Name == req.Name &#123;</span><br><span class="line">        userList = <span class="built_in">append</span>(userList, user)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入查询条件，则返回所有用户</span></span><br><span class="line">    userList = userData</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *res = UserRes&#123;</span><br><span class="line">    Success: <span class="literal">true</span>,</span><br><span class="line">    Data: userList,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 注册 rpc 服务</span></span><br><span class="line">  err := rpc.RegisterName(<span class="string">&quot;Users&quot;</span>, <span class="built_in">new</span>(Users))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;rpc 注册 User 失败&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动 rpc 服务</span></span><br><span class="line">  listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8081&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;rpc 启动失败&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;rpc 服务启动成功，监听端口：8081&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> listener.Close() <span class="comment">// 确保在程序结束时关闭监听器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 等待客户端连接</span></span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;rpc 连接失败&quot;</span>, err)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> rpc.ServeConn(conn) <span class="comment">// 启动一个协程处理连接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserReq <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id  <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRes <span class="keyword">struct</span> &#123;</span><br><span class="line">  Success <span class="type">bool</span></span><br><span class="line">  Data []UserReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 Dial 方法链接 rpc 服务端</span></span><br><span class="line">  conn, err1 := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8081&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;连接 rpc 服务失败&quot;</span>, err1)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close() <span class="comment">// 确保在程序结束时关闭连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> res UserRes</span><br><span class="line">  <span class="comment">// 调用远程方法 ListUsers</span></span><br><span class="line">  conn.Call(<span class="string">&quot;Users.ListUsers&quot;</span>, UserReq&#123;Name: <span class="string">&quot;李四&quot;</span>&#125;, &amp;res)</span><br><span class="line">  err2 := conn.Call(<span class="string">&quot;Users.ListUsers&quot;</span>, UserReq&#123;Name: <span class="string">&quot;李四&quot;</span>&#125;, &amp;res)</span><br><span class="line">  <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;调用 rpc 服务失败&quot;</span>, err2)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;调用 rpc 服务成功&quot;</span>, res)   <span class="comment">// 调用 rpc 服务成功 &#123;true [&#123;2 李四 20 12345678902&#125;]&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gPRC"><a href="#gPRC" class="headerlink" title="gPRC"></a>gPRC</h4><p><strong>gRPC</strong> 是 Google 开源的高性能、通用的 <strong>RPC 框架</strong>，且支持多种语言，用来在分布式系统中进行服务间通信，基于：</p><ul><li><strong>HTTP/2</strong>（高效双向流传输，支持多路复用、头部压缩、流控）</li><li><strong>Protocol Buffers（protobuf）</strong>（高效序列化）</li></ul><p>在 gRPC 中会使用 .proto 这个文件，需要在这个文件中定义接口，然后根据使用的开发语言去生成客户端与服务端使用请求响应包</p>]]></content>
      
      
      <categories>
          
          <category> go 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 容器网络</title>
      <link href="/4209932858/"/>
      <url>/4209932858/</url>
      
        <content type="html"><![CDATA[<h3 id="容器网络基本概述"><a href="#容器网络基本概述" class="headerlink" title="容器网络基本概述"></a>容器网络基本概述</h3><p>​    对于 linux 容器来说它的网络栈实际是被一个 network namespace 所包住的，通过名称空间实现和宿主机的网络栈隔离，其中包括网卡，回环设备，路由表和 iptables 规则</p><p>​    不过也可以使用 <code>-net=host</code> 的参数启动容器，这样这个容器就会直接使用宿主机的网络栈，容器内监听的端口就成了宿主机的实际端口</p><p>​    这种方式虽然提供很好的网络性能，但容易出现端口冲突（<strong>宿主机端口永远是最稀缺的资源</strong>）</p><p>​    因此常用的网络模式是利用网桥作为虚拟交换机来实现多容器间通信，因此如果使用宿主机网络栈，那么就必须提前规划好容器使用端口</p><p>​    对于一个容器来说，它和宿主机之间通过一个虚拟设备 Veth Pair 进行连接，其中一端插在容器内部网络栈的网卡上（eth0），另一端则是在宿主机上（vethxxxx），所以 Veth Pair 可以将宿主机的 host namespace 与容器的 network namespace 连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(.venv) ➜  cdosapi-vm brctl show</span><br><span class="line">bridge name     bridge <span class="built_in">id</span>               STP enabled     interfaces</span><br><span class="line">docker0         8000.02424129ea3d       no              veth75c08a3</span><br></pre></td></tr></table></figure><p>​    在宿主机上，通过 <code>brctl show</code> 命令可以查看到在 docker0 上有一个 veth75c08a3 设备被插入，这个 docker0 网卡在安装 docker 时就会被自动安装</p><p>​    当宿主机上的两个容器要进行通信时，数据包就会流入到 docker0 网桥上，而对于 docker0 对应的两个容器虚拟设备来说，他们将不会拥有数据包的处理权限，可以类比成交换机上的网口</p><p>​    当容器一通信前，会发送 ARP 请求给到网桥，网桥通过 ARP 广播转发到其他的网口上，容器二收到后会将自己 eth0 网卡的 MAC 地址返回，此时容器一的数据包就明确了数据包的方向。数据包发送会同样进入到 docker0 网桥，网桥通过一个 MAC 地址映射表，将容器一数据包的目标 MAC 地址进行匹配，匹配到容器二的网口并将数据包发送过去</p><p><img src="https://static001.geekbang.org/resource/image/e0/66/e0d28e0371f93af619e91a86eda99a66.png?wh=1715*995" alt="img"></p><p>​    同样，宿主机通过 ping 命令访问容器一时，请求一样会进入 docker0 网桥，根据映射规则将请求转发给对应的容器一的网口</p><p><img src="https://static001.geekbang.org/resource/image/9f/01/9fb381d1e49318bb6a67bda3f9db6901.png?wh=1715*995" alt="img"></p><p>​    当容器一想要访问到另一个宿主机时，请求会从网桥来到宿主机所在网络，通过宿主机网络找到指定的宿主机，将数据包发送过去</p><p>​    而如果容器一要访问集群中另一个宿主机上的容器时，这时候就在网桥上进一步衍生出了 overlay network 覆盖网络，可以将其看作是一个集群公用的一个特殊网桥</p><p><img src="https://static001.geekbang.org/resource/image/90/95/90bd630c0723ea8a1fb7ccd738ad1f95.png?wh=1834*994" alt="img"></p><p>​    不过其实不用这个覆盖网络，仅仅靠配置路由表一样可以实现容器访问不同节点的容器</p><h3 id="docker-容器网络-6-种模式"><a href="#docker-容器网络-6-种模式" class="headerlink" title="docker 容器网络 6 种模式"></a>docker 容器网络 6 种模式</h3><p>​    包括 bridge、host、none、overlay、macvlan 和 ipvlan 六种模式</p><h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><p>​    默认的网络模式，利用 docker0 虚拟网桥连接宿主机和容器网络，容器会拥有独立的 ip。适用于单机容器网络，多容器可以用端口映射来提供访问</p><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>​    是直接使用宿主机网络栈，容器不会拥有独立的 ip，端口也是直接使用宿主机的，但是性能接近原生。适用于高性能需求的容器通信方式</p><h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><p>​    不为容器创建任何网络环境，与宿主机网络完全隔离，容器内只会保留一个回环接口，这种模式下完全交由管理者来根据自己的需求来进行容器的网络配置</p><h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><p>​    共享之前创建已创建容器的网络，新创建的容器一样不会有自己的 ip，且端口也是共享的</p><h4 id="macvaln"><a href="#macvaln" class="headerlink" title="macvaln"></a>macvaln</h4><p>​    这种模式允许容器拥有独立的 mac 和 ip 地址，使得容器像是虚机一样直接通过物理网络通信，实现需要容器应用与非容器应用或虚机混合的访问场景，属于 underlay 网络</p><h4 id="ipvlan"><a href="#ipvlan" class="headerlink" title="ipvlan"></a>ipvlan</h4><p>​    和 maclvan 一样支持直接使用物理网络，但使用共享 mac 地址或是直接路由方式，这样可以减少 mac 地址消耗，也是属于 underlay 网络</p><h4 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h4><p>​    允许跨多主机的分布式网络通信，是在物理网络上建立的一层抽象网络覆盖多主机通信，并且内置了 dns 服务实现容器跨主机访问。通过 overlay 组网，容器跨主机通信时，物理网络只承载主机的网络通信，容器通信将在 overlay 的虚拟网络中进行</p><p>​    其逻辑就是对网络数据包进行进一步封装，当容器要访问另一个网络的容器时，数据包传给所在宿主机后，宿主机会对此进行封住将自己的地址作为原地址，将目标容器所在宿主机地址作为目的地址，然后发送过去，目标容器宿主机进行解包，将数据包转发到自己内部网络的容器中</p><p>​    overlay 网络架构是在跨主机，跨数据中心，以及多云(混合云) 场景下广泛使用的</p>]]></content>
      
      
      <categories>
          
          <category> container network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes-搭建</title>
      <link href="/4253636491/"/>
      <url>/4253636491/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes-搭建"><a href="#Kubernetes-搭建" class="headerlink" title="Kubernetes 搭建"></a>Kubernetes 搭建</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>​    虚拟机选择的是 virtualBox，原因是轻量化，以学习和测试为目的的话比较适合。以一个最容易的 k8s 服务集群搭建来说，需要创建至少两个虚拟机，分别代表 master 和 node</p><h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><p>​        virtualBox 中创建好 ubuntu 虚拟机后，默认的网络模式是 NAT 网络地址转换模式，注意这里有一个问题，创建好两台虚拟机后，使用 <code>ifconfig</code> 查看网络信息，会发现两个虚拟机的 ip 是一致的，这会导致 node 想要通过 join 加入到 master 时连接会被拒绝</p><p>​        所以，在 virtualBox 的虚拟机设置中，网卡设置需要从 网络地址转换（NAT）换成 NAT 网络，因为 virtualBox 软件的全局设置中网卡标签栏中是 NAT Networks，并且可以在全局网卡的 NAT 配置栏里看到默认设置 ip 网络段</p><p>​        另外，如果想要通过 ssh 方式让主机终端连接虚拟机，在虚拟机的网卡设置中还需要另外加上一个网卡，模式选择 host-only。同时主机终端通过 ssh 连接前，需要确保虚拟机中 ssh 服务已经开启</p><p>​        还有一点是 virtualBox 默认无法实现主机内容与虚拟机交互实现复制粘贴，可以先尝试在虚拟机设置中的 “常规” 标签栏中点击 “高级” 栏，将 “共享粘贴板” 选择 “双向”，”拖放” 也可以选择 “双向”，如果无法解决可以，且安装的是 Ubuntu 的虚拟机，可以安装 <code>sudo apt-get install virtualbox-guest-x11</code>，再执行 <code>sudo VBoxClient --clipboard</code> 即可</p><h3 id="kubeadm-部署"><a href="#kubeadm-部署" class="headerlink" title="kubeadm 部署"></a>kubeadm 部署</h3><p>​        这里遇到的问题是，在安装当前最新版本 1.26.0 时，服务要么 init 出现问题，要么就是网络插件安装问题，最后是通过安装了 1.23.0 的版本成功运行 k8s 服务</p><p>​        首先，需要进行换源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line">$ curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">$ <span class="built_in">echo</span> deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">$ apt-get update</span><br></pre></td></tr></table></figure><p>​        完成后，安装 kubelet，kubeadm，kubectl，docker，前三个也可以不指定版本，安装最新的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install -y kubelet=1.23.0-00 kubeadm=1.23.0-00 kubectl=1.23.0-00 docker.io</span><br></pre></td></tr></table></figure><p>​        以上操作安装完成后，就可以创建 master 的 yaml 配置文件了，注意前面的两个操作在非 master 虚拟机上同样需要执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">&quot;registry.aliyuncs.com/google_containers&quot;</span></span><br><span class="line"><span class="comment">#controllerManager:</span></span><br><span class="line"><span class="comment">#  extraArgs:</span></span><br><span class="line"><span class="comment">#    horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;  # 这些配置在高版本中已无效</span></span><br><span class="line"><span class="comment">#    horizontal-pod-autoscaler-sync-period: &quot;10s&quot;</span></span><br><span class="line"><span class="comment">#    node-monitor-grace-period: &quot;10s&quot;</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">extraArgs:</span></span><br><span class="line">    <span class="attr">runtime-config:</span> <span class="string">&quot;api/all=true&quot;</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.23.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/data/k8s/etcd</span></span><br></pre></td></tr></table></figure><p>​        完成后，通过下面的命令实现 master 上 k8s 的部署，如果一切正常则会返回下面的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --config kubeadm.yaml</span><br><span class="line">$ Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">    sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">    sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">      https: //kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.0.2.15:6443 --token 6670ua.fq1b9689u9f2g5b2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:08a7e92f174901474be812eef1b4d738c78f63ec4898aa31889530c350e04c00</span><br></pre></td></tr></table></figure><p>​        如果 init 过程中，提示 <code>[ERROR Swap]: running with swap on is not supported. Please disable swap</code>，这说明没有关掉虚拟机的交换内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a            <span class="comment"># 零时关闭所有交换区</span></span><br><span class="line">$ nano /etc/fstab       <span class="comment"># 永久关闭</span></span><br><span class="line"><span class="comment"># /swapfile        none      swap      sw       0       0    # 将 swapfile 这一行注释</span></span><br></pre></td></tr></table></figure><p>​        如果提示 <code>[ERROR CRI]: container runtime is not running: output: time=&quot;2023-03-10T21:02:13+08:00&quot; level=fatal msg=&quot;validate service connection: CRI v1 runtime API is not implemented for endpoint \&quot;unix:///var/run/containerd/containerd.sock\&quot;</code>，这是可能是因为 containerd 进程禁止了 <code>cri</code> 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nano  /etc/containerd/config.toml</span><br><span class="line">disabled_plugins = [<span class="string">&quot;cri&quot;</span>]   <span class="comment"># 如果这个配置中设置了 cri 可以去除</span></span><br></pre></td></tr></table></figure><p>​        除此之外，还可能是因为 kubelet 改为了使用了 systemd 进程，同样可以编辑 <code>nano /etc/containerd/config.toml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[plugins]</span><br><span class="line">  ...</span><br><span class="line">    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]   # 找到这个配置块</span><br><span class="line">      ...</span><br><span class="line">      SystemdCgroup = false   # 将该值改为 true</span><br></pre></td></tr></table></figure><p>​        或者可以更优雅的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s/SystemdCgroup = false/SystemdCgroup = true/&#x27;</span> /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p>​        完成修改后，需要重启进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart containerd</span><br></pre></td></tr></table></figure><p>​        当 init 一切顺利，就需要根据给出的指示做如下操作， 这些内容在 init 成功后会在执行的目录下创建一个 init-succeed.txt 的文件，这个操作如果没弄，使用 kubectl 操作时会遇到超时的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"># 如果使用的普通用户做的以上操作，需要执行下面三个命令</span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"># 如果使用 root 用户做了前面的 init，那么就需要添加一个变量到系统中</span><br><span class="line">export KUBECONFIG=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure><p>​        这个时候就可以在 master 上看 node 的状态了，然后可以看到状态为 NotReady，查看详情后可以知道是因为网络插件没有被部署，同时如果查看 pods 也可以看到例如 coredns，controller-manager 这几个 pod 的状态也是 pending 的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME            STATUS     ROLES                  AGE   VERSION</span><br><span class="line">fw-virtualbox   NotReady   control-plane,master   26h   v1.23.0</span><br><span class="line"></span><br><span class="line">$ kubectl describe node fw-virtualbox   <span class="comment"># 可以用 describe 看节点的详情信息</span></span><br><span class="line">...</span><br><span class="line">Conditions:</span><br><span class="line">...</span><br><span class="line">Ready  False ...  KubeletNotReady runtime network not ready: NetworkReady=<span class="literal">false</span> reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized</span><br></pre></td></tr></table></figure><p>​        kubernetes 提供了多种网络插件，可以在官方文档中找到，这里安装的是 flannel，直接通过下面的命令就可以部署网络插件，也可以使用 <code>wget</code> 或 <code>curl -o</code> 将这个 yaml 下载下来，再通过 <code>kubectl apply -f &lt;yaml文件&gt;</code> 部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -n kube-system -f <span class="string">&quot;https://cloud.weave.works/k8s/net?k8s-version=<span class="subst">$(kubectl version | base64 | tr -d &#x27;\n&#x27;)</span>&quot;</span>      <span class="comment"># 如果超时可以执行下面的命令</span></span><br><span class="line"></span><br><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>​        完成后正常情况下所有的 pod 应该都是 running 的状态，可以通过 <code>kubectl get pods -A</code> 查看，如果要查看指定 namespace 的 pod，使用 <code>kubectl get pods -n kube-system</code> 查看 kube-system 名称下的 pod</p><p>​        如果 <code>get pods</code> 查看到 coredns 的 pod 没有按照预期 running，显示 containerCreating，可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod coredns-6d8c4cb4d-rvdl9 -n kube-system</span><br><span class="line">......open /run/flannel/subnet.env: no such file or directory</span><br></pre></td></tr></table></figure><p>​        这个问题是没有 subnet.env 文件，可以手动创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nano /run/flannel/subnet.env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入以下内容</span></span><br><span class="line">FLANNEL_NETWORK=172.100.0.0/16</span><br><span class="line">FLANNEL_SUBNET=172.100.1.0/24</span><br><span class="line">FLANNEL_MTU=1450</span><br><span class="line">FLANNEL_IPMASQ=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>​        如果 kube-flannel 的状态是 CrashLoopBackoff，通过 describe 可以看到错误信息是 <code>pod cidr not assigned</code>，那么应该是因为 init 时没有给定参数 –pod-network-cidr 指定网段</p><p>​        此时可以在 init 的 yaml 中通过配置形式加上下面的内容，然后可以通过 <code>kubectl reset</code> 还原，在使用 init 去部署 master</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">networking:</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br></pre></td></tr></table></figure><p>​        当 master 部署成功，非 master 节点安装好 kubectl，kubeadmin，kubelet，docker 后就可以通过下面的的命令，加入到集群中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm <span class="built_in">join</span> 10.0.2.15:6443 --token 6670ua.fq1b9689u9f2g5b2 \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:08a7e92f174901474be812eef1b4d738c78f63ec4898aa31889530c350e04c00</span><br></pre></td></tr></table></figure><h3 id="minikube"><a href="#minikube" class="headerlink" title="minikube"></a>minikube</h3><p>​    可以参考 <a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a> 进行安装</p><p>​    这里使用 WSL 的 Ubuntu 进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb</span><br><span class="line">sudo dpkg -i minikube_latest_amd64.deb</span><br><span class="line"></span><br><span class="line">minikube start</span><br></pre></td></tr></table></figure><p>​    如果启动遇到这个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exiting due to DRV_NOT_HEALTHY: Found driver(s) but none were healthy. See above for suggestions how to fix installed drivers.</span><br></pre></td></tr></table></figure><p>​    可以执行启动时给出的建议命令，将用户加入到 docker 组中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span> &amp;&amp; newgrp docker</span><br></pre></td></tr></table></figure><h5 id="使用本地-docker-镜像"><a href="#使用本地-docker-镜像" class="headerlink" title="使用本地 docker 镜像"></a>使用本地 docker 镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">minikube images <span class="built_in">ls</span>    <span class="comment"># 查看 minikube 里的镜像</span></span><br><span class="line">sudo docker images    <span class="comment"># 查看 docker 中的镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接导入本地镜像</span></span><br><span class="line">minikube image load [image:vesion]     <span class="comment"># image:vesion 对应 docker image 中的 repository:tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在 minikube 中构建镜像</span></span><br><span class="line">minikube image build -t image:version .</span><br></pre></td></tr></table></figure><p>​    另外，还需要更改 minikube 默认的镜像拉去策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">test/demo</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Never</span>    <span class="comment"># Never 表示不从远程镜像仓库中拉取</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="网络插件-calico"><a href="#网络插件-calico" class="headerlink" title="网络插件 - calico"></a>网络插件 - calico</h3><p>​    calico 网络插件相比前面安装的 flannel 来说，在性能和灵活性上要更好一些，功能支持更全面，是在生产环境中流行的方案</p><p>​    按照官方文档的安装方法，可能是需要机器能够访问外网进行下载的，除此之外，也开始使用下面地址的 yaml 来启动 calico 的 pop</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.16/manifests/calico.yaml</span><br></pre></td></tr></table></figure><h3 id="污点"><a href="#污点" class="headerlink" title="污点"></a>污点</h3><p>​    默认情况下 Master 节点是不允许运行用户 Pod 的，实现依靠的是 Kubernetes 的 Taint/Toleration 机制，如果一个节点被打上 Taint ，表示这个节点的所有 pod 都不允许在这个节点上运行，但也支持对 pod 声明 Toleration 来接触这个限制 </p><p>​    比如，对 node1 节点加上调度限制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 foo=bar:NoSchedule</span><br></pre></td></tr></table></figure><p>​    NoSchedule 表示不进行调度，当节点中有新 pod 要执行时，就会停止调度，除此之外还有其他值，PreferNoSchedule 表示尽量不调度，NoExecute 表示不调度并对现有 pod 做驱逐</p><p>​    要查看某个节点的上的 Taints，可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe nodes | grep Taints</span><br><span class="line">Taints:             node.kubernetes.io/not-ready:NoSchedule</span><br></pre></td></tr></table></figure><p>​    另外，如果 pod 没有调度起来，通过 <code>kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;</code> 查看执行信息中，发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod didn&#x27;t tolerate   # 也是表明 pod 被限制调度</span><br></pre></td></tr></table></figure><p>​    对此，可以通过命令来取消限制调度的污点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node.kubernetes.io/not-ready-</span><br></pre></td></tr></table></figure><p>​    注意最后的 <code>-</code>，这个命令表示移除所有节点 <code>node.kubernetes.io/not-ready</code> 为键的 Taints</p><h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><p>​    是 k8s 中广泛流行的一个可视化的集群控制和信息，可以直接通过下面命令来部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc6/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>​    完成后，可以用 <code>kubectl get pods -n kubernetes-dashboard</code> 来检查状态查看是否成功部署，启动 dashboard 需要依赖代理，kubernetes-dashboard 默认是只允许节点本机访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>​    命令输入后，会是一个前台进程，然后就可以通过浏览器访问 <code>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/secret?namespace=default</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建账号</span></span><br><span class="line">$ kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard</span><br><span class="line">serviceaccount/dashboard-admin created</span><br><span class="line"><span class="comment"># 注意 1.24 版本更新后，不会自动创建对应 secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">$ kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/dashboard-admin-rb created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 secrets 的 name</span></span><br><span class="line">$ kubectl get secrets -n kubernetes-dashboard | grep dashboard-admin</span><br><span class="line">dashboard-admin-token-fcdtl        kubernetes.io/service-account-token   3      65s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取账号 token</span></span><br><span class="line">$ kubectl describe secrets dashboard-admin-token-fcdtl -n kubernetes-dashboard</span><br><span class="line">Name:         dashboard-admin-token-fcdtl</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: dashboard-admin</span><br><span class="line">              kubernetes.io/service-account.uid: f5cfc9d5-902e-418a-b12f-d74d73e510aa</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IjM2eFk5WjNQZDYtZkFWQ2w5cWhONjBhVm5PYnFJS1cyV3JsS2czOU1XSEkifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4temdmc2siLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiZjVjZmM5ZDUtOTAyZS00MThhLWIxMmYtZDc0ZDczZTUxMGFhIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.H22cykLA6aOIrQaAdIdPMqqGjD4LwKw9DFIkFxJz0EUcU8GLrjon_kzxb-1JM8HY0PFrbchnEnCWZp1sOTPD5JibLh6-BpYAOR6OHYyaQKVAw9BVqKIWe7EkFQvKoah52CCEdOEN4NFdX-8m_rRWxRlJajN_NrzbVW1t1SbuVomRlxcZfDaMNsN4i1FEL08vl0ku171H50BpmC0L-PaGM-B9a2haz91uafCeWv51cPrmuYB6UCbDALZfFTcLSlje2IGuIjv408_EF8u3bfLmfTgwr3UDK6QHD1mCoyPNjwMNIVyUmnCS_4CiRZNSzCqkttJP8LCDWTsVRXKpSxgvCw</span><br></pre></td></tr></table></figure><h2 id="Containerd"><a href="#Containerd" class="headerlink" title="Containerd"></a>Containerd</h2><p><img src="C:%5CUsers%5CDELL%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230624143256377.png" alt="image-20230624143256377"></p>]]></content>
      
      
      <categories>
          
          <category> kuberbetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kuberbetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wsl docker 卸载</title>
      <link href="/undefined/"/>
      <url>/undefined/</url>
      
        <content type="html"><![CDATA[<h3 id="WSL-中卸载-docker-的问题"><a href="#WSL-中卸载-docker-的问题" class="headerlink" title="WSL 中卸载 docker 的问题"></a>WSL 中卸载 docker 的问题</h3><p>​    在使用 <code>apt remove docker-ce</code> 时最后返回了下面的错误信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure><p>​    在了解过后，说是 docker 这个服务因为已经停止或没有使用，所以无法卸载。于是看到解决办法中需要修改 docker-ce.prerm 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([ -x &quot;/etc/init.d/docker&quot; ] || [ -e &quot;/etc/init/docker.conf&quot; ]) &amp;&amp; \</span><br><span class="line">   [ &quot;$1&quot; = remove ]; then invoke-rc.d docker stop || exit $?</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    将其修改如下即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([ -x &quot;/etc/init.d/docker&quot; ] || [ -e &quot;/etc/init/docker.conf&quot; ]) &amp;&amp; \</span><br><span class="line">   [ &quot;$1&quot; = remove ]; then exit $?</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​    然后再次通过 apt 去卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt remove docker-ce docker-ce-cli docker-ce-rootless-extras    </span><br><span class="line">apt purge docker-ce      <span class="comment"># purge 卸载，会同时删除软件的配置信息，remove 卸载则会保留</span></span><br><span class="line">apt purge docker-ce-cli</span><br><span class="line">apt purge containerd.io</span><br><span class="line">apt autoremove package-name   <span class="comment"># autoremove 卸载，会同时将软件包的依赖一起进行卸载       </span></span><br></pre></td></tr></table></figure><p>​    还可以手动进行彻底删除，包括已经下载的镜像文件等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/docker</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/containerd</span><br><span class="line"><span class="built_in">rm</span> -rf /opt/containerd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日积跬步</title>
      <link href="/2970976912/"/>
      <url>/2970976912/</url>
      
        <content type="html"><![CDATA[<h3 id="Flask-蓝图，应用注册问题"><a href="#Flask-蓝图，应用注册问题" class="headerlink" title="Flask 蓝图，应用注册问题"></a>Flask 蓝图，应用注册问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: module &#x27;apps.app01.views.user&#x27; has no attribute &#x27;name&#x27;</span><br></pre></td></tr></table></figure><p>​    按照教程一步步做的，虽然有些改动，但是去启动的时候总是抛出没有 “name” 属性的异常，后来发现模块导入时没有直接导入蓝图注册的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> user,book</span><br><span class="line"></span><br><span class="line">apps = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_app</span>():</span><br><span class="line">    apps.register_blueprint(blueprint=user)</span><br><span class="line"><span class="comment"># views 文件中创建了蓝图对象 user = Blueprint(&quot;user&quot;, __name__)，但是在文件导入时，只是导入 views 下的 user 模块，然后蓝图注册的 blueprint 参数这里写的模块，所以一直抛出没有 name 属性</span></span><br><span class="line">    </span><br><span class="line">    apps.register_blueprint(blueprint=user.user)</span><br><span class="line"><span class="comment"># 只需要将点出 user 这个蓝图对象即可，或者在导入时，直接在 user 模块导入 user 蓝图对象</span></span><br><span class="line">    <span class="keyword">return</span> apps</span><br></pre></td></tr></table></figure><h3 id="hexo-提交，提示-url-错误"><a href="#hexo-提交，提示-url-错误" class="headerlink" title="hexo 提交，提示 url 错误"></a>hexo 提交，提示 url 错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br><span class="line">INFO  Start processing</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">TypeError [ERR_INVALID_URL]: Invalid URL: http://ham&amp;quot;]</span><br></pre></td></tr></table></figure><p>​    提交报错，因为是配置中不小心改到什么地方，后来搜索后发现，可能是文章里某处设置了 <code>http://ham</code> 所以出现的报错。然后确实在一篇文章中写了这样一个错误地址，改了之后就没问题了</p><h3 id="虚拟机-linux-查看-ip，ens33-上不显示-ip-地址"><a href="#虚拟机-linux-查看-ip，ens33-上不显示-ip-地址" class="headerlink" title="虚拟机 linux 查看 ip，ens33 上不显示 ip 地址"></a>虚拟机 linux 查看 ip，ens33 上不显示 ip 地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[fw@mr ~]$ ifconfig </span><br><span class="line">ens33: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 00:0c:29:ca:f6:d8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 238  bytes 14751 (14.4 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>​    <strong>方法：</strong></p><p>​    1）在 windows 的 “服务” 中，找到 VMware 虚拟机的 NAT 和 DHCP 两个服务，并启动他们</p><p>​    2）重启虚拟机，也可以重启 network，输入：<code>systemctl restart network</code></p><h3 id="多对多外键字段约束问题"><a href="#多对多外键字段约束问题" class="headerlink" title="多对多外键字段约束问题"></a>多对多外键字段约束问题</h3><p>​    在 django 进行数据文件迁移时，返回 null has no effect on ManytoManyField 的异常。这里提示了 null 参数的约束是无效的，所以在 manytomany 的外键字段上，将 null 给去掉即可</p><p>​    补充：如果在迁移文件前误将 migrations 中的文件删除，会导致迁移时抛出异常，可以选择将该文件的所有迁移文件全部删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -path &quot;*/migrations/*.py&quot; -not -name &quot;__init__.py&quot; -delete</span><br><span class="line">find . -path &quot;*/migrations/*.pyc&quot; -delete</span><br></pre></td></tr></table></figure><p>​    删除后再重新执行 makemigrations 的命令，生成新的数据迁移文件，在使用 migrate 将文件迁移作用到数据库上</p><p>​    另外，如果 makemigrations 迁移时不生效，可以先检查 app 是否在 installed_app 中注册了</p><h3 id="type-和-isinstance-区别"><a href="#type-和-isinstance-区别" class="headerlink" title="type 和 isinstance 区别"></a>type 和 isinstance 区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit -s <span class="string">&quot;s = &#x27;hello&#x27;&quot;</span> <span class="string">&quot;type(s) is str&quot;</span></span><br><span class="line">python -m timeit -s <span class="string">&quot;s = &#x27;hello&#x27;&quot;</span> <span class="string">&quot;isinstance(s, str)&quot;</span></span><br></pre></td></tr></table></figure><p>​    如果用作类型判断上，type 方法和 isinstance 方法的区别是，后者范围要更大，只要元素是对象的子孙类都返回 True，另外 type 方法在执行效率上其实不及 isinstance 方法</p><h3 id="json-的-strict-参数"><a href="#json-的-strict-参数" class="headerlink" title="json 的 strict 参数"></a>json 的 strict 参数</h3><p>​    一般情况下 json 的数据在 loads 时都是正常的结构数据，但有些接口内部的键值对是通过使用字符串模板，再利用变量和格式化完成</p><p>​    由于是字符串模板通常是提前就写好的，其中可能就会存在一些含有被保留的转义符，例如 \n, \t, \0 等等，如果模板结构比较复杂含有嵌套，且模板中包含了多个双引号和单引号，再使用 loads 方法去读 json 数据可能就会报错，可以在使用 <code>json.loads()</code>方法时，设置 strict 参数为 False 来允许这些含有转义的字符</p><p>​    曾经在项目中接入三方 SDK 时，遇到过类似的问题，当时使用 js 开发去解析 SDK 从容器里返回的数据时报出错误，仔细看了响应后返现返回上是正确的，只是 js 在转为对象时遇到了上述的问题导致出现错误</p><h3 id="celery-的-worker-运行"><a href="#celery-的-worker-运行" class="headerlink" title="celery 的 worker 运行"></a>celery 的 worker 运行</h3><p>​    简单使用 celery 时，在运行异步任务之前都需要启动 celery 的 worker，可以通过命令行 <code>celery -A app worker -l info</code> 来启动 worker<br>​    除此之外还有一种方式，就 <strong>通过实例化的 celery 应用的 worker_main() 方法启动</strong>，这样运行模块文件后，任务名的前缀将会为所在模块文件名，而不是以 <code>__main__</code> 开头 </p><h3 id="celery-查看异步任务-result-的错误"><a href="#celery-查看异步任务-result-的错误" class="headerlink" title="celery 查看异步任务 result 的错误"></a>celery 查看异步任务 result 的错误</h3><p>​    返回信息 <code>AttributeError: DisabledBackend&#39; object has no attribute &#39;_get_task_meta_for&#39;</code></p><p>​    查阅到的资料说，一种是 celery 的 backend 没有设置，这个已配置所以排除，第二个是说模块错误 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.result <span class="keyword">import</span> AsyncResult</span><br><span class="line">res = AsyncResult(<span class="string">&quot;daa1386d-031d-4685-914d-dbbc2ad529b6&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    大致排查下来就是，<strong>要查看异步任务的结果，不能使用 celery 的模块，这个 celery 应该是实际的 celery 实例应用</strong></p><h3 id="python-命令行的-m-参数"><a href="#python-命令行的-m-参数" class="headerlink" title="python 命令行的 -m 参数"></a>python 命令行的 -m 参数</h3><p>​    参数的注释 <code>run library module as a script (terminates option list)</code>，是指将模块当作脚本去运行</p><p>​    <strong>实际上 m 参数更明确的意义是让模块可以进入到 sys 的模块搜索路径中，所以如果系统中存在多个 python 版本，安装目录位置有都不同</strong></p><p>再使用 pip 安装后 python 模块命令，例如 virtualenv 创建虚拟环境时，就会出错或是不能正常创建使用，这时就可以使用 m 参数，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python2 -m virtualenv venv2    <span class="comment"># 这个 python2 是 2.7 版本安装后，自己在系统上设置的环境变量是 python2</span></span><br><span class="line">python3 -m virtualenv venv3    <span class="comment"># 这个 python3 是 3.9 版本安装后，自己在系统上设置的环境变量是 python3</span></span><br><span class="line"><span class="comment"># 另外，如果安装了两个版本，还需要在各级安装目录下，将执行文件对应改为 python2 和 python3</span></span><br></pre></td></tr></table></figure><h3 id="mysql-的字符排序"><a href="#mysql-的字符排序" class="headerlink" title="mysql 的字符排序"></a>mysql 的字符排序</h3><p>​    其中 <strong>utf8mb4_general_ci 排序规则，对字母的大小写不敏感，就是不区分大小写</strong></p><p>​    而 <strong>utf8mb4_bin 排序规则，对字符大小写敏感，也就是区分大小写</strong></p><p>​    不过在项目中通常 ORM 框架里查询可以设置是否要检查大小写</p><h3 id="angular-模板渲染-url-存在-unsafe-前缀"><a href="#angular-模板渲染-url-存在-unsafe-前缀" class="headerlink" title="angular 模板渲染 url 存在 unsafe 前缀"></a>angular 模板渲染 url 存在 unsafe 前缀</h3><p>​    问题案例：<code>unsafe: xxxxx://xxxx.xxx.xxxx/xxx</code></p><p>​    两种解决方式，可以全局层面上，也可以局部模块使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DomSanitizer</span>, <span class="title class_">SafeUrl</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/platform-browser&#x27;</span>;   <span class="comment">// 需要引入的两个模块</span></span><br><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">selector</span>: <span class="string">&#x27;app-root&#x27;</span>,</span><br><span class="line">  <span class="attr">templateUrl</span>: <span class="string">&#x27;./app.component.html&#x27;</span>,</span><br><span class="line">  <span class="attr">styleUrls</span>: [<span class="string">&#x27;./app.component.css&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppComponent</span> &#123;</span><br><span class="line">  title = <span class="string">&#x27;my_app&#x27;</span>;</span><br><span class="line">  empcode = <span class="string">&quot;XXXXX&quot;</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">private sanitizer: DomSanitizer</span>) &#123;&#125; </span><br><span class="line">    </span><br><span class="line">  <span class="title function_">generateSafeImageUrl</span>(<span class="attr">code</span>: string): <span class="title class_">SafeUrl</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">sanitizer</span>.<span class="title function_">bypassSecurityTrustUrl</span>(<span class="string">&#x27;ctripperchat://opendial/&#x27;</span> + code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------</span><br><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;BlurAdmin&#x27;</span>).<span class="title function_">config</span>([<span class="string">&#x27;$compileProvider&#x27;</span>, <span class="string">&#x27;$sceDelegateProvider&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">$compileProvider, $sceDelegateProvider</span>) &#123;</span><br><span class="line">  $sceDelegateProvider.<span class="title function_">resourceUrlWhitelist</span>([<span class="string">&#x27;self&#x27;</span>, ]);</span><br><span class="line">  $compileProvider.<span class="title function_">aHrefSanitizationWhitelist</span>(<span class="regexp">/^\s*(https?|ftp|mailto|ctripperchat):/</span>);  <span class="comment">// 对 a 标签的 href 的路由通过正则匹配加入到白名单</span></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><h3 id="Pycharm-的相同内容选择快捷键"><a href="#Pycharm-的相同内容选择快捷键" class="headerlink" title="Pycharm 的相同内容选择快捷键"></a>Pycharm 的相同内容选择快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一次选择所有的相同内容</span></span><br><span class="line">Ctrl + Shift + Alter + j</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐个选择相同的内容</span></span><br><span class="line">Alter + J</span><br></pre></td></tr></table></figure><h3 id="python-的模块引入"><a href="#python-的模块引入" class="headerlink" title="python 的模块引入"></a>python 的模块引入</h3><p>​    一个记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文中说在 Python 3 规范中，包目录下的__init__.py 并不是必须的，这个我想补充一下，这个__init__.py最好还是有，并且在这个文件里面通过from . import module的形式把该目录下的所有模块文件都写上，如果不这样做，我们只能通过from 包目录 import 模块 的方式来正确使用，而如果直接 import 包目录 的话，虽然import过程不会报错，但是我们在使用该包目录下的模块的时候就会报找不到模块的错误了！</span><br></pre></td></tr></table></figure><h3 id="sql-查询的错误"><a href="#sql-查询的错误" class="headerlink" title="sql 查询的错误"></a>sql 查询的错误</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no column name was specified <span class="keyword">for</span> column <span class="number">4</span> of &#x27;x&#x27;</span><br></pre></td></tr></table></figure><p>​    本身的 sql 语句在修复语法问题后，执行时显示上述错误。原因是这个 sql 语句本身结构是一个子查询，在外层查询中使用 count 函数统计记录数，子查询中含有 4 个查询字段</p><p>​    上面的错误原因就是在子查询的最后一个查询字段上，这个查询字段使用了 date_add 的函数，但是最后没有给 as 来对函数列起名，所以查询时显示了 <code>4 of &#39;x&#39;</code> 的错误位置</p><h3 id="Linux-上-python-项目安装前需要安装基础库"><a href="#Linux-上-python-项目安装前需要安装基础库" class="headerlink" title="Linux 上 python 项目安装前需要安装基础库"></a>Linux 上 python 项目安装前需要安装基础库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install install libsasl2-dev libldap2-dev libssl-dev python2-dev libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>​    python2：<code>libsasl2-dev libldap2-dev python2-dev</code></p><p>​    python3：<code>libsasl3-dev libldap3-dev python3-dev</code></p><p>​    补充：</p><p>​    如果系统中安装了 2 和 3 两个版本，但是 pip 只有 pip2 是有命令的，pip3 却没有，可以使用 <code>sudo apt-get install python-pip3</code></p><h3 id="nginx-启动报错"><a href="#nginx-启动报错" class="headerlink" title="nginx  启动报错"></a>nginx  启动报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">尝试 service nginx start； nginx -s reload 都无法运行 nginx，加了 sudo 也没成功</span><br><span class="line">- nginx -c /etc/nginx/nginx.conf，如果不成功可以加 sudo 再试试</span><br><span class="line"></span><br><span class="line">sudo nginx -t 检查配置是否有错误</span><br><span class="line"></span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)</span><br><span class="line">遇到这个问题，可以把 site-available 的端口改成 1024 以上</span><br></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>​    创建 sites-enabled 的目录后，使用 <code>-s reload</code> 提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] &quot;server&quot; directive is not allowed here &#x27;.....&#x27;</span><br></pre></td></tr></table></figure><p>​    排查后发现，是 nginx.conf 的程序配置文件中，includes 指定 sites-enbaled 的位置写错了，这个 includes 应该在 nginx.conf 的 http 块中配置，而不是在最外层</p><h3 id="nginx-无法监听-80-端口"><a href="#nginx-无法监听-80-端口" class="headerlink" title="nginx 无法监听 80 端口"></a>nginx 无法监听 80 端口</h3><p>​    可以使用 sudo 前缀，用 root 权限去启动 nginx</p><p>​    如果 sudo 下提示 nginx 找不到，可以 sudo 后使用 nginx 执行文件的完整路径</p><h3 id="MySQL-python"><a href="#MySQL-python" class="headerlink" title="MySQL-python"></a>MySQL-python</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">使用 pip 安装时一直出现一下错误：</span><br><span class="line">copying MySQLdb/constants/REFRESH.py -&gt; build/lib.linux-x86_64-2.7/MySQLdb/constants</span><br><span class="line">    copying MySQLdb/constants/CLIENT.py -&gt; build/lib.linux-x86_64-2.7/MySQLdb/constants</span><br><span class="line">    running build_ext</span><br><span class="line">    building &#x27;_mysql&#x27; extension</span><br><span class="line">    creating build/temp.linux-x86_64-2.7</span><br><span class="line">    x86_64-linux-gnu-gcc -fno-strict-aliasing -Wdate-time -D_FORTIFY_SOURCE=2 -g -ffile-prefix-map=/build/python2.7-W40Ff2/python2.7-2.7.18=. -flto=auto -ffat-lto-objects -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Dversion_info=(1,2,5,&#x27;final&#x27;,1) -D__version__=1.2.5 -I/usr/include/mysql -I/usr/include/python2.7 -c _mysql.c -o build/temp.linux-x86_64-2.7/_mysql.o</span><br><span class="line">    _mysql.c:44:10: fatal error: my_config.h: No such file or directory</span><br><span class="line">       44 | #include &quot;my_config.h&quot;</span><br><span class="line">          |          ^~~~~~~~~~~~~</span><br><span class="line">    compilation terminated.</span><br><span class="line">    error: command &#x27;x86_64-linux-gnu-gcc&#x27; failed with exit status 1</span><br><span class="line">    ----------------------------------------</span><br><span class="line">    </span><br><span class="line">安装了各种依赖后，pip 安装依然如此，最后的方案是：</span><br><span class="line">sudo wget https://raw.githubusercontent.com/paulfitz/mysql-connector-c/master/include/my_config.h -O /usr/include/mysql/my_config.h</span><br><span class="line">然后再安装就成功了</span><br></pre></td></tr></table></figure><h3 id="supervisor-启动的应用无法读取环境变量"><a href="#supervisor-启动的应用无法读取环境变量" class="headerlink" title="supervisor  启动的应用无法读取环境变量"></a>supervisor  启动的应用无法读取环境变量</h3><p>​    一种解决方式是，在应用程序的 supervisor 的 ini 配置文件中，直接将程序依赖的环境变量写入到配置文件中</p><h3 id="Win-的-80-端口被占用"><a href="#Win-的-80-端口被占用" class="headerlink" title="Win 的 80 端口被占用"></a>Win 的 80 端口被占用</h3><p>​    可以先去排查 windows 的功能和程序中是否安装了 iis 应用服务，该服务会默认占用 80 端口，可以在功能列表中找到 Internet information services 的复选框，展开后如果 web 管理工具是选中，取消后即可</p><p>​    然后，打开服务列表，找到 W3C 日志记录服务，将其禁用后，80 端口就会释放</p><h3 id="docker-容器"><a href="#docker-容器" class="headerlink" title="docker 容器"></a>docker 容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器的进程 pid</span></span><br><span class="line">$ docker inpsect --format <span class="string">&#x27;&#123;&#123; .State.Pid&#125;&#125;&#x27;</span>  2ddf4fd3435</span><br><span class="line">24488</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过容器 pid 查看同期所有 Namespace 对应文件</span></span><br><span class="line">$ <span class="built_in">ls</span> -l /proc/24488/ns</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="flask-异步视图支持"><a href="#flask-异步视图支持" class="headerlink" title="flask 异步视图支持"></a>flask 异步视图支持</h3><p>​    安装好 flask 后，通过 async 和  await 语法创建了异步视图，但是在运行 flask app 的时候，返回以下异常信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Install Flask with the &#x27;async&#x27; extra in order to use async views.</span><br></pre></td></tr></table></figure><p>​    简单来说就是当前的 flask 无法直接使用异步视图，需要安装 asgiref，<code>pip install asgiref</code></p><h3 id="虚拟机-ubuntu-安装-ssh-的问题"><a href="#虚拟机-ubuntu-安装-ssh-的问题" class="headerlink" title="虚拟机 ubuntu 安装 ssh 的问题"></a>虚拟机 ubuntu 安装 ssh 的问题</h3><p>​    在使用的 virtualbox 中安装了 ubuntu 的虚拟机，想要通过 ssh 让主机访问虚拟机，但是启动 ssh 的时候，一直提示找不到 ssh 的服务，索性就选择重装，但是 <code>apt install openssh-server</code> 报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系</span><br></pre></td></tr></table></figure><p>​    但是通过 <code>remove</code> 卸载后安装，依然不能成功安装，所以需要通过 <code>--purge</code> 参数来彻底卸载，去除原来的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove openssh-server openssh-client --purge -y</span><br><span class="line"></span><br><span class="line">apt-get install openssh-server openssh-client</span><br></pre></td></tr></table></figure><p>​    安装完成后，在使用 <code>service ssh restart</code> 重启 ssh 服务就成功了</p><p>​    补充：注意使用 shh 连接 virtualbox 虚拟机前，前提是主机可以访问到虚拟机，virtualbox 虚拟机默认的网卡设置是 NAT 模式，通过 ifcofig 命令可以看到主机和虚拟机的主网卡并不在一个网络，需要添加一个网卡进行 host-only 模式设置</p><p>​    完成后，还需要在 NAT 模式网卡下设置端口转发，转发规则中主机 IP 可以不填，主机端口设置一个未使用的端口号，如 2222，然后子系统的端口设置虚拟机默认 ssh 的 22 端口就可以了</p><h3 id="django-连接-mysql-容器问题"><a href="#django-连接-mysql-容器问题" class="headerlink" title="django 连接 mysql 容器问题"></a>django 连接 mysql 容器问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.OperationalError: (2059, &quot;Authentication plugin &#x27;caching_sha2_password&#x27; cannot be loaded: /usr/lib/mysql/plugin/caching_sha2_password.so: cannot open shared object file: No such file or directory&quot;)</span><br></pre></td></tr></table></figure><p>​    当时场景是 django 容器连接 mysql 容器，在更改 django 配置文件中数据库的 host 为 mysql 容器的 ip 后，依然显示如上所示的连接问题</p><p>​    <em>问题原因是：mysql 的容器使用的 8 的版本，该版本中 caching_sha2_password 密码处理方式，对于 django 1.10 版本来说并不支持，所以最后重新弄了 mysql 5.6 的版本</em></p><p>补充：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 允许 root 远程登录</span><br><span class="line">$ <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION</span><br><span class="line">$ flush privileges;</span><br></pre></td></tr></table></figure><h3 id="django-ORM-回滚"><a href="#django-ORM-回滚" class="headerlink" title="django ORM 回滚"></a>django ORM 回滚</h3><p>​    django 在进行迁移操作后，会在对应的 migrations 的目录下按照序号逐一生成出迁移文件，每一个序号可以看作是数据库的一个版本，当要进行回滚时，可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate [app-name] 0083</span><br></pre></td></tr></table></figure><p>​    上面的 app-name 即在 django 中创建的应用，后面的序号即要进行回滚的版本号，假设现在 migrations 目录下最后的迁移文件序号是 0084，那么上面的命令就会回滚到 0083 迁移文件对数据库修改的版本上</p><p>​    除此之外，还可以通过 <code>python manage.py showmigrations</code>，来看 django 中所有应用各自所有的迁移文件版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[X] .......</span><br><span class="line">[X] 0082_auto_20230321_1451</span><br><span class="line">[X] 0083_auto_20230608_1706</span><br><span class="line">[ ] 0084_auto_20230612_1958</span><br></pre></td></tr></table></figure><p>如果想要查看某一个应用，可以在 <code>showmigrations</code> 后加上具体的 app-name</p><h3 id="ORM-update-方法"><a href="#ORM-update-方法" class="headerlink" title="ORM update 方法"></a>ORM update 方法</h3><p>​    注意在 django 中更新数据可以有两种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj = Disk.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="string">&#x27;d-xxxxxxxxx&#x27;</span>).update(size=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">obj = Disk.objects.get(<span class="built_in">id</span>=<span class="string">&#x27;d-xxxxxxxxx&#x27;</span>)</span><br><span class="line">obj.size = <span class="number">40</span></span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure><p>​    这两种方式都可以正常更新数据的 size 字段，但是不同支持在于，第一种通过 <strong>update 方法直接更新，更适用于批量的数据更新，并且如果 Disk 中有更新时间的字段，且设置了 auto_now=True，那么使用 update 更新记录时，将不会自动更新 auto_now 的记录更新时间，需要手动在 update 方法中对字段赋值 datetime.datetime.now()</strong></p><p>​    第二种方式不同于第一种的是，通过直接对查询对象的属性字段进行赋值，使用 save 方法来更新时，ORM 会自动去更新 auto_now 的字段</p><h3 id="django-group-by-查询"><a href="#django-group-by-查询" class="headerlink" title="django group by 查询"></a>django group by 查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cdosapi.models <span class="keyword">import</span> Vm</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"></span><br><span class="line">Vm.objects.<span class="built_in">filter</span>(zone__region_code=<span class="string">&quot;SFO-ALI&quot;</span>).values(<span class="string">&quot;app_env&quot;</span>).annotate(count=Count(<span class="string">&quot;app_env&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="通过-curl-获取当前机器的公网-ip"><a href="#通过-curl-获取当前机器的公网-ip" class="headerlink" title="通过 curl 获取当前机器的公网 ip"></a>通过 curl 获取当前机器的公网 ip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ifconfig.me</span><br></pre></td></tr></table></figure><h3 id="sqlite-数据文件通过-DBeaver-连接显示-database-is-locked"><a href="#sqlite-数据文件通过-DBeaver-连接显示-database-is-locked" class="headerlink" title="sqlite 数据文件通过 DBeaver 连接显示 database is locked"></a>sqlite 数据文件通过 DBeaver 连接显示 database is locked</h3><p>​    最后发现是因为 DBeaver 中使用的 sqlite 的文件是在 WSL 这个 Linux 子系统里的，把这个 sqlite 的 db 文件复制到 windows 的盘下，就可以正常打开了</p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在路上 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于MySQL的一些问题</title>
      <link href="/1772758044/"/>
      <url>/1772758044/</url>
      
        <content type="html"><![CDATA[<h3 id="全索引扫描的情况"><a href="#全索引扫描的情况" class="headerlink" title="全索引扫描的情况"></a>全索引扫描的情况</h3><h4 id="对条件字段使用函数操作"><a href="#对条件字段使用函数操作" class="headerlink" title="对条件字段使用函数操作"></a>对条件字段使用函数操作</h4><p>​    在 mysql 中定义了很多函数可供使用，例如 <code>month(), year(), convert(), format()</code> 等等，但在查询时，如果对字段使用了函数操作，那么将无法使用索引来加速</p><p>​    例如现有一张交易日志表，存储了 2016 - 2018 年每天的数据记录，约 10 万条记录，具体表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tradelog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `operator` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `t_modified` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>​    现在查询条件是根据 t_modified 字段查询所有月份是 7 的总记录数，那么这个 sql 可以是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span></span><br></pre></td></tr></table></figure><p>​    但这个查询语句可能并不如期那样快速返回，其原因就是因为当对 t_modified 含有索引的字段使用函数操作后，优化器需要进行索引选择，优化器可以选择使用主键索引，也可以使用普通索引，对比后 t_modified 的索引更小依然会选择 t_modified 索引</p><p>​    使用 explain 分析查询语句：</p><p><img src="https://static001.geekbang.org/resource/image/27/55/27c2f5ff3549b18ba37a28f4919f3655.png?wh=1637*143" alt="img"></p><p>​    use index 表示查询使用到了索引，从 rows 的返回可以看出这个查询语句是扫描的全表的，所以可见查询字段使用函数后就变成来全表遍历，而不是利用索引树的搜索来提升效率</p><p>​    其实可以假设 t_modified 的索引树是下面这样的，如果查询的 where 是具体的时间，例如 <code>where t_modified=&#39;2018-7-1&#39;</code>，那么根据索引树的搜索可以快速定位到数据。但是使用了 <code>where month(t_modified)=7</code> 后，对于索引树的第一层来说，就不满足关键字值的判断，所以就变成了对整个索引树使用遍历方式去搜索</p><p><img src="https://static001.geekbang.org/resource/image/3e/86/3e30d9a5e67f711f5af2e2599e800286.png?wh=1142*856" alt="img"></p><p>​    由此可见，在 MySQL 中如果对查询条件做函数的操作，是有可能造成优化器无法按照预期利用索引树提升查询，而导致通过遍历索引的方式使得查询返回时间变长</p><p>​    所以，上面的那个查询可以换一种方式去查询，可以手动指定出范围，因为数据库中只有 2016 到 2018 的数据，所以 sql 可以如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2016-7-1&#x27;</span> <span class="keyword">and</span> t_modified <span class="operator">&lt;</span> <span class="string">&#x27;2016-8-1&#x27;</span>) <span class="keyword">or</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2017-7-1&#x27;</span> <span class="keyword">and</span> t_modified <span class="operator">&lt;</span> <span class="string">&#x27;2017-8-1&#x27;</span>) <span class="keyword">or</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (t_modified <span class="operator">&gt;=</span> <span class="string">&#x27;2018-7-1&#x27;</span> <span class="keyword">and</span> t_modified <span class="operator">&lt;</span> <span class="string">&#x27;2018-8-1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​    除此之外，还有一个情况也同样可能会进行全索引的扫描，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>​    该查询中 <code>where id + 1 = 10000</code> 的操作，会去使用到主键索引，但优化器会去遍历这个 id 索引，一次次计算判断，而不是直接定位到 9999 的 id，所以这个条件语句需要改成 <code>where id = 10000 - 1</code></p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>​    同样利用上面例子的表，这次查询一个指定的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid <span class="operator">=</span> <span class="number">110100</span></span><br></pre></td></tr></table></figure><p>​    按理来说，这个查询利用了 tradeid 索引去查应该会很快，但是 explain 的返回却还是显示查询使用的是全表扫描</p><p>​    这里唯一不同的地方就是 <strong>tradeid 字段使用的 varchar 类型，而对于 MySQL 来说，字符串和数字的判断，会按照规则将 字符串 转为 数字 类型，这一步是 MySQL 自己做的隐式类型转换。另外，如果字符串无法通过类型转化得到数字，则会按照 0 来处理</strong></p><p>​    所以，上面那个查询，对于 MySQL 来说实际上是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="built_in">CAST</span>(tradeid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110100</span></span><br></pre></td></tr></table></figure><p>​    从这里可以看出，这里依然使用函数对索引字段做操作。换一个情况，如果是 <code>where id = &quot;110100&quot;</code>，这个查询条件则不会全表扫描而是走了索引，这里 id 是数字类型，MySQL 依然会隐式类型转化将字符串变成数字，但是这个转换不是在 id 字段上，而是在查询条件的值上，所以这个查询会走 id 的索引</p><h4 id="隐式编码转化"><a href="#隐式编码转化" class="headerlink" title="隐式编码转化"></a>隐式编码转化</h4><p>​    沿用上面的表，这里再添加一个交易操作的详情表 trade_detail，表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>​    可见两个表的字符集是不同的，tradelog 表是 utf8mb4，trade_detail 表是 utf8，现在执行一个关联查询操作，sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> l.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​    这个查询语句通过 explain 分析后，首先得出的是优化器在 tradelog 表上使用了索引定位到了 id 为 2 的记录，但是 trade_detail 上却没有使用 tradeid 的索引，而是全表扫描主键索引，通过遍历一个个判断是否 tradeid 相等</p><p>​    这个原因就是因为 uft8mb4 是 uft8 的超集，MySQL 查询会隐式转化，将 uft8 转为 utf8md4，那么和隐式类型转化一样，同样是索引字段使用了函数操作，所以导致了查询慢</p><p>​    再换一个例子去查询，只是查询条件修改一下，将 <code>l.id</code> 改为 <code>d.id</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l, trade_detail d <span class="keyword">where</span> d.tradeid<span class="operator">=</span>l.tradeid <span class="keyword">and</span> d.id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​    那么这个查询的 explain 和上面就不同了，首先是通过索引找到 trade_detail 表中 id 是 2 的记录，而这次 tradelog 表却使用了 tradeid 索引找到了记录，但这不代表 MySQL 没有转换编码</p><p>​    这两个查询区别在于优化器在查询的先后有区别，第一个查询中 <code>where d.tradeid=l.tradeid and l.id=2</code>，tradelog 是驱动表，trade_detail 是被驱动表，而第二个查询 <code>where d.tradeid=l.tradeid and d.id=2</code> 中 trade_detail 是驱动表，tradelog 是被驱动表，对于被驱动表来说，第一个相当于是在 trade_detail 中将 tradeid 字段的编码类型转为 utf8mb4 然后和 tradelog 的 tradeid 判断，而第二个相当于是在 tradelog 中对 tradeid 字段的值，也就是从 trade_detail 里得到的 tradeid 转为 utf8mb4</p><p>​    由此可见，编码的隐式类型转化，除了字符集编码的不同是条件之一，因外一个关键是被驱动表里是否是对索引字段使用了函数操作</p><h4 id="超出长度的查询"><a href="#超出长度的查询" class="headerlink" title="超出长度的查询"></a>超出长度的查询</h4><p>​    如果一个表里，字符类型的 varchar 设置了 10 的长度，但是在查询时，这个字段的查询条件的值是超过 10 的长度。那么对于 MySQL 来说会将查询条件的值截断，取出前 10 个字符，然后按照这个字段的索引还是查询</p><p>​    这样一来，通过索引会得到很多记录，而如果查询字段是 <code>select *</code>，那么这些索引得到的记录还需要回表进行一次遍历判断，判断条件的值是否与索引得到记录中字段的值一致，这同样导致了查询慢</p><h3 id="单条记录查询慢的情况"><a href="#单条记录查询慢的情况" class="headerlink" title="单条记录查询慢的情况"></a>单条记录查询慢的情况</h3><p>​    针对这种情况，首先可以使用 <code>show processlist</code> 去查询当前语句的状态</p><h4 id="等待-MDL-锁"><a href="#等待-MDL-锁" class="headerlink" title="等待 MDL 锁"></a>等待 MDL 锁</h4><p>​    如果 <code>show processlist</code> 得到下面的结果</p><p><img src="https://static001.geekbang.org/resource/image/50/28/5008d7e9e22be88a9c80916df4f4b328.png?wh=1312*213" alt="img"></p><p>​    这里状态表示，要么是有线程正在对 t 请求，要么就是 t 表上有 MDL 写锁，所以当前的查询被阻塞了。写锁这种情况在 5.7 以前会出现，因为后面有 online DDL 机制，会将 MDL 写锁降级，避免阻塞发生</p><p>​    如果想要结束掉，可以使用 sys.schema_table_lock_waits 得到造成阻塞的线程 id，再 kill 掉即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> blocking_pid <span class="keyword">from</span> sys.schema_table_lock_waits</span><br></pre></td></tr></table></figure><h4 id="等待-flush"><a href="#等待-flush" class="headerlink" title="等待 flush"></a>等待 flush</h4><p>​    如果使用 <code>select processlist</code> 的查询结果中如果有显示 <code>waiting for table flush</code>，这就是表示有线程在做 <code>flush tables</code> 的操作，或者是一个 <code>flush tables</code> 操作被其他线程阻塞了</p><p>​    MySQL 的 <code>flush</code> 操作会将打开的表关闭，并将查询缓存清空，并将数据刷入到磁盘中</p><p>​    MySQL 一般会有两种 <code>flush</code> 操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock    # 只作用在 t 表</span><br><span class="line">flush tables <span class="keyword">with</span> read lock      # 作用在所有打开的表</span><br></pre></td></tr></table></figure><p>​    其中 with read lock 表示加上了全局读锁，来锁定库里所有的表，值得一提的是如果某个表身上有锁，那么使用 flush 操作就会被阻塞</p><h4 id="等待行锁"><a href="#等待行锁" class="headerlink" title="等待行锁"></a>等待行锁</h4><p>​    如果一个记录在并发过程中，先是被更新了，那么自然会加上写锁，在未提交前，如果一个线程去查询想得到最新的数据，那么 <strong>在查询语句的最后需要加上 <code>lock in share mode</code>，这样才能读取已提交的最新版本数据</strong></p><p>​    但是此时就会因为读写锁互斥的问题造成查询的线程被阻塞，使得可能长时间无法返回</p><p>​    如果要结束到阻塞，可以使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span><span class="string">&#x27;`test`.`t`&#x27;</span>\G</span><br></pre></td></tr></table></figure><p>​    会查询得到以下结果：</p><p><img src="https://static001.geekbang.org/resource/image/d8/18/d8603aeb4eaad3326699c13c46379118.png?wh=864*669" alt="img"></p><p>​    补充一点，这里有两个 kill 命令，其中 <code>kill query 4</code>，并不能结束阻塞，只是将当前这个 <code>select</code> 的查询线程关闭，而实际上造成阻塞的是 update 语句加上的行锁，所以需要使用 <code>kill 4</code> 来结束到当前会话，并会自动回滚会话连接里正在执行的线程，也就会将锁释放</p><h4 id="查询慢"><a href="#查询慢" class="headerlink" title="查询慢"></a>查询慢</h4><p>​    查询慢，最直观的例子就是查询的条件字段，是没有索引的，这样的查询会随着数据量的增多，导致查询时间会成正比增加</p><p>​    除此之外，如果查询的字段，本身经过了非常多的修改，且使用了 <code>lock in share mode</code> 去读最新版本数据，那么很有可能也会查询很慢</p><p>​    按照默认可重复读的隔离级别，查询默认是按照一致性视图进行读取，但是如果在此期间，一个线程对数值做大量更新操作，例如下面情况</p><p><img src="https://static001.geekbang.org/resource/image/84/ff/84667a3449dc846e393142600ee7a2ff.png?wh=936*322" alt="img"></p><p>​    会话B 做了 100 万次更新，那么对于字段 c 来说，undo log 的重做日志里就记录了 100 万个回滚操作，对于第一个查询 <code>select * from where id=1</code> 来说，就需要根据 undo log 一直回退计算</p><p><img src="https://static001.geekbang.org/resource/image/46/8c/46bb9f5e27854678bfcaeaf0c3b8a98c.png?wh=1142*856" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-消息队列</title>
      <link href="/311488900/"/>
      <url>/311488900/</url>
      
        <content type="html"><![CDATA[<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>​    消息队列是生产消费者模型中最关键的一个部分，它需要接受来自生产者发送的消息，并进行短暂的存储，然后对于消息的消费者可以异步来获取消息</p><p>​    由此，<strong>消息队列应该需要满足以下三个需求</strong>：</p><p>​    <strong>首先，对于消息的存储应该是有序的</strong>，应该是先进先出，如果消息不是有序存储，消费者在异步获取时，假如有两个消息都是对库存修改，但是修改值不同，如果直接存储更新后的结果，那么在获取时，在后一个消息被先处理的情况下，库存值显然是错误的。对此，可以换一种方式，将扣除的值作为消息存储，消费者无论先处理哪个，最后计算的库存值都是正确的，但是这有一个前提，就是在中间没有读取库存的情况下，如果中间操作时有读取操作，计算的数值还是错误的</p><p>​    <strong>其次，消息队列要避免消息的重复消费</strong>，如果一个消息被重复消费进行处理，显然是错误的，一种避免重复消费的方法，是通过给消息设置一个唯一的 id 作为标识</p><p>​    <strong>最后，消息队列要保证消息可靠性</strong>，因为消费者在处理时可能出现错误而退出，应该要允许消费者重新获取该消息再次处理，否者造成消息丢失，一样会对业务造成错误影响</p><h3 id="redis-的队列实现"><a href="#redis-的队列实现" class="headerlink" title="redis 的队列实现"></a>redis 的队列实现</h3><p>​    redis 本身的数据结构 list，就是一个满足了先进先出的双端队列，允许通过 <code>lpush</code> 将消息依次写入到队列，通过 <code>rpop</code> 来依次获取消息</p><p><img src="https://static001.geekbang.org/resource/image/b0/7c/b0959216cbce7ac383ce206b8884777c.jpg?wh=3000*2250" alt="img"></p><p>​    虽然 redis 的 list 满足了消息队列的有序存取，但是 list 的队列需要消费者通过一个死循环来一直尝试获取，对于消费者的程序来说，如果 <code>rpop</code> 的结果是空值，就要继续循环直到得到结果，而如果消息队列中长时间没有消息，这对消费者的程序来说会一直消耗 CPU 资源</p><p>​    所以，redis 支持了 <code>brpop</code> 命令，允许在获取时，如果没有读到消息，则自动阻塞，直到有消息进入队列，再开始读取</p><p>​    虽然 list 是可以作为有序队列存储，但是要避免重复消费，还是要在应用层面上做处理，每次写入消息队列之前都需要对消息添加一个唯一的 id，例如 <code>lpush my_mq 12345601:stock:5</code> 可以表示消息 id 为 12345601 记录的库存是 5</p><p>​    至此 redis 的 list 就满足消息队列的前两个需求，接着就是要保证消息的可靠性，按照正常的 <code>rpop</code> 来说，如果消费者者处理出现错误，而这个消息已经被移出了消息队列，消费者后续的操作可能就出现了中断，导致后续一系列的消息处理都是错误的，所以，redis 有提供了 <code>brpoplpush source destination</code> ，对应着有 <code>rpoplush</code>，这个命令允许将移出的消息从 source 加入到 destination 中，这样一来相当于是把要消费的消息做了一个备份，如果消费者出现问题退出，恢复后可以从 destination 中再次获取消息来处理</p><p><img src="https://static001.geekbang.org/resource/image/50/3d/5045395da08317b546aab7eb698d013d.jpg?wh=3000*2135" alt="img"></p><p>​    上面的图和模式，都是一对一的生产消费者模式。这引出了另一个问题，如果生产者发送消息速度过快，消费者处理消息的速度比较慢，就很容易导致 redis 中积累越来越多的消息，内存被快速占用。所以，消费者可以采用多个，利用消费者集群来处理消息</p><h4 id="streams"><a href="#streams" class="headerlink" title="streams"></a>streams</h4><p>​    <strong>streams 是 redis 5.0 版本后加入新的数据类型，是专门针对消息队列而实现的</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2020/09/en-us_image_0167982791.png" alt="img"></p><ul><li><strong>Consumer Group</strong> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)</li><li><strong>last_delivered_id</strong> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动</li><li><strong>pending_ids</strong> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）</li></ul><p>​    与 list 类型最大的不同，就是 streams 可以支持消费组的形式来读取消息队列，除此之外，streams 可以自动生成唯一 id</p><p>​    <img src="https://static001.geekbang.org/resource/image/b2/14/b2d6581e43f573da6218e790bb8c6814.jpg?wh=2922*943" alt="img"></p><h4 id="消息队列的命令"><a href="#消息队列的命令" class="headerlink" title="消息队列的命令"></a>消息队列的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入消息队列 xadd</span></span><br><span class="line">$ 127.0.0.1:6379&gt; XADD mystream * name hamilton age 24</span><br><span class="line">$ <span class="string">&quot;1669044617062-0&quot;</span></span><br><span class="line"><span class="comment"># key 表示队列名称</span></span><br><span class="line"><span class="comment"># * 表示自动生成唯一 id</span></span><br><span class="line"><span class="comment"># xadd 可以一次添加多个 field 和 value</span></span><br><span class="line"><span class="comment"># 1669044617062-0 是最后消息生成的唯一 id，1669044617062 是写入消息的毫秒的时间戳，0 是消息在当前这个时间戳上属于第一个消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取消息队列 xrange，会自动过滤已经删除的消息</span></span><br><span class="line">$ 127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">$ 1) 1) <span class="string">&quot;1669044617062-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;hamilton&quot;</span></span><br><span class="line">      3) <span class="string">&quot;age&quot;</span></span><br><span class="line">      4) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="comment"># - 表示最小 id；+ 表示最大 id；也可以自己指定最小和最大 id 的范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看队列长度</span></span><br><span class="line">$ xlen mystream</span><br><span class="line">$ (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息 xread（可以阻塞或非阻塞读取）</span></span><br><span class="line">$ XREAD count 1 block 10 streams mystream 1669044617062-0</span><br><span class="line">$ 1) 1) <span class="string">&quot;mystream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1669045548642-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;hamilton&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="comment"># count 1 表示只读取 1 条消息，不使用该参数默认会读取 id 下所有消息</span></span><br><span class="line"><span class="comment"># block 表示以阻塞方式读取，10 表示阻塞读取超时时间为 10 毫秒，如果不是使用 block 则是非阻塞读取</span></span><br><span class="line"><span class="comment"># 如果最后不指定 id 1669044617062-0，可以使用 $ 来获取队列中最新的消息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="消费者的命令"><a href="#消费者的命令" class="headerlink" title="消费者的命令"></a>消费者的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建消费组 xgroup create</span></span><br><span class="line">$ XGROUP create mystream mygroup 0</span><br><span class="line">$ OK</span><br><span class="line"><span class="comment"># mystream，表示消费组所要获取消息的消息队列</span></span><br><span class="line"><span class="comment"># mygroup 0，mygroup 是组名，0 是 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息 xreadgroup（可以阻塞或非阻塞读取）</span></span><br><span class="line">$ XREADGROUP block 100 group mygroup consumer streams mystream &gt;</span><br><span class="line">$ 1) 1) <span class="string">&quot;mystream&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1669044617062-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;hamilton&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;24&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;1669045548642-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;hamilton&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;24&quot;</span></span><br><span class="line">      3) 1) <span class="string">&quot;1669045576739-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;hamilton&quot;</span></span><br><span class="line">            3) <span class="string">&quot;age&quot;</span></span><br><span class="line">            4) <span class="string">&quot;24&quot;</span></span><br><span class="line"><span class="comment"># group mygroup，group 指定消费组为 group</span></span><br><span class="line"><span class="comment"># streams mystream，streams 指定消息获取的队列为 mystream</span></span><br><span class="line"><span class="comment"># &gt; 表示从第一条没被读取的消息开始读取</span></span><br><span class="line"></span><br><span class="line">$ XREADGROUP count 1 block 100 group mygroup consumer streams mystream &gt;</span><br><span class="line">$ (nil)</span><br><span class="line"><span class="comment"># 这里使用 count 参数继续从 mystream 中读取 1 条消息，返回是空，所以消息一旦被读取，会被 redis 加入到内部的 pending list 中存储，消费者成功处理后会使用 xack 命令通知队列处理完成，完成后消息才会被移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已读取的消息 xpending</span></span><br><span class="line">$ XPENDING mystream mygroup</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1669044617062-0&quot;</span>      <span class="comment"># 已读消息的最小 id</span></span><br><span class="line">3) <span class="string">&quot;1669045576739-0&quot;</span>      <span class="comment"># 已读消息的最大 id</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer&quot;</span></span><br><span class="line">      2) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="comment"># mystream 是消息队列，mygroup 是消费组</span></span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> redis-消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-整理</title>
      <link href="/306062435/"/>
      <url>/306062435/</url>
      
        <content type="html"><![CDATA[<h3 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h3><p>​    nodejs 整体上设计架构和 chrome 浏览器很相似，chrome 强大的性能源自于 V8 引擎，nodejs 也同样继承了这一点，摆脱了 chrome 中 UI 部分的组件，例如 webkit，显卡，html 等，这使得 js 可以脱离浏览器来执行，从而实现了 nodejs 可以开发后端程序</p><p><img src="https://wei-foun.github.io/img/chrome%E5%92%8Cnodejs.jpg" alt="img"></p><p>​    nodejs 保留了前端中 js 的那些 api，没有更改任何语言的特性，<strong>nodejs 是基于 单线程 的 异步IO 架构</strong></p><p>​    首先，单线程带来的优势是无需时刻注意状态同步问题，避免了死锁产生，减少了线程切换带来的性能开销。但有利就有弊，单线程的模式无法利用到多核 CPU，程序可能因为一个小错误就直接结束退出，另一个问题就是如果涉及到大量 CPU 密集操作可能会影响 异步IO 的调用</p><p>​    为了解决可能的 CPU 密集操作对 nodejs 中异步IO 造成性能影响，nodejs 可以使用  child_process 利用子进程来将计算性的任务分解，通过进程的事件消息来传输结果，这样一来可以有效提升健壮性</p><p>​    然后，是异步IO，在 node 中非常多的操作支持异步处理，比如 fs 模块可以异步读取文件，网络请求和像前端一下异步执行，这种方式可以很大程度上发挥单线程的性能。并且 nodejs 沿用前端中 js 独特的 事件 和 回调函数，基于事件的编程方式可以实现轻量化，低耦合的优势，通过异步执行，回调函数可以随时对结果做处理。但异步编程的方式相比同步代码来说，在复杂性和可读性上会增加一些难度</p><h3 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h3><p>​    nodejs 使用的是 CommonJs 的规范，这其中涵盖了模块，I/O 流，文件系统，套接字等等，并且 node 对通过 packages 规范实现了 NPM 的模块管理系统，使得应用开发的依赖管理更加容易，且 commonjs 的模块引入机制天然的避免了变量冲突污染的问题</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    commonjs 对模块的定义包含三部分，模块引用、模块定义、模块标识</p><p>​    在 node 中引入模块，使用 require 方法，其中可以接收模块的标识，也可以使用路径字符串引入自己定义的文件模块</p><p>​    对于模块，<strong>node 中一个文件就可以作为一个模块，在模块中存在一个 module 对象，这个对象包含了一个 exports 的属性，对于引入来说，通常引入的是 exports 这个对象中的方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib1.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>, i = <span class="number">0</span></span><br><span class="line">    args = <span class="variable language_">arguments</span></span><br><span class="line">    l = args.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// lib2.js</span></span><br><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./lib1&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>))    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>​    <img src="https://wei-foun.github.io/img/%E6%A8%A1%E5%9D%97%E6%A0%87%E8%AF%86.jpg" alt="img"></p><p>​    node 将模块实际分为了两类，提供基础底层操作 api 的核心模块， 以及用户编写的文件模块。在模块引入上，<strong>node 会将引入过的模块进行缓存，通过优先从缓存加载减少二次引入时的 IO 开销</strong>，需要注意的是 node 缓存的并不是实际的 js 文件，而是对编译和执行后的对象进行缓存</p><p>​    模块的查找路径是一个数组，<strong>可以通过 <code>module.paths</code> 查看当前模块的所有查找路径，node 的模块查找策略是从当前文件所在目录的 node_modules 目录开始查找，没有找到就是一层层向上级目录中存在的 node_module 进行查找</strong></p><p>​    文件模块引入时，commonjs 允许可以忽略文件模块标识的后缀，因为 node 在查找时会按照 js，json，node 的后缀依次补足尝试查找，在这个过程中 node 会通过 fs 模块同步调用查找，所以会引起可能的性能问题</p><p>​    另外，在引入自定义模块或是通过多级模块目录方式引入时，在通过后缀补充查找后没有找到目标文件，node 会将目录当做包来处理。并且 node 会通过 packages.json 中的 main 作为包中模块引入的入口，默认会去寻找 index.js，如果没有则依然是一层层向上搜索 node_modules 路径，全部搜索没有目标文件则会抛出异常</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>​    包是在模块概念上进一步的组织，包的结构目录中包含 package.json 的文件，bin 目录（存放可执行二进制文件），lib 目录（存放 JavaScript 代码），doc 目录（存放相关文档）以及 test 目录（存放单元测试代码），package.json 是包描述文件，这个 json 对象中包含一系列描述关键字</p><p>​    name 字段，表示包的名字，由小写字母和数组组成且必须唯一，为了避免 NPM 中公开项目有重名冲突</p><p>​    description 字段，是包的描述信息内容</p><p>​    version 字段，是包的版本号</p><p>​    keywords 字段，是包的关键字，用来方便 NPM 中搜索</p><p>​    maintainers 字段，是包的维护者列表，每一个维护者信息对象包含 name，email 和 web 三个字段</p><p>​    licenses 字段，是指包所使用的许可证列表</p><p>​    dependencies 字段，是包所依赖的相关包的列表。另一个相关的 devDependencies 字段是指开发环境下包的依赖列表，如果一个包只是在开发环境中使用，使用 npm 安装时需要使用 <code>-D</code> 或 <code>--save-dev</code> 参数</p><p>​    scripts 字段，是脚本操作对象，主要用来进行 安装，测试，运行 等</p><p>​    说回到 NPM，它的出现让 node 有了和三方模块之间很好的开发生态系统，提供了高效可靠的工具，避免了重复造轮子。通过 <code>npm  install</code> 就可以去安装一个开源模块，安装完成后，在 package.json 的 dependencies 中会自动加上这个包的描述名</p><p>​    补充：<code>npm install</code> 中有个 <code>-g</code> 的参数，通常解释为全局安装，但实际并不是通过 <code>-g</code> 安装后在任何位置使用 require 都可以引入安装的包，<code>-g</code> 安装实际上是指将包安装后添加一个全局可用的执行命令，可以在 package.json 中的 bin 字段去配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;express&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./bin/express&quot;</span>    <span class="comment">// 配置 express 执行命令，实际指向的是安装 bin 目录下的执行文件</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump-详解</title>
      <link href="/2205743281/"/>
      <url>/2205743281/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    tcpdump 是 unix 系统下的一个数据包嗅探工具，也就抓包工具，不同于与 fiddler 或 wireshark 等工具，这类工具是具有可视化的操作界面的，tcpdump 则是一个命令行操作和显示的抓包工具</p><p>​    本身的原理是在系统中注册一种虚拟的底层网络协议来获取对网络设备中数据报的处理权。当网卡接收到一个网络报文后，会在系统中遍历注册的网络协议来对报文进行处理，当抓包模块将自己模拟成一个网络协议后，这个伪装协议会得到数据处理的机会，然后将完整的数据报文复制，并发送给抓包接收模块，由此实现了对网络设备中报文的窥探</p><p>​    如果系统中没有命令，可以直接 <code>apt-get install tcpdump</code> 安装，在此之前需要执行 <code>apt-get upgrade</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>​    tcpdump 的命令行大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tcpdump [option] [proto] [dir] [type]</span></span><br></pre></td></tr></table></figure><p>​    option 是各种参数设置，proto 是协议过滤，dir 是可以过滤出数据流向，可以是源或目标，type 是指定关键字过滤，可是设置端口 port；主机地址 host 等</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>​    tcpdump 中常用的参数：</p><p>​    -i 参数，表示指定网卡设备，后面需要加上指定的网卡名称，例如 eth0，如果系统只有一块网卡可以不用设置</p><p>​    -n 参数，表示不解析域名，显示 ip 地址，可以提高速度；-nn 表示显示端口，而不是服务名，也会提升速度</p><p>​    -e 参数，表示显示数据链路层的信息，这样可以查看到源和目标的 mac 地址，以及 vlan 信息</p><p>​    -v 参数，表示显示基础信息，包含 ttl 以及服务类型；-vv 参数则会显示更加详细的信息</p><p>​    -p 参数，表示不开启混杂模式，默认使用 tcpdump 是开启混杂模式的，这样网卡会接收所有数据，而不是网络端口是自己的数据，使用 -p 可以减少一部分的杂质数据</p><p>​    -c 参数，用于指定抓取的包的数量，例如 -c 10，表示抓取 10 个数据包</p><p>​    -s 参数，表示抓取的数据长度，例如 -s0 则表示截取报文的全部内容</p><p>​    协议参数，通常包括 tcp，udp，arp，rarp，ip ，icmp 等等</p><p>​    host 关键字参数可以指定目标主机地址，net 关键字参数可以指定网络地址，port 参数用于指定目标端口</p><p>​    src 关键字可以指定 ip 的源地址，dst 关键字可以指定目标 ip 地址</p><p>​    tcpdump 的过滤规则支持组合模式，可以通过 <code>and（&amp;&amp;），or（||），not（!）</code> 来做多种条件的组合</p><p>​    接来下是在 docker 中的 nginx 容器，使用 tcpdump 对 eth0 抓取的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">06:45:21.487161 02:42:06:7d:2d:5e &gt; 02:41:ac:12:00:02, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 64, <span class="built_in">id</span> 59404, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    172.17.0.1.59246 &gt; 172.17.0.2.80: Flags [S], <span class="built_in">cksum</span> 0x5854 (incorrect -&gt; 0x9675), <span class="built_in">seq</span> 825108449, win 64240, options [mss 1460,sackOK,TS val 125572650 ecr 0,nop,wscale 7], length 0</span><br></pre></td></tr></table></figure><p>​    首先，可以看到的是抓取的时间，是 时:分:秒.毫秒 的格式；然后可以看到发送方的 ip 和 port 是 172.17.0.1.59246，然后是 &gt; 符号表示的数据流向，紧接着就是接收方的 ip 和 port；然后是 : 符号后面的部分，Flags 表示数据报的内容以及标识符，这里 标识符 是 S，seq 序列号，建立连接后还会有 ack 确认序列号，win 串口大小，最后是数据长度 length</p><h4 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h4><p>​    S 表示 SYN，TCP 中表示建立连接；S. 则表示收到请求并建立连接</p><p>​    F 表示 FIN，TCP 中表示关闭连接；F. 则表示收到请求并关闭连接</p><p>​    P 表示 PSH，TCP 中表示数据传输；P. 则表示收到请求并开始传输数据</p><p>​    R 表示 RST，TCP 中表示连接重置；R. 则表示收到请求并重置连接</p><p>​    . 表示 ACK，TCP 中表示收到请求进行确认</p><h3 id="基本过滤"><a href="#基本过滤" class="headerlink" title="基本过滤"></a>基本过滤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定主机过滤</span></span><br><span class="line">$ tcpdump host 192.168.1.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个主机地址</span></span><br><span class="line">$ tcpdump host 192.161.12 and ! 192.168.1.1    <span class="comment"># 监听 1.12 和除 1.1 之外的所有地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 源ip 或 目标ip 过滤</span></span><br><span class="line">$ tcpdump -i eth0 src 192.168.1.12</span><br><span class="line">$ tcpdump -i eth0 dst 192.168.1.22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定网段过滤</span></span><br><span class="line">$ tcpdump net 192.168.1.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个端口过滤</span></span><br><span class="line">$ tcpdump port 80 or 8080</span><br><span class="line">$ tcpdump portrange 8000-8080</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcpdump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gunicorn</title>
      <link href="/2213352412/"/>
      <url>/2213352412/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    Gunicorn（绿色独角兽）是一个 Python WSGI UNIX 的 HTTP 服务器，从 Ruby 的独角兽（<a href="http://www.oschina.net/p/unicorn">Unicorn</a> ）项目移植的。采用了 pre-fork worker 的模型，Gunicorn 服务器几乎可以与各种 Web 框架兼容，只需非常简单的执行，轻量级的资源消耗，以及相当迅速</p><p>​    <img src="https://static.oschina.net/uploads/img/201703/12145841_UgME.jpg" alt="12145841_UgME.jpg"></p><p>​    所以在一般的生产环境中，基本如上图所示，客户端请求在实际到达 Python 的应用程序前，会经过 nginx，由 nginx 实现负载均衡和请求分发，然后请求会被分发到 WSGI 服务器，也就是 gunicorn</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>​    gunicorn 的架构使用的是 master - worker 架构，在启动 gunicorn 后，会创建一个 master 的进程，并根据设置创建出对应数量的 worker 进程，worker 会监听请求，并进行处理，<strong>一般建议的 worker 数是 CPU 数 * 2 + 1</strong></p><p>​    master 的进程是一个简单的循环，负责对进程的信号做监听，会自动重启关闭的 worker 进程</p><p><img src="https://upload-images.jianshu.io/upload_images/6177832-47e70a4b30918469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/910/format/webp" alt="img"></p><p>​    所谓的 pre-fork，这个预分发表明了在主进程处理 http 前，就已经完成了 worker 进程的创建</p><h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><p>​    gunicorn 支持了三种并发模式：<strong>Sync</strong>，<strong>gthread</strong>，<strong>Async</strong></p><p>​    <strong>Sync</strong> 是默认的模式，即每个 worker 一次同步处理一个请求，其余的请求需要等待</p><p>​    <strong>gthread</strong> 是采用线程工作的方式，需要安装上 gthread 库，这种模式下请求会被加入到线程池中，每一个 worker 中给的线程都是资源共享的，使用这种模式需要指定 threads 参数</p><p>​    <strong>Async</strong> 就是协程异步的模式，需要使用到 gevent 或 eventlet，这种模式非常适用于 IO 密集项目</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>​    gunicorn 的启动很简单，在命令行中输入 <code>gunicorn -w 2 myapp:app</code> 即可运行，-w 参数就是设置 worker 进程的数量，myapp:app，中 myapp 实际是 myapp.py 文件，也就是项目文件，app 则是实际的应用名称</p><p>​    以 Flask 为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">5001</span>)</span><br></pre></td></tr></table></figure><p>​    一般在调试开发时，通常可以直接使用 <code>python test.py</code> 来运行 flask 应用，当使用 gunicorn 时，则是 <code>gunicorn -w 2 test:app</code>，如果在应用中直接使用的是 app.run()，那么在 gunicorn 的命令中可以使用 -b 参数，去绑定 ip 和端口，即 <code>-b 0.0.0.0:5001</code></p><p>​    如果是 django  项目，则启动命令中 app 实例是 <code>项目名称.wsgi:application</code></p><p>​    注意，上面的命令在回车后执行，都是在终端前台执行，如果要放到后台作为守护进程，可以再加上 <code>-D</code> 参数</p><p>​    <strong>注意如果使用的模式非默认的 sync，则在命令中需要使用 <code>--worker-class</code> 去指定模式</strong></p><p>​    如果启动模式使用 gthreads 的模式，启动命令则是 <code>gunicorn -w 2 --threads=2 --worker-class=gthread test:app</code></p><p>​    如果启动模式使用异步 IO 的 gevent 的模式，启动命令则是 <code>gunicorn --worker-class=gevent -w 2 test:app</code>，同时还可以指定每个 worker 的最大连接数，使用 <code>--worker-connections=1000</code> 设置</p><p>​    除了通过命令行设置参数，gunicorn 还是有一个 <code>-c</code> 参数允许通过配置文件来运行</p>]]></content>
      
      
      <categories>
          
          <category> WSGI 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx-整理</title>
      <link href="/557344215/"/>
      <url>/557344215/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    nginx 是一个开源的，支持高性能，高并发的www服务和代理服务软件。它是俄罗斯人 lgor sysoev 使用 C 语言开发的，nginx 占用的系统资源更少，使用基于事件驱动的架构，使得其可以支持数以百万级别的 TCP 连接</p><p>​    nginx 不但是一个优秀的 web 服务软件，还可以作为反向代理，负载均衡，以及缓存服务使用</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​    可以在官方网站下载安装包，<code>wget -c https://nginx.org/download/nginx-1.16.1.tar.gz</code>，这样下载后的文件是源码文件是需要进行遍历安装的</p><p>​    通常情况下，在正式安装之前，还需要安装一些相关的依赖，<code>yum install gcc zlib-devel bzip2-devel pcre pcre-devel openssl openssl-devel -y</code></p><p>​    安装依赖完成后，对 nginx 的安装包进行解压，<code>tar -zxvf nginx-1.16.1.tar.gz</code>，然后进入到解压后的目录中，开始释放 makefile 文件 <code>./configure  --prefix=/usr/local/niginx1.16</code>，prefix 参数指定最后 nginx 的安装位置</p><p>​    然后开始编译安装 <code>make &amp;&amp; make install</code>，安装完成后，进入安装目录，使用 <code>nginx</code> 就可以启动 nginx 服务，如果要指定启动的 nginx 配置文件，可以使用 <code>nginx -c</code> 去指定配置文件的目录，如果要关闭 nginx 可以使用 <code>nginx -s stop</code>，如果要重载配置文件可使用 <code>nginx -s reload</code></p><p>​    除此之外，一种更便捷的方式就是使用 docker 容器，安装好 docker 后，使用 <code>docker pull nginx</code> 就是下载最新的 nginx 镜像</p><p>​    然后通过镜像文件运行 nginx 容器 <code>docker run --name nginx-test -p 8080:80 -d nginx</code>，–name 指定容器的名称，-p 将本机的 8080 端口映射到 nginx 容器的 80 端口，-d 表示让容器在后台运行，最后的 nginx 其实就是镜像文件的名称</p><p>​    容器启动后，本地访问 8080 就会将请求发送到 nginx 容器</p><p>​    Ubuntu 上也可以更快捷使用 <code>sudo apt-get install nginx</code> 进行安装，然后使用 <code>sudo systemctl nginx start</code> 启动</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>​    安装完成后，在 <code>/etc/nginx</code> 目录下会有以下目录 <code>conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params</code></p><p>​    nginx.conf，这是 nginx 服务的配置文件，里面的 <code>include /etc/nginx/conf.d/*.conf</code> 就是让 nginx 去加载对应的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    conf.d 目录里存放这不同网站的配置文件，里面会有一个默认的配置文件 default.conf，这个文件其实就是一个参考文件，实际运用中该文件可以删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  auto;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------------------------</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------------------------</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>对于配置文件来说，可以分成三块：</strong></p><p>​    <strong>全局块，即上面横线隔开的第一部分，用于定义进程数，日志的路径等</strong></p><p>​    <strong>events 块，用来配置事件处理模型，进程最大的连接数，以及 http 协议的 keep-alive 的超时时间</strong></p><p>​    <strong>http 块，用来配置路由，设置静态文件代理，反向代理，负载均衡等</strong></p><p>​    <strong>注意，其实 http 块内部还可以分成三部分：首先是 http 块内部第一部分 全部块，这个配置会对所有 nginx 的站点生效；server 块，是针对单站点的配置；location 块，是针对单个页面或是 url 配置，以及静态文件下载等</strong></p><p>​    对于 location 的路由配置，支持普通字符串匹配和正则匹配，正则匹配中各种不同方式有着不同的优先级</p><table><thead><tr><th align="left">匹配符</th><th align="left">匹配规则</th><th align="left">优先级</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">精确匹配</td><td align="left">1</td></tr><tr><td align="left">^~</td><td align="left">以某个字符串开头</td><td align="left">2</td></tr><tr><td align="left">~</td><td align="left">区分大小写的正则匹配</td><td align="left">3</td></tr><tr><td align="left">~*</td><td align="left">不区分大小写的正则匹配</td><td align="left">4</td></tr><tr><td align="left">!~</td><td align="left">区分大小写的不匹配正则</td><td align="left">5</td></tr><tr><td align="left">!~*</td><td align="left">不区分大小写的不匹配正则</td><td align="left">6</td></tr><tr><td align="left">/</td><td align="left">通用匹配，任何请求都会匹配到</td><td align="left">7</td></tr></tbody></table><p>​    安装完  nginx 后，在 /etc/nginx/ 目录下可能还会有两个目录，即 sites-available 和 sites-enabled，前者通常就是针对多个不同站点，将各自的配置文件放在该文件夹下，后者则是一个软链地址，软链的目标就是 sites-available 里的配置文件</p><p>​     sites-available 表示可以用来存放可以使用的站点配置文件，sites-enabled 表示启用的站点配置文件，也就是说当站点暂时不使用时，可以在 sites-enabled 将对应配置文件删除，但实际的配置文件还在 sites-available 中，所以如果后期要恢复，只需要再创建软链即可</p><p>​    创建软链使用 <code>ln -s  源文件  目标文件</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/sites-enabled#  ln -s ../sites-available/test.txt test.txt</span></span><br><span class="line"><span class="comment"># 表示将 上一级 目录中 sites-available 文件夹下的 test.txt 软链接到当前目录的 test.txt，该文件会自动创建</span></span><br></pre></td></tr></table></figure><h4 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局块</span></span><br><span class="line"> user www-data;</span><br><span class="line"> worker_processes  2;      <span class="comment"># 默认1，一般建议设成 CPU 核数 1-2 倍</span></span><br><span class="line"> error_log logs/error.log; <span class="comment"># 错误日志路径</span></span><br><span class="line"> pid logs/nginx.pid;       <span class="comment"># 进程id</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment"># Events块</span></span><br><span class="line"> events &#123;</span><br><span class="line">   <span class="comment"># 使用 epoll 的 I/O 模型处理轮询事件</span></span><br><span class="line">   <span class="comment"># 可以不设置，nginx 会根据操作系统选择合适的模型</span></span><br><span class="line">  use epoll;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 工作进程的最大连接数量, 默认 1024 个</span></span><br><span class="line">  worker_connections  2048;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># http 层面的 keep-alive 超时时间</span></span><br><span class="line">  keepalive_timeout 60;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 客户端请求头部的缓冲区大小</span></span><br><span class="line">  client_header_buffer_size 2k;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> http &#123; <span class="comment"># http 全局块</span></span><br><span class="line"> </span><br><span class="line">  include mime.types;  <span class="comment"># 导入文件扩展名与文件类型映射表</span></span><br><span class="line">  default_type application/octet-stream;  <span class="comment"># 默认文件类型</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 日志格式及 access 日志路径</span></span><br><span class="line">  log_format   main <span class="string">&#x27;$remote_addr - $remote_user [$time_local] $status &#x27;</span></span><br><span class="line">     <span class="string">&#x27;&quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">     <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line">  access_log   logs/access.log main;</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 允许 sendfile 方式传输文件，默认 为off</span></span><br><span class="line">  sendfile     on;</span><br><span class="line">  tcp_nopush   on; <span class="comment"># sendfile 开启时才开启</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment"># http server 块</span></span><br><span class="line">   <span class="comment"># 简单反向代理</span></span><br><span class="line">  server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name domain2.com www.domain2.com;</span><br><span class="line">    access_log   logs/domain2.access.log main;</span><br><span class="line">   </span><br><span class="line">     <span class="comment"># 转发动态请求到web应用服务器</span></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass     http://127.0.0.1:8000;</span><br><span class="line">      deny 192.24.40.8;  <span class="comment"># 拒绝的ip</span></span><br><span class="line">      allow 192.24.40.6; <span class="comment"># 允许的ip  </span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment"># 错误页面</span></span><br><span class="line">    error_page   500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment"># 负载均衡</span></span><br><span class="line">  upstream backend_server &#123;</span><br><span class="line">    server 192.168.0.1:8000 weight=5; <span class="comment"># weight 越高，权重越大</span></span><br><span class="line">    server 192.168.0.2:8000 weight=1;</span><br><span class="line">    server 192.168.0.3:8000;</span><br><span class="line">    server 192.168.0.4:8001 backup;   <span class="comment"># 热备</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  server &#123;</span><br><span class="line">    listen          80;</span><br><span class="line">    server_name     big.server.com;</span><br><span class="line">    access_log      logs/big.server.access.log main;</span><br><span class="line">     </span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 10M; <span class="comment"># 限制用户上传文件大小，默认 1M</span></span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 使用 proxy_pass 转发请求到通过 upstream 定义的一组应用服务器</span></span><br><span class="line">      proxy_pass     http://backend_server;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">      proxy_redirect off;</span><br><span class="line">      proxy_set_header X-Real-IP  <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http 请求重定向到 https 请求</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name domain.com;</span><br><span class="line">   <span class="built_in">return</span> 301 https://$server_name<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>​    nginx 可以天然作为静态文件服务器使用，且支持对静态文件缓存，以及文件下载和压缩</p><h4 id="静态文件缓存"><a href="#静态文件缓存" class="headerlink" title="静态文件缓存"></a>静态文件缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/(html|js|css) &#123;   <span class="comment"># 匹配 html|js|css 文件</span></span><br><span class="line">  root   /var/www/big.server.com/static_files;</span><br><span class="line">  expires 10d;    <span class="comment"># expries 设置缓存时间是 10 天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意，上面使用的 root，通常还会见到另一个关键字 alias，两者的区别是：</p><p>​    <strong>root 对路径的处理是，root 后配置的路径，会加上 location 上配置的匹配路径</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/static/ &#123;                        </span><br><span class="line">  root /usr/share/nginx/html/;   <span class="comment"># 静态资源路径</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 当请求路由是： .../static/test.js</span></span><br><span class="line"><span class="comment"># 对应到 nginx 服务器的目录地址是：/usr/share/nginx/html/static/test.js</span></span><br></pre></td></tr></table></figure><p>​    <strong>alias 对路径的处理是，alias 后配置路径，会替换掉 location 上匹配的路径</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ ^/static/ &#123;                        </span><br><span class="line">  <span class="built_in">alias</span> /usr/share/nginx/html/;   <span class="comment"># 静态资源路径</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 当请求路由是： .../static/test.js</span></span><br><span class="line"><span class="comment"># 对应到 nginx 服务器的目录地址是：/usr/share/nginx/html/test.js</span></span><br></pre></td></tr></table></figure><h4 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h4><p>​    nginx 中可使用 gzip 对传输文件进行压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment"># 开启 gzip 压缩功能</span></span><br><span class="line">   gzip on;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置允许压缩的页面最小字节数; 这里表示如果文件小于 10k，压缩没有意义.</span></span><br><span class="line">   gzip_min_length 10k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置压缩比率，最小为 1，处理速度快，传输速度慢；</span></span><br><span class="line">    <span class="comment"># 9 为最大压缩比，处理速度慢，传输速度快; 推荐 6</span></span><br><span class="line">   gzip_comp_level 6;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置压缩缓冲区大小，此处设置为 16 个 8K 内存作为压缩结果缓冲</span></span><br><span class="line">   gzip_buffers 16 8k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置需要压缩的类型</span></span><br><span class="line">   gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>​    如果一些静态文件除了提供访问预览，还需要支持下载，在 nginx 中的 location 里通过设置 autoindex 就可以很方便的实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location /download/ &#123;    </span><br><span class="line">  <span class="comment"># 下载文件所在目录</span></span><br><span class="line">  root /usr/share/nginx/html;</span><br><span class="line">         </span><br><span class="line">  <span class="comment"># 开启索引功能</span></span><br><span class="line">  autoindex on;  </span><br><span class="line">         </span><br><span class="line">  <span class="comment"># 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）</span></span><br><span class="line">  autoindex_exact_size off;</span><br><span class="line">         </span><br><span class="line">  <span class="comment"># 显示本机时间而非 GMT 时间</span></span><br><span class="line">  autoindex_localtime on;  </span><br><span class="line">                 </span><br><span class="line">  <span class="comment"># 强制以附件形式下载指定后缀的文件，不要浏览器直接打开</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$request_filename</span> ~* ^.*?\.(txt|jpg|png)$) &#123;</span><br><span class="line">    add_header Content-Disposition <span class="string">&#x27;attachment&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nginx-变量"><a href="#nginx-变量" class="headerlink" title="nginx 变量"></a>nginx 变量</h3><p>​    上面的重定向使用了 $ 开头的变量，这些是 nginx 运行自带的变量，除了这些还有以下的变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$args</span>, 请求中的参数;</span><br><span class="line"><span class="variable">$content_length</span>, HTTP请求信息里的 <span class="string">&quot;Content-Length&quot;</span>;</span><br><span class="line"><span class="variable">$content_type</span>, 请求信息里的 <span class="string">&quot;Content-Type&quot;</span>;</span><br><span class="line"><span class="variable">$host</span>, 请求信息中的 <span class="string">&quot;Host&quot;</span>，如果请求中没有 Host 行，则等于设置的服务器名;</span><br><span class="line"><span class="variable">$limit_rate</span>, 对连接速率的限制;</span><br><span class="line"><span class="variable">$request_method</span>, 请求的方法，比如 <span class="string">&quot;GET&quot;</span>、<span class="string">&quot;POST&quot;</span> 等;</span><br><span class="line"><span class="variable">$remote_addr</span>, 客户端地址;</span><br><span class="line"><span class="variable">$remote_port</span>, 客户端端口号;</span><br><span class="line"><span class="variable">$request_uri</span>, 请求的 URI，带查询字符串;</span><br><span class="line"><span class="variable">$server_protocol</span>, 请求的协议版本，<span class="string">&quot;HTTP/1.0&quot;</span> 或 <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line"><span class="variable">$server_addr</span>, 服务器地址;</span><br><span class="line"><span class="variable">$server_name</span>, 请求到达的服务器名;</span><br><span class="line"><span class="variable">$server_port</span>, 请求到达的服务器端口号;</span><br></pre></td></tr></table></figure><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>​    nginx 的代理分为了两种，一种是正向代理，另一种是反向代理。所谓代理，其实就是中间者，一个渠道，所以对于代理来说，就需要 发起者 和 接收者，前者就是客户端，后者自然就是提供服务的服务器</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>​    其实就是将 nginx 和 客户端 划分在一起作为一个整体，不同的客户端将请求发送到 nginx 服务器，通过这个服务器作为客户端的代理，将请求按照配置发送到指定的处理服务的服务器地址</p><p><img src="https://wei-foun.github.io/img/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="img"></p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>​    顾名思义，以上面正好相反，反向代理可以将 nginx 和 服务处理服务器 作为一个整体，那么对于客户端来说，自己其实并不知道实际提供服务处理的服务器，也就是说客户端相当于是在和 nginx 做交互</p><p><img src="https://wei-foun.github.io/img/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="img"></p><p>​    实现反向代理的配置，在 server 块的 location 中配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转发动态请求</span></span><br><span class="line">server &#123;  </span><br><span class="line">   listen 80;                                                        </span><br><span class="line">   server_name localhost;</span><br><span class="line"></span><br><span class="line">   location / &#123;    <span class="comment"># 将监听所有 url</span></span><br><span class="line">       proxy_pass http://localhost:8080;    <span class="comment"># 将 nginx 监听到的 80 端口请求转发到本地的 8080 端口</span></span><br><span class="line">       proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>​    通常随着项目的请求逐步增加，考虑到项目的健壮性，以及扩展到分布式的架构等，用于处理请求的服务器会增多，那么方向代理时，就需要通过负载均衡，来对请求进行分发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server &#123;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">    server 192.168.0.3:8000 down; <span class="comment"># 不参与负载均衡</span></span><br><span class="line">    server 192.168.0.4:8001 backup; <span class="comment"># 热备</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> server &#123;</span><br><span class="line">    listen         80;</span><br><span class="line">    server_name     big.server.com;</span><br><span class="line">    access_log     logs/big.server.access.log main;</span><br><span class="line">     </span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 10M; <span class="comment"># 限制用户上传文件大小，默认 1M</span></span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">      <span class="comment"># 使用 proxy_pass 转发请求到通过 upstream 定义的一组应用服务器</span></span><br><span class="line">      proxy_pass     http://backend_server;</span><br><span class="line">      proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">      proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">      proxy_redirect off;</span><br><span class="line">      proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    nginx 默认情况下，是按照请求的时间逐一分发到目标服务器，也就是 <strong>默认是按照轮询方式</strong></p><p>​    除此之外，nginx 的负载均衡 <strong>还支持 weight 权重方式，ip_hash ip 哈希分发方式，url_hash url 哈希分发方式，fair 响应时间分发方式</strong></p><p>​    weight 权重分配：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># weight 分发</span></span><br><span class="line">upstream backend_server &#123;</span><br><span class="line">    server 192.168.0.1:8000 weight=1;</span><br><span class="line">    server 192.168.0.2:8000 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ip 哈希分发方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip_hash 分发</span></span><br><span class="line">upstream backend_server &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    url 哈希分发方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url_hash 分发</span></span><br><span class="line">upstream backend_server &#123;</span><br><span class="line">    <span class="built_in">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line">    server 192.168.0.1:8000;</span><br><span class="line">    server 192.168.0.2:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    fair 方式：需要安装三方库 upstream-fair，它的规则是响应时间较短的代理地址会优先分发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server &#123;</span><br><span class="line">   server 192.168.0.1:8000;</span><br><span class="line">   server 192.168.0.2:8000;</span><br><span class="line">   fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nginx-与-uWSGI"><a href="#Nginx-与-uWSGI" class="headerlink" title="Nginx 与 uWSGI"></a>Nginx 与 uWSGI</h3><p>​    uWSGI 是 Python Web 应用程序的服务器，Python 的应用程序例如 Django 和 Flask 都是遵循的 uwsgi 协议，所以 nginx 与 python 的 Web 应用程序通讯，中间还需要通过 uWSGI 服务器</p><p>​    一般代理使用的是 proxy_pass 的配置项来设置，将普通的 http 协议请求转发到 upstream 上游服务器，当要与 uWSGI 服务器通信时，则需要使用 uwsgi_pass 来设置，同时需要 include nginx 目录下的 uwsgi_params</p><p>​    如果 Django 部署的时候，使用的不是 uwsgi，而是 gunicorn 运行服务，也无需使用 uwsgi_pass</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream uwsgi_backend &#123;  <span class="comment"># http请求转发配置</span></span><br><span class="line">  server localhost:8888;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80 default_server;</span><br><span class="line">  listen       [::]:80 default_server;</span><br><span class="line">  server_name  _;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">     proxy_http_version 1.1;</span><br><span class="line">     proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">     proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">     proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">     uwsgi_pass  uwsgi_backend;                  <span class="comment"># 使用 uwsgi_pass 将 http 转发到上层</span></span><br><span class="line">     include  /etc/nginx/uwsgi_params;           <span class="comment"># 使用 include，导入 nginx 的 uwsgi_params</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果 nginx 和 uWSGI 是在一个服务器上安装的，可以不使用负载均衡，使用 unix socket 通信的速度会更快些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;    </span><br><span class="line">   include /etc/nginx/uwsgi_params;</span><br><span class="line">   uwsgi_pass unix:/run/uwsgi/django_test1.sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTPS-配置"><a href="#HTTPS-配置" class="headerlink" title="HTTPS 配置"></a>HTTPS 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 负载均衡，设置HTTPS</span></span><br><span class="line">upstream backend_server </span><br><span class="line">  server APP_SERVER_1_IP;</span><br><span class="line">  server APP_SERVER_2_IP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  listen [::]:443 ssl http2;</span><br><span class="line">  server_name your_domain.com;</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># ssl证书及密钥路径</span></span><br><span class="line">  ssl_certificate /path/to/your/fullchain.pem;</span><br><span class="line">  ssl_certificate_key /path/to/your/privkey.pem;</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># SSL会话信息</span></span><br><span class="line">  client_max_body_size 75MB;</span><br><span class="line">  keepalive_timeout 10;</span><br><span class="line"> </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    proxy_pass http://backend_server;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见算法</title>
      <link href="/3963924866/"/>
      <url>/3963924866/</url>
      
        <content type="html"><![CDATA[<h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h3><table><thead><tr><th>排序算法</th><th>最差时间分析</th><th>平均时间复杂度</th><th>稳定性</th><th>空间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n²)</td><td>稳定</td><td>O(1)</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n²)</td><td>稳定</td><td>O(1)</td></tr><tr><td>快速排序</td><td>O(n²)</td><td>O(nlogn)</td><td>不稳定</td><td>O(logn)</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(n)</td></tr></tbody></table><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>​    简单来说就是用来衡量算法运行的时间，例如最简单的 range(n) 的 for 循环来说，最后遍历的元素是 n-1 个，整个时间复杂度上可以看成如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">时间复杂度 = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + .... + (n-<span class="number">4</span>) + (n-<span class="number">3</span>) + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)</span><br><span class="line">          = Cn   (C是一个常数) </span><br><span class="line">          = n</span><br><span class="line">          = O(n）</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">              </span><br><span class="line">时间复杂度 = <span class="number">1</span> * [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)] + <span class="number">2</span> * [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)] + ...</span><br><span class="line">          = [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)] * [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)]</span><br><span class="line">          = n * n</span><br><span class="line">          = O(n²)</span><br></pre></td></tr></table></figure><p>​    所以，可以简单理解 <strong>一次循环</strong> 的执行，时间复杂度上就是 <strong>O(n)</strong>；一般来说，时间复杂度高的算法会比时间复杂度低的算法要慢；并且如果算法在循环中，每一次循环会少遍历原来的一半的话，时间复杂度上可以简单看作是 O(logn)</p><p>​    常见的时间复杂度的高低比较：<strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n²logn) &lt; O(n³)</strong> </p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>​    和时间复杂度一样，用来评估算法在空间上内存的占用大小，如果算法执行不涉及需要申请空间的话，就可以看作是 O(1) 的，一般来说算法的效率都是 <strong>“空间换时间”</strong></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>​    <strong>最简单的理解：</strong>每一轮遍历，都是将当轮循环的最大值一层层往 “上”（往数组最后）抛出</p><p>​    简单说明：一个数组 [5,1,7,2] 进行冒泡排序，会有两个指针，第一个指针 i 表示轮数，第二 j 的则是元素的下标索引指针</p><p>​    i = 0 的遍历：i 指向 5，先将数组的第 0 和 1 位（即 j 与 j+1）进行比较，即比较 5 和 1，因为 5 &gt; 1，所以交换两者的位置后得到 [1,5,7,2]，完成后将指针 j + 1，继续遍历数组，同样的方法比较 5 和 7，因为 5 &lt; 7，所以数组不变依然是 [1,5,7,2]，依次类推，继续遍历，最后第一轮完成返回的数组是 [1,5,2,7]</p><p>​    i = 1 的遍历：第一轮完成后，可见数组并不是有序的，所以第二轮遍历依然是将这一轮的最大值抛出，不过此时数组需要分成两部分，非有序和有序，有序的部分就是在第一轮中最末尾的元素，非有序就是末尾元素前的经过第一轮后的数组，所以对于第二轮来说，要遍历的就是 [1,5,2]，最后将这一次的最大值加入到有序数组中的第一个位置上</p><p>​    关于 i 的循环语句 <code>range(len(li) - 1)</code>，这个语句可以直接是 <code>range(len(li))</code>，但是 <code>-1</code> 是因为真正的排序其实由 j 的循环去操作，而 j 在第一轮就会冒出最大值到列表最后，<code>-1</code> 就省去了最后当排序完成后，i 还要去判断列表最后一个元素</p><p>​    关于 j 的循环语句 <code>range(len(li) - i - 1)</code>，同样可以直接是 <code>range(len(li) - 1)</code>，之所以是 <code>-i - 1</code> 同样是一种优化，因为 j 的每一轮会冒出最大值，到最后的有序数组部分，也就是说 i 完成一轮，数组最后的有序部分就会多一个值，<code>-i - 1</code> 就为为了减少对有序部分的再次比较，也就说第一次 j 冒出最大值 9 到有序部分后，下一次 j 的循环中比较只用比较无序部分</p><p>​    可见，对于冒泡排序来说，需要 n 轮的循环，所以对于无序的数组来说，一般的时间复杂度是 O(n²) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)                   <span class="comment"># [9, 2, 8, 6, 0, 5, 7, 3, 1, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bubble_sort(li))      <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>​    <strong>优化：</strong></p><p>​    上面的代码处理了大部分正常的情况，也说了一般的时间复杂度是 O(n²) ，但是如果对于一个数组来说，它看似是一个有序的，只是有一个元素穿插在了其他的位置上，例如 [1,4,2,6,8]，这里面 2 之后都是有序的，也就是这一轮只需要交换 4 和 2 就可以了，所以上面的代码还可以优化，加上一个标记，防止第一轮完成后去继续遍历，这个优化只是限于只用一轮遍历交换两个数的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> exchange:</span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure><p>​    这样一来，对于类似 [1,4,2,6,8] 的数组，时间复杂度就是 O(n) 了</p><p>​    所有的循环都是可以用递归来实现的，所以上面的冒泡排序也可以用递归实现，但是使用递归方式在效率上会有所影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; li[i+<span class="number">1</span>]:</span><br><span class="line">            li[i], li[i+<span class="number">1</span>] = li[i+<span class="number">1</span>], li[i]</span><br><span class="line">            exchange = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> exchange:</span><br><span class="line">        bubble_sort(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)                 <span class="comment"># [6, 1, 0, 8, 2, 5, 3, 9, 7, 4]</span></span><br><span class="line"><span class="built_in">print</span>(bubble_sort(ll))    <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>​    <strong>最简单的理解：</strong>每一轮遍历，都将数组中的最小值放到最前面</p><p>​    简单说明：对 [2,4,6,0,1] 进行选择排序，与冒泡一样会分成有序和无序两个部分，同样会有两个指针，指针 i 作为最小值的索引，指针 j 用来对数组遍历</p><p>​    i = 0 的遍历：首先，将数组索引 0 的元素作为最小值，使用 min_pos = i 标记最小值的索引，那么接下去的遍历就是从数组的第二个元素比较开始。如果数组的第二个元素大于第一个元素，就需要更改 min_pos 这个最小索引标记，将 min_pos 改为 j，然后指针 j 继续往后遍历和比较，只要比较出最小的值，就修改 min_pos 为 j。所以在第一轮结束，得到的数组是 [0,4,6,2,1]</p><p>​    i = 1 的遍历：首先，这一次 min_pos 的 i 值从 0 改为了 1，即这次开始分为了有序部分和无序部分，有序部分即 0，后面的 [4,6,2,1] 是无序部分，也就是这一轮需要遍历出其中的最小值，然后这个最小值成为这个数组的索引为 0 的第一位，即最后得到的数组是 [0, 1, 6, 2, 4]</p><p>​    之后的遍历，也是同样的思路，在 i = n 的位置开始，找到后面数组中的最小值后，两者的位置进行互换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        min_pos = i      <span class="comment"># 每一轮，都假设当前位置是最小的值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(li)):    <span class="comment"># 从当前位置之后开始遍历比较</span></span><br><span class="line">            <span class="keyword">if</span> li[min_pos] &gt; li[j]:        <span class="comment"># 如果最小位置大于遍历位置，所以当前位置不是实际最小位置</span></span><br><span class="line">                min_pos = j                <span class="comment"># 重新赋值最小位置为当前判断得到的位置</span></span><br><span class="line">        li[i], li[min_pos] = li[min_pos], li[i]    <span class="comment"># 比较循环结束，将得到实际最小位置和当前以为最小位置互换</span></span><br><span class="line">    <span class="keyword">return</span> li </span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(len(li)):</span></span><br><span class="line">    <span class="comment">#    for j in range(i+1, len(li)):</span></span><br><span class="line">    <span class="comment">#        if li[i] &gt; li[j]:</span></span><br><span class="line">    <span class="comment">#            li[i], li[j] = li[j], li[i]</span></span><br><span class="line">    <span class="comment"># return li</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li)                     <span class="comment"># [4, 3, 1, 7, 2, 0, 9, 5, 8, 6]</span></span><br><span class="line"><span class="built_in">print</span>(select_sort(li))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>​    <strong>最简单的理解：</strong>就像按照点数整理纸牌一样，从无序区中拿取第一张牌依次和前面的比较大小</p><p>​    简单说明：对 [2,4,6,0,1] 进行插入排序，每一轮把无序区的第一个元素抽出，与前面的元素进行比较，前面的元素如果大于抽出的元素，则往后移动，一直到没有元素大于抽出的元素，就将其放到那个位置上</p><p>​    遍历流程：首先，依然是两个指针，指针 i 作为数组元素的整个遍历，指针 j 作为抽出元素与其前面位置的元素的比较。将抽取的数的元素（即 li[i]）赋值一个变量保存，然后指针 j 为当前 i 前一位（即 j = i -1），在 while 循环中一直遍历这个指针到 0 的位置，且将抽出的元素与其前面的元素比较，如果这些元素大于抽出的元素，就需要将抽出的位置重新赋值给大于其的元素，如此一来，可以实现将前面所有大于抽出元素的元素实现位置后移。到最后，循环条件不满足了，即 j - 1 = -1 了，就需要 +1 来让索引回到 0 的位置，并且将抽出的元素最后赋值给 0 的位置（注意：这里指的是最后的时候，其中如果遍历时，如果 j -1 后的元素不大于抽出的元素，就说明 j + 1 的位置就是抽出元素应该存在的位置）</p><p>​    也就是说，在 i = 3 时，即抽出元素是 0 的遍历中，数组的流程是：</p><p>​    [2,4,6,0,1]  &gt; [2,4,6,6,1] &gt; [2,4,4,6,1] &gt; [2,2,4,6,1] &gt; [0,2,4,6,1]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:    <span class="comment"># li[j] 是当前位置前一位  # li[j] &gt; tmp 升序  li[j] &lt; tmp 降序</span></span><br><span class="line">            li[j + <span class="number">1</span>] = li[j]            <span class="comment"># li[j+1] 是当前位置</span></span><br><span class="line">            j -= <span class="number">1</span>                       <span class="comment"># 将遍历位置前移一位</span></span><br><span class="line">        li[j + <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li)                    <span class="comment"># [8, 5, 6, 1, 2, 7, 0, 4, 3, 9]</span></span><br><span class="line"><span class="built_in">print</span>(insert_sort(li))       <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>​    最重要的思路就是：<strong>分治法（divide and conquer）</strong>，整体来说快速排序分三个步骤</p><p>​    1）partition：选择基准分割数，将数组分割成两部分，基准数左边全部是小于基准数的数组，右边则都是大于的</p><p>​    2）对两个数组分别递归调用快排</p><p>​    3）整理最后的数组，将排序后的左边 + 基准数 + 右边</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    pivot = li[<span class="number">0</span>]</span><br><span class="line">    left_part = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">    right_part = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">    left_part = quick_sort(left_part)</span><br><span class="line">    right_part = quick_sort(right_part)</span><br><span class="line">    <span class="keyword">return</span> left_part + [pivot] + right_part</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li)                    <span class="comment"># [2, 3, 5, 6, 8, 0, 4, 9, 7, 1]</span></span><br><span class="line"><span class="built_in">print</span>(quick_sort(li))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>​    需要知道的是，在上面的代码的中由于对左右两个部分是利用列表生成式去实现的，所以在空间复杂度上是 O(n) 的，但是这种方式和一般空间复杂度 O(logn) 的在执行上差别不会太大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空间复杂度 O(logn) 的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">li,left,right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="string">    快速排序是不稳定的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    快速排序存在最坏情况，最坏情况下，时间复杂度为 O(n²)</span></span><br><span class="line"><span class="string">    即如果一个列表是倒叙的排列，这种情况下每次递归只少一个数</span></span><br><span class="line"><span class="string">    而如果是随机的数列，每次递归给分成一半</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(li,left,right)</span><br><span class="line">        quick_sort(li,left,mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">li,left,right</span>):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]</span><br><span class="line">    li[left] = tmp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">li = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(quick_sort(li,<span class="number">0</span>,<span class="built_in">len</span>(li)-<span class="number">1</span>))    <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>​    注意，虽然快排在理论上时间复杂度是 O(nlogn)，但实际上快排会受到实际数组排序而被影响，如果数据原本就是接近有序，那么利用基准数作为左右分解再去排序的时间复杂度则会退化到 O(n²)，主要的原因就是因为基准数的选择上有问题</p><p>​    简单实现上，在数据排序相对均匀的情况下，利用第一个或最后一个作为基准数作为分界点都可以达到平均的时间复杂度，但这种方式没有考虑到数据本身的特点，那么想要防止算法的退化，简单的一点的做法可以是通过三个数字来进行取中，或者是随机法</p><p>​    三数取中法，就是在数组区间中取出第一个，中间，最后一个数，然后对比这三个数，最后选择一个中间值作为基准数从而当做分界点，这样的做法相对来说每一次递归中数据的间隔相对固定，要比单纯直接利用一个数来分界会均匀一些，但是这也随数据大小而定，如果数据量很大，取中法的选择可能就需要由三个数变为五个数或是十个数</p><p>​    随机法，顾名思义就是在每次递归的区间中，随机选择一个随机值作为分界点，这样的做法也可以使最后的排序能在平均时间复杂度上，避免极端情况导致退化</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>​    先从简单的思路理解：假设一个数组可以分为两段，也就是两个有序的数组，通过整理最后合为一个有序数组，整个一次的步骤称为 “归并”</p><p>​    假设现在有两个有序数组：[1,2,5]，[0,3,4,8]；需要循环遍历两个数组，并进行大小比较，即需要分别取出两个数组的索引下标，也就是需要两个参数作为指针，在每一次比较后，将小的元素从其所在数组移除加入到新的数组中，并对其所在数组的指针 +1，如此反复进行比较以及指针后移；最后，如果两个数组的长度不相等，势必会出现到最后无法继续比较的情况，就需要将还有多余元素的数组直接在新的数组后追加即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并两个有序数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_li</span>(<span class="params">li_a, li_b</span>):</span><br><span class="line">    len_a, len_b = <span class="built_in">len</span>(li_a), <span class="built_in">len</span>(li_b)</span><br><span class="line">    a = b = <span class="number">0</span></span><br><span class="line">    new_li = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a &lt; len_a <span class="keyword">and</span> b &lt; len_b:</span><br><span class="line">        <span class="keyword">if</span> li_a[a] &lt; li_b[b]:</span><br><span class="line">            new_li.append(li_a[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_li.append(li_b[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a &lt; len_a:</span><br><span class="line">        new_li.extend(li_a[a:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_li.extend(li_b[b:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_li</span><br><span class="line"></span><br><span class="line">li_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">li_2 = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(merge_sort(li_1,li_2))    <span class="comment"># [0, 1, 2, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure><p>​    上面的代码实现了对两个有序数组的最后排序，那么对于归并排序就可以直接借此实现了，只需要将打乱的数组交给函数，函数内部去计算得到一个中间数，分别得到左右两部分，然后递归调用，对左右两个数组继续拆分，到最后拆到左右两个数组都是一直有一个元素，去调用归并来实现合并</p><p><img src="https://wei-foun.github.io/img/%E5%BD%92%E5%B9%B6.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接着上面的归并，来实现归并排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = <span class="built_in">int</span>(<span class="built_in">len</span>(li) / <span class="number">2</span>)</span><br><span class="line">        merge_left = merge_sort(li[:mid])</span><br><span class="line">        merge_right = merge_sort(li[mid:])</span><br><span class="line">        <span class="keyword">return</span> merge_li(merge_left, merge_right)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)                  <span class="comment"># [8, 7, 6, 2, 1, 4, 5, 0, 3, 9]</span></span><br><span class="line"><span class="built_in">print</span>(merge_sort(ll))      <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>​    最后，从分析和 diamante 实现可知，归并排序每一次循环都会减少一半的循环对象，所以时间复杂度上是 O(nlogn) ，给归并的方法中由于创建了一个新的列表去进行 append 的操作，所以空间复杂度上是 O(n) 的</p><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>​    计数排序适用于数据范围不大的场景，其特点就是计数和范围。在计数之前，需要确定出数据的范围，注意这个范围并不是指数组的长度，而是数组中的最大值。然后利用这个值作为新的数组的长度值，同时将新数组的每一个索引对应的元素赋值为 0，这么做的目的就是为了后面循环时进行累计计数的操作，注意这里新的数组长度需要在最大值上 + 1，</p><p>​    简单来说，就是确定出最大值后，按照这个最大值划分出一个个桶，有点类似桶排序的操作，但是在桶内不是存放实际数据，而是通过遍历操作进行累加。例如，数组是 [2,6,3,3,5]，得到最大值是 6 后创建出 [0,0,0,0,0,0,0] 的数组，然后将新的数组的下标当做是原数组的值，新数组的值则是对应原数据的出现次数，那么经过遍历后就得到了 [0,0,1,2,0,1,1]</p><p>​    接下来就是计数的操作，这里会在前面的新数组上再次遍历，将小于等于的元素做累加计数，也就是数组的索引对应的元素的前一位元素的和</p><p>​    注意这个计数操作的遍历，需要从索引 1 开始，因为按照范围创建的数组长度的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数组 = [2, 6, 3, 3, 5]</span><br><span class="line">范围遍历后的数组 = [0, 0, 1, 2, 0, 1, 1]   对应原数组数据的计数</span><br><span class="line"> 0  1  2  3  4  5  6    这里索引 index 同时也是原数组的数据元素</span><br><span class="line">小于等于的计数数组 = [0, 0, 1, 3, 3, 4, 5]   对应数据的小于等于的计数</span><br><span class="line">   0  1  2  3  4  5  6    索引 index 同时也是原数组的数据元素</span><br></pre></td></tr></table></figure><p>​    然后就是计数排序的关键部分，需要将原数组反向遍历，将得到的数组作为索引去找到计数数组对应的元素，例如 5 对应的计数数组中的元素是 4，那么经过计数排序后，这个 5 应该出现的位置是 4 - 1，也就是索引 3 的位置，同时对应的 计数数组的元素 4 也需要减去 1，将其值变为 3。简单理解就是说将计数数组中小于等于元素 4 的一个数从计数中排除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">原数组 = [2, 6, 3, 3, 5]</span><br><span class="line">计数排序数组 = [0, 0, 0, 0, 0, 0, 0]      计数数组 = [0, 0, 1, 3, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">1）原数组倒数第一位开始遍历，得到 5，得到计数数组的元素 4，4 - 1 = 3，计数排序数组[3] = 5</span><br><span class="line">计数排序数组 = [0, 0, 0, 5, 0, 0, 0]      计数数组 = [0, 0, 1, 3, 3, 3, 5]</span><br><span class="line"></span><br><span class="line">2）原数组倒数第二位开始遍历，得到 3，得到计数数组的元素 3，3 - 1 = 2，计数排序数组[2] = 3，计数数组[3] = 2</span><br><span class="line">计数排序数组 = [0, 0, 3, 5, 0, 0, 0]      计数数组 = [0, 0, 1, 2, 3, 3, 5]</span><br><span class="line"></span><br><span class="line">3）原数组倒数第三位开始遍历，得到 3，得到计数数组的元素 3，2 - 1 = 1，计数排序数组[1] = 3，计数数组[3] = 1</span><br><span class="line">计数排序数组 = [0, 3, 3, 5, 0, 0, 0]      计数数组 = [0, 0, 1, 1, 3, 3, 5]</span><br><span class="line"></span><br><span class="line">4）原数组倒数第四位开始遍历，得到 6，得到计数数组的元素 5，5 - 1 = 4，计数排序数组[4] = 6</span><br><span class="line">计数排序数组 = [0, 3, 3, 5, 6, 0, 0]      计数数组 = [0, 0, 1, 1, 3, 3, 4]</span><br><span class="line"></span><br><span class="line">5）原数组倒数第五位开始遍历，得到 2，得到计数数组的元素 1，1 - 1 = 0，计数排序数组[0] = 2</span><br><span class="line">计数排序数组 = [2, 3, 3, 5, 6, 0, 0]      计数数组 = [0, 0, 0, 1, 3, 3, 4]</span><br></pre></td></tr></table></figure><p>​    由此可见，最后计数排序得到数组就完成了对原数组的排序，但是为了实现原地排序操作，可以对原数组在做一次遍历，每一个索引对应的新的元素就是计数排序后的数组索引对应的元素，从而将值进行替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">li, n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">max</span> = li[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span> &lt; li[i]:</span><br><span class="line">            <span class="built_in">max</span> = li[i]</span><br><span class="line"></span><br><span class="line">    a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>+<span class="number">1</span>)]</span><br><span class="line">    b = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a[li[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">max</span>+<span class="number">1</span>):</span><br><span class="line">        a[i] = a[i-<span class="number">1</span>] + a[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        index = a[li[i]] - <span class="number">1</span></span><br><span class="line">        b[index] = li[i]</span><br><span class="line">        a[li[i]] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        li[i] = b[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">li = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(count_sort(li, <span class="built_in">len</span>(li)))     <span class="comment"># [1, 2, 3, 3, 5, 5, 6, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>​    堆（heap），其实可以看作是一个完全二叉树，通常又分大根堆和小根堆，两者的区别是，<strong>大根堆中任意一个节点都要大于它的孩子节点，小根堆则正好相反</strong></p><p>​    <strong>堆排序的时间复杂度是 O(nlogn)，并且是原地排序算法</strong>，因为堆排序不借助其余数组，而是在原数组上进行排序</p><p><img src="https://wei-foun.github.io/img/%E5%A0%86.jpg" alt="img"></p><p>​    堆排序的过程：</p><p>​    1）构建堆，以大根堆为例</p><p>​    2）得到堆顶的元素为最大元素</p><p>​    3）去掉堆顶元素，将堆最后一个元素移至堆顶，通过调整再次得到有序的大根堆</p><p>​    4）移除堆顶元素，即作为第二大的元素</p><p>​    5）重复开始步骤 3），直到堆为空</p><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_6_0.gif" alt="排序（6）：堆排序"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift</span>(<span class="params">li,low,high</span>):</span><br><span class="line">    <span class="comment"># 对树进行向下调整，li 表示树，low 表示当前树的根节点位置，high 表示树最后的节点位置</span></span><br><span class="line">    tmp = li[low]</span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="comment"># while 判断左右子节点是否小于 high，如果 j 超出 hight，表示指针 i 所在位置已经是堆中最后的节点</span></span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># j + 1 表示右子节点，判断是否该节点是否存在，且左小于右</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 条件通过，j 就 +1，将 j 指向右节点位置</span></span><br><span class="line">        <span class="keyword">elif</span> li[j] &gt; tmp:</span><br><span class="line">            <span class="comment"># 判断 li[j] 表示的左节点或右节点是否大于他们父节点</span></span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            <span class="comment"># 条件通过，表示子节点中的值是大于当前的父节点，将父节点的位置的值变为子节点的值</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="comment"># 同时，为了向后继续遍历，将父节点的 i 指针指向子节点的 j 指针，来遍历后一个子树的父子节点</span></span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 并重新计算 j 指针指向的子树结构的左节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果上面都不满足，说明 i 指针的父节点大于 j 指向的子节点，不需要调整指针，直接退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line">    <span class="comment"># 循环结束，说明当前堆结构调整完成，将 i 指针位置的父节点还原</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">li</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):    <span class="comment"># 任何一个子节点找父节点都是 len(li) // 2 - 1</span></span><br><span class="line">        <span class="comment"># 构建堆，是自下而上操作，时间复杂度是 O(logn)</span></span><br><span class="line">        sift(li, low, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 依次出数，是自上而下操作，时间复杂度是 O(logn)</span></span><br><span class="line">        li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">        sift(li, <span class="number">0</span>, high-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)                   <span class="comment"># [0, 7, 4, 5, 3, 6, 9, 1, 2, 8]</span></span><br><span class="line"><span class="built_in">print</span>(heap_sort(ll))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>​    堆的概念和之前的几个排序相比理解上复杂很多，但是堆也是一个很实用的数据结构，对于 top-k 的问题，使用堆排序可以快速方便的得到结果</p><p>​    首先，在 sift 的函数中接收三个参数，分别是 树，树的根节点位置，最后节点的位置；同时，函数内部用了三个变量来做递进，tmp 表示当前树根的根节点元素（注意：不会一直是堆顶的那个根元素，在遍历中是会产生改变的），i 被赋予参数 low 的值，表示父节点的位置，j 则就是左子节点的位置 2 * i + 1；从动态的演示图中，可以知道构建大根堆的调整是从最后的父子节点开始的，所以循环的条件就是 j（左子节点的位置）最后一定是要小于等于树最后的节点的位置（就是小于或等于列表的长度），因为左子节点一定是小于右子节点的，是右子节点位置 -1 的，j &gt; high 就说明 i 的位置已经是叶子节点了，也就是说 i 代表的父节点已经是列表最后一位，没有后续的子节点了，即此时堆的调整应该结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> j &lt;= high:</span><br><span class="line"><span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    接着是循环内的第一个判断，j 表示为左节点位置，+1 就表示右节点位置，和循环条件一样，右节点必须是小于等于最后的节点的位置，= 表示当前调整的树是整个堆最后的一个子树，&lt; 则表示前面或者上一层的子树，但是这个条件并不足以判断是否调整父子节点位置，另外还需要比较的是左节点和右节点的大小，<code>li[j] &lt; li[j+1]</code> 表示左边小于右边，那么就将 j + 1，也就是指向其中大的那个节点。所以这个判断表示的意思是判断是否存在右节点，并且判断大小，如果右边的大，j 指向右边，这一步的目的是为了从子节点中选出大的那个子节点，将 j 的指针指向该节点，在后续操作中，调整 i 和 j，即将父节点替换为比它大的子节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> li[j] &gt; tmp:</span><br><span class="line">   li[i] = li[j]</span><br><span class="line">   i = j</span><br><span class="line">   j = <span class="number">2</span> * i + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    这个判断语句，首先是  <code>li[j] &gt; tmp</code> 表示，左节点或者是上面的 if 判断通过后的右节点，与他们的父节点进行大小比较，如果大于则表示，这个子树是要进行调整的，将 <code>li[i] = li[j]</code> ，表示将原本父节点的位置替换为子节点，完成后将 i 重新赋值为 j，j 重新改为 2 * i + 1，作为下一次递进后的左节点</p><p>​    最后一个 else 的判断的语句中直接 break 退出循环了，所表示的是当前的左或者右两个节点的值都小于父节点，也就是说不需要进行子树调整</p><p>​    函数的最后还有一个 <code>li[i] = tmp</code>， 表示的是将原来的父节点赋值给叶子节点，这里的 i 之所以是叶子节点，是因为经过 while 循环后 i = j ，这个 i 成为了上次调整后的左或右的节点，而最后的左和右就是上一次的叶子节点；也就是说，将原本小于左右的父节点赋值给其中的子节点</p><p>​    这里其实可以再优化一下，因为 tmp 变量的目的最后其实就是为了将父子交换，所以上面的代码可以省去 <code>tmp = li[low]</code> 这行，并将循环判断中的父子判断改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> j &lt;= high:</span><br><span class="line">    <span class="keyword">if</span> j+<span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> li[i] &lt; li[j]:</span><br><span class="line">        li[i], li[j] = li[j], li[i]</span><br><span class="line">        i = j</span><br><span class="line">        j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>​    那么，上面的整个 sift 的函数其实就是实现了堆的调整，然后就是 heap_sort 函数了，这其中涉及了递归调用，去将列表初始化为堆，并且完成调整后，挨个进行出去并同时调整返回最后需要的有序的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    sift(li, low, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​    函数里的第一个循环就是用来构造堆的，这里的 n 表示的是给的数组的长度，也就是堆的节点数，上面也说了从动态演示中，对于堆的调整是从数组右后往前的，所以在构造堆时，要确定传入的 low 和 high 的值，依然是从后开始，那么 high 的参数可以设为 <code>len(li)-1</code>，就是代码中的 n-1，因为将 high 的值设为最后一个节点位置，不会影响堆递进的调整，因为不管是堆中那一个部分需要进行调整，都不会超过最后一个位置的范围，而且 sift 函数都是对各自的子树去调整，最终都是调整父与左右两个子节点的关系，所以不会影响到堆的调整</p><p>​    然后就是 low 的值了，堆的调整都是父节点和左右子节点比较出大的然后调整，所以 low 参数可以设为父节点的位置，因为 n - 1 是最后的节点，那么对应父节点就是式子：</p><p>​    <code>( i - 1 ) // 2 = ( n - 1 - 1 ) // 2 = ( n - 2 ) // 2 = n // 2 - 1</code></p><p>​    那么最后的父节点在堆中的位置就是 len(li) // 2 - 1，最后通过循环，设一个步长为 -1 的 range(n//2-1, -1, -1)，就可以依次去调整每一个父节点的子树，也就是完成了堆的构造</p><p>​    构造堆之后，就是排序的步骤了，在 sift 函数中会去对堆去调整，再加上调整后的堆是大根堆，接下来的排序只需要将堆顶取出和最后的节点交换即可，每交换一次便会从新调整一次得到一个新的大根堆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">    sift(li, <span class="number">0</span>, high-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​    在这个循环中，high 的值是从最后一个节点的位置开始，以 -1 步长向前取值，然后交换 <code>li[0], li[high]</code>，实现将堆顶的最大元素和队尾进行交换，同时再去使用 sift 去调整重新构造的新的大根堆，注意这里 high 的参数是：遍历出来的 high - 1，也就是将刚才已经放到队尾的最大值排除，防止再次被交换调整，这样递进上去，就可以实现对堆的排序了</p><p>​    对于 堆 这个结构，python 还提供了 <strong>heapq</strong> 这个模块来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">li</span>):</span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> li:</span><br><span class="line">        heapq.heappush(h, value)</span><br><span class="line">    <span class="keyword">return</span> [heapq.heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)              <span class="comment"># [4, 5, 9, 2, 0, 1, 8, 3, 6, 7]</span></span><br><span class="line"><span class="built_in">print</span>(heap_sort(ll))   <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># 可以看到使用 heapq 模块也能实现堆排序，类似 sorted 方法，但是与 sorted 的排序不同的是，heapq 模块实现的堆排序不是稳定的</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># heapq 模块常见的函数</span></span><br><span class="line">heapq.heappush(head, itrm)    <span class="comment"># 将 item 将入到堆中，且保持堆的不变性</span></span><br><span class="line">heapq.heappop(head)           <span class="comment"># 弹出并返回 heap 的最小元素，且保持堆的不变性，如果堆为空，抛出 IndexError，使用 head[0] 只能访问最小元素但是不会进行弹出</span></span><br><span class="line">heapq.heappushpop(head, item)     <span class="comment"># 相当于是 push 和 pop 的整合，先将 item 将入堆，并弹出返回最小元素，heappushpop 要比上面的两个方法执行起来更有效率</span></span><br><span class="line">heapq.heapify(x)              <span class="comment"># 将 列表x 原地转换为 堆 的结构，是一个 小根堆 结构</span></span><br><span class="line">heapq.heapreplace(head, item)     <span class="comment"># 和 heappushpop 相反，是先将最小项弹出返回后，将新的 item 将入到堆中，保持堆不变性，同样比联合使用 push 和 pop 在单步操作上更有效率，并且如果堆为空，也会抛出 IndexError </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># headpreplace 方法有一个问题，因为毕竟是先进行弹出，再去添加，就会导致可能这个方法返回的值会比添加的 item 值要大，不过不希望如此，可以使用 heappushpop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，heappush 方法也可以去传入元组，这样形式适用于例如任务优先级与跟踪主记录赋值的场景</span></span><br><span class="line">h = []</span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>, <span class="string">&#x27;write code&#x27;</span>))    <span class="comment"># 元素的第一个值代表优先级</span></span><br><span class="line">heapq.heappush(h, (<span class="number">7</span>, <span class="string">&#x27;release product&#x27;</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>, <span class="string">&#x27;write spec&#x27;</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">3</span>, <span class="string">&#x27;create tests&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(h))     <span class="comment"># (1, &#x27;write spec&#x27;)</span></span><br></pre></td></tr></table></figure><h5 id="Top-k-问题"><a href="#Top-k-问题" class="headerlink" title="Top-k 问题"></a>Top-k 问题</h5><p>​    top-k 是堆结构的典型使用场景，但不说其他的方式就不能实现。比如时间复杂度都为 O(n²) 的冒泡排序，选择排序，插入排序，可以用这三个任何一个对数组进行整体的排序，但是只需要遍历 k 次就可以获取最大的 k 个元素，也就是说最多就需要遍历 k 次就够了，所以对于 top-k 问题，使用这三个算法排序后，就不再是对列表中 n 个元素去进行二次遍历，最后的时间复杂度就是 O(kn)</p><p>​    也可以使用理论上时间复杂度都是 O(nlogn) 的快速排序，归并排序，然后通过切片操作，再去获取到最大的 k 个，那整体上来说，切片只是遍历了 k 次，那最后时间复杂度是 O(nlogn+k)</p><p>​    如果使用堆排序，相对上面的方法，在时间复杂度上会更优。<strong>整体思路，先将列表前面 k 个元素，构建一个小根堆的结构，那对于 k 个元素的堆构建，这个时间复杂度上是 O(klogk)。然后，将列表在 k 位置之后的元素遍历，与前面小根堆的根节点比较大小</strong>，如果元素大于根节点的值，就替换这个根节点，如果结构不满足小根堆，那就是说需要进行一次堆调整，调整后将最小节点作为根节点，那这一步的操作，时间复杂度首先是 n-k 个元素的遍历，然后就是堆调整的 logk，因为每一次遍历都可能需要调整，所以就是 (n-k)(logk)，即 O(nlogk - klogk)，<strong>最后的时间复杂度就是 O(klogk) + O(nlogk - klogk)，即 O(nlogk)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift</span>(<span class="params">li, low, high</span>):</span><br><span class="line">    <span class="comment"># 构建小根堆</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[i] &gt; li[j]:</span><br><span class="line">            li[i], li[j] = li[j], li[i]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">top_k</span>(<span class="params">li, k</span>):</span><br><span class="line">    heap = li[:k]</span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(k//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift(heap, low, k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift(heap, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[high] = heap[high], heap[<span class="number">0</span>]</span><br><span class="line">        sift(heap, <span class="number">0</span>, high-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h4><p>​    二分法查找是非常常见的一个查找的算法，相比起线性查找来说，时间复杂度上从 O(n) 变成了 O(logn)，这种提升就是因为二分法每一次都会省去一半的数量，即 n，n/2，n/4，n/8，n/2^k，那么当 n/2^k = 1 时，即 2^k = n，即 k = log₂n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性查找       O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search</span>(<span class="params">data_set, value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">range</span>(data_set)):</span><br><span class="line">        <span class="keyword">if</span> data_set[i] == value:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 二分法查找     O(logn)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, num</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; num:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">li.sort()</span><br><span class="line"><span class="built_in">print</span>(li)                       <span class="comment"># [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 12]</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">10</span>))       <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">6</span>))        <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>​    二分法查找，从字面理解就是将原列表拆分进行查找，也就是以列表的中间元素为断点拆分两个列表，然后判断这个中间元素与要查找元素的大小，大于就表示要查找的元素是在右边的列表中，反之，小于则表示被查元素是在左边的列表中；<strong>注意：使用 二分法 的前提是 可迭代元素 是 有序的</strong></p><p>​    <strong>另外，需要注意的是，对于 mid 的计算   <code>mid = (low + high) // 2</code> 实际上是会有问题的，因为 low 和 high 的值如果很大则有可能造成溢出，所以可优化成 <code>mid = low + (high - low) // 2</code>。那么对于除法的优化，则是可以用位置来计算，可以优化成 <code>mid = low + ((high - low) &gt;&gt; 1)</code></strong></p><p>​    经过第一次二分，就将要搜索的范围减少了一半，后续的操作就是循环地去对被查元素所在的列表进行二分，直到最后中间元素等于被查元素，就表示找到了，这个中间元素的下标索引就是被查元素在原列表的中索引位置，如果二分到最后列表只有两个元素，那么计算后得到的中间下标索引就是 0 ，也就是第一个元素和被查元素不相等，需要作出一个返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版本的二分法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, num, low, high</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; num:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li, num, low, mid - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li, num, mid + <span class="number">1</span>, high)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">li.sort()</span><br><span class="line"><span class="built_in">print</span>(li)                              <span class="comment"># [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 12]</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">len</span>(li)))  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">6</span>, <span class="number">0</span>, <span class="built_in">len</span>(li)))   <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>​    使用 二分法 去查找的时候，不一定得到就是完全正确的目标索引位置，因为如果列表的元素是允许有重复的，且要查找的元素正好能在 mid 的位置上，那么如果 mid 前面的元素和目标值是一致的，那么就不能返回目标值在列表中第一次出现的位置</p><h4 id="二分法查找（元素第一次出现的位置）"><a href="#二分法查找（元素第一次出现的位置）" class="headerlink" title="二分法查找（元素第一次出现的位置）"></a>二分法查找（元素第一次出现的位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    l, h = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = (l + h) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">while</span> mid != <span class="number">0</span> <span class="keyword">and</span> nums[mid-<span class="number">1</span>] == nums[mid]:</span><br><span class="line">                <span class="comment"># 从 mid 位置向前遍历，判断值是否一致，一致就将 mid - 1，同时 mid 不能为 0</span></span><br><span class="line">                mid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">       <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            r = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    上面的思路其实很容易理解，就是在通过二分法确定了查找的元素后，在该元素的位置往前遍历，因为实现二分法的前提是数据是有序排列的，所以通过向前遍历判断从而得到元素第一次实现的位置</p><p>​    除了上面的这种判断外，当 nums[mid] == target，还可以通过一下代码实现判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">    <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> nums[mid - <span class="number">1</span>] != target: <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span>: high = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    两段判断代码的思路其实大体来说是一致的，不同之处是前者是 and 判断，后者是用 or。后者的一个注意点是 high 这个变量，如果 mid 不为 0 或者是 nums[mid - 1] = target 了，其实就是说明要么 mid 已经到最低位了，即表示 mid 就是查询元素的第一次出现的位置了，要么就是 mid 不在最低位，而 nums[mid - 1] 又不等于 target，也就是说 mid 已经是第一次出现的位置。当两个条件都不满足时，就表示需要调整范围，也就是调整 high 这个变量，因为 mid 的区间总是 low 到 high 位，所以两个条件都不满足，high 则等于 mid - 1</p><h4 id="二分法查找（大于等于查找元素的第一次出现位置）"><a href="#二分法查找（大于等于查找元素的第一次出现位置）" class="headerlink" title="二分法查找（大于等于查找元素的第一次出现位置）"></a>二分法查找（大于等于查找元素的第一次出现位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, h = <span class="number">0</span>, <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = (l + (h - l) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> li[mid] &gt;= t:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> li[mid - <span class="number">1</span>] &lt; t:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">7</span>))    <span class="comment"># 5   li[5] = 8</span></span><br></pre></td></tr></table></figure><p>​    同样是二分法的变题，但相对而言代码上则简单一些，因为查找大于等于目标值的第一次位置，实际上目标值的区间就会是在 mid + 1 到 high 的区间内，所以 mid 的值小于目标值，只要更改 low 的位置为 mid +1 即可，而大于等于则是同样的逻辑，所以可以少了 if 的判断</p><p>​    当 mid 的值大于等于目标值，一旦 mid 最后计算后是 0 就是查找结束了，mid 的值就可以返回。或者是 mid - 1 的值小于了目标值，也是表示 mid 位置的值是大于等于目标值的第一个位置，也可以直接返回。而两个条件都不满足，则就更改 high 的位置，让 high 为 mid - 1 这样就可以排除后面大于目标值的一个元素</p><h4 id="二分法查找（元素出现的最后位置）"><a href="#二分法查找（元素出现的最后位置）" class="headerlink" title="二分法查找（元素出现的最后位置）"></a>二分法查找（元素出现的最后位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, n, = <span class="number">0</span>, <span class="built_in">len</span>(li)</span><br><span class="line">    h = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = l + (h - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] &lt; t:</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; t:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == n - <span class="number">1</span> <span class="keyword">or</span> li[mid + <span class="number">1</span>] != t:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">5</span>))    <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>​    查找元素最后的出现的位置，大体上和查找第一次出现位置是类似的，不同之处是就是在等于查找元素时，内部的判断逻辑上，查找的区间是在 mid + 1 到 high。当 mid 指向的值和目标值一致，就要从 mid 开始往后查找，但同样是有两个条件，如果 mid 是数组的最后的一个元素，那必然就是最后的位置，如果 mid + 1 指向的值不等于目标值，也就是说 mid 所在位置的目标值就是最后出现的位置。如果两个条件都不满足，就要将区间头部 + 1，也就是 mid + 1</p><p>​    另外，要注意的是上面除了 low 和 high 两个变量外，还有一个变量 n，所表示的就是数组的最后一位</p><h4 id="二分法查找（小于等于查询元素的最后出现位置）"><a href="#二分法查找（小于等于查询元素的最后出现位置）" class="headerlink" title="二分法查找（小于等于查询元素的最后出现位置）"></a>二分法查找（小于等于查询元素的最后出现位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, n = <span class="number">0</span>, <span class="built_in">len</span>(li)</span><br><span class="line">    h = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = l + (h - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] &gt; t:</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == n - <span class="number">1</span> <span class="keyword">or</span> li[mid + <span class="number">1</span>] &gt; t:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">7</span>))   <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​    思路同理于查找大于等于的第一次出现位置，只是实现上正好相反。由于是查找最后的位置，所以同样需要 n 这个变量来记录数组最后的索引。查找小于等于的最后位置，那么实际的查找区间就是 low 到 mid - 1，所以当 mid 指向的值大于目标值，high 就要在 mid 上减 1</p><p>​    当 mid 指向的值小于等于目标值时，就需要判断 mid，如果 mid 是数组最后的一位，那就是小于等于的最后位置，如果 mid + 1 的值大于了目标值，表示 mid 的位置就是小于等于目标值的最后位置。如果两个条件都不满足，就需要改变区间，因为是查找最后位置，所以 low 就是 mid + 1</p><h4 id="旋转排序数组查找"><a href="#旋转排序数组查找" class="headerlink" title="旋转排序数组查找"></a>旋转排序数组查找</h4><p>​    该数组不同正常排序的数组，是在某一个位置进行拆分，将拆分的两个数组位置互换，然后在这个数组中查询指定的元素索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, n = <span class="number">0</span>, <span class="built_in">len</span>(li)</span><br><span class="line">    h = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = l + (h - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == t:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[<span class="number">0</span>] &lt;= li[mid]:</span><br><span class="line">            <span class="keyword">if</span> li[<span class="number">0</span>] &lt;= t &lt; li[mid]:</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> li[mid] &lt; t &lt;= li[n-<span class="number">1</span>]:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(search(li, <span class="number">1</span>))    <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>​    本题简单的思路是可以找到数组的旋转位置，这样就能得到左右两边都是有序的数组，再判断目标值与两个数组的第一个元素，以此确定目标值所在的数组，再利用二分法进行查找。这种方式实现要简单一些，但是会多一些判断逻辑</p><p>​    然后就是上面代码的方式，整体上和普通二分法类似，区别同样是逻辑判断的处理上。首先的一个判断就是 mid 的位置元素是目标值，这样就直接把 mid 返回，如果不等于目标值，就相当于利用这个 mid 将数组分割成左右两部分，两个部分中至少有一个数组是有序的</p><p>​    假设左边是有序的，即区间范围是 [ low, mid )，即 0 的位置元素是小于等于 mid 指向的元素，接下来需要再次进行判断，从而修改 low 或 high 指向的位置。如果目标值大于等于 0 位置的元素，且小于 mid 指向元素，表明目标值在这个有序范围内，那么就要控制 high 的指向，变为当前 mid -1 的位置，从而缩减不必要的部分。反之，则表明目标值不在 0 到 mid 这个范围内，那么 low 的位置就需要改为 mid + 1，舍去掉 0 到 mid 有序的部分</p><p>​    如果一开始 mid 位置的元素要小于 0 位置的元素，那么则表明 mid 之后是有序的，同样需要进行后续的判断更改 low 或 high。如果目标值大于 mid，且小于等于原数组最后一个元素，说明目标值在该范围内，就需要将 low 改为 mid + 1，反之就是更改 high 为 mid - 1</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest_Framework-整理</title>
      <link href="/685301591/"/>
      <url>/685301591/</url>
      
        <content type="html"><![CDATA[<h3 id="序列化-Serializer"><a href="#序列化-Serializer" class="headerlink" title="序列化 Serializer"></a>序列化 Serializer</h3><h4 id="django-的-serializers"><a href="#django-的-serializers" class="headerlink" title="django 的 serializers"></a>django 的 serializers</h4><p>​    django 本身自带了序列化的组件 serializers（djang.core.serializers），这个序列化器使用 serialize 方法来进行对象的序列化，该方法接收两个参数，format 表示要序列化的格式，通常就是 json，第二个是 instance，要对模型类的对象序列化传给前端就可以使用这个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> course.models <span class="keyword">import</span> Course</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line">s = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, Course.objects.<span class="built_in">all</span>())</span><br><span class="line"><span class="comment"># 返回的 s 就是一个 json 字符串，模型类的所有记录都会被序列化，</span></span><br><span class="line"></span><br><span class="line">s = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, Course.objects.<span class="built_in">all</span>(), fields=(<span class="string">&quot;course_name&quot;</span>, <span class="string">&quot;course_detail&quot;</span>))</span><br><span class="line"><span class="comment"># 如果针对只需要几个字段序列化，可以使用 fields 去指定</span></span><br></pre></td></tr></table></figure><p>​    注意，django 组件中 serializers 的序列化器，对模型类的实例做序列化时，如果一个模型类中有外键关联字段，那么使用 serialize 方法序列化后，并不能直接得到外键关联的对象，而是只能得到外键关联到的字段的值，如果一个 foreign key 关联的是用户表的用户主键，那么最后的 json 数据里序列化的结果就是用户表中的主键 id</p><p>​    另外，django core 中的 serializers 序列化支持的功能有限，如果要在前后端分离的项目中使用，这个序列化器首先不能对前端的数据做校验，数据校验需要自己提取 request.data 里的数据做校验处理。同时，后端对模型类中的实例序列化时，也不能加入自定义的数据，而且序列化多个对象还需要自己处理分页等功能。此外，如果序列化的数据出现异常，要返回给前端的结果，也需要自己再去做对应的处理</p><h4 id="drf-的-serializers"><a href="#drf-的-serializers" class="headerlink" title="drf 的 serializers"></a>drf 的 serializers</h4><p>​    drf 的序列化器，需要从 rest_framework 中导入 serializers，用法和 django 的 orm 非常类似，根据 models 中的模型类定义对应的 serializer</p><p>​    <strong>补充：字段的参数</strong></p><table><thead><tr><th>参数名称</th><th>作用</th></tr></thead><tbody><tr><td><strong>max_length</strong></td><td>最大长度</td></tr><tr><td><strong>min_lenght</strong></td><td>最小长度</td></tr><tr><td><strong>allow_blank</strong></td><td>是否允许为空</td></tr><tr><td><strong>read_only</strong></td><td>表明该字段仅用于序列化输出，默认False</td></tr><tr><td><strong>write_only</strong></td><td>表明该字段仅用于反序列化输入，默认False</td></tr><tr><td><strong>required</strong></td><td>表明该字段在反序列化时必须输入，默认True</td></tr><tr><td><strong>default</strong></td><td>反序列化时使用的默认值</td></tr><tr><td><strong>error_messages</strong></td><td>包含错误编号与错误信息的字典</td></tr><tr><td><strong>label</strong></td><td>用于HTML展示API页面时，显示的字段名称</td></tr><tr><td><strong>help_text</strong></td><td>用于HTML展示API页面时，显示的字段帮助提示信息</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>, verbose_name=<span class="string">&quot;课程名称&quot;</span>, help_text=<span class="string">&quot;课程名称&quot;</span>, null=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    introduction = models.TextField(verbose_name=<span class="string">&quot;课程介绍&quot;</span>, help_text=<span class="string">&quot;课程介绍&quot;</span>)</span><br><span class="line">    teacher = models.ForeignKey(settings.AUTH_USER_MODEL,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                verbose_name=<span class="string">&quot;讲师&quot;</span>,</span><br><span class="line">                                help_text=<span class="string">&quot;讲师&quot;</span>,</span><br><span class="line">                                )</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>,</span><br><span class="line">                                help_text=<span class="string">&quot;课程价格&quot;</span>,</span><br><span class="line">                                verbose_name=<span class="string">&quot;课程价格&quot;</span>)</span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>, verbose_name=<span class="string">&quot;创建日期&quot;</span>)</span><br><span class="line">    updated_at = models.DateTimeField(auto_now=<span class="literal">True</span>, verbose_name=<span class="string">&quot;更新日期&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        verbose_name = <span class="string">&quot;课程表&quot;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        ordering = (<span class="string">&#x27;price&#x27;</span>, )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line"><span class="comment"># ------- serializers.py -----------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseSerializer</span>(serializers.Serializer):</span><br><span class="line">    name = serializers.CharField()</span><br><span class="line">    introduction = serializers.CharField()</span><br><span class="line">    price = serializers.CharField()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>​    然后在视图中，只需导入整个 CourseSerializer 就可以使用了，比如前端通过 course_list 的 api 请求课程的资源，就要实例化 CourseSerializer 对象，并传入查询集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; get，从模型类获取对象，序列化返回给前端&quot;&quot;&quot;</span></span><br><span class="line">    objs = CourseSerializer(instance=Course.objects.<span class="built_in">all</span>(), many=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 因为 ORM 的 all 获取到的是多个对象，所以序列化需要 many=True 这个参数，表示对多个实例做序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response(data=objs.data, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure><p>​    <strong>补充：如果只是模型中普通字段的展示，使用例如 serializers.CharField() 就可以了，但对于一些外键关联的字段，例如一对多，或多对多，且又可能还需要做一些逻辑处理，则需要使用 serializers.SerializerMethodField()</strong></p><p>​    <strong>当一个序列化字段使用 SerializerMethodField 来做展示时，则需要对应在序列化类中定义 <code>get_字段名</code> 的方法，且需要接受一个参数 obj，表示传递进来的查询集对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">recommend_courses = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_recommend_courses</span>(<span class="params">self, obj</span>):</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: item.pk,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: item.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> obj.recommend_courses.<span class="built_in">all</span>()</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>​    当前端通过 api 要创建一个课程时，会将对应的键值数据传递给后端，只需将数据给到序列器，就能实现对数据的创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; post，从前端接收到序列化的数据，进行反序列化，并校验数据，通过则保存，否则就返回异常&quot;&quot;&quot;</span></span><br><span class="line">    data = CourseSerializer(data=request.data, partial=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># partial=True，表示 data 中数据不需要满足 models 中所有字段，只有部分字段，也可以更新和创建</span></span><br><span class="line">    <span class="comment"># ！！但是如果 models 中设定了字段的约束，比如不能为空，那么 data 中必须有这个数据，否则校验就不通过</span></span><br><span class="line"></span><br><span class="line">    data.teacher = request.user</span><br><span class="line">    <span class="keyword">if</span> data.is_valid():</span><br><span class="line">        <span class="comment"># data.save(teacher=request.user)</span></span><br><span class="line">        data.save()</span><br><span class="line">        <span class="keyword">return</span> Response(data=data.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="comment"># ！！注意，Response 中的 data，要是 Serializer 序列化后对象的 data，而不能直接将 Serializer 对象给 Response</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(data.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>​    <code>data = CourseSerializer(data=request.data, partial=True)</code> 会创建出 serializer 对象</p><p>​    注意，上面对 data 的 teacher 属性的赋值，这个值是 request.user，其实就是当前登录用户对象，也就是对应的用户表的实例，因为在 Course 表中 teacher 是外键，关联到用户表，而前端在提交数据时，无需给到后端 teacher_id 这个表字段的 id，因为创建 Course 默认用当前登录用户，所以在使用 save 时，需要给已经将前端数据序列化后的 data 对象，加上 teacher 字段的值</p><p>​    如果是前端的数据给到后端，CourseSerializer 的实例化中需要使用 data 参数，值就是 request.data，因为基本前端过来的格式是 json 数据，都会放在请求对象的 data 中</p><p>​    <strong>前端到后端，即反向序列化，序列化类在实例化时，参数使用 data，值是 request 中的 data</strong></p><p>​    <strong>后端到前端，即正向序列化，序列化类在实例化时，使用 instance 参数，值就是 orm 查询的查询集对象</strong></p><p>​    <strong>另外，如果前端执行的更新操作，那么在序列化时，需要同时使用 instance 和 data 两个参数，instance 表示的是要更新的那条记录的实例，data 就是前端提交的要更新的键值数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;PUT&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">course = Course.objects.get(<span class="built_in">id</span>=course_id)</span><br><span class="line"> <span class="keyword">except</span> Course.DoesNotExist:</span><br><span class="line"><span class="keyword">return</span> Response(data=&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;没有该课程&quot;</span>&#125;, status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">    obj = CourseSerializer(instance=course, data=request.data)</span><br><span class="line">    <span class="keyword">if</span> obj.is_valid():</span><br><span class="line">        obj.save()</span><br><span class="line">        <span class="comment"># 这里不需要在设置 teacher 的字段，因为更新操作的请求 data 中包含了这个字段</span></span><br><span class="line">        <span class="keyword">return</span> Response(data=obj.data, status=status.HTTP_201_CREATED)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(data=obj.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>​    <strong>补充：</strong> 实例化序列化对象的过程中，<strong>如果要额外加入自定义的数据，可以使用 context 的参数</strong>，将键值数据给到字典，传递给 context</p><p>​    <strong>前端的数据序列化完成后，得到序列化对象，需要先调用 is_valid 方法进行数据校验，验证通过返回 True，否则就是 False</strong>，不通过时，序列化器对象的 errors 的属性会包含错误信息，这和 django 的 form 组件的流程是一致的，通过验证的数据，可以从 validated_date 中获取。另外 is_valid 的方法可以设置 raise_exception=True 来设置当数据验证不通过抛出 serializers.ValidationError 时，直接给前端返回 HTTP 400 Bad Request 的响应</p><p>​    通过校验后，就是保存数据，使用序列化器对象的 save 方法，就可以实现创建或更新。<strong>save 方法内部会判断创建这个序列化对象时，会判断 self.instance 是不是空（即实例化序列化时是否传入了 instance 参数），没有的话就调用模型类的 create 方法创建记录，如果有传递 instance 就表示是更新操作，就会调用 update 方法</strong></p><h4 id="serializers-的钩子"><a href="#serializers-的钩子" class="headerlink" title="serializers 的钩子"></a>serializers 的钩子</h4><p>​    drf 中 serializers 的功能与 django 的 form 组件相似，除了能做序列化外，也有 form 组件一样的功能去校验字段的数据，form 有局部和全局钩子，drf 的 serializers 也一样支持钩子函数来对字段做额外的校验</p><p>​    <strong>局部钩子 validate_字段</strong>，对单个字段做自定义的校验，可接受一个参数 value，即规则通过将 value 返回，如果逻辑处理不通过，可以 raise 抛出 serializers.ValidationError 的错误，ValidationError 中 detail 属性是错误的描述，code 属性可以是处理字段名称</p><p>​    <strong>全局钩子 validate</strong>，对多个字段做自定义的校验，可接受一个参数 attrs，大概是 querydict 字典，可以 get 到属性拿到对应的值，如果校验通过需要将 attrs 返回</p><p>​    如果某个字段需要做多个校验，那么局部钩子就不能实现了，所以 drf 给 serializers 类提供了一个参数 validators 属性，该属性可以接受多个用来校验该字段的钩子函数</p><h4 id="ModelSerializer"><a href="#ModelSerializer" class="headerlink" title="ModelSerializer"></a>ModelSerializer</h4><p>​    是 serializers 的子类，和 django 的 modelform 类似，也是直接基于模型类来定义序列化类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CourseSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="comment"># price = serializers.CharField()    ModelSerializer 也可以额外定义序列化字段</span></span><br><span class="line">    teacher = serializers.ReadOnlyField(source=<span class="string">&quot;teacher.username&quot;</span>)</span><br><span class="line">    <span class="comment"># ReadOnlyField 表示当前字段是 只读 字段，也就说前端不需要对该字段的数据提交，source 表示从 teacher.username 到关联表取出 username</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Course</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;introduction&#x27;</span>, <span class="string">&#x27;teacher&#x27;</span>, <span class="string">&#x27;price&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    注意，这里的 teacher 属性中的 source，这个 teacher 实际上的是一个 instance 的实例，在 models 里 Course 模型类的 teacher 字段是 ForeignKey 做的外键，关联到了 django 默认的 settings.AUTH_USER_MODEL，AUTH_USER_MODEL = ‘auth.User’</p><p>​    因此上面序列化类的 teacher 就是从 User 中得到一个实例，并且返回了这个实例的 username 字段。所以，返回的 json 中 teacher 的值，是一个字符串而不是一个对象</p><p>​    正常情况下，根据 Course 表来说，序列化中的外键字段是 teacher_id，<strong>django 会在迁移时在数据库的表中，自动对模型中外键字段加上 _id 的后缀</strong>，所以默认序列化的 fields 中的 teacher 其实是表中 teacher_id 的字段，但是在 drf 中并不需要自己手动加上 _id 后缀，目的就是使字段和模型定义统一</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机导论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;introduction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;包含内容有，计算机网络，计算机硬件，计算机历史发展，计算机基础知识等等&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;teacher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;33.30&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>​    如果在 CourseSerializer 这个 ModelSerializer 中，需要通过外键获取 User 中的多个字段，可以是一个个在 CourseSerializer 中添加自定义的字段，再用 source 去指向得到一个字符串</p><p>​    也可以在 CourseSerializer 中嵌套 UserSerializer 这个自定义的序列化类，其中这个 UserSerializer 中 class Meta 的 fields 属性就可以指定其他序列化类查询时需要返回的字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">&quot;username&quot;</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    teacher = UserSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Course</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;introduction&#x27;</span>, <span class="string">&#x27;teacher&#x27;</span>, <span class="string">&#x27;price&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    这样一来，由于没有了 source 的字段属性去单独获取指定的值，CourseSerializer 的 teacher 就会返回一个 instance ，也就是说在返回的 json 中，teacher 这个字段的值不再是字符串，而是对应的一个对象，其中会包括了在 UserSerializer 中 fields 属性设置的字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机导论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;introduction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;包含内容有，计算机网络，计算机硬件，计算机历史发展，计算机基础知识等等&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;teacher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>      </span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;33.30&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="drf-视图与路由"><a href="#drf-视图与路由" class="headerlink" title="drf 视图与路由"></a>drf 视图与路由</h3><h4 id="FBV"><a href="#FBV" class="headerlink" title="FBV"></a>FBV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(<span class="params">[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">course_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用 django 原生的请求处理方式，也就是自己构建 json 数据，再将 json 数据给到 response 返回&#x27;&#x27;&#x27;</span></span><br><span class="line">    course_dict = &#123;....&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(course_dict)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        course = json.loads(request.body.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># 原生 django 获取 post 的 json 数据，需要从 request.body 中获取，且得到是字节类型</span></span><br><span class="line">        <span class="keyword">return</span> HttpReposne(json.dumps(course), content_type=<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Course</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> CourseSerializer</span><br><span class="line"><span class="keyword">from</span> django.views.decorators <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">course_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用 drf 序列化组件的方式&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        objs = CourseSerializer(instance=Course.objects.<span class="built_in">all</span>(), many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(data=objs.data, status=status.HTTP_200_OK)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        data = CourseSerializer(data=request.data, partial=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># drf 可以从 request.data 中获取 post 的 json 数据 </span></span><br><span class="line">        <span class="keyword">if</span> data.is_valid():</span><br><span class="line">            data.save(teacher=request.user)</span><br><span class="line">            <span class="keyword">return</span> Response(data=data.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">return</span> Response(data.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>​    注意，在没使用 drf 的认证组件的情况下，会受到 django 的 csrfmiddleware 中间件的影响，需要提供 token 才能去测试，而 <strong>django 提供了一个装饰器来绕开 csrfmiddleware，csrf_exempt 装饰器</strong>（from django.views.decorators.csrf import csrf_exempt）</p><p>​    使用 FBV 方式开发 drf 的路由设置，和 django 原本的 url 设置是一致的，所以 urls.py 的编写都是一样的</p><h4 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># APIView</span></span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">csrf_exempt, <span class="string">&quot;dispatch&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseList</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">        s = CourseSerializer(instance=queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(s.data, status=status.HTTP_200_OK)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        s = CourseSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> s.is_valid():</span><br><span class="line">            s.save(teacher=request.user)</span><br><span class="line">            <span class="keyword">return</span> Response(s.data, status=status.HTTP_200_OK)</span><br><span class="line">        <span class="keyword">return</span> Response(s.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure><p>​    drf 对 django CBV 的 View 做了进一步封装得到 APIView，其中最主要的就是 dispatch 方法，<strong>drf 的 APIView 在 dispatch 方法中做了一些类组件的初始化和调用，包括认证组件，权限组件，频率组件</strong></p><p>​    CBV 中避免出现 csrf 的问题，是使用 method_decorator 装饰器，其中参数是 csrf_exempt，name 参数是 dispatch，因为类视图的调用是通过 as_view 方法，然后到 dispatch 中做分发，所以类视图的请求处理的位置是在 dispatch 的方法这，当然也可以直接对 post 的请求直接装饰 csrf_exempt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GenericAPIView</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle,)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perform_create</span>(<span class="params">self, serializer</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重写 ListCreateAPIView 中的 mixins.CreateModelMixin 类的创建方法&quot;&quot;&quot;</span></span><br><span class="line">        serializer.save(teacher=self.request.user)</span><br><span class="line">        <span class="comment"># 默认 CreateModelMixin 使用 create 方法去生成数据对象（实际内部会去调用 perform_create 方法，通过 serializer 参数的 save 去创建），但是 teacher 字段并不由前端输入来创建的，是通过登录对象作为 teacher，所以要重写 perform_create 方法，</span></span><br><span class="line">        <span class="comment"># Generic 的 View，要获取 request，需要通过 self.request 来获取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseDetail</span>(generics.RetrieveUpdateDestroyAPIView):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    generics.RetrieveUpdateDestroyAPIView 表示支持 获取，更新，删除的一个 APIView，相当于是：</span></span><br><span class="line"><span class="string">    mixins.RetrieveModelMixin,</span></span><br><span class="line"><span class="string">    mixins.UpdateModelMixin,</span></span><br><span class="line"><span class="string">    mixins.DestroyModelMixin,</span></span><br><span class="line"><span class="string">    GenericAPIView</span></span><br><span class="line"><span class="string">    这是个单独功能类的封装，RetrieveUpdateDestroyAPIView 本身也是继承了这几个 mixin 的类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    permission_classes = (IsOwnerorReadOnly,)</span><br><span class="line">    throttle_classes = (IPThrottle,)</span><br></pre></td></tr></table></figure><p>​    GCBV 是在 CBV 的 APIView 上的又一次封装得到 GenericAPIView，并且结合 mixins，创建了针对不同请求方法的通用类视图</p><table><thead><tr><th>通用类视图</th><th>处理的请求方法</th><th>继承父类</th></tr></thead><tbody><tr><td>CreateAPIView</td><td>post</td><td>mixins.CreateModelMixin，GenericAPIView</td></tr><tr><td>ListAPIView</td><td>get（获取所有）</td><td>mixins.ListModelMixin，GenericAPIView</td></tr><tr><td>RetrieveAPIView</td><td>get（获取指定记录）</td><td>mixins.RetrieveModelMixin，GenericAPIView</td></tr><tr><td>DestroyAPIView</td><td>delete</td><td>mixins.DestroyModelMixin，GenericAPIView</td></tr><tr><td>UpdateAPIView</td><td>put 和 patch</td><td>mixins.UpdateModelMixin，GenericAPIView</td></tr><tr><td>ListCreateAPIView</td><td>get 和 post</td><td>mixins.ListModelMixin，mixins.CreateModelMixin，GenericAPIView</td></tr><tr><td>RetrieveUpdateAPIView</td><td>get（指定记录），put，patch</td><td>mixins.RetrieveModelMixin，mixins.UpdateModelMixin，GenericAPIView</td></tr><tr><td>RetrieveDestroyAPIView</td><td>get（指定记录），delete</td><td>mixins.RetrieveModelMixin，mixins.DestroyModelMixin，GenericAPIView</td></tr><tr><td>RetrieveUpdateDestroyAPIView</td><td>get（指定记录），put，patch，delete</td><td>mixins.RetrieveModelMixin，mixins.UpdateModelMixin，               mixins.DestroyModelMixin，GenericAPIView</td></tr></tbody></table><p>​    ListModelMixin 提供一个 list 方法，其中会调用 get_queryset 获取设定的查询集，并将查询集给 paginate_queryset 做分页，最后使用 get_serializer 方法获取设置的序列化器将查询集进行序列化，将序列化器对象的 data 数据给到 Response 返回，返回状态码是 200</p><p>​    所以，使用到 ListAPIView 时，需要在通用类视图中，设置 queryset 属性，即要序列化的查询集，同时还需要设置 serializer_class 属性，值就是自定义的序列化类</p><p>​    CreateModelMixin 提供了一个 create 的方法， 其中会调用 get_serializer 方法，将 request.data 数据给到设置的序列化类，然后就是序列化类的一套操作，is_valid 做校验，数据通过校验后会调用 <strong>perform_create</strong> 方法并传入序列化器对象，该方法实际上会调用序列化器的 save 方法去创建</p><p>​    所以，使用 CreateAPIView，也要定义 serializer_class，如果数据创建成功，会返回 201 状态码的响应，否则会返回 400 状态码，如果创建记录前要更改序列化器中的数据，需要重写 perform_create 方法</p><p>​    RetrieveModelMixin 提供了一个 retrieve 方法，<strong>内部会调用 self.get_object 方法，实际上是调用了 GenericAPIView 中的 get_object 方法</strong>，内部 <strong>filter_kwargs 字典会去查看 lookup_field 和 lookup_url_kwarg</strong> 两个属性，前者是 pk，后者默认是 None，然后以 pk 作为 key，值就是从 self.kwargs 即从 url 上获取 self.lookup_url_kwarg 或 self.lookup_field 的值作为 url 参数的 key 来获取到具体的请求资源，也就说默认情况下，是从 url 上拿到 pk 关键字的值，<strong>再到模型类中获取，获取的方法会去调用 get_object_or_404 方法</strong>，如果实例不存在就返回 404。得到实例后，会再去 get_serializer 获取序列化类，然后序列化返回 data 中的数据</p><p>​    所以，使用 RetrieveModelMixin 时，如果要明确 api 用什么 key 去数据库中查询，如果不是 pk 字段，就需要定义一个 lookup_url_kwarg 这个属性，然后是要设置 queryset 属性，同时设置上序列化类 serializer_class</p><p>​    UpdateModelMixin 提供了 update 方法来实现更新操作，<strong>首先会去 kwargs 上用 pop 获取是否有 partial 参数，没有就是 False，否则 partial 的值就是 True。然后就是调用 get_object 获取 instance 和 get_serializer 获取序列化类，用 is_valid 校验后，会使用 perform_update 来更新，实际上也是调用序列化的 save 方法</strong></p><p>​    DestroyModelMixin 提供了 destroy 方法，主要就是 <strong>通过 get_object 得到具体的 instance，再去使用 perform_destroy 方法，去调用 instance 的 delete 方法删除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ViewSet</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookInfoViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):</span><br><span class="line">        books = BookInfo.objects.<span class="built_in">all</span>()</span><br><span class="line">        serializer = BookInfoSerializer(books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">self, request, pk=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            books = BookInfo.objects.get(<span class="built_in">id</span>=pk)</span><br><span class="line">        <span class="keyword">except</span> BookInfo.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">        serializer = BookInfoSerializer(books)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>​    ViewSet 是 APIView 的更深一步的封装，ViewSet 继承了 ViewSetMixin 和原本的 APIView，ViewSetMixin 重写 as_view 的方法，要求了在 urls 的路由配置中，http 的请求动词要和对应处理的 ViewSet 视图集类中的方法进行映射，即 <code>MyViewSet.as_view(&#123;&#39;get&#39;: &#39;list&#39;, &#39;post&#39;: &#39;create&#39;&#125;)</code></p><p>​    get 请求对应的方法名会有两种，一种是获取所有查询集的 list，另一种是获取指定实例的 retrieve</p><p>​    更新的请求中，put 对应 update 用作完整的更新，patch 对应 partial_update 用作部分字段传递的局部更新</p><p>​    在 ViewSet 上，还有更进一步的封装 ModelViewSet，ModelViewSet 将所有的处理方法都集合到了一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelViewSet</span>(mixins.CreateModelMixin,</span><br><span class="line">                   mixins.RetrieveModelMixin,</span><br><span class="line">                   mixins.UpdateModelMixin,</span><br><span class="line">                   mixins.DestroyModelMixin,</span><br><span class="line">                   mixins.ListModelMixin,</span><br><span class="line">                   GenericViewSet):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A viewset that provides default `create()`, `retrieve()`, `update()`,</span></span><br><span class="line"><span class="string">    `partial_update()`, `destroy()` and `list()` actions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    使用 viewsets 的 ModelViewSet 时，路由的配置和 ViewSet 是一样的，在 as_view 中都需要配置请求动词和对应方法的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">&#x27;view_set/course/&#x27;</span>, views.CourseViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>: <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;post&#x27;</span>: <span class="string">&#x27;create&#x27;</span>&#125;), name=<span class="string">&quot;vs_course&quot;</span>),</span><br><span class="line"></span><br><span class="line">path(<span class="string">&#x27;view_set/course/&lt;int:pk&gt;/&#x27;</span>, views.CourseViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>: <span class="string">&#x27;retrieve&#x27;</span>, <span class="string">&#x27;put&#x27;</span>: <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>: <span class="string">&#x27;partial_update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>: <span class="string">&#x27;destroy&#x27;</span>&#125;), name=<span class="string">&quot;vs_course_detail&quot;</span>),</span><br></pre></td></tr></table></figure><p>​    注意，因为 GET 请求获取的资源可能是一个集合，也可能是具体的对象资源，所以在使用 viewsets 的时候，是需要创建两个 url 的，但是所要执行的视图函数都是一样的，区别就在于 as_view 中，请求动词和视图集中提供的方法</p><h3 id="drf-认证组件-——-authentication"><a href="#drf-认证组件-——-authentication" class="headerlink" title="drf 认证组件 —— authentication"></a>drf 认证组件 —— authentication</h3><p>​    <strong>关于 drf 的组件，可以通过两种方式来使用，一种是全局 settings 中配置，另一种是在视图类中设置</strong></p><p>​    <strong>认证组件的执行要先于其他的功能组件</strong>，因为 <strong>dispatch 中调用 initialize_request 对 request 封装时，会使用 get_authenticators 方法获取认证类，会去遍历视图类中设置的 authentication_classes 属性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_request</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns the initial request object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>​    如果没有设置，就会去全局配置文件中查找 DEFAULT_AUTHENTICATION_CLASSES 的配置项</p><p>​    <strong>全局配置，需要在 settings 中配置一个 REST_FRAMEWORK 的字典，认证组件需要配置 DEFAULT_AUTHENTICATION_CLASSES</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">        <span class="comment"># 默认认证组件, 认证组件会在视图最开始处理时执行，并且也先于权限，认证组件的优先级是最高的</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,</span><br><span class="line">        <span class="comment"># 最基本的 http 用户名，密码认证方式，通过后 request.user 是登录用户对象，request.auth 是 None</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,</span><br><span class="line">        <span class="comment"># Session 方式根据后端的会话认证，前端可以通过 ajax 来发送认证，但是 post 和 put 请求都需要携带 csrf_token，认证通过后，request.auth 也是返回 None</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.TokenAuthentication&#x27;</span>,</span><br><span class="line">        <span class="comment"># 多个认证组件，由上至下进行，认证通过后，返回 request.user, request.auth</span></span><br><span class="line">        <span class="comment"># 不通过，则向下进行其他类型的认证，一旦通过，那么后面的认证模块就不会再去执行</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>drf 中认证组件有 BasicAuthentication，SessionAuthentication 和 TokenAuthentication</strong>。initialize_request 中完成对 Request 的封装后得到 request 实例，会执行 <strong>initial 方法，内部会去执行 perform_authentication(request) 方法，该方法会去调用 request.user</strong></p><p>​    <strong>然后会去调用 _authenticate 方法，该方法会循环 self.authenticators</strong>，这个 authenticators 就是在 initialize_request 封装 Request 时，循环遍历设置的 authentication_classes 得到的认证类的列表。然后会去调用 <strong>每个认证类的 authenticate 方法，认证通过会返回 user_auth_tuple</strong>，这个元组有两个元素，第一个就是 user 的实例，第二个是 auth 值就是 None </p><p>​    使用 BasicAuthentication 认证时，postman 在请求头的字段字段会添加一个 Authorization 字段，值是 Basic + 一个空格 + 用户名和密码在 base64 字后的密文。由于请求头信息中包含了用户敏感信息，虽然是编码后的值，但是这个密文是可以回推从而得到明文信息的，所以 BasicAuthentication 并不是一种绝对安全的方式，通常情况下在使用 postman 做接口测试时，会使用这个认证。<strong>如果认证失败了，在响应头会多一个 WWW-Authenticate 的字段</strong></p><p>​    SessionAuthentication 认证使用的是 django 框架的 Session 框架做认证，所以 SessionAuthentication 是需要请求中要携带 csrf_token 的。认证通过了 user 属性也是用户实例，auth 也是 None，但是认证不通过，不会在响应头中添加字段</p><p>​    TokenAuthentication 是 drf 基于 token 令牌的一种认证方式，<strong>使用 TokenAuthentication 的话，需要在 installed-app 中加上 ‘rest_framework.authtoken’，同时需要进行数据迁移同步数据库，会生成一张 authtoken_token 的表</strong>，包含三个字段 key，也就是 token 令牌；created 表示创建时间；user_id 表示用户 id</p><p>​    如果使用的 django 自己的 AUTH_USER_MODEL 作为用户模型类，在创建用户时不会主动去给对应用户创建 token，所以需要使用信号机制来触发 TokenAuthentication 的 Token 模型类，来生成一个 token 令牌</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> django.db.model.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment"># from django.contrib.auth.models import User</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @receiver(post_save, sender=User)</span></span><br><span class="line"><span class="meta">@receiver(<span class="params">post_save, sender=settings.AUTH_USER_MODEL</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_token</span>(<span class="params">sender, instance=<span class="literal">None</span>, created=<span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建用户时，触发信号，函数接收信号和用户对象，在 token 表中创建该用户的 Token&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> created:</span><br><span class="line">        <span class="comment"># 用户创建后触发信号，created 会是 True</span></span><br><span class="line">        Token.objects.create(user=instance)  </span><br><span class="line">        <span class="comment"># 创建 token 时，user 字段就是刚才创建好的用户实例 instance</span></span><br></pre></td></tr></table></figure><p>​    rest_framework.authtoken 也提供了一个视图 obtain_auth_token 接口用来返回用户的 token 信息，在 postman 上通过设置的路由，访问 obtain_auth_toekn 这个接口时，还是需要使用用户名和密码登录的，然后才能获取到自己的 token</p><p>​    TokenAuthentication 认证成功后，user 会被赋值为用户的实例，auth 则被赋值为 Token 的实例，得到对应的 token 令牌。认证失败的话，响应头中也会有 WWW-Authenticate 字段</p><p>​    得到用户的 token 后，在后面的请求可以在 postman 的 Auth 认证栏中选择 API key 的方式，key 就是 Authorzation 字段，value 就是 Token + 空格 + token 的值</p><p>​    <strong>补充：</strong>drf 的组件设置因为可以全局，也可以在局部设置，两者的优先级是局部要优先</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> authentication_classes, permission_classes, throttle_classes</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BasicAuthentication, SessionAuthentication, TokenAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_classes(<span class="params">(<span class="params">TokenAuthentication,</span>)</span>)</span></span><br><span class="line"><span class="meta">@permission_classes(<span class="params">(<span class="params">IsAuthenticated,</span>)</span>)</span></span><br><span class="line"><span class="meta">@throttle_classes(<span class="params">...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">course_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    在 FBV 和 CBV 中局部设置认证，权限，频率组件，需要使用 rest_framework 中 decorators 装饰器中的 authentication_classes, permission_classes, throttle_classes 来做装饰，注意组件的执行顺序</p><p>​    而在 GCBV 之后，组件的设置可以直接通过属性方式设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br></pre></td></tr></table></figure><h3 id="drf-权限组件-——-permissions"><a href="#drf-权限组件-——-permissions" class="headerlink" title="drf 权限组件 —— permissions"></a>drf 权限组件 —— permissions</h3><p>​    权限组件同样可以进行全局配置，或是在视图类中通过 permission_classes 属性来设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line"><span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">    <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,   <span class="comment"># 认证是否通过</span></span><br><span class="line">),</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br></pre></td></tr></table></figure><p>​    drf 的 permissions 组件提供多种权限校验，<strong>AllowAny 允许所有，也就是不校验权限；IsAuthenticated 检查是否通过认证，认证通过的用户才能访问；IsAdminuser 只有管理员权限的角色可以访问；IsAuthenticatedOrReadOnly，表示认证通过的可以访问和操作，而认证未通过的匿名用户只能使用 get 请求</strong></p><p>​    drf 的权限组件的执行流程是，在 <strong>dispatch 的 initial 方法中调用 self.check_permissions(request)，该方法会去调用 get_permissions 方法会循环遍历得到权限组件的列表</strong>，然后遍历这个列表得到每一个权限校验类，去 <strong>调用 has_permission 方法</strong>，这个方法会返回 True 或 False 来表示是否有权限</p><p>​    所以自定义权限检查类时，需要定义一个 <strong>has_permission 方法，该方法用于检查是否有权限访问视图，如果是模型类的权限，可以定义 has_object_permission</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsOwnerorReadOnly</span>(permissions.BasePermission):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义权限，只允许对象的所有者才能编辑&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_object_permission</span>(<span class="params">self, request, view, obj</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        所有的 request 请求都有读权限，GET，HEAD，OPTION</span></span><br><span class="line"><span class="string">        :param request: drf 自己的 request</span></span><br><span class="line"><span class="string">        :param view: view 表示当前视图</span></span><br><span class="line"><span class="string">        :param obj: obj 表示 instance</span></span><br><span class="line"><span class="string">        :return: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:   <span class="comment"># (&quot;GET&quot;,&quot;HEAD&quot;,&quot;OPTION&quot;)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> request.user == obj.teacher</span><br></pre></td></tr></table></figure><h3 id="drf-频率组件-——-throttling"><a href="#drf-频率组件-——-throttling" class="headerlink" title="drf 频率组件 —— throttling"></a>drf 频率组件 —— throttling</h3><p>​    同样支持两种配置方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line"><span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.AnonRateThrottle&#x27;</span>,   <span class="comment"># 对匿名用户做频率显示</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.UserRateThrottle&#x27;</span>,   <span class="comment"># 对请求用户做频率限制</span></span><br><span class="line">    ],</span><br><span class="line"><span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># THROTTLE_RATES 支持 second，minute，hour，day</span></span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;100/day&#x27;</span>,     <span class="comment"># 匿名用户每天只能访问 100 次</span></span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;2/minute&#x27;</span>,    <span class="comment"># 限制用户每分钟只能访问 2 次</span></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br></pre></td></tr></table></figure><p>​    频率组件的执行流程和权限组件是一样的，<strong>initial 中去调用 self.check_throttles(request)</strong>，会去遍历设置的频率类，调用 <strong>allow_request</strong> 方法判断结果是 True 还是 False，如果 allow_request  返回 False 了，会接着调用频率类的 <strong>wait</strong> 方法，这个方法返回的就是需要等待的时间</p><p>​    同时，check_throttles 中还会创建一个列表，会将 wait 返回的时间添加进去，并且会去遍历取出一个最大值</p><p>​    drf 中 <strong>匿名用户频率限制 AnonRateThrottle 类</strong>，主要使用 ip 地址来进行区分限制；<strong>登录用户 UserRateThrottle 类</strong>，使用的是 user_id 来区分做限制；<strong>ScopedRateThrottle 类是对每个视图做访问限制</strong>，使用 ip 或 user_id 来区分</p><p>​    如果要 <strong>自定义频率限制类，需要实现两个基本方法，allow_request 和 wait</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> throttling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPThrottle</span>(throttling.BaseThrottle):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;每个 ip 一分钟内只能访问 3 次&#x27;&#x27;&#x27;</span></span><br><span class="line">    ip_pool = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.history_list = []</span><br><span class="line">        self.cur_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allow_request</span>(<span class="params">self, request, view</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.history_list)</span><br><span class="line">        ip = request.META.get(<span class="string">&#x27;REMOTE_ADDR&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> ip <span class="keyword">not</span> <span class="keyword">in</span> self.ip_pool:</span><br><span class="line">            self.ip_pool[ip] = [self.cur_time]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        self.history_list = self.ip_pool[ip]</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     if self.cur_time - self.history_list[-1] &gt; 60:</span></span><br><span class="line">        <span class="comment">#         self.ip_pool[ip].pop(-1)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line">        <span class="keyword">while</span> self.history_list <span class="keyword">and</span> self.cur_time - self.history_list[-<span class="number">1</span>] &gt; <span class="number">60</span>:</span><br><span class="line">            self.history_list.pop(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.history_list) &lt; <span class="number">3</span>:</span><br><span class="line">            self.history_list.append(self.cur_time)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span> - (self.cur_time - self.history_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="drf-分页组件-——-pagination"><a href="#drf-分页组件-——-pagination" class="headerlink" title="drf 分页组件 —— pagination"></a>drf 分页组件 —— pagination</h3><p>​    全局的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>:  <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">100</span>,      <span class="comment"># 每页数目</span></span><br><span class="line">    <span class="string">&#x27;MAX_PAGE_SIZE&#x27;</span>: <span class="number">10</span>,   <span class="comment"># 显示的页数最多是 10 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    自定义按照页数参数的分页器，需要继承 PageNumberPagination。注意下面所使用的类视图都是通用类视图，因为通用类视图中有 pagination_class 的属性可以设置自定义的分页器类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagintation.PageNumberPagination</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargeResultsSetPagination</span>(<span class="title class_ inherited__">PageNumberPagination</span>):</span><br><span class="line">    page_size = <span class="number">1000</span>    <span class="comment"># page_size 和全局的 PAGE_SIZE 一样，表示每一页的数据条数</span></span><br><span class="line">    page_size_query_param = <span class="string">&#x27;page_size&#x27;</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BillingRecordsView</span>(generics.ListAPIView):</span><br><span class="line">    queryset = Billing.objects.<span class="built_in">all</span>()</span><br><span class="line">    pagination_class = LargeResultsSetPagination</span><br></pre></td></tr></table></figure><p>​    这里 page_size_query_param 的属性，这个属性的作用是允许动态获取指定的数据条数。默认情况下，设置 page_size 来控制每一页的数据条数，在 url 上使用通过参数 ?page=1 来获取不同页上 page_size 设定的数目，因为默认分页器的 page_query_param 属性的值就是 “page”，这个 page 就是代表 api 的 url 上的获取指定页的参数 page</p><p>​    设置 page_size_query_param 的值为 “page_size”，就表示前端通过的 api 上 url 的参数中允许使用 page_size 来指定要获取的数据条数，但是如果设置了 page_size 属性的值是 10，那么即使 api 上使用 ?page_size=100，也只能获得 10 条记录</p><p>​    除了 PageNumberPagination 使用 page 参数来做分页，drf 还有 LimitOffsetPagination 支持通过偏移量获取不同的数据记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> LimitOffsetPagination</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BillingRecordsView</span>(generics.ListAPIView):</span><br><span class="line">    queryset = Billing.objects.<span class="built_in">all</span>()</span><br><span class="line">    pagination_class = LimitOffsetPagination</span><br></pre></td></tr></table></figure><p>​    <strong>LimitOffsetPagination 的属性有 default_limit 作用和 page_size 一样，表示每一页的数量，还有  limit_query_param 属性表示 url 上的参数，默认就是 limit，还有 offset_query_param 属性，也是指向参数 offset</strong></p><p>​    所以使用 LimitOffsetPagination 做分页器，api 的 url 使用的参数就是 ?limit=100&amp;offset=400，表示的就是从 400 开始取出 100 条记录</p><p>​    <strong>非通用类视图的 APIView 视图中，可以在 list 的方法内，手动实例化分页器对象，然后调用对象的 paginate_queryset 方法，这个方法要接收的参数第一个是查询集对象，第二个是 request</strong></p><p>​    分页器类中还实现了 get_paginated_response 来构建返回的 response，在页数分页类 PageNumberPagination 中，get_paginated_response 需要接受处理好分页后的查询对象数组，会自动将上下页的路由处理好并放在响应中，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_paginated_response</span>(<span class="params">self, data</span>):</span><br><span class="line">    <span class="keyword">return</span> Response(OrderedDict([</span><br><span class="line">        (<span class="string">&#x27;count&#x27;</span>, self.page.paginator.count),   <span class="comment"># count 不是总页数，而是分页对象接收的查询集的长度，也就是每页的数据条数</span></span><br><span class="line">        (<span class="string">&#x27;next&#x27;</span>, self.get_next_link()),</span><br><span class="line">        (<span class="string">&#x27;previous&#x27;</span>, self.get_previous_link()),</span><br><span class="line">        (<span class="string">&#x27;results&#x27;</span>, data)</span><br><span class="line">    ]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pagination</span>(<span class="title class_ inherited__">PageNumberPagination</span>):</span><br><span class="line">    page_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GASListViewSet</span>(viewsets.ViewSet):    <span class="comment"># ViewSet 继承了 APIView 和 ViewSetMixin</span></span><br><span class="line">    authentication_classes = [MyJWTAuthentication]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):</span><br><span class="line">        gases = Goods_And_Services.objects\</span><br><span class="line">            .<span class="built_in">filter</span>(deleted_at=<span class="literal">None</span>, creator_id_id=request.user_obj.get(<span class="string">&#x27;user_id&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        paginator = Pagination()</span><br><span class="line">        gases = paginator.paginate_queryset(gases, request)</span><br><span class="line"></span><br><span class="line">        serializer = GASSerializer(instance=gases, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> paginator.get_paginated_response(serializer.data)</span><br><span class="line">        <span class="comment"># return Response(data=serializer.data)</span></span><br></pre></td></tr></table></figure><h3 id="drf-解析组件-——-parsers"><a href="#drf-解析组件-——-parsers" class="headerlink" title="drf 解析组件 —— parsers"></a>drf 解析组件 —— parsers</h3><p>​    解析器的作用就是从前端中根据 content_type 字段的类型，来对前端发送的数据做解析。<strong>在 drf 中 parsers 解析器默认提供了三种解析器，包括 JSONParser，FormParser 和 MultiPartParser，分别对应处理 json 数据，表单数据，以及复杂的表单数据解析，比如表单中提交的数据会有文件的上传的话就可以使用 MultiPartParser</strong>，全局配置需要设置 DEFAULT_PARSER_CLASSES</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PARSER_CLASSES&#x27;</span>:[</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.JSONParser&#x27;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.FormParser&#x27;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.MultiPartParser&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果在类视图函数中做针对性的数据解析，需要使用 parser_classes 的属性指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    parser_classes = [JSONParser, ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    JSONParser 会根据 application/json 的类型做解析，从 request.data 中解析前端的 json 数据并返回一个 dict 字典</p><p>​    FormParser 会根据 application/x-www-form-urlencoded 类型解析，同样在 request.data 中取出键值数据，但最后返回的是一个 QueryDict 对象</p><p>​    MultiPartParser 会根据 multipart/form-data 类型做解析，为了完全支持前端的表单数据解析，通常会与 FormParser  一起使用，所以和 FormParser 一样都是返回 QueryDict  对象</p><p>​    <strong>FileUploadParser 是专门用来处理前端文件上传的解析类，要获取解析数据通过 file 这个字段，即 request.data[‘file’]</strong></p><p>​    如果要自定义解析类，需要继承 BaseParser，并对 parse 方法进行实现，parse 的方法接收三个参数。stream 表示前端的 request 的数据流对象，media_type 表示就是前端中对应 Content_Type 字段的数据类型，parser_context 表示解析数据的上下文，这个参数必须是字典类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlainTextParser</span>(<span class="title class_ inherited__">BaseParser</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Plain text parser.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    media_type = <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, stream, media_type=<span class="literal">None</span>, parser_context=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Simply return a string representing the body of the request.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> stream.read()</span><br></pre></td></tr></table></figure><p>​    media_type 和 parser_context 不是必要参数，因为这个两个参数默认是 None，所以在 parse 方法主要完成的就是 request 数据对象的读取</p><p>​    解析类的执行流程，在 dispatch 中执行 request 的初始化方法 initialize_request，这个方法会调用 get_parser_context 方法从参数 request 中得到 parser_context，然后返回 Request 类的实例，这里实例第一个参数就是 django 自身的 request，然后包括调用 get_parsers 方法从设置的 parser_classes 中遍历解析类，或是从全局中获取默认的解析类列表，然后还包括前面提到的 get_authenticators 方法得到认证类，get_content_negotiator 方法得到分页类，同时会将 parser_context 传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_request</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns the initial request object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>​    在 Request 这个类中，有一个 data 的属性，在函数视图中的 request.data 就会从这个属性获取数据，该属性会去调用 _load_data_and_files 方法，会去调用 _parse 方法，这个私有方法的内部实际就是调用了解析类的 parse 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parsed = parser.parse(stream, media_type, self.parser_context)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="comment"># If we get an exception during parsing, fill in empty data and</span></span><br><span class="line">    <span class="comment"># re-raise.  Ensures we don&#x27;t simply repeat the error when</span></span><br><span class="line">    <span class="comment"># attempting to render the browsable renderer response, or when</span></span><br><span class="line">    <span class="comment"># logging the request or similar.</span></span><br><span class="line">    self._data = QueryDict(<span class="string">&#x27;&#x27;</span>, encoding=self._request._encoding)</span><br><span class="line">    self._files = MultiValueDict()</span><br><span class="line">    self._full_data = self._data</span><br></pre></td></tr></table></figure><p>​    同时将 Querydict 的数据赋给 _data 变量，文件的数据则是给 _files 变量，最后 _parse 会返回一个元组包含解析后的 (data, files)</p><h3 id="drf-渲染组件-——-renderers"><a href="#drf-渲染组件-——-renderers" class="headerlink" title="drf 渲染组件 —— renderers"></a>drf 渲染组件 —— renderers</h3><p>​    渲染组件和解析组件其实是一个道理，只是方向不同，渲染类的作用是后端的数据通过渲染类转变为前端能够处理的数据类型，drf 默认使用了两个 JSONRenderer，BrowsableAPIRenderer 两个渲染类，全局中配置通过 DEFAULT_RENDERER_CLASSES 设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_RENDERER_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.JSONRenderer&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    类视图中使用，则可以直接通过 renderer_classes 属性设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    renderer_classes = [JSONRenderer, ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure><p>​    当视图返回 response 的时候，在 Response 的类中有一个 rendered_content 的属性方法，内部最终是通过 getattr 得到 renderer 设置的渲染类，通过调用 renderer 的 render 方法的得到 ret 并返回</p><h3 id="drf-异常处理"><a href="#drf-异常处理" class="headerlink" title="drf 异常处理"></a>drf 异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_exception_handler</span>(<span class="params">exc, context</span>):</span><br><span class="line">    <span class="comment"># 先调用 REST framework 默认的异常处理方法获得标准错误响应对象</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在此处补充自定义的异常处理</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">&#x27;status_code&#x27;</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>​    在全局配置中，如果没有定义自定义的异常处理函数，默认会去使用 drf 自己的视图异常处理方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;rest_framework.views.exception_handler&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    drf 中常见的异常有：</p><p>​    AuthenticationFailed 表示认证失败</p><p>​    NotAuthenticated 表示没有进行认证</p><p>​    PermissionDenied 表示权限拒绝</p><p>​    MethodNotAllowed 表示请求方法不支持，CBV 通过 api_view （from rest_framework.decorators import api_view）的装饰器，可以指定允许的请求方式，@api_view([“GET”, “POST”])，表示只允许 get 和 post</p><p>​    Throttled 表示超出频率限制</p><p>​    ValidationError 表示数据校验有错误</p><h3 id="drf-的全局配置"><a href="#drf-的全局配置" class="headerlink" title="drf 的全局配置"></a>drf 的全局配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DRF的全局配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 设置分页</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>: <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment"># 设置日期格式化</span></span><br><span class="line">    <span class="string">&#x27;DATETIME_FORMAT&#x27;</span>: <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,</span><br><span class="line">    <span class="comment"># 当 DRF 返回 response 对象时，要使用的 rander 类</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_RENDER_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.renders.JSONRenderer&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.renders.BrowsableAPIRenderer&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 解析器，如何解析 request 请求中的 request.data</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PARSER_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.JSONParser&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.FormParser&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.MultiPartParser&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 权限以及认证相关的配置</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.TokenAuthentication&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> python web框架 </category>
          
          <category> Django </category>
          
          <category> Rest_Framework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rest_Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery-整理</title>
      <link href="/2201923992/"/>
      <url>/2201923992/</url>
      
        <content type="html"><![CDATA[<h3 id="Celery-架构"><a href="#Celery-架构" class="headerlink" title="Celery 架构"></a>Celery 架构</h3><p>​    celery 是一个基于 python 开发的简单、灵活且可靠的分布式任务队列框架，通过消息队列作为中间件来实现异步或定时任务的调度，其基本的思想也是运用了生产-消费者模型。<strong>celery 适用于很多 web 应用的场景，比如文件上传，邮件的发送等 IO 的操作</strong>，可以交给 celery 去异步处理，从而不对当前的 web 应用的操作造成阻塞</p><p>​    celery 的组成部分有四部分组成：</p><p>​    <strong>1）task，即异步任务或者是定时任务</strong></p><p>​    <strong>2）broker，即消息队列的中间件</strong></p><p>​    <strong>3）worker，消息队列中任务的执行者</strong></p><p>​    <strong>4）backend，worker 完成任务后的结果存储</strong></p><p><img src="https://foofish.net/images/584bbf78e1783.png" alt="img"></p><p>​    由生产者将待处理的任务发往消息中间件（Broker），由消费者（任务执行单元 celery worker）监听这个 Broker，当 Broker 中有任务，消费者监听时发现有待处理任务会自动从 Broker 中取出任务进行处理，最后将运行的结果存储在 Backend 中 </p><p>​    使用 celery 前，需要先通过 pip 去安装 <code>pip install celery</code></p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">broker = <span class="string">&#x27;redis://localhost:6379/1&#x27;</span></span><br><span class="line">backend = <span class="string">&#x27;redis://localhost:6379/1&#x27;</span></span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>, broker=broker, backend=backend)</span><br><span class="line"><span class="comment"># 实例化 Celery 的 app，第一个参数是会是所有任务的前缀名，即 celery 应用的名字</span></span><br><span class="line"><span class="comment"># broker 就是消息队列，这里使用的是 redis，但是对于 redis 的连接信息，通常会方法在配置文件中</span></span><br><span class="line"><span class="comment"># 同理，backend 这里也是用 redis 来存放 worker 完成任务后的结果</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="keyword">from</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task    </span><span class="comment"># celery 的异步任务需要通过 celery 的实例，使用 task 做装饰来定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> tasks</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span></span><br><span class="line">result = tasks.add.delay(<span class="number">2</span>,<span class="number">4</span>)    <span class="comment"># 异步任务的执行使用 delay 方法</span></span><br><span class="line">    result.get()</span><br></pre></td></tr></table></figure><p>​    <strong>上面是创建了一个 celery_app 的应用，目录包括了两个文件 <code>__init__.py; tasks.py</code></strong>，在 tasks.py 就是要异步处理的任务，事实上也可以将 celery 的实例和异步任务的函数放在一个文件中，而 <code>__init__.py</code> 中是创建的 celery 的应用，启动时，会自动从应用所在的目录里加载</p><p>​    <strong>还有另外一种目录结构，就是在 celery_app 的目录下，创建一个 celery.py 文件</strong>，该文件和上述的 <code>__init__.py</code> 作用是一样的，启动时会自动寻找 -A 参数指定的模块下的是否有 celery 文件来启动应用</p><p>​    在 celery_app 的同级目录中，新建了一个 app.py 的文件，该文件的作用是类似于 django 的 manage.py，作为任务启动执行的入口</p><p>​    在执行异步任务前，需要先启动 celery 的 worker，否则 celery 的任务依然不能异步执行</p><p>​    <strong>启动 worker，<code>celery -A &lt;module&gt; worker -l info</code></strong>，<strong>这里的 module 指的就是 celery 的实例位置，也就是 app 所在的目录位置</strong>，所以启动 worker 的命令是 <code>celery -A celery_app worker -l info</code>。-l 参数是 loglevel 表示日志级别，后面的 info 表示的是在 celery 的终端上 info 级别的日志信息才会显示</p><p>​    <strong>注意！！windows 下使用 celery 时，除了 celery 还需要安装 gevent 这个包</strong>，并且启动 worker 还需要加上 <code>-P gevent</code>，即 <strong><code>celery -A &lt;module&gt; worker -l info -P gevent</code></strong></p><p>​     如果是在其他目录下，启动 celery 的 worker，又不想切换到 celery 应用的目录，可以使用  <strong>参数 <code>--workdir=</code>，指定 celery 应用位置</strong>，比如 <code>celery -A celery_app worker -l info --workdir=.\celery-contab -P gevent</code></p><p>​    <strong>命令行中启动 worker 后，celery 的终端上会在 [tasks] 中显示应用当前的异步任务</strong></p><p>​    然后就可以执行异步任务，在 tasks 中定义了一个 add 的函数，使用 time 的 sleep 模拟了一个阻塞，当异步任务的函数在 app.py 的中执行，这个阻塞的异步任务就会给到 celery，同时 celery 的 worker 会在任务列表中获取任务去执行，也就说在执行 add 这个任务时并不会因为阻塞而导致程序停顿，任务由 worker 在 sleep 的时间结束完成后，将这个任务的结果存在了 celery 实例指定的 backend 内</p><p>​    另外，当执行一个异步任务函数后，在 celery 的终端上会显示收到任务，同时给任务赋予一个 uuid 作为标识，任务执行完毕会返回 succeeded</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2021-06-07 10:58:54,549: INFO/MainProcess] Received task: celery_app.task1.add[2a4778d7-c484-4cb7-a096-295ef0a46f95]</span><br><span class="line">[2021-06-07 10:58:58,600: INFO/MainProcess] Task celery_app.task1.add[2a4778d7-c484-4cb7-a096-295ef0a46f95] succeeded in 4.047000000020489s: 6</span><br></pre></td></tr></table></figure><p>​    <strong>补充：如果异步任务函数有多个装饰器做装饰，需要确保的是 <code>@app.task</code> 一定是要在最上方</strong></p><h3 id="task-和-shared-task"><a href="#task-和-shared-task" class="headerlink" title="task 和 shared_task"></a>task 和 shared_task</h3><p>​    通常在定义一个异步函数时，会使用 @app.task，task 中默认第一个参数就是 self，就是 celery 的实例，但是默认异步函数不会与 celery 的实例绑定在一起，如果异步函数中要是用 celery 实例的其他属性或方法，就需要给 task 设置属性 bind=True，让任务和 celery 连接起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task(<span class="params">bind=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    <strong>使用 bind=True 的常见场景就是任务重试，只要异步任务绑定了 celery 的实例，如果异步任务执行失败需要重试，就可以去执行 <code>app.Task.retry()</code> 进行重试</strong></p><p>​    另外除了 task 还有一个 shared_task，这个作用是为了避免任务对 celery 的实例产生依赖，因为一个项目下会存在多个应用，多个应用可能会使用到很多需要 celery 处理的异步任务，如果有些任务本身与 celery 的 app 没有强烈的联系，可以在项目的多个应用中都会使用，那么就可以使用 shared_task</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>​    任务调度执行常见有两种方法，上面是直接使用 delay 方法启动异步任务，<strong>delay 方法可以接受参数，这些参数会给到任务函数</strong></p><p>​    还有一种是 apply_async 方法，这个方法和 delay 是类似的，不过相比 delay 方法，<strong>apply_async 能够接受一些运行需要的参数，比如可以设置使用的队列，多少时间内执行等等</strong></p><h3 id="多个子任务"><a href="#多个子任务" class="headerlink" title="多个子任务"></a>多个子任务</h3><p>​    有时在一个任务中可能会需要等待其他的任务处理完成的响应，但是如果是在一个异步任务的函数中，通过 delay 去执行其他的子任务，这样会导致这些子任务的执行成为同步的方式，多个子任务会等待执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_page_info</span>(<span class="params">url</span>):</span><br><span class="line">    page = fetch_page.delay(url).get()</span><br><span class="line">    info = parse_page.delay(url, page).get()</span><br><span class="line">    store_page_info.delay(url, info)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">return</span> myhttplib.get(url)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_page</span>(<span class="params">url, page</span>):</span><br><span class="line">    <span class="keyword">return</span> myparser.parse_document(page)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store_page_info</span>(<span class="params">url, info</span>):</span><br><span class="line">    <span class="keyword">return</span> PageInfo.objects.create(url, info)</span><br></pre></td></tr></table></figure><p>​    <strong>在 celery 中提供了针对多个任务的处理就是使用 chain，利用 任务链 将任务连接起来，一个 worker 执行完一个任务后，后续的任务就会自动被执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> celery <span class="keyword">import</span> chain</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> proj.tasks <span class="keyword">import</span> add, mul</span><br><span class="line"></span><br><span class="line"><span class="comment"># (4 + 4) * 8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain(add.s(<span class="number">4</span>, <span class="number">4</span>) | mul.s(<span class="number">8</span>))().get()</span><br><span class="line"><span class="number">64</span></span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 上面例子中同步子任务，使用 chain 就可以按照下面的方式来写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_page_info</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># fetch_page -&gt; parse_page -&gt; store_page</span></span><br><span class="line">    chain = fetch_page.s(url) | parse_page.s() | store_page_info.s(url)</span><br><span class="line">    chain()</span><br></pre></td></tr></table></figure><h3 id="routing"><a href="#routing" class="headerlink" title="routing"></a>routing</h3><p>​    通常可能会出现，项目中使用多个不同的 worker 处理不同类型的任务，比如可能在 redis 的 1 库用来作为处理异步邮件发送的队列，而使用 redis 的 2 库作为文件上传的队列，或是 3 库来定时任务的队列等等</p><p>​    所以在使用多个 worker 处理不同任务时，就需要实现一个路由来将任务做分发，让指定的队列接收各自收到的任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task_queues = &#123;     <span class="comment"># task_queues 定义 broker 的各个队列</span></span><br><span class="line">    <span class="string">&#x27;queue1&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;exchange&#x27;</span>: <span class="string">&#x27;queue1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;routing_key&#x27;</span>: <span class="string">&#x27;queue1&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;queue2&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;exchange&#x27;</span>: <span class="string">&#x27;queue2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;routing_key&#x27;</span>: <span class="string">&#x27;queue2&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task_routes = &#123;     <span class="comment"># task_routes 定义各个队列和任务的映射，让指定的任务使用指定的队列</span></span><br><span class="line">    <span class="string">&#x27;celery_app.tasks.my_task1&#x27;</span>: &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;queue1&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;celery_app.tasks.my_task2&#x27;</span>: &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;queue1&#x27;</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;celery_app.tasks.my_task3&#x27;</span>: &#123;<span class="string">&#x27;queue&#x27;</span>: <span class="string">&#x27;queue2&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    除了在配置中设置 task_routes 路由来将任务分发到指定的队列外，在使用 apply_async 的方法调用执行任务函数的时候，可以使用 queue 属性去指定要发送的队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.apply_async(queue=<span class="string">&#x27;queue1&#x27;</span>)    <span class="comment"># 调用时，使用 apply_async 方式，可以传递 queue 指定队列</span></span><br></pre></td></tr></table></figure><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>​    除了对 IO 阻塞任务做异步处理，celery 也能实现定时任务，<strong>使用定时任务，需要配置 celerybeat_schedule</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">app.conf.update(</span><br><span class="line">    CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">        <span class="string">&#x27;add_task&#x27;</span>:&#123;</span><br><span class="line">            <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_app.task1.add&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;schedule&#x27;</span>: timedelta(scconds=<span class="number">20</span>),</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: (<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;multi_task&#x27;</span>: &#123; </span><br><span class="line">            <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_app.task2.multi&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;schedule&#x27;</span>: crontab(hour=<span class="number">17</span>, minute=<span class="number">30</span>, day_of_week=<span class="number">1</span>),</span><br><span class="line">            <span class="string">&#x27;args&#x27;</span>: (<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​    celerybeat_schedule 配置项是一个字典结构，其中以任务名做为 key，value 也是一个字典包括三个键值，task 就是要执行的任务，schedule 就是定时的设置，agrs 就是执行时传给任务的参数</p><p>​    <strong>定时任务的 schedule 的设置可以有两种方式，使用 datetime 模块的 timedelta</strong>，适用于比较频繁的定时任务。或是 <strong>使用 celery 的 schedule 的 crontab 模块</strong>，这个更适于周期相对比较大的定时任务</p><p>​    <strong>timedelta 的参数有：days（天），second（秒），minutes（分钟），hours（小时）</strong></p><p>​    <strong>crontab 的参数有：month_of_year（月份），day_of_month（日期），day_of_week（周），hour（小时），minute（分钟）</strong></p><p>​    配置了 <strong>定时任务，需要通过 celery beat 命令去启动</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; celery beat -A celery_app -l info</span><br></pre></td></tr></table></figure><p>​    <strong>celery beat 命令会在 celery 下开启一个 beat 进程，该进程会不断判断是否有定时任务需要被执行</strong>，<strong>注意 beat 和 worker 是两个不同的进程</strong>，所以启动 beat 后还需要去启动 worker</p><p>​    如果要 <strong>同时启动 beat 和 worker，可以使用 -B 或 -b 参数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; celery -b -A celery_app worker -l info</span><br></pre></td></tr></table></figure><p>​    <strong>补充：两个启动参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--without-gossip    Don’t subscribe to other workers events.</span><br><span class="line">--without-mingle    Don’t synchronize with other workers at start-up.</span><br></pre></td></tr></table></figure><p>​    <code>--without-gossip</code> 表示不去订阅其他的 worker，默认情况下启动多个 celery worker，这些 worker 会通过订阅方式知道相互之间的状态，官方文档中说目前只用于各 worker 之间的时钟同步，但 gossip 未来会有很多扩展的可能性<br>​    <code>--without-mingle</code> 表示在启动 worker 时不要和其他 worker 同步。默认情况下一个集群里的 worker 在启动时会向其他 worker 进行数据同步，其中包括已撤销的数据和逻辑始终等，在启动时会有一秒的延迟来进行同步操作</p><h3 id="celery-配置"><a href="#celery-配置" class="headerlink" title="celery 配置"></a>celery 配置</h3><p>​    对于每一个 celery 实例，都有一个 conf 的属性可以配置 celery 使用的配置信息，这样在实例 app 的时候就不要再传入 broker 和 backend，celery 会自动根据配置去找到对应的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"><span class="comment"># 增加配置</span></span><br><span class="line">app.conf.update(</span><br><span class="line">    result_backend=<span class="string">&#x27;redis://localhost:6379/1&#x27;</span>,</span><br><span class="line">    broker_url=<span class="string">&#x27;redis://localhost:6379/1&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​    不过，对于相对较大的项目，可以创建一个 config 的配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.py</span></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://localhost:6379/1&#x27;</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://localhost:6379/1&#x27;</span></span><br></pre></td></tr></table></figure><p>​    那么在实例创建的时候，就可以导入这个配置文件来使用，app 提供了一个方法 config_from_object，这个方法可以指定配置文件的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.config_from_object(<span class="string">&#x27;celery_app.config&#x27;</span>)</span><br><span class="line"><span class="comment"># config_from_object 表示通过 celery 实例对象去导入配置信息</span></span><br></pre></td></tr></table></figure><p>​    其余相关配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">BROKER_URL = <span class="string">&#x27;redis://localhost:6379/1&#x27;</span></span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://localhost:6379/1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 worker 并发数</span></span><br><span class="line">CELERYD_CONCURRENCY = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置任务被执行后，再去确认（默认是任务执行就会确认）</span></span><br><span class="line"><span class="comment"># ack_late 的目的是防止任务出现执行期间反生崩溃，导致不知道任务状态，即使通过 retry 方法重试，还是会立即确认，那么这个任务将永远不能正确执行完成</span></span><br><span class="line">CELERY_ACKS_LATE = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非常重要，有些情况下可以防止死锁</span></span><br><span class="line">CELERYD_FORCE_EXECV = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 worker 最多执行 100 个任务就会被销毁，防止内存泄漏</span></span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置单个任务的最大运行时间，单位是 秒</span></span><br><span class="line">CELERYD_TASK_TIME_LIMIT = <span class="number">5</span> * <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入任务模块</span></span><br><span class="line">CELERY_IMPORTS = (</span><br><span class="line">    <span class="string">&#x27;celery_app.task1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;celery_app.task2&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置不同任务的队列，和 task_toutes 类似</span></span><br><span class="line">CELERY_QUEUES = &#123;</span><br><span class="line">    <span class="string">&#x27;beat_tasks&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 定时任务</span></span><br><span class="line">        <span class="string">&#x27;exchange&#x27;</span>: <span class="string">&#x27;beat_tasks&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;exchange_type&#x27;</span>: <span class="string">&#x27;direct&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;binding_key&#x27;</span>: <span class="string">&#x27;beat_tasks&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;work_queue&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># 普通任务</span></span><br><span class="line">        <span class="string">&#x27;exchange&#x27;</span>: <span class="string">&#x27;work_tasks&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;exchange_type&#x27;</span>: <span class="string">&#x27;direct&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;binding_key&#x27;</span>: <span class="string">&#x27;work_tasks&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认使用的任务队列</span></span><br><span class="line">CELERY_DEFAULT_QUEUE = <span class="string">&#x27;work_queue&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置定时任务计划</span></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="string">&#x27;task1&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_app.task1.add&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: timedelta(seconds=<span class="number">10</span>),   <span class="comment"># timedelta 用来计算时间差，表示当前任务执行计划是 每 10 秒执行一次</span></span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (<span class="number">40</span>, <span class="number">10</span>)    <span class="comment"># args 的参数会传递给执行的任务</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;task2&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;celery_app.task2.multiply&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: crontab(hour=<span class="number">16</span>, minute=<span class="number">37</span>),    <span class="comment"># crontab 可以设置固定时间的任务</span></span><br><span class="line">        <span class="string">&#x27;args&#x27;</span>: (<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="django-中使用-celery"><a href="#django-中使用-celery" class="headerlink" title="django 中使用 celery"></a>django 中使用 celery</h3><p>​    在 django 中使用 celery 的话，配置可以使用导入方式，可以直接将 celery 的配置写在 django 的 settings 里。如果是在 django 中引入一个 celery 应用，那么需要先安装 django-celery 这个库，然后在 celery 配置上引入 djcelery 并做加载，注意在 django 的 install-app 中要添加上 djcelery，djcelery 支持利用 django 的 manage.py 去启动 celery</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line"></span><br><span class="line">.... <span class="comment"># 一系列的配置</span></span><br></pre></td></tr></table></figure><p>​    然后，在 django 的 settings 中导入这个配置 <code>from celery_app.celeryconfig import *</code></p><p>​    如果是将 celery 配置直接写入 django 的配置文件中，那么在实例 celery 的时候需要去设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 celery 配置加入到 django 的配置环境中</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;proj.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 celery app</span></span><br><span class="line">app = Celery(<span class="string">&#x27;proj&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 django 的 settings 中得到 CELERY_ 开头的配置信息</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;django.conf:settings&#x27;</span>, namespace=<span class="string">&#x27;CELERY&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 celery 能够自动去加载 django 的任务函数</span></span><br><span class="line">app.autodiscover_tasks()</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 基础</title>
      <link href="/882465098/"/>
      <url>/882465098/</url>
      
        <content type="html"><![CDATA[<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>​    ES6 中新增的两个声明语法 let 和 const，原本 ES 的声明使用都是用 var，但是 var 的变量会因为声明提前，且 var 声明的变量是全局的，可以被任意修改，导致执行结果不是预期值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)     <span class="comment">// undefined，var a 声明变量会在最开始去执行，此时 a 没有赋值，执行输出，返回是 undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)     <span class="comment">// 1，因为 var 的变量提升，相当于将 var a = 1，拆成了 var a 和 a = 1 两个语句，并将 var a 放置在代码最前部，所以执行完 a = 1，a 就被赋值了</span></span><br></pre></td></tr></table></figure><p>​    所以，<strong>使用 var 定义变量，无论在代码的任何位置，最终都会成为一个全局作用域上的变量</strong>，那么在 for 循环语句中就会出现问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>​    在通过 var 变量 i 进行循环遍历后，数组 a 的每一个元素都是一个匿名函数，循环遍历完成后，全局的 i 就是 10，而当调用数组 a 的函数时，函数的输入是此刻全局的 i 的值，而不是循环中预期输出的值</p><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>​    针对 var 的问题，可以使用 ES6 新增的 let 语法来解决，<strong>let 的变量，只在声明的空间内有效，没有变量提升，并且同作用域中不能重复声明</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// 1，let 的变量不会有变量提升的问题 </span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined，全局空间不能访问 let 变量的值</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>​    这里的循环，会输出预期值，因为 let 的 i 变量只对当前这此循环的空间有效，所以数组 a 中的匿名函数对象在各自的空间内，都有一个变量 i，而 i 的值就是当前循环的次数</p><p>​    <strong>注意：一个循环语句 for，for 循环语法中的变量其实这个循环的父级作用域，而循环体内部的代码块有着自己单独的子作用域</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;    <span class="comment">// 用于计数的 i 和循环体内的 i 并不是一个作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>​    所以在 <strong>不同的空间作用域下，let 的变量名可以相同，并且相互之间不会影响，这就解决了 var 的变量可能存在的变量名污染问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>​    可见在 <strong>同一作用域下 let 的变量不允许重复声明</strong>，而 var 的变量是可以重复声明的，并且后一次会覆盖前一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);   <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    let 的出现为 ES6 带来了 <strong>块级作用域，即 {} 作为一个块，块可以嵌套，每一个块的作用域相互不干扰</strong>，所以更加明确了 let 的变量在不同作用域下，不会出现覆盖</p><p>​    <strong>注意：</strong>ES6 里规定了局部中存在 let  和 const 声明，那么这些变量就不能提前使用，即使这个变量在全局中存在，可不会和全局绑定，而是和内部封闭的作用域绑定，如果提前访问，那么直到变量被 let 或 const，都称为 “暂时性死区” temporal dead zone，简称 TDZ </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>​    <strong>const 的变量的特点是 只读，变量一经 const 声明就需要立即完成初始化赋值，这个值在之后就不能被更改</strong>，所以 const 都用来声明固定的值，比如常量</p><p>​    const 和 let 有类似的地方，比如都不会有变量提升，都存在自己的块级作用域防止污染，<strong>因为 const 的只读特点，所以 const 自然也不能重复声明</strong></p><p>​    <strong>注意：</strong>const 的不可变，本质上是不允许将 const 的值指向的内存地址所保存的数据被更改，但是需要特别注意，如果这个常量的数据类型是一个可变的容器类型，如数组，对象，那么数据的更改依旧是可以操作的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>​    是赋值操作的一种扩展方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c)    <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];   <span class="comment">// ... 可以将剩余元素做解构赋值</span></span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3，数组是空，a 和 b 都匹配得到 undefined，所以触发默认值的赋值</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1，数组有元素 1，所以 a 和 b 的赋值将被 1 覆盖，默认值不生效</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2，数组中有两个元素，所以可以对应赋值给 a 和 b，默认值不生效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;  </span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;   // 对象的结构赋值，可以直接给出 key</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>​    <strong>ES6 在基本数据类型 string，number，boolean，objecct，null，undefined 之外，新增了 symbol</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="title class_">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="title function_">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="title class_">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>​    可见 symbol 类型可以确保每一个值都是不同的，所以可以作为对象的属性名</p><h4 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h4><table><thead><tr><th>null</th><th>undefined</th></tr></thead><tbody><tr><td>可作为赋值的值，表示变量不指向任何对象</td><td>也可作为赋值的值，变量未赋值时默认值是 undefined</td></tr><tr><td>使用 typeof 查看类型，会返回 object</td><td>使用 typeof 返回还是 undefined</td></tr><tr><td>null 表示的是值为空，或不存在引用</td><td>undefined 表示变量对定义或未赋值</td></tr><tr><td><strong>两个值为 null 的变量做 + - / * 时，会返回 0</strong></td><td><strong>两个值为 undefined 的变量做 + - / * 时，会返回 NaN</strong></td></tr></tbody></table><h3 id="Map-对象"><a href="#Map-对象" class="headerlink" title="Map 对象"></a>Map 对象</h3><p>​    map 和 object 很类似，都是键值对的形式，但是 <strong>object 的 key 只能是 string 或 symbo 两个类型，而 map 则没有这个限制</strong></p><p>​    并且 <strong>map 的键值是有顺序的，默认是 FIFO 的顺序，同时 ，map 对象可以通过 size 获取键值对个数，而 object 对象则需要通过遍历来计数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">var</span> keyString = <span class="string">&quot;a string&quot;</span>; </span><br><span class="line">myMap.<span class="title function_">set</span>(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">get</span>(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line">myMap.<span class="title function_">get</span>(<span class="string">&quot;a string&quot;</span>);   <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keyObj = &#123;&#125;;</span><br><span class="line">myMap.<span class="title function_">set</span>(keyObj, <span class="string">&quot;和键 keyObj 关联的值&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">get</span>(keyObj); <span class="comment">// &quot;和键 keyObj 关联的值&quot;</span></span><br><span class="line">myMap.<span class="title function_">get</span>(&#123;&#125;); <span class="comment">// undefined, 因为 keyObj !== &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keyFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 函数</span></span><br><span class="line">myMap.<span class="title function_">set</span>(keyFunc, <span class="string">&quot;和键 keyFunc 关联的值&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">get</span>(keyFunc); <span class="comment">// &quot;和键 keyFunc 关联的值&quot;</span></span><br><span class="line">myMap.<span class="title function_">get</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;) <span class="comment">// undefined, 因为 keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>​    map 可以和 arry 相互转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMap)    <span class="comment">// Map &#123; &#x27;key1&#x27; =&gt; &#x27;value1&#x27;, &#x27;key2&#x27; =&gt; &#x27;value2&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(myMap))   <span class="comment">// [ [ &#x27;key1&#x27;, &#x27;value1&#x27; ], [ &#x27;key2&#x27;, &#x27;value2&#x27; ] ]</span></span><br></pre></td></tr></table></figure><h3 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h3><p>​    set 是元素唯一的集合，所以适合用来给数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...mySet]; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]); <span class="comment">// &#123;1, 2, 3, 4&#125;   // 并集</span></span><br><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x))); <span class="comment">// &#123;2, 3&#125;   // 交集</span></span><br><span class="line"><span class="keyword">var</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x))); <span class="comment">// &#123;1&#125;    // 差集</span></span><br></pre></td></tr></table></figure><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">string.<span class="title function_">includes</span>(<span class="string">&quot;banana&quot;</span>);     <span class="comment">// true     // includes 方法返回参数字符串是否在 string 中出现</span></span><br><span class="line">string.<span class="title function_">startsWith</span>(<span class="string">&quot;apple&quot;</span>);    <span class="comment">// true     // startWith 方法返回参数字符串是否是 string 的头部</span></span><br><span class="line">string.<span class="title function_">endsWith</span>(<span class="string">&quot;apple&quot;</span>);      <span class="comment">// false    // endWith 方法返回参数字符串是否是 string 的尾部</span></span><br><span class="line">string.<span class="title function_">startsWith</span>(<span class="string">&quot;banana&quot;</span>,<span class="number">6</span>)  <span class="comment">// true     // 从索引 6 开始字符串的头部是否是参数字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;*&quot;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>));    <span class="comment">// &quot;**&quot;     // repeat 方法接收一个正数，用来重复字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>,<span class="string">&quot;0&quot;</span>));  <span class="comment">// &quot;00001&quot;   // padStart 和 padEnd 都可以接收两个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>,<span class="string">&quot;0&quot;</span>));    <span class="comment">// &quot;10000&quot;   // 第一个参数是补全后字符串的最小长度，补全的字符串超过该值则会被截断</span></span><br><span class="line">                                                <span class="comment">// 第二个参数是补全使用的字符串，默认是空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;ham&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>)  <span class="comment">// hello ham    // `` 是模板字符串，可以用来当做格式化字符串操作</span></span><br></pre></td></tr></table></figure><h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b11</span>   <span class="comment">// 0b 或 0B 表示二进制</span></span><br><span class="line"><span class="number">0o11</span>   <span class="comment">// 0o 或 0O 表示八进制</span></span><br><span class="line"></span><br><span class="line">number.<span class="built_in">parseInt</span>()     <span class="comment">// parseInt 方法从全局方法改为 number 对象的方法，但全局的 parseInt 方法依然保留</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseFloat</span>()   <span class="comment">// 同理 parseInt，也保留了全局方法</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&#x27;0011&#x27;</span>,<span class="number">2</span>);   <span class="comment">// 3   // parseInt 的第二个参数，是指定数值的进制，默认 parseInt 是 10 进制</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">0</span>)   <span class="comment">// isInteger 判断是否为整数，如果参数是字符串，返回的是 false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="number">10.2</span>)    <span class="comment">// 10  // math 模块的 trunc 方法返回数字的整数部分，如果参数是字符串会被转为数值类型后操作</span></span><br></pre></td></tr></table></figure><h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><p>​    对象的创建是使用 Object 的 create 方法，该方法会通过将原型对象作为参数传递创建一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)      <span class="comment">// 等同于字面量方式 var object = &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>​    js 中还有一种基于函数来创建对象，也就是构造器函数，这种方式在创建对象时需要使用 new 关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;           <span class="comment">// 构造函数 的特点是，函数名的首字母是大写的</span></span><br><span class="line">    <span class="keyword">var</span> object = &#123;&#125;</span><br><span class="line">    object.<span class="property">name</span> = name</span><br><span class="line">    object.<span class="property">age</span> = <span class="number">22</span></span><br><span class="line">    <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ham&#x27;</span>)    <span class="comment">// 注意使用 new 来实例对象</span></span><br></pre></td></tr></table></figure><p>​    如果构造器函数中有固定的默认值，也可以在构造器函数的原型上定义属性或方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;ham&#x27;</span>     <span class="comment">// 在构造函数的原型对象上创建 name 属性</span></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ham&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> d2 = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">21</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;...d1, ...d2&#125;)   <span class="comment">// &#123; name: &#x27;ham&#x27;, age: 21 &#125;   // 可以用 &#123;&#125; 和 ... 合并多个对象</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(d1, d2)    <span class="comment">// Object.assign 方法同样可以合并多个数组，合并的结果会在第一个参数的对象上</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d1)          <span class="comment">// &#123; name: &#x27;ham&#x27;, age: 21 &#125;</span></span><br><span class="line"><span class="comment">// 注意 assign 方法拷贝是浅拷贝，所以原对象中的值改变，合并后的对象的值也会改变</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>,<span class="number">3</span>], [<span class="number">5</span>]);  <span class="comment">// [5,3]  </span></span><br><span class="line"><span class="comment">// Object.assign 还可以合并数组，但合并时会将 [1,3] 转为 &#123;0:1, 1:3&#125;，[5] 转为 &#123;0:5&#125;，所以合并后就是 &#123;0:5, 1:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">1</span>,<span class="number">1</span>);       <span class="comment">// true  // Object.is 方法判断两个值是否严格相等，类似于 ===</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(d1)     <span class="comment">// freeze 方法接收一个对象，会让该对象变为不可变对象，即无法修改属性和值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(d1)   <span class="comment">// isFrozen 方法接收一个对象，用于判断该对象是否是冻结状态</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(d1)       <span class="comment">// seal 方法同样接收一个对象，不同于 freeze 的是 seal 方法密封对象后，对象属性可修改</span></span><br></pre></td></tr></table></figure><h4 id="构造函数，原型对象，原型链"><a href="#构造函数，原型对象，原型链" class="headerlink" title="构造函数，原型对象，原型链"></a>构造函数，原型对象，原型链</h4><p>​    构造函数可以看作是一个类，通过使用 <code>new</code> 关键字来创建实例对象</p><p>​    对于 <strong>构造函数 来说，它还有个属性 <code>prototype</code>，指向的是构造函数的 原型对象，而对于这个 原型对象，它有一个 <code>constructor</code> 的属性，指向的是这个 构造函数</strong></p><p>​    当通过 new 实例出构造函数的实例对象后，这个 <strong>实例对象会有一个隐式属性 <code>__prot__</code>，这个属性同样指向的是构造函数 <code>prototype</code> 所指向的 原型对象 的 <code>prototype</code></strong>，这样一来对于实例对象来说，就可以通过这个隐式属性去原型对象上寻找在构造函数上没有定义的属性或方法</p><p>​    对于 构造函数 中 <code>prototype</code> 所指向的 原型对象 并不是最后的对象，这个 原型对象 也拥有一个 <code>__proto__</code> 属性指向上一层的 原型对象，而这个对象其实就是 js 的 Object 对象</p><p><img src="https://wei-foun.github.io/img/%E5%8E%9F%E5%9E%8B%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="img"></p><p>​    <strong>原型链，就是当一个对象调用的属性/方法自身不存在时，就会去自己 <code>__proto__</code> 关联的前辈 <code>prototype</code> 对象上去找，如果没找到，就会去该原型对象 <code>__proto__</code> 关联的前辈 <code>prototype</code> 去找。依次类推，直到找到属性/方法 undefined 为止</strong></p><p>​    <strong>补充：使用 new 实例化对象时，会创建一个 this 变量引用该对象，属性和方法会被加入到 this 引用的对象中</strong></p><h4 id="call，apply，bind"><a href="#call，apply，bind" class="headerlink" title="call，apply，bind"></a>call，apply，bind</h4><p>​    这三个函数的作用是类似的，都可以改变 this 的指向问题</p><p>​    <strong>call 方法</strong>：<strong>需要满足 this 调用属性，参数也逐个对应</strong>，如果参数没有给值，或者 this 的属性不存在，都返回 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employee1 = &#123;<span class="attr">firstName</span>: <span class="string">&#x27;alex&#x27;</span>, <span class="attr">lastName</span>: <span class="string">&#x27;ham&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> employee2 = &#123;<span class="attr">firstName</span>: <span class="string">&#x27;tony&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invite</span>(<span class="params">greeting1, greeting2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting1 + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>+ <span class="string">&#x27;, &#x27;</span>+ greeting2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invite.<span class="title function_">call</span>(employee1, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;How are you?&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello alex ham, How are you?</span></span><br><span class="line">invite.<span class="title function_">call</span>(employee2, <span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello tony undefined, undefined</span></span><br></pre></td></tr></table></figure><p>​    <strong>apply 方法</strong>：<strong>和 call 类似，但 apply 允许接收一个数组作为参数</strong>，这样就是省去了用 call 方法需要一个个将参数传递，因此 call 和 apply 方法可以相互转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invite.<span class="title function_">apply</span>(employee1, [<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;How are you?&#x27;</span>])</span><br><span class="line"><span class="comment">// Hello alex ham, How are you?</span></span><br></pre></td></tr></table></figure><p>​    <strong>bind 方法</strong>：和前两者有所不同，<strong>通过 bind 调用时，实际上会产生一个新函数，bind 会将 this 传递给 bind 方法的第一个参数，而函数原本的参数需要传递给使用 bind 创建的新函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inviteEmployee1 = invite.<span class="title function_">bind</span>(employee1)</span><br><span class="line"><span class="title function_">inviteEmployee1</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;How are you?&#x27;</span>)</span><br><span class="line"><span class="comment">// Hello alex ham, How are you?</span></span><br></pre></td></tr></table></figure><h4 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h4><p>​    对于构造函数来说，继承需要通过改变 this 指向来实现，这样实现的好处是拒绝了引用的属性被实例所共享，因为 this 只会指向调用者，但是这种继承存在父类的原型不会被子类继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;parent1&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;<span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);<span class="variable language_">this</span>.<span class="property">type</span>=<span class="string">&#x27;child&#x27;</span>&#125;</span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">Child</span>()   <span class="comment">// Child &#123;name: &#x27;parent1&#x27;, type: &#x27;child&#x27;&#125;</span></span><br><span class="line">s1.<span class="property">name</span>=<span class="string">&#x27;child1&#x27;</span></span><br><span class="line">s2 = <span class="keyword">new</span> <span class="title class_">Child</span>()   <span class="comment">// Child &#123;name: &#x27;parent1&#x27;, type: &#x27;child&#x27;&#125;</span></span><br><span class="line">s1.<span class="property">name</span>            <span class="comment">// &#x27;child1&#x27;</span></span><br><span class="line">s2.<span class="property">name</span>            <span class="comment">// &#x27;parent1&#x27;</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;    <span class="comment">// ƒ () &#123;&#125;</span></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="title class_">Parent</span>()  <span class="comment">// Parent &#123;name: &#x27;parent1&#x27;&#125;</span></span><br><span class="line">p1.<span class="property">say</span>             <span class="comment">// ƒ () &#123;&#125;</span></span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">Child</span>()   <span class="comment">// Child &#123;name: &#x27;parent1&#x27;, type: &#x27;child&#x27;&#125;</span></span><br><span class="line">s1.<span class="property">say</span>             <span class="comment">// undefined     // 父类原型的方法无法被子类使用</span></span><br></pre></td></tr></table></figure><h4 id="原型链的继承"><a href="#原型链的继承" class="headerlink" title="原型链的继承"></a>原型链的继承</h4><p>​    利用了实例对象和构造函数都有属性指向原型对象的特点，将子类的 prototype 属性改为父类构造函数的实例对象，这样子类相当于继承了父类所有的属性和方法</p><p>​    但是使用原型链继承，如果原型的属性和方法被修改，那么子类的不同实例对象都会共享这个原型的修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;parent1&#x27;</span>;<span class="variable language_">this</span>.<span class="property">list</span>=[<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span>=name&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"></span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;alex&#x27;</span>)    <span class="comment">// Child &#123;name: &#x27;alex&#x27;&#125;</span></span><br><span class="line">s2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;tony&#x27;</span>)    <span class="comment">// Child &#123;name: &#x27;tony&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">s1.<span class="property">list</span>  <span class="comment">// [1, 2]</span></span><br><span class="line">s2.<span class="property">list</span>  <span class="comment">// [1, 2]</span></span><br><span class="line">s1.<span class="property">list</span>.<span class="title function_">push</span>(<span class="number">3</span>)       <span class="comment">// 父类属性修改会影响所有的子类</span></span><br><span class="line">s1.<span class="property">list</span>  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">s2.<span class="property">list</span>  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><h4 id="slice-和-splice"><a href="#slice-和-splice" class="headerlink" title="slice 和 splice"></a>slice 和 splice</h4><p>​    slice 是基本的数组切片操作，<strong>slice 的返回是一个新数组</strong>，所以 slice 操作 <strong>不会对原数组造成修改</strong></p><p>​    splice 是根据索引来向数组添加或删除的操作，<strong>会将删除的元素放入数组返回</strong>，同时也 <strong>会对原数组造成修改</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">2</span>)    <span class="comment">// [1,2]</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>(<span class="number">4</span>)      <span class="comment">// [5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">2</span>)             <span class="comment">// [1,2]    arr = [3,4,5]   splice 修改了原数组</span></span><br><span class="line"><span class="keyword">let</span> newArr = arr.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)   <span class="comment">// [4]      arr = [1,2,3,&#x27;a&#x27;,&#x27;b&#x27;,5]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">10</span>)    <span class="comment">// [10,10,10]   // Array(3) 预设一个长度为 3 的数组，fill 方法将参数作为每一个元素的值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)        <span class="comment">// [1,2,3]    // Array.of 方法可以接受多个参数，并全部加入到数组中返回</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)    <span class="comment">// [1,2,3]    // Array.from 方法可以将可迭代对象转为数组</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="number">0</span>: <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;)  <span class="comment">// [1,2]   // Array.from 方法可以接受类数组对象，但必须要要有 length 属性，否则就会返回空数组 []，注意类数组对象的 key 必须是数值，否则数组的元素会是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n * <span class="number">2</span>))   <span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="comment">// Array.from 方法的第二个参数 mapFn，map 函数会将数组每一个元素代入 map 函数做操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="attr">do</span>: <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arrayLike = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="keyword">function</span> (<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">do</span>(n);      <span class="comment">// Array.from 方法的第三个参数是 map，可以指定 this 用来做更加复杂的操作</span></span><br><span class="line">&#125;, map)); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">keys</span>())   <span class="comment">// [0,1,2]   // 组合使用 Array 和 from 创建 0-2 的数组</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)          <span class="comment">// 3   // find 方法可以返回符合条件的第一个元素</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item == <span class="number">2</span>)    <span class="comment">// 1   // findIndex 方法返回符合条件的第一个元素的索引</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)   <span class="comment">// true    // includes 方法和 string 的一致，是否包含参数元素</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span> ,[<span class="number">2</span>, <span class="number">3</span>]].<span class="title function_">flat</span>()    <span class="comment">// [1, 2, 3]    // flat 方法可以将嵌套的多为数组拉平成一维数组，flat 方法参数为 Infinity 则无视原数组有多少嵌套，元素都会在一个一维数组</span></span><br></pre></td></tr></table></figure><p>​    数组的遍历，有点像是对象的遍历，数组的索引为 key，而 value 则是索引对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用 for... of 循环</span></span><br><span class="line"><span class="keyword">let</span> entries = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map 方法遍历</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">return</span> e**<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3><p>​    ES-6 中函数有一种新的写法，就是箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;     <span class="comment">// 参数部分 v，如果有多个，可以使用 () 包起来，函数体 v，如果有多行，需要使用 &#123;&#125; 包起来</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span>(<span class="params">v</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>​    <strong>需要注意的是 =&gt; 箭头函数适用于非方法的函数，因为箭头函数中没有 this，super</strong></p><p>​    <strong>箭头函数的内部的 this 指向的是全局的 window，但是可以用 call 或 apply 去改变 this 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义时，this 绑定的是 fn 中的 this 对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// fn 的 this 对象为 &#123;a: 18&#125;</span></span><br><span class="line">fn.<span class="title function_">call</span>(&#123;<span class="attr">a</span>: <span class="number">18</span>&#125;);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>​    立即调用函数，立即执行调用的函数表达式，就是说函数的定义和调用是在一起的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>​    <strong>立即调用函数的一个主要目的是实现数据隐私，在 IIFE 中定义的任何变量，在外部都无法直接访问</strong>，如果访问则会抛出异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&quot;IIFE&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line"><span class="comment">// Error: message is not defined</span></span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>​    回调函数首先本身是一个函数，不同普通函数的是触发方式不同，回调函数做将自己作为一个函数的参数，换句话说就是将自己放入到函数内部，由外部函数才执行触发完成</p><p>​    由于 js 是一种事件驱动的语言，当使用 js 在侦听事件时，通常不会是等待响应而是要继续执行后续的操作或事件，所以回调是非常有必要的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callbackFunction</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="title function_">prompt</span>(<span class="string">&#x27;Please enter your name.&#x27;</span>)</span><br><span class="line">  <span class="title function_">callback</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">outerFunction</span>(callbackFunction)</span><br></pre></td></tr></table></figure><h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><p>​    <strong>回调地狱是一种包含多层嵌套回调函数</strong> 的情况，通常来说会出现回调地狱的一种情况是需要让异步函数按照顺序逐个执行，随着可能的层级越多，回调地狱的代码在可读性上会很复杂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">async1</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async3</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">async4</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                ....</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​    <strong>ES6 新增了 class 关键字来使得类的定义更加清晰</strong>，使用 class 去定义类，本质上其实是 function，<strong>内部要定义初始化方法 constructor</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Example</span> = <span class="keyword">class</span> &#123;     <span class="comment">// Example.name 返回 Example</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a</span>) &#123;      <span class="comment">// constructor 方法是类的默认方法，创建实例对象时会自动调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;       <span class="comment">// constructor 中可以定义实例属性或实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Example</span> = <span class="keyword">class</span> <span class="title class_">Exam</span> &#123;   <span class="comment">// Example.name 返回 Exam </span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用 class 去定义类的方法时，实际上是定义在了原型上，class 创建的类保留了 prototype 属性，另外对于类而言，没有静态属性，只有静态方法，静态方法前需要加上关键字 static</p><p>​    同时，实例属性是在定义类时，在内部定义的变量，可以通过 this 去访问变量</p><p>​    当创建实例对象时，需要使用 new 关键字，这和构造函数创建对象一致</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>​    装饰器的作用其实就是修改类的行为，本身实际上是一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">target</span>) &#123;     <span class="comment">// 定义 testable 的装饰器函数，函数的第一个参数实际上就是类</span></span><br><span class="line">    target.<span class="property">isTestable</span> = <span class="literal">true</span>;   <span class="comment">// 给被装饰的类，添加一个属性 isTestable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Example</span>.<span class="property">isTestable</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​    当然装饰器既然作为函数，自然就可以接受参数，当需定义装饰器参数时，就要创建一个嵌套函数，闭包函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testable</span>(<span class="params">isTestable</span>) &#123;     <span class="comment">// isTestable 作为装饰器函数 testable 的参数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;       <span class="comment">// target 是被装饰的类，这里需要另外使用给一个函数接收这个类，形成闭包</span></span><br><span class="line">        target.<span class="property">isTestable</span>=isTestable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">testable</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Example</span>.<span class="property">isTestable</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>​    装饰器是可以定义多个的，当一个函数或类装饰了多个装饰器，执行的顺序是由外向内进入， 即从上外下进入代码，执行的返回由内向外，即最下面的装饰器会最先返回，将结果给到上一层装饰器</p><h4 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h4><p>​    在默认的构造方法 constructor 里，使用 this 去初始化属性时，会默认调用 set 方法，使用实例对象去调用属性时，会调用 get  方法，setter 和 getter 必须同时存在，否则实例化对象时会抛出异常，并且 set 和 get 两个方法要在同一层中，如果因为继承，将两个方法分开也会出现问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">b</span> = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">a</span>()&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_a</span> = a;  <span class="comment">// 注意，这里如果写 this.a = a，存在递归调用，不断输出 setter，最后触发 RangeError</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> exam1 = <span class="keyword">new</span> <span class="title class_">Example1</span>(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 只输出 setter , 不会调用 getter 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(exam1.<span class="property">_a</span>);           <span class="comment">// 1, 可以直接访问</span></span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​    继承的关键字是 <strong>extends</strong>，另外要注意在子类中的 constructor 方法里还需要使用 super 方法，因为对于子类来说它没有自己的 this 属性，使用的是父类的 this 对象，如果不调用 super 方法在实例化时会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father1</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_a</span> = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father1</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>();     <span class="comment">// 子类中，constrictor 构造方法必须要使用 super()，且要在使用初始化 this 进行赋值前调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> <span class="title class_">Child1</span>();</span><br><span class="line">test1.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test1.<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>​    是在 DOM 结构中，事件捕获会从上往下依次去捕获对应的触发事件，例如父层 div 元素设置有点击事件，子层同样有点击事件，当对子层触发点击时，事件会一级级向内触发捕获</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>​    和事件捕获的顺序正好相反，<strong>事件冒泡是从下往上触发，点击事件会先从最内部对应的事件函数触发，然后一层层向外部触发对应的函数</strong></p><p>​    如果要 <strong>阻止事件在事件链的向上冒泡，可以使用事件的 stopProPagation 方法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;secondFunc()&quot;</span>&gt;</span>DIV 2</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;firstFunc(event)&quot;</span>&gt;</span>DIV 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">firstFunc</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;DIV 1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  event.<span class="title function_">stopPropagation</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">secondFunc</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;DIV 2&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>​    是一种侦听事件的方式，<strong>可以在父级元素上绑定事件侦听，这样子级元素的事件都会被父级侦听到，可以有效减少事件 的注册和绑定</strong></p><p>​    addEventListener 方法接收三个参数，第一个参数是事件名称，名称无需写前缀 on，第二个参数是事件执行函数，第三个参数是布尔类型的值，true 表示在事件捕获阶段触发，false 表示在事件冒泡阶段触发，默认是 false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#registration-form&#x27;</span>);</span><br><span class="line"><span class="comment">// 听从表单内字段的更改</span></span><br><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line"><span class="comment">// 记录已更改的字段</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="异步-promise"><a href="#异步-promise" class="headerlink" title="异步 promise"></a>异步 promise</h3><p>​    js 中通过 promise 对象来获取异步操作的消息，<strong>promise 有三个状态：pending（未完成态），fulfilled（完成态），rejected（失败态），而对于 promise 的最后状态就只有成功或失败</strong></p><p>​    promise 一旦创建执行，就无法进行取消只能等它执行完成，<strong>如果 promise 中没有设置回调，那么 promise 内部会抛出异常，而这个异常不会冒泡到外部</strong></p><p>​    <strong>promise 函数内部有两个回调参数，第一个是 resolve 即执行完成，第二个是 reject，即执行出现错误失败。promise 执行后，可以通过 then 方法去获取返回信息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><p>​    <strong>promise 的 then 方法最后返回其实还是一个 promise 的对象，因此 promise 还可以继续调用 then 方法，也就说 promise 是支持链式调用的</strong></p><p>​    <strong>补充：promise 的 then 方法在 js 中 event loop 中是微任务（Microtask），所以会被加入到微任务的队列中进行处理，对于微任务的处理来说，也不同于宏任务队列，微任务的处理会在执行栈执行完成，清空后执行微任务队列中所有的微任务，而对于宏任务来说，宏任务的队列会有回栈操作</strong></p><p>​    除了 then 之外，<strong>promise 还有 all 的方法，all 方法可以接受一个数组参数，数组中每一个元素都是 promise</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3])</span><br></pre></td></tr></table></figure><p>​    <strong>当 p1，p2，p3 的状态全部都成功 fulfilled 时，p 的状态也会是 fulfilled，p1，p2，p3 的返回结果会以数组形式给到 p 的回调函数 then</strong></p><p>​    <strong>当 p1，p2，p3 的状态其中任意一个为 rejected 时，p 也会为 rejected，第一个状态为 rejected 的结果会给到 p 的回调函数</strong></p><p>​    和 all 方法正好相反的方法是 <strong>race 方法，参数同样是元素为 promise 的数组，但是只会将最先成功或拒绝的 promise 的结果返回给 p 的回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1,p2,p3])</span><br></pre></td></tr></table></figure><h3 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h3><p>​    生成器中可以使用 yield 关键，将函数的执行挂起，从而提供了改变程序执行流程的可能，为异步编程提供了解决方案</p><p>​    js 中的生成器函数会在关键字 function 后面加上 *，然后在需要挂起的地方之前，需要使用 yield 关键字，当执行获取返回时，需要使用 next 方法来开始或者回到上一次挂载的位置继续执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">func</span>(<span class="params"></span>)&#123;     <span class="comment">// function* 表示该函数是一个生成器函数</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"> <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意，生成器的执行机制和普通函数不太相同，虽然调用上都是直接加上 ()  就可以调用，但是生成器不会立即返回第一个结果，生成器函数调用后返回的是指向内部状态对象的指针，因此需要使用可迭代器对象的 next 方法，由 next 去操作指针的走动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title function_">func</span>()</span><br><span class="line">f.<span class="title function_">next</span>()    <span class="comment">// one       // &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>()    <span class="comment">// two       // &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>()    <span class="comment">// three     // &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>()                 <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>​    由此可见，第一次调用 next 方法后，输出了字符串 one，然后执行到 yield 关键字就停止了，yield 后的值作为了返回向的 value 的值，表示当前执行位置的状态是 1，且 done 属性是 false，表示生成器函数还没有执行结束</p><p>​    第二，三次调用 next 方法也是同理，不同的是第三次调用 next 后，输出了字符串 three 后，没有了 yield 的关键字，而是使用 return 来返回，意味着生成器函数到此已执行结束，所以 done 的值是 true。第四次调用 next 由于生成器已经结束，所以不会有任何输出</p><h4 id="next"><a href="#next" class="headerlink" title="next"></a>next</h4><p>​    关于 <strong>next 的调用有两种形式，一种是传参，一种是不传参。不传参的时候，yield 的返回是 undefined，而传参时，这个参数会作为 yield 的返回，也就是说下一次的 next 可以使用本次 next 所传递的参数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">sendParameter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one:&quot;</span> + x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two:&quot;</span> + y);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;total:&quot;</span> + (x + y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp1 = <span class="title function_">sendParameter</span>();</span><br><span class="line">sendp1.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp1.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// one:undefined</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp1.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// two:undefined</span></span><br><span class="line"><span class="comment">// total:NaN</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp2 = <span class="title function_">sendParameter</span>();</span><br><span class="line">sendp2.<span class="title function_">next</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp2.<span class="title function_">next</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// one:20</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp2.<span class="title function_">next</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// two:30</span></span><br><span class="line"><span class="comment">// total:50</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="ES-7-的异步补充-async"><a href="#ES-7-的异步补充-async" class="headerlink" title="ES-7 的异步补充 async"></a>ES-7 的异步补充 async</h3><p>​    增加了关键字 async，当这个关键字出现在函数前，表示这个函数会返回一个 promise，async 简化了异步的编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">helloAsync</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">helloAsync</span>())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">helloAsync</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​    与 async 对应的关键字是 await，如果 async 函数中出现 await 关键字，那么执行到 await 时会进行等待，等待 await 后返回的结果，await 关键字后面可以跟随 promise，这样的话就是表示在 async 异步函数中，需要等待内部 promise 的执行完成</p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-整理-三</title>
      <link href="/1674812330/"/>
      <url>/1674812330/</url>
      
        <content type="html"><![CDATA[<h2 id="性能角度：唯一索引和普通索引的选择"><a href="#性能角度：唯一索引和普通索引的选择" class="headerlink" title="性能角度：唯一索引和普通索引的选择"></a>性能角度：唯一索引和普通索引的选择</h2><p><img src="https://static001.geekbang.org/resource/image/1e/46/1ed9536031d6698570ea175a7b7f9a46.png" alt="img"> </p><p>​    以该图为例，从查询和更新两个角度分析两种索引的性能影响，ID 是唯一索引，k 是普通索引</p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from T where id=5;</span><br></pre></td></tr></table></figure><p>​    在这个查询语句中，会从索引树的根节点开始，按层搜索到叶子节点，最后得到图中右下角的数据页，再使用二分法的在数据页中进行内部查找来定位记录</p><p>​    1）<strong>对于普通索引来说，在数据页中查找到满足条件的第一条记录（5,500）后，还需要往后继续查找下一个记录，直到查找到的记录不满足 k = 5 这个条件为止</strong></p><p>​    2）<strong>对于唯一索引，由于唯一性设置，所以在查找到满足的第一条记录后便会停止继续往后的检索</strong></p><p>​    在 <strong>InnoDB 中，数据是按 数据页 为单位来读写的</strong>，当要读取一条记录的时候，并不会是将记录本身从磁盘进行读取，而是通过以页为单位，将页中的所有数据读取到内存中</p><p>​    因此，在使用普通索引情况下，查询 k=5 时，满足条件后的下一次判断的数据很大程度会在内存中，不过如果 k=5 是在这个页中的最后一条，就会相对麻烦一些，需要将下一页从磁盘读到内存在判断第一条是否是满足查询条件。但是，如果是整型字段，一个数据页几乎存放超过千个的 key，所以对于之前那个情况出现的概览会很低</p><p>​    <strong>所以在查询过程中，虽然普通索引比唯一索引要多出一个判断，但两者的性能差距并没有过于明显的差距</strong></p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>​     在 <strong>更新过程中，普通索引 会使用一个叫做 “change buffer”（写缓冲） 的东西，而唯一索引则不适用</strong></p><p>​    当需要更新一个数据页时，如果数据页存在于内存中，就直接更新；否则，在不影响数据一致性的前提下，<strong>InnoDB 会将更新的操作缓存到 change buffer，来减少对磁盘数据页的读取提升语句执行的速度</strong></p><p>​    同时，<strong>change buffer 数据读入时是会占用 buffer pool（缓冲池） 的</strong>，所以不能无限增大，可以通过参数 <code>innodb_change_buffer_max_size</code> 动态地设置占用的空间阈值，因此 change buffer 可以避免对内存的直接占用，提高内存使用率</p><p>​    <strong>当更新操作完成后，在查询时如果需要访问这个数据页，则将数据页读入内存中，再执行 change buffer 中与这个页有关的操作，以此来保证数据逻辑的正确性，这个过程称为 merge</strong></p><p>​    由此 change buffer 实际是一个可以持久化的数据，除了使用 <strong>查询时会触发 merge，系统也会定期来执行 merge</strong>，包括数据库关闭前也会执行该操作</p><p>​    <strong><em>merge 的流程步骤：</em></strong></p><p>​    <em>1）从磁盘读取老版本的数据页到内存中</em></p><p>​    <em>2）在 change buffer 中找到该数据页的记录，将其应用来生成新版本的数据</em> </p><p>​    <em>3）将 数据变更 和 change buffer 的变更写入 redo log。此时，数据页和内存中 change buffer 对应磁盘的位置都还没进行修改，所以是脏页，而在这之后会各自刷自己的物理数据进行修改</em></p><pre><code>对于唯一索引来说，更新的操作之前会先判断该操作是否违反了唯一性的约束，因此会先将数据页读入到内存才能去判断，而仅对更新这一步而言，由于数据页已经在内存了，所以直接在内存中更新会很快，由此 **唯一索引不使用 change buffer**</code></pre><p>​    所以，对于更新的过程会有两种情况：</p><p>​    <strong>当前更新的数据所在数据页，在内存中</strong></p><p>​    1）唯一索引，找到数据插入的位置，判断是否违反约束，没有则插入值，执行结束</p><p>​    2）普通索引，找到数据插入的位置后，将值插入，执行结束</p><p>​    <strong>当前更新的数据所在数据页，不在内存中</strong></p><p>​    1）唯一索引，将数据页先读取到内存中，在没有冲突情况下，插入值，执行结束</p><p>​    2）<strong>普通索引，将更新的记录存入 change buffer ，执行结束</strong></p><p>​    <strong>当目标数据页在内存中时，唯一索引 和 普通索引 更新过程的效率上没有明显的区别，但是当目标数据页不在内存中时，使用 change buffer 的 普通索引 在更新上的性能会有很明显的提升</strong>，所以当执行 merge 真正做更新时，change buffer 记录下来的数据变更动作越多，更新的收益也就越大</p><p>​    因此对于 <strong>写多读少的业务</strong>，也就是数据写完后被立即访问的概率很小的情况下，<strong>利用 change buffer 的效果最好，类似的场景有账单类，日志类的系统</strong>；相反，如果数据更新后会被马上查询，就算使用了 change buffer 来记录变更，但由于紧随的查询语句，会立刻触发 merge 过程，从而在 随机IO 的次数并不会减少，同时还增加了 change buffer 的维护</p><h3 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log  和  change buffer"></a>redo log  和  change buffer</h3><p>​    <strong>redo log（重做日志）</strong>的目的是为了提高执行效率减少随机访问，对每一条执行的语句会先将操作记录到日志中，然后在适当时会按照日志记录写入进磁盘（WAL，write-ahead logging）</p><p>​    <strong>change buffer（写缓存）</strong>目的同样是为了减少随机访问，只不过会在内存中将操作记录起来，并且根据目标所在数据页是否在内存中，决定是直接内存中修改还是从磁盘读取后再修改</p><p>​    假如执行  <code>insert into t(id,k) values(id1,k1),(id2,k2);</code> 语句，并且加入查找 k 的索引树后，k1 所在的数据页是在 change buffer 中，而 k2 所在的数据页不在内存中，所以这行语句会涉及四个部分：内存，redo log（ib-log-fileX），数据表空间（t.ibd），系统表空间（ibdata1）</p><p><img src="https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png" alt="img"> </p><p>​    执行语句后会有以下的操作：</p><p>​    1）直接在内存中对 k1 所在的数据页 Page1 中，将数据插入</p><p>​    2）k2 所在的 Page2 不在内存，change buffer 将操作记录写入内存</p><p>​    3）redo log 将两个语句（一个是在内存中 k1 的插入，一个是数据页不在内存的 k2 使用 change_buffer 操作）操作写入到日志中，并且是按照顺序写的</p><p>​    虚线部分所指部分分别是：系统表空间，数据表空间，这两张表的操作都是后台完成，不会影响语句的响应时间，因此整个语句执行成本很低，只是写了两处内存，同时两处写操作被一起写磁盘到 redo log</p><p>​    此时，如果查询语句是发生在更新语句后不久，内存中假设数据都还存在，进行查询  <code>select * from t where k in (k1,k2);</code></p><p><img src="https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png" alt="img"> </p><p>​    图中可以看到，在读到 Page1 的时候，是直接从内存中将需要的数据进行返回，所以并不一定要从 redo log 将数据更新到磁盘上，再从磁盘读取</p><p>​    当在读 Page2 时，是将其读到内存中，并应用了 change buffer 里的操作记录，直接的生成正确的数据版本返回，因此只有在需要去读 Page2 中的数据时才会将其引入内存</p><p>​    所以，<strong>redo log 主要节省的是磁盘写入的 随机IO 消耗（转成顺序写）</strong>；<strong>change buffer 节省的则是随机读磁盘的 IO 消耗</strong></p><h2 id="索引有时候为什么会寻错"><a href="#索引有时候为什么会寻错" class="headerlink" title="索引有时候为什么会寻错"></a>索引有时候为什么会寻错</h2><p>​    其实在大所述的情况下，当语句来到优化器这一步时，优化器都可以选择正确的索引，但依然会有出现原本执行速度很快，但实际执行却比预期慢很多的情况</p><p>​    现在建一张表，除主键id外，另有a，b两个字段，分别创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB；</span><br></pre></td></tr></table></figure><p>​    接着往表中插入10万行的记录，按（1,1,1），（2,2,2）… （100000,100000,100000）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>​    接着，执行一条对 a 字段的查询语句，通过   <code>explain</code> 分析后，得到结果可以看到索引使用了 a 的索引，且强制使用索引 a 去查询得到扫描行数和这个结果是一样的都是 10001 行</p><p><img src="https://static001.geekbang.org/resource/image/2c/e3/2cfce769551c6eac9bfbee0563d48fe3.png" alt="img"> </p><p>​    但是如果使用两个事务 session A 和 session B，在 session B 中将所有数据删除后，再将数据添加回来，同时依然使用分析语句去执行查询</p><p><img src="https://static001.geekbang.org/resource/image/1e/1e/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" alt="img"> </p><p>​    通过   <strong>慢查询日志（slow log，通过 <code>long_query_time</code> 设置）</strong>去查看执行情况，并且为了对比是否出现索引选择错误，执行两个相同的查询，但是其中一个 <strong>使用 <code>force index（a）</code> 来强制让优化器使用 索引a</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;   <span class="comment">-- 大于 0 秒的执行都会记录到慢查询日志</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure><p>​    <code>long_query_time=0</code> 来设置慢查询日志的阈值为 0，让这个线程接下来的语句都会被记录在慢查询日志中</p><p><img src="https://static001.geekbang.org/resource/image/7c/f6/7c58b9c71853b8bba1a8ad5e926de1f6.png" alt="img"> </p><p>​    最后的结果中，可以看出使用原来的查询语句出现了索引使用错误的问题，Q1 的查询语句扫描了 10万行，对全表进行了扫描，而 Q2 强制使用 索引a ，则和之前的一样，扫描了 10001 行，且两者的查询时间也相差近一倍，所以前一条查询优化器使用错了索引，导致查询的时间变长</p><h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>​    对于优化器而言，就是选择适合的索引，找到一个最优的执行方案，用最小的代价去执行语句。在数据库里，扫描行数值影响执行代价的因素之一，<strong>扫描的行数越少，意味着对磁盘的访问会越少，对 CPU 资源的消耗就越少</strong></p><p>​    但是扫描行数并不是唯一的影响因素，优化器还会结合是否使用临时表，是否排序等因素进行综合判断，上面的例子中很明显问题是在扫描行数</p><p>​    在 MySQL 执行语句之前，其实也不能精确地知道满足条件的搜索条件的记录会有多少条，而是通过根据统计信息去估算大概的扫描记录数。至于这个统计的信息就是索引的 “区分度”，同一个索引上的值越多，这个索引的区分度就会越好，<strong>索引上不同的值的个数，称为 “基数”（cardinality），所以也就是基数越大，相对索引的区分度越好</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t；  <span class="comment">-- show index 可以查看表的中索引的基数</span></span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/16/d4/16dbf8124ad529fec0066950446079d4.png" alt="img"> </p><p>​    返回的信息可见，即使该表的三个字段的值都是一样的，但统计信息的 基数值 最后可能会出现不同的情况</p><h3 id="索引基数"><a href="#索引基数" class="headerlink" title="索引基数"></a>索引基数</h3><p>​    在 MySQL 中会使用采样统计的方式去计算基数，因为如果是整表每一行记录去进行统计，代价太大了，<strong>InnoDB 通过采样统计方式默认会选择 N 个 数据页，去统计这些页上的不同值，并算出一个平均值，再去乘以这个索引的页面数，来得到最后的索引的基数值</strong></p><p>​    由于数据表是会持续性更新的，因此索引统计信息也会随之改变，<strong>当变更的数据行数超过 1/M 的时候，会自动触发一次重新统计索引</strong>，在 MySQL 中有两种存储索引统计的方式，是可以通过参数 <code>innodb_stats_persistent</code> 来选择的：</p><p>​    1）设置 <strong>on</strong> 状态，<strong>表示统计信息会持久化存储，此时默认的 N 是 20，M 是 10</strong></p><p>​    2）设置 <strong>off</strong> 状态，<strong>表示统计信息只在内存中存储，此时默认的 N 是 8，M 是 16</strong></p><p>​    但是由于索引统计是采样统计方式，所以两种方式无论 N 这个数据页取多少，所得到的基数都很容易不准，而且索引的统计只是一个输入，对具体语句来说，优化器还需要判断语句本身会扫描的行数</p><p><img src="https://static001.geekbang.org/resource/image/e2/89/e2bc5f120858391d4accff05573e1289.png" alt="img"> </p><p>​    从图中可以看到第一个语句扫描行数是 104620 行，如果使用错了索引这个值是符合预期的；但是后一个语句的扫描行数从之前显示的 10001 行 变为了 37116 行，很明显出现了偏差从而误导了优化器的选择，可即使是 37116 要小于 10 万行，可是优化器最后还是选择扫描是 10 万行的执行计划</p><p>​    因为优化器认为选择使用扫描 10 万行的执行计划，这些都是直接在主键索引上扫描的，没有回表操作，不需要额外的代价，使用 索引a，每一次的取值都必须回到主键索引上查找整行数据，优化器认为前者在主键索引上扫描更快，但是最后看执行时间却并不这样，要多近一倍时间</p><p>​    但是在一开始的查询中，同样优化器会考虑到普通索引回表的代价，但还是使用了 索引a，说明策略没有问题，所以问题就是因为扫描行数的错误，所以最后统计信息不对导致没有使用 索引a</p><p>​    <strong>统计的索引信息出现问题，可以使用 <code>analyze</code> 命令手动地重新统计</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> t;</span><br></pre></td></tr></table></figure><p>​    另一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    很显然这个查询语句没有满足的内容返回，但是优化器内部会如何选择索引？</p><p><img src="https://static001.geekbang.org/resource/image/1d/b9/1d037f92063e800c3bfff3f4dbf1a2b9.png" alt="img"> </p><p>​    从 索引a 和 索引b 的结构中图中看，如果是使用 索引a，扫描行数只需是 索引a 前面的 1000 个值，然后用得到的主键索引去回表取行，再根据 字段b 去一一过滤得到最后的返回</p><p>​    如果使用 索引b，则扫描行数是 50001 行，然后执行和 索引a 后续一样的操作，所以按理来说使用 索引a 会更快</p><p>​    使用 explain 来分析一下后，最终优化器选择了 索引b，最后扫描行数是 50198 行，所以依然选错了索引</p><p><img src="https://static001.geekbang.org/resource/image/48/b8/483bcb1ef3bb902844e80d9cbdd73ab8.png" alt="img"> </p><h3 id="索引异常的处理方式"><a href="#索引异常的处理方式" class="headerlink" title="索引异常的处理方式"></a>索引异常的处理方式</h3><p>​    <strong>1）使用 <code>force index</code> 去指定索引</strong></p><p>​    强制优化器按照指定索引去选择执行语句，不让优化器去评估其他的执行代价；但是使用这个语法会有局限性，如果索引名字发生更改，这个指定也必须更改，并且如果出现数据库迁移，这个语法很可能会有不兼容的情况</p><p>​    <strong>2）引导优化器选择正确的索引</strong></p><p>​    上面的例子中，优化器放弃使用 索引a，说明 a 对于优化器来说相比 b 来说不够适合使用，可以将 <code>order by b limit 1</code> 改成 <code>order by b,a limit 1</code></p><p>​    之前优化器使用 索引b，因为对优化器来说   <code>order by b</code> 使用 索引b 可以避免排序，因为 b 本身是索引且有序，选择 b 就不要排序只要遍历且取出第一行，所以对优化器认为这个代价相对更小</p><p><img src="https://static001.geekbang.org/resource/image/14/94/14cd598e52a2b72dd334a42603e5b894.png" alt="img"> </p><p>​    <code>order by b,a</code> 这样的写法意味着这两个索引字段都需要排序，所以扫描行数就成了影响决策的主要条件，优化器就会选择 索引a，这样只用扫描 1000 行即可；但是这个修改依然不是通用的，之所以在这个语句里有效，因为查询语句指定了返回结果 <code>limit 1</code>，在这个表中如果有满足条件的记录，<code>order by b limit 1</code> 和 <code>order by b,a limit 1</code> 所返回的都是 b 的值是最小的那一行，只有逻辑上是一致的，才能使用这种方式</p><p>​    除此之外，还有另一种修改方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">100</span>) alias limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    这里用了子查询做了一张虚拟表，此外还使用   <code>limit 100</code> 来让优化器知道如果使用 索引b 的代价会很高，同样这样的修改也不具有通用性</p><p>​    <strong>3）可以创建新的更合适的索引，或者删除本身没有用的索引</strong></p><h2 id="给字符串的字段加索引"><a href="#给字符串的字段加索引" class="headerlink" title="给字符串的字段加索引"></a>给字符串的字段加索引</h2><p>​    在现在的用户登录中很多都支持使用邮箱登录，由此业务中会有对邮箱账号的查询 <code>select f1,f2 from User where email=&#39;xxx&#39;;</code> 的语句，但是这样的查询由于因为 email 字段没有索引，每执行一次都是以扫描全表的方式进行搜索</p><p>​    在 MySQL 中可以通过设置 <strong>前缀索引，可以将字符串的一部分作为索引，默认情况下如果不指定前缀长度，则该索引将会包含整个字符串</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> index index1(email);         <span class="comment">-- 整个字符串作为索引内容</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> index index2(email(<span class="number">6</span>));      <span class="comment">-- 字符串的前6个字符作为索引内容</span></span><br></pre></td></tr></table></figure><p>​    使用前缀索引显然会比整字符串作为索引要更节省空间，但是由此带来的是在查询上，前缀索引相比之下会增加额外的扫描次数</p><p>​    如果现在执行一个查询： <code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></p><p>​    对整字符串的索引 index1：</p><p>​    1）先从 index1 的索引树上找到满足条件的索引值，得到这个索引所记录的主键索引 id</p><p>​    2）回表到主键索引中找到指定的 id 所在行，判断 email 的值是否正确，正确就将记录加入结果集</p><p>​    3）继续从 index1 的索引树上取下一个索引值，判断不满足条件，循环结束</p><p>​    所以，使用全部的字符串作为索引内容，整个过程只去主键索引拿了一次数据，只扫描了一行</p><p>​    对于前缀索引 index2：</p><p>​    1）从 index2 的索引树上，从条件中取出前缀长度的字符串并查询匹配该字符串的记录，得到主键索引的 id</p><p>​    2）到主键上找到对应 id 的行，判断是否与条件的值是一样的，不一样则丢弃，一样则加入结果集</p><p>​    3）再次回到 index2 的索引树，从上一次的位置往下取一条记录，并且判断是否满足指定的前缀，并再次回表从主键索引上得到对应行，然后重复第2步，    </p><p>​    在这个过程中，匹配前缀是否满足的情况下，很有可能会扫描多行数据，如果前几个的字符串是一致的，因此使用前缀索引容易导致最后查询的次数变多，但是如果把前缀的长度增加，可能最后并不会增加太多的次数</p><p>​    <strong>总结：使用前缀索引，定义好长度，是可以做到既节省占用空间，也可以不用额外的去增加太多的查询（增加查询次数是必然的，但增加的多少取决于定义前缀的长度能有多大的区分）</strong></p><h3 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h3><p>​    实际上在建立索引时关注的就是区分度，区分度越高，也就意味重复的键值会越少，因此可以通过统计索引上有多少个不同的值取判断使用多长的前缀</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询在索引字段上有多少个不同的值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> <span class="keyword">User</span>;</span><br><span class="line"><span class="comment">-- 然后可以依次选取不同的长度来统计不同长度得到值，比如统计4-7个字节的前缀索引</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>) <span class="keyword">as</span> L4),</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>) <span class="keyword">as</span> L5),</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>) <span class="keyword">as</span> L6),</span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>) <span class="keyword">as</span> L7),</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">User</span>;</span><br></pre></td></tr></table></figure><p>​    前缀索引只是选取了局部的字符串去做匹配，所以肯定会损失区分度，因此在统计前可以预先设定一个理想化可接受的损失比例，比如 5% 等，然后在返回 L4-L7 中，找出不小于 L * 95% 的值，如果其中 L6 和 L7 都满足得到化，就可以选择 L6 做最后的前缀索引</p><h3 id="使用前缀索引对覆盖索引的影响"><a href="#使用前缀索引对覆盖索引的影响" class="headerlink" title="使用前缀索引对覆盖索引的影响"></a>使用前缀索引对覆盖索引的影响</h3><p>​    上面的例子中，使用了整个字符串的索引和前 6 个字符的前缀索引，在知道前缀索引是会增加扫描行数后，这已经是影响性能的一点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;windows98@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    对于这个查询语句，只要求返回的结果包含主键 id 和 email 字段，<strong>index1 使用整个字符串做 email 索引，就会利用到覆盖索引，因为在 email 索引树上找到对应的值后就可以获取到记录的主键 ID，所以就不需要回到 id 的索引上再去查询一次</strong>；而 index2 使用的前缀索引，就不得不回到 id 索引上找到对应行去判断 email 的字段的值一致</p><p>​    需要知道的是，就算 index2 直接使用完整的前缀索引，<strong>将整个字符串长度作为前缀值，比如将 email 索引改为 <code>email(17)</code>，但是查询时由于系统不确定前缀索引的定义是否是截断了完整信息，因此依然会回到 id 索引树进行查找</strong></p><p>​    简而言之，设置 前缀索引 时需要考虑到是有 覆盖索引 的优化，完整字符串做前缀索引时，如果查询字段可以在完整字符的前缀索引，就会利用到索引覆盖直接获取到字段的值</p><h3 id="前缀索引的多种方式"><a href="#前缀索引的多种方式" class="headerlink" title="前缀索引的多种方式"></a>前缀索引的多种方式</h3><p>​    相比对邮箱使用前缀索引来说，对于例如身份证号，不仅长度更长，且其中前6位使地址码会有大量的相同情况，如果对此使用长度是6的前缀索引，那这个区分度就相对非常低了。但是如果增加长度，需要加到12位，才能满足区分度要求的话，这个字符串索引所占用的空间就会大很多，所以可以通过其他方式去实现这样的索引</p><p>​    <strong>1）使用倒序存储</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询时，使用 reverse 将字符串反转</span></span><br><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​    将身份证在存储时就先将其翻转，使用倒序的值来存储，由于身份证的后六位不像前六位的地址码不会有重复的逻辑，所以这样使用 6 个字符的长度做前缀索引也能提供足够的区分度，但是在此之前依然是使用 <code>count(distinct)</code> 方法去验证</p><p>​    <strong>2）增加一个字段，使用 hash 值存储</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure><p>​    在插入数据时，对身份证号使用   <code>crc32()</code> 函数得到一个校验码并存储到 hash 的字段上，但是 hash 也会有 hash 冲突的可能，由此在查询语句时 where 条件需要判断 id_card 的值是否完全一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> filed <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> id_card_crc <span class="operator">=</span> crc32(<span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span>)</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">id_card<span class="operator">=</span><span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    对比 倒序存储 和 增加 hash 字段两种方式</p><p>​    相同点：<strong>两者都不能支持范围的查询</strong>，只能支持等值的查询语句</p><p>​    不同点：</p><p>​        1）在占用空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，但是增加 hash 字段方式会要多出一个字段的空间；不过使用倒序索引方式前缀的长度相比 hash 后的长度可能会要大一些，这一点来说两者的消耗可能是差不多的</p><p>​        2）在 CPU 消耗方面，倒序存储在读和写都要使用函数 reverse，而 hash 字段的方式也会需要额外使用 crc32 这个函数，从两个函数的复杂度看，前者会比后者消耗资源少一些</p><p>​        3）查询效率上，hash 字段方式的查询性能会更稳定一些，即使使用 crc32 后会有冲突的概览，但是这个概率本身来说非常低，可能每次平均的扫描行数是接近 1 行的；如果是倒序存储方式，就依然是前缀索引的问题，增加扫描行数是必然的</p><h2 id="MySQL-刷页"><a href="#MySQL-刷页" class="headerlink" title="MySQL 刷页"></a>MySQL 刷页</h2><p>​    刷页的目的就是为了将正确的数据更新到磁盘上进行存储，但是有时候可能会出现很灵异的现象就是一个语句的执行突然间变慢且是随机性的，持续的时间也非常短，出现这个问题的可能原因就是数据库是在刷 “脏页”</p><p>​    <strong>脏页，即内存中的数据页和磁盘的数据页内容不一致时，该数据页就是 “脏页”</strong>，<strong>当内存数据写入到磁盘后，内存和磁盘数据页一致，此时内存中的该数据页就是 “干净页”</strong></p><p>​    数据库每当需要   <code>flush</code> 脏页的时候，会将内存的脏页覆盖到磁盘的数据页上，而这个过程不会涉及 redo log。对于更新而言，首先根据 WAL 技术，将操作按顺序记录到 redo log，并在内存中生成新版本数据，当触发刷脏页时，将内存的数据页刷到磁盘上，这样一来通过 WAL 实现了原本的 随机写入 改为了 顺序写入，提升了效率。</p><p>​    但是，WAL 虽然将随机变成了顺序，却也由此导致内存中会产生 脏页，要实现内存与磁盘的数据一致，就需要进行 <code>flush</code></p><p><img src="https://static001.geekbang.org/resource/image/34/da/349cfab9e4f5d2a75e07b2132a301fda.jpeg" alt="img"> </p><h3 id="引发数据库-flush-过程的情况"><a href="#引发数据库-flush-过程的情况" class="headerlink" title="引发数据库 flush 过程的情况"></a>引发数据库 flush 过程的情况</h3><p>​    1）redo log 文件是有空间大小限制的，<strong>一旦 redo log 写满了，系统会停止掉所有的更新操作</strong>，并且 <strong>新的操作过程想要记录，就必须擦除掉旧的记录</strong>，留出空位来保存新的记录。不过，在擦除之前必须要先将正确的数据更改到磁盘上，图中浅绿色部分即将要擦除的脏页这部分将执行 flush 到磁盘，最后 write pos - cp’ 的区域就是可以写入新的 redo log 的区域</p><p><img src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg" alt="img"> </p><p>​    2）就是系统的内存空间不足，此时需要新的内存页（即从磁盘读取新的数据页到内存），而内存不够用的时候，就会淘汰一部分数据页，将空出的内存空间给其他的数据页使用。如果淘汰的是脏页，就会先将脏页写入磁盘，这么做可以确保每一个数据页有两种状态：</p><ul><li><p>数据页在内存中存在，那内存中的肯定是正确的结果，可以直接返回</p></li><li><p>内存没有数据，那数据文件上的结果就是正确的，可以读取到内存返回，这样的效率最高</p><p>3）在系统认为处于 “空闲” 的状态下，会合理安排时间，每有适当的机会就刷一部分脏页</p><p>4）确定数据库需要关闭的情况下， MySQL 会把内存的脏页全部 flush 到磁盘上，在下一次启动 MySQL 的时候，就直接从磁盘上读数据，且启动速度会很快</p></li></ul><h3 id="四种情况的性能分析"><a href="#四种情况的性能分析" class="headerlink" title="四种情况的性能分析"></a>四种情况的性能分析</h3><p>​    对于上述的第三种情况，即 MySQL 空闲的时候进行刷页，这时的系统本身不会有什么压力；第四种情况是数据库关闭，这也不会产生什么性能问题，所以主要针对前两种</p><p>​    对于第一种 <strong>redo log 写满状态</strong> 下，进行 flush 刷页。这种情况是 InnoDB 要尽量避免的，因为发生这种情况，整个 <strong>系统就不能再接受更新了，且所有的更新都会阻塞住</strong></p><p>​    对于第二种内存不够用，会先将脏页写入磁盘。这是最常见的，InnoDB 用缓冲池 ( buffer pool) 来管理内存，<strong>缓存池中的内存页会有三种状态：</strong>    </p><p>​    <strong>1）还没有使用的；2）使用了且是干净页；3）使用了且是脏页</strong></p><p>​    在 InnoDB 的策略中时尽可能使用内存，因此对于一个长时间运行的库来说，未被使用的页会相对很少；而当需要读取新的数据页到内存中，就必须到缓冲池中申请一个数据页，这时内存不够用了就只能把很久不用的数据页从内存中先淘汰掉，在此之前会判断要淘汰的数据页是否是脏页还是干净页，前者在释放空间前会先写入磁盘，后者直接释放即可</p><p>​    通常情况下，淘汰的数据页大多会是脏页，此时进行刷页会有两种情况来影响性能，是必须要去避免的：    </p><p>​    1）如果需要淘汰的脏页个数太多，就会导致过程的响应时间会变长</p><p>​    2）另一种就是日志（redo log）写满，这就会导致更新全部堵住，写入性能降为 0</p><h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><p>​    在 InnoDB 中可以通过   <strong>参数 <code>innodb_io_capacity</code> 设置刷页的最大性能</strong>，这个值可以设置为磁盘的 IOPS (磁盘的每秒输入或输出的速度)，这个 IOPS 可以通过 fio 工具来测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio <span class="operator">-</span>filename<span class="operator">=</span>$filename <span class="operator">-</span>direct<span class="operator">=</span><span class="number">1</span> <span class="operator">-</span>iodepth <span class="number">1</span> <span class="operator">-</span>thread <span class="operator">-</span>rw<span class="operator">=</span>randrw <span class="operator">-</span>ioengine<span class="operator">=</span>psync <span class="operator">-</span>bs<span class="operator">=</span><span class="number">16</span>k <span class="operator">-</span>size<span class="operator">=</span><span class="number">500</span>M <span class="operator">-</span>numjobs<span class="operator">=</span><span class="number">10</span> <span class="operator">-</span>runtime<span class="operator">=</span><span class="number">10</span> <span class="operator">-</span>group_reporting <span class="operator">-</span>name<span class="operator">=</span>mytest </span><br></pre></td></tr></table></figure><p>​    对于刷页的性能来说，<code>innodb_io_capacity</code> 的值设置很重要，设置不准确很容易导致出现性能问题，比如写入很慢，但数据库 IO 的压力却不大</p><h3 id="刷页速度"><a href="#刷页速度" class="headerlink" title="刷页速度"></a>刷页速度</h3><p>​    <strong>对于 InnoDB 来说去刷磁盘的速度有两个因素：一个是脏页的比例，另一个是 redo log 写盘的速度</strong>；InnoDB 会分别单独算出这两个数值进行参考</p><p>​    <strong>脏页比例：可以通过参数 <code>innnodb_max_dirty_pages_pct</code> 设置，该值默认是 75%</strong>，InnoDB 会根据当前的脏页比例（ innodb_buffer_pool_drity /  innodb_buffer_pool_pages_total ），算出一个范围在 0 - 100 之间的数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当前的脏页比例</span><br><span class="line">select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_dirty&#x27;;</span><br><span class="line">select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_total&#x27;;</span><br><span class="line">select @a/@b;</span><br><span class="line"></span><br><span class="line"># 脏页比例的阈值计算</span><br><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;   # 即 100%，以最大性能出进行刷页</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    日志的写入速度：InnoDB 会给每条日志记录给一个序号，通过当前的该序号的值与 checkpoint 对应的序号值计算一个差值，再通过一个计算公式得到一个 0 - 100 的数字，计算结果随差值的增大而增大</p><p>​    最后，计算得到两个值后，系统会取较大的值记为 R，再根据   <code>innodb_io_capacity</code> 的定义参数乘以 R% 来控制刷脏页的速度</p><p><img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" alt="img"> </p><p>​    所以，当 InnoDB 在后台刷脏页，将内存页写入磁盘的过程中，如果出现需要淘汰脏页或是刷脏页的逻辑占用 IO 资源都会影响到更新效率。所以需要合理设置 <code>innodb_io_capacity</code> 的值，且需要去关注脏页的动态，<strong>尽可能不要触及默认的 75% 这个阈值</strong></p><p>​    <strong>补充</strong></p><p>​    MySQL 8.0 以前的版本中，会有一个机制去判断要 flush 掉的脏页，是否相邻的数据页也是脏页，如果是的话，就会把这个相邻脏页一起刷掉。但是这个机制还会像递归一样会往下蔓延，只要相邻的是脏页，就会被加入到被刷的行列里，这对于机械硬盘来说是一个减少 IO 的优化，但对于 SSD 这种 IOPS 高的设备来说会是一个导致语句执行变慢的一个原因</p><p>​    在 InnoDB 中，参数   <code>innodb_flush_neighbors</code> 可以控制这个行为，参数值为 1 表示启用上述的机制，参数值为 0 则在刷页时，只会对自己进行刷页，8 的版本中已经默认设置为 0</p><h2 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h2><p>​    数据库中的表由两部分组成：表结构定义和数据，<strong>8.0 以前的版本，表结构都是存在 “.frm” 为后缀的文件中，从 8.0 开始，允许将表结构的定义内容放在系统数据表中</strong>，因为相比数据来说表结构定义占用的空间非常小</p><p>​    在   <strong>InnoDB 中，表的数据有两种方式存储：共享表空间 或者 独立的文件</strong>，可以通过 <strong>参数 <code>innodb_file_per_table</code> 来控制，自从 5.6.6 版本之后，该参数的默认值就是 ON</strong></p><p>​    1） 参数的值为 <strong>OFF，表示将数据放在共享表空间，也就是与数据字典放在一起</strong></p><p>​    2） 参数的值为 <strong>ON，会将每一个表的数据单独存储在以 “.ibd” 后缀的文件中</strong></p><p>​    第二种以单独文件存储的方式更加容易管理，而且如果不需要某个表，使用   <code>drop table</code> 就可以删除这个数据文件，使用第一种方式 <strong>存储在共享表空间，即使表被删除，空间也不会被回收</strong></p><h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p>​    InnoDB 中的数据都是以 B+树 结构来组织的，如果此时需要 <strong>删除一行记录，InnoDB 引擎只会将删除的这一行标记为删除（即 “标记删除” ），在此之后如果需要插入一行记录，又恰好是在被标记删除这一行的位置上，那么新的记录就会复用这个位置，整个过程中磁盘的大小是不会发生缩小的</strong> </p><p>​    同理，因为 InnoDB 中数据是存储在数据页上的，如果将一个数据页上的所有数据删除，如果有新的数据写入，那么该 <strong>数据页也同样可以复用</strong>，<strong>但是数据页的复用与记录的复用是不同的</strong></p><p>​    <strong>记录的复用：前提新插入的数据是需要符合范围条件</strong> 的，比如图中如果将 R4 删除，此时新加入的数据的 id 必须是 300 - 600 之间，才可以直接复用之前标记删除的空位（空间位置），如果插入的 id 是 大于 600 ，就不能对空位进行复用</p><p><img src="https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png" alt="img"> </p><p>​    <strong>数据页的复用：</strong>当一个 <strong>数据页从 B+树 上被摘除，是可以在任何位置复用的</strong>，例如图中 page A 上的所有数据被删除，page A 会被标记可复用，这个时候新插入的数据不会关注 id 的值，即使是 50 也能使用 page A，此时该数据页就被复用了</p><p>​    类比：记录的复用相当于你给你的车买一个固定的停车位，以后不管你换了什么车都能停在这个车位上；数据页的复用就像路边的停车位，假如一个车位是一个数据页，当别人的车离开了，你就能使用这个车位</p><p>​    数据页的复用除了由于数据页上的数据全部被删除情况下会被标记可复用外，当相邻的两个数据页本身在利用率很低的情况下，系统也会将其中一个数据页的数据迁移到另一个数据页上，然后被迁移数据后的那个数据页同样会被标记为可复用</p><p>​    在表中删除一个数据记录，使用   <code>delete</code> 命令，如果是使用这个命令将一整表的数据删除，最后导致的情况就是数据页会被标记可复用，且磁盘上看到的文件大小不会变小，所以对于数据记录的删除，<strong><code>delete</code> 命令并不能将表空间进行回收</strong>，但是这些空间是可以被复用的，就像是个隐形的空洞一样</p><p>​    除了数据的删除之外，插入数据也可能会造成这样的现象。数据的插入如果是按照索引递增顺序插入，那么索引的结构是紧凑的，但是如果是随机插入，就可能会造成索引的数据页分裂</p><p><img src="https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png" alt="img"> </p><p>​    图中显示即为在原数据表中插入 id 为 550 的数据，在原本的数据页上 page A 是 300 - 600，550 位于其中间，所以如果想要保存就无法使用原来的 page A ，不得不去申请一个新的数据页 page B。page A 用来存储 300 - &lt; 550 的 id，page B 则从 550 - &lt; 700，所以 page A 的 id 是 600 的 R5 会存储到 page B，此时就是数据页的分裂。分裂完成后，在 page A 中就留下一个空位</p><p>​    更新的操作，就类似于删除旧的 id 数据，插入一个新的 id 数据，所以同样会造成空洞效果，<strong>也因此对于一个表来说，经过大量的增删改后，都是可能存在空洞的</strong>。对于这样的现象，即数据删除了但是最后所使用的的空间却没有释放，所以要想回收表空间，就必须要将空洞给去掉</p><h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>​    对于 表A 如果出现很多空洞，需要将空间收缩，就可以创建与 表A 结构相同的 表B，然后按照主键 ID 自增的顺序，将 表A 的数据一行行的读取写入到 表B。这样对 表A 来说 表B 就没有了空洞且数据一样，表B 的数据页利用率相对 表A 就会更高，当数据全部导入到了 表B，用 表B 去替换 表A，就起到了对 表A 的空间进行收缩的作用</p><p>​    <strong><code>alter table A engine=InnoDB;</code> 的命令可以实现重建表</strong>，在 5.5 版本之前该命令的流程和上述是差不多的，区别是上面的 表B 这个临时表不用自己创建，MySQL 会自动完成创建临时表、完成数据迁移，表名交换、删除旧表的整个操作</p><p><img src="https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png" alt="img"> </p><p>​    需要知道的是上述重建表的四个步骤中，比较耗时的就是第二步将数据插入到临时表中，而且在此步骤期间，一旦有新的数据要写入 表A ，这些新的数据就会丢失，因为一致性要求，第二步时 表A 会被加上DDL 锁，因此 表A 中不能有更新，通常也说这个 DDL 不是 Online 的；不过，在 5.6 版本开始就引入了 Online DDL</p><h3 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h3><p>​    Online DDL 相比原来的不能进行 online 的重建表做了部分优化处理，因此重建表的流程也有所不同：</p><p>​    1）首先 <strong>会建立一个临时文件</strong>（原来不能 online 的则是建立临时表），并扫描 表A 中主键的所有索引数据页</p><p>​    2）用数据页中 表A 的记录生成 B+树，存储到临时文件中</p><p>​    3）生成临时文件的过程中，期间所有对 表A 的操作会被记录在一个 row log 中</p><p>​    4）临时文件生成后，将 row log 日志文件中记录的操作应用到临时的文件，得到一个逻辑上与 表A 相同的数据文件</p><p>​    5）用临时文件替换 表A 的数据文件</p><p><img src="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png" alt="img"> </p><p>​    从图中可以看到，因为有了日志文件去记录和应用操作，这使得了 表A 可以在重建表的过程中依然能够提供增删改操作，这就是 Online DDL</p><p>​    <strong>需要注意的：</strong>    </p><p>​    <strong>在 <code>alter</code> 语句启动时，会获取 DDL 表级锁，而这个锁在最一开始得到就是 MDL写锁，目的是防止其他线程也对该表进行表结构等操作</strong>，在表级锁的时候提到 MDL 有 读锁 会和 写锁 有冲突，那为什么加的是 MDL写锁 的情况下，最后还能增删改？</p><p>​    这是因为 <strong>在 表A 将自己的数据拷贝到 临时文件 之前，MDL 写锁 会被退化成 读锁，这样就不会阻塞期间其他线程对 表A 的增删改操作</strong></p><p>​    在 MySQL 5.5 及之前的版本，Online DDL  的方法是会阻塞 DML（增删改查），且对于 Online DDL 这样的重建表可以通过在业务低峰期使用，来达到对表空间的回收</p><p>​    上面两种重建表的方式其实本质上都差不多，都会需要对原表进行扫描表结构，并建立临时文件或临时表，再将原记录进行插入。这些操作本身是非常消耗 IO 和 CPU 资源的，所以对于线上的服务，必须控制好整个操作时间，可以通过 <code>gh-ost</code> 去进行操作会比较安全</p><h3 id="online-和-inplace"><a href="#online-和-inplace" class="headerlink" title="online  和  inplace"></a>online  和  inplace</h3><p>​    DDL 中 “inplace” 和 “Online” 非常相似，但两者并不同</p><p>​    在非 online 的重建表中，数据会被从 表A 存储到临时表，而这个表由 server层 创建</p><p>​    online DDL 下，使用的是临时文件，但这是由 InnoDB 内部创建的，整个 DDL 过程都由 InnoDB 内部完成，因此对于 server层 来说，整个操作数据不是移动到临时表中，而像是一个 “原地” 操作，这就是 “inplace”</p><p>​    因此，对应 inplace 来说这样的方式是会对空间有所占用的，只是表面上 inplace 去看待拷贝数据时，认为了表中的数据自己做了一种更新</p><p>​    所以如果有一个 1TB 的表，而磁盘是 1.2TB，肯定是不能使用 inplace 的 DDL，因为其中临时文件是要占空间的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重建表语法，其实用的是 ALGORITHM=inplace</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span>inplace;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 但是 inplace 的重建表则是使用拷贝表的方式 ALGORITHM=copy</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span><span class="keyword">copy</span>;</span><br></pre></td></tr></table></figure><p>​    当使用   <code>ALGORITHM=copy</code> ，即强制拷贝表， 那么重建表的流程就是最开始的那张图，通过临时表做重建</p><p>​    但是，假如要给表去添加   <strong>全文索引</strong> <code>alter table t FULLTEXT(field_name);</code> 这个过程则是 inplace，因为会阻塞增删改的操作，因此 <strong>重建表的过程无法对数据进行操作，那这个 DDL 就是 非online 的</strong></p><p>​    <strong>总结：</strong></p><p>​    1）<strong>DDL 过程如果是 online 的，就一定是 inplace 的</strong></p><p>​    2）<strong>但是使用 inplace 的 DDL，不一定是 online 的</strong>。截止到 8.0 的版本，在添加 全文索引（ FULLTEXT index）和 空间索引（SPATIAL index）的情况下就是这样</p><p>​    3） <strong><code>alter table t engine=InnoDb</code> 重建表，不意味着一定将表中的空洞全部整理释放掉</strong>。当执行一次重建表之后，InnoDB 不会把整张表占满，每一个页会留出 1/16 用来后续的更新操作使用。所以一张表如果刚执行过了一次重建表，或者本身表中也没有什么空洞下，重建表反而会导致表占用的空间变大</p><p>​    <strong>补充：</strong></p><p>​    <code>alter table t engine=InnoDb</code> 即 recreate，在 5.6 开始默认就是 online DDL 的</p><p>​    <code>analyze table t</code> 即对表的索引信息进行重新统计， 不会修改数据，但是该过程会添加 MDL 读锁</p><p>​    <code>optimize table t</code> 相当于上面两个的联合，即 recreate + analyze</p><h2 id="count-变慢"><a href="#count-变慢" class="headerlink" title="count(*) 变慢"></a>count(*) 变慢</h2><p>​    当要统计记录总数，很容易就会想到使用 <code>select count(*) from t</code> 这个语句，但是这个语句往往随着系统中数据的增多，而执行的时间也会变长，并且对于 <code>count(*)</code> 的实现不同引擎也有所不同</p><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)  的实现方式"></a>count(*)  的实现方式</h3><ul><li><p><strong>MyISAM 引擎会把表的总行数记录在磁盘上</strong>，所以对执行 <code>count(*)</code> 的时候会直接返回这个记录值，因此效率很高；如果这个语句加了 <code>where</code> 条件的话，依然不会很快地将值返回</p></li><li><p><strong>InnoDB 引擎在执行 <code>count(*)</code> 的时候，需要将数据一行行从引擎里面读出来，然后累积计数</strong></p><p><strong>注意：</strong>之所以 InnoDB 不像 MyISAM 一样记录一个总值，是因为 InnoDB 由于多版本并发控制（MVCC）的缘故，使得 InnoDB 的表在决定返回的具体行数是多少并不确定。比如，现在使用三个线程各自去执行统计行数，B 和 C 会在统计前各自插入一行记录在进行统计，但是两者执行插入的时间不同</p></li></ul><p><img src="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png" alt="img"> </p><p>​    这个例子默认以可重复读（RR）的隔离级别，即每一个事务的数据只会对自己的视图可见，因此最后三个线程完成后得到的统计值都不一样，但却是同一时刻执行查询统计。正是因为每一行记录被读取后都需要判断自己是否对当前会话可见，只有其中可见的行才会被加入进行计算得到最后表的总行数</p><p>​    不过 InnoDB 在执行 <code>count(*)</code> 的时候还是做了优化的，<strong>InnoDB 的主键索引树的叶子节点存储的都是数据，而普通索引树上的叶子节点存储的是主键值，所以相对而言普通索引树要主键索引树小很多</strong>，对于 <code>count(*)</code> 来说，遍历哪一个索引树得到的结果逻辑上都是一致的，所以优化器在选择时会使用最小的那一棵索引树进行遍历。<strong>保证逻辑正确的前提，尽量少的扫描数据量，是数据库系统设计的通用法则之一</strong></p><h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a>show table status</h3><p>​    使用 <code>show table status</code> 可以显示库中所有表的相关信息，其中会有一个记录行数的 <code>Rows</code> 的字段，但是这个数并不能准确表示该表的总记录数，因为这个值是一个估值，是有误差的</p><p>​    <strong>对于 MyISAM 来说，count(*) 在使用条件过滤情况下很快，但是该引擎不支持事务</strong></p><p>​    <strong>show table status 命令返回很快，但其中的行数统计并不准确</strong></p><p>​    <strong>InnoDB 的 count(*) 需拿全表来统计，结果准确但同时性能上会慢</strong></p><h3 id="缓存保存计数方式的可行性"><a href="#缓存保存计数方式的可行性" class="headerlink" title="缓存保存计数方式的可行性"></a>缓存保存计数方式的可行性</h3><p>​    通常情况下，对于一个更新频繁的服务，使用缓存来支持效率要高很多，但是使用 redis 去保存一个表的总行数是否真的可行？</p><p>​    首先，因为是缓存，那对其来说最主要的一点就是数据会丢失，也因此 redis 才会有数据持久化来将数据进行物理保存，但依然会有丢失的情况。如果在数据表中插入一行数据，redis 中对保存的总行数进行 +1 ，假如这时 redis 出现异常重启了，之后再去到 redis 中把该值读取时，会发现刚才的计数操作却丢失了</p><p>​    当然，对于这样的情况，可以在 redis 重启后，数据库单独执行一次   <code>count(*)</code> 来获取正确的行数并将该值交给 redis 保存。本身 redis 对于异常重启的情况概率就小，因此单独使用一次全表扫描，任然是可以接受的</p><p>​    其次，实际工作中即使在 redis 正常工作下，对于总行数的值依然会有逻辑不正确。对于 redis 来说，当有数据行插入后进行 +1 操作，或者是先自己 +1，然后数据库再写数据</p><p>​    但是对于并发下出现在 redis 操作之前，数据行已经插入之后，如果有事务执行了查询 redis 计数，就会导致这个值与实际不符</p><p><img src="https://static001.geekbang.org/resource/image/39/33/39898af053695dad37227d71ae288e33.png" alt="img"></p><p><img src="https://static001.geekbang.org/resource/image/5c/db/5c2f786beae1d8917cdc5033b7bf0bdb.png" alt="img"></p><p>​    反过来，如果只是将 会话A 的执行顺序互换，最后的结果也显而易见，会话B 返回的  redis 计数是正确了，但是最近的记录中，则没有了会话A 插入的记录</p><p>​    这就是因为使用两种不同存储的结构的系统，无法支撑分布式事务，因此不能拿到精确一致的视图</p><h3 id="直接数据库保存计数"><a href="#直接数据库保存计数" class="headerlink" title="直接数据库保存计数"></a>直接数据库保存计数</h3><p>​    通过上面使用缓存来存储总行数，可以发现依然会有数据丢失或计数不准确的情况，那就直接在数据中用一张表记录表的总行数，这样首先解决了崩溃丢失的问题，因为 InnoDB 支持崩溃恢复且不丢失数据，接下来就是考虑数据正确的问题</p><p>​    InnoDB 因为支持事务，导致表不能把 <code>count(*)</code> 直接保存，再通过查询去得到这个值。但利用事务的特性，可以解决掉之前 redis 因为执行先后问题出现返回不准确的情况</p><p><img src="https://static001.geekbang.org/resource/image/9e/e3/9e4170e2dfca3524eb5e92adb8647de3.png" alt="img"></p><p>​    在可重复读的隔离级别下，事务执行前会创建自己的视图，且视图中的操作记录未提交前都是只自己可见，所以图中 会话B 的返回的计数值读到的是 会话A 操作之前的数据，最新的记录也是一样</p><h3 id="count-的不同用法"><a href="#count-的不同用法" class="headerlink" title="count 的不同用法"></a>count 的不同用法</h3><p>​    <code>count()</code> 本身作为聚合函数，对于返回的结果集，会一行行去判断，如果 count 函数的参数不是 NULL，累计数就 +1，最后将累计数返回</p><p>​    <strong><code>count(*)</code>， <code>count(id)</code>，<code>count(1)</code> 都表示返回满足条件的结果集的总行数；count(字段)，则表示返回满足条件的数据里，参数 “字段” 不为 NULL 的总个数</strong></p><p>​    <code>count(id)</code> ：<strong>InnoDB 会遍历整张表，把每一行的 id 取出来交给 server 层</strong>，server 层得到后，判断 id 不可能为空的，就按行进行累加计数</p><p>​    <code>count(1)</code>：同样会 <strong>遍历整表，但是并不取值</strong>，server 层对于返回的 <strong>每一行，会放一个数字 “1” 进去</strong>，然后判断不可能为空的，按行累加</p><p>​    <code>count(字段)</code>：会 <strong>有两种情况判断</strong></p><p>​    1）<strong>参数字段的定义是 “not null”</strong>，server 层会一行行从记录中读取这个字段，判断不能为 null，就累加</p><p>​    2）<strong>参数字段的定义是允许为 “null”</strong>，在执行时判断到有可能是 null 的行，还要 <strong>把值取出来再判断一次，不是 null 的话才累加</strong></p><p>​    <strong><code>count(*)</code> ：不会取出全部字段</strong>，而专门做了优化（<strong>选择最少的索引树遍历</strong>），判断肯定不是 null 的，就按行累加</p><p>​    所以，按照效率排序的话，<strong>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 整理</title>
      <link href="/3714377604/"/>
      <url>/3714377604/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis-概览"><a href="#Redis-概览" class="headerlink" title="Redis 概览"></a>Redis 概览</h3><p><img src="https://static001.geekbang.org/resource/image/79/e7/79da7093ed998a99d9abe91e610b74e7.jpg" alt="img"> </p><p>​    redis 是一个高性能的 key-value 的非关系型数据库，支持丰富的数据结构，同时作为缓存应用还支持了数据的持久化，相比另一种内存型数据库 memcached 功能更多</p><table><thead><tr><th>对比参数</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>类型</td><td>1）支持内存   2）是一种非关系型数据库</td><td>1）支持内存  2）key-value 键值对形式  3）缓存系统</td></tr><tr><td>数据存储类型</td><td><strong>1）string  2）list  3）set  4）hash  5）sorted set（zset）</strong>有序集合</td><td>1）文本型  2）二进制类型</td></tr><tr><td>查询类型</td><td>1）批量操作  2）<strong>支持事务，但不具备原子性，因为不能回滚</strong>  3）每个类型有不同的 crud</td><td>1）crud  2）以及其他命令</td></tr><tr><td>附加功能</td><td>1）发布 / 订阅模式  2）主从分区  3）序列化支持  4）脚本支持</td><td>1）多线程服务支持</td></tr><tr><td>网络 IO 模型</td><td>1）单线程 + IO 多路复用  2）<strong>6 的版本开始支持多线程</strong>，但对于命令执行依然是单线程</td><td>1）多线程，非阻塞 IO 模式</td></tr><tr><td>事件库</td><td>自封装简易事件库 AeEvent</td><td>传统的 LibEvent 事件库</td></tr><tr><td>持久化</td><td>1）RDB  2）AOF</td><td>不支持</td></tr></tbody></table><p>​    redis 严格意义上来说并不完全是单线程，只对于 redis 的网络 IO 和键值读写是通过单线程来完成的，而 redis 的其他功能，持久化、异步删除、集群数据同步等，都是由额外的线程做单独处理。而 <strong>redis 的数据操作快速，主要是使用 IO 多路复用的机制，避免了 socket 的阻塞</strong></p><h3 id="Redis-数据类型及使用场景"><a href="#Redis-数据类型及使用场景" class="headerlink" title="Redis 数据类型及使用场景"></a>Redis 数据类型及使用场景</h3><p>​    <strong>string（字符串）：可以用实现简单的 KV 键值对存储，比如计数器功能进行统计，缓存用户 session 信息</strong></p><p>​    <strong>list（列表）：支持双端操作，可用作双端队列，比如用户的关注，粉丝列表，或是作为消息队列</strong></p><p>​    <strong>hash（哈希表）：用来存储彼此相关信息的键值对</strong></p><p>​    <strong>set（集合）：存储不重复元素，用来实现去重，比如存储标签</strong></p><p>​    <strong>sorted set（有序集合）：可以用来实现信息的排行榜功能</strong></p><p><img src="https://wei-foun.github.io/img/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%84.jpg" alt="img"></p><h4 id="五种类型的底层实现"><a href="#五种类型的底层实现" class="headerlink" title="五种类型的底层实现"></a>五种类型的底层实现</h4><p>​    <strong>string：使用 long 类型整数 或 sds（simple dynamic string，简单动态字符串），可以存储文本或二进制的数据。sds 会分为三部分，alloc 表示剩余实际分配长度，len 来记录字符串的长度，这样就能以 O(1) 的时间来查询到字符串的长度值，真正字符串数据存在在 buff 中，字符串的末尾会加一个字符 <code>\0</code> 表示结束</strong></p><p>​    当存储的数据是有符号的整数，会使用 long 类型存储，而存储字符则会使用 sds 存储，使用 sds 存储会增加内存消耗，因为 alloc 会占用 4 个字节，len 也会占用 4 个字节，在 buf 中还有一个 <code>\0</code> 占用一个字节</p><p><img src="https://wei-foun.github.io/img/redis-sds.jpg" alt="img"></p><p>​    <strong>list：使用 ziplist 或 double linked list，3.2 版本中又增加了 quicklist，quicklist 可以看作是前两者的结合</strong></p><p>​    <strong>ziplist（压缩列表），同样是一个连续地址的结构，相比起数组类型存储要更加节省内存</strong>，因为数组中每一个元素的大小都是相同的，<strong>数组创建后每一个元素都是固定 20 字节</strong>；ziplist 是 <strong>每一个元素的大小全部根据元素的真实大小来存储</strong></p><p>​    同时，<strong>压缩列表的头部有三个字段，zlbytes 即列表的字节长度，zltail 即列表尾部偏移量，zllen 即压缩列表中元素的个数，同时在列表最后还有一个字段，zlend 即表示列表结束位置，zlend 默认值是 255</strong>。那么对于压缩列表的查询第一个元素和最后一个元素，就可以直接根据头三个字段去查询得到，也就是说 <strong>压缩列表的头尾两个元素的查找都是 O(1) 的，其他位置的查找依然是 O(n)</strong></p><p><img src="https://static001.geekbang.org/resource/image/f6/9f/f6d4df5f7d6e80de29e2c6446b02429f.jpg?wh=3457*972" alt="img"></p><p>​    压缩列表中每个 entry 元素有 4 个部分：encoding 是编码方式，占用 1 字节。len 表示 entry 的长度，占用 4 字节。key 则是实际存储的数据。prev_len 表示前一个 entry 的长度，会占用 1 或 5 个字节，如果值是 1 个字节表示前一个 entry 长度小于 254 个字节</p><p>​    <strong>一个列表中所有字符串的长度小于 64 个字节，或者保存的元素数量小于 512 个都会使用 ziplist ，否则使用 double linked list</strong></p><p>​    <strong>hash：使用 ziplist 或 hashtable</strong></p><p>​    <strong>set：使用 intset 或 hashtable</strong></p><p>​    <strong>sorted set：使用 skiplist 跳（跃）表</strong>，简单理解就是通过链表上添加多级索引，利用类似二分法的方式进行查找，每一级索引的节点数都是上一级的一半，<strong>查找一个元素的时间复杂度会是 O(logn)</strong></p><p><img src="https://www.pianshen.com/images/573/e2be2c76594df76ebddfe9c3c4e516a5.png" alt="在这里插入图片描述"> </p><p>​    注意：数据类型的底层数据结构在时间复杂度上可能是存在区别的，比如 哈希表 结构的 O(1)，压缩链表、双向链表以及整数数组的结构是 O(n)，而跳表的结构是 O(logn)，但是 redis 的数据类型都支持非常丰富的命令，所以具体的时间复杂度并不是一定和该数据使用的数据结构是一致的</p><p>​    比如 hash 的命令，hset 或 hget 这样的 <strong>单个元素操作</strong>，时间复杂度就是数据结构的时间复杂度 O(1)，但 hash 的操作还支持 hmset 以及 hmget 这样一次可以进行多个元素的操作情况下，<strong>时间复杂度就随着元素个数而改变</strong>，就从 O(1) 变成了 O(m)</p><p>​    redis 除了支持多个元素操作，有的类型还可以进行范围的查询操作，比如 hash 有 hgetall 和 set 的 smembers 来返回所有的元素，list 有 lrange 和 zset 有 zrange 来返回部分元素，这些 <strong>范围的操作，都需要通过遍历进行，在时间复杂度上就会是 O(n)</strong></p><h4 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h4><p>​    redis 通过全局哈希表来实现快速的键值访问，虽然说是哈希表，但实际上一个数组，每个元素称为是一个哈希桶（entry），每个 entry 实际上保存了 *key 和 *value 两个指针，来指向实际设置的键值。同时 entry 里还有一个 *next 用来指向下一个 entry</p><p><img src="https://static001.geekbang.org/resource/image/1c/5f/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg?wh=1773*875" alt="img"></p><p>​    entry 的三个指针都是 8 个字节，也就是说全局哈希表中每一个 entry 最少是 24 个字节</p><p>​    至于说是至少 24 个字节，是因为 redis 再分配内存时，实际是 jemalloc 这个库进行的操作，<strong>jemalloc 分配内存会根据申请的字节数 n，找到比 n 大的最接近 n 的 2 次幂的数作为分配空间，以此减少频繁分配的次数。也就说 entry 申请时需要 24 个字节，但是 jemalloc 实际上会去分配 2^5^ 即 32 个字节</strong></p><h4 id="数据类型的常用命令"><a href="#数据类型的常用命令" class="headerlink" title="数据类型的常用命令"></a>数据类型的常用命令</h4><p>​    string：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set key value       # 设置指定 key 的值，如果 key 存在，覆盖 value</span><br><span class="line">get key             # 获取指定 key 的值</span><br><span class="line">getrange key start end           # 获取 key 的 start 到 end 位置的子字符串</span><br><span class="line">mset key1 value1 key2 value      # 批量设置多个 key</span><br><span class="line">mget key1  key2     # 批量获取多个 key</span><br><span class="line">incr key            # 对字符串的数字自增 +1</span><br><span class="line">decr key            # 对字符串的数字自减 —1</span><br><span class="line">incrby key value    # 指定要增加的 value</span><br><span class="line">decrby key value    # 指定减去 value 的值</span><br><span class="line">setnx key value     # 只有在 key 不存在时，才创建 key 和 value，如果 key 存在，不会覆盖 value</span><br><span class="line">setex key seconds value          # 设置 key 的 过期时间</span><br></pre></td></tr></table></figure><p>​    list：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lpush key value     # 在列表头部插入 value，可以指定多个 value 一起插入</span><br><span class="line">lpop key            # 在列表的头部移除一个元素并返回</span><br><span class="line">rpush key value     # 在列表尾部插入 value，可以指定多个 value 一起插入</span><br><span class="line">rpop key            # 在列表的尾部移除一个元素并返回</span><br><span class="line">lindex key index    # 通过 index 索引获取列表 key 的指定元素</span><br><span class="line">blpop key timeout   # 从列表 key 的头部移除一个元素，没有的话进行阻塞，直到超过 timeout 或有元素可以返回，brpop 同理</span><br><span class="line">lpushx key value       # 将 value 从已存在的列表头部加入，如果列表不存在，命令不会生效</span><br><span class="line">lrem key count value   # 从列表中移除指定 count 数量的 value</span><br><span class="line">lset key index value   # 通过列表索引将 value 进行插入</span><br><span class="line">llen key               # 获取列表的长度</span><br><span class="line">brpoplpush source destination timeout   # 从 source 列表尾部移除一个元素加入到 destination 列表的头部，没有元组可以操作就阻塞，直到超出 timeout 或有元素可以操作</span><br></pre></td></tr></table></figure><p>​    hash：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hset key field value      # 给哈希表 key，设置 field 字段，值为 value</span><br><span class="line">hget key field            # 获取哈希表 key，field 字段的值</span><br><span class="line">hmset key field value field1 value1      # 批量设置多个字段和值</span><br><span class="line">hmget key field field1    # 批量获取多个字段的值</span><br><span class="line">hgetall key               # 获取哈希表中所有的键值对</span><br><span class="line">hkeys key                 # 获取哈希表中所有的字段</span><br><span class="line">hvals key                 # 获取哈希表中所有的值</span><br><span class="line">hexists key field         # 判断哈希表中指定的 key 是否存在</span><br><span class="line">hlen key                  # 获取哈希表中字段的数量，键值对的数量</span><br><span class="line">hsetnx key field value    # 只有字段 field 不存在时，才设置指定的 value</span><br></pre></td></tr></table></figure><p>​    set：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sadd key member1 [member2]    # 向集合加入一个或多个成员</span><br><span class="line">scard key                     # 获取集合中成员的个数</span><br><span class="line">smembers key                  # 获取集合中所有的成员</span><br><span class="line">spop key                      # 随机从集合中移除一个元素并返回</span><br><span class="line">srem key member1 [member2]    # 从集合中指定移除一个或多个成员</span><br><span class="line">srandmembers key [count]      # 随机获取集合中的一个值，可以通过 count 指定获取值的个数</span><br></pre></td></tr></table></figure><p>​    sorted set：与 set 不同，<strong>每一个元素会关联一个 double 类型的分数，redis 通过分数实现从小到大的排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zadd key score1 member1 [score2 member2]    # 向有序集合中插入一个或多个成员，如果成员已存在则更新分数</span><br><span class="line">zcarf key                                   # 获取有序集合的成员数</span><br><span class="line">zcount key min max                          # 计算分数在 min 和 max 之间的成员个数</span><br><span class="line">zrange key start stop [withscores]          # 通过索引获取指定区间的成员，使用 withscores 参数则会将成员对应的分数也返回</span><br><span class="line">zrank key member                            # 返回有序集合中指定成员的索引</span><br><span class="line">zrem key member1 [member2]                  # 移除有序集合中一个或多个成员</span><br><span class="line">zrangebyscore key min max [withscores] [limit offset count]   # 返回分数在 min 到 max 之间的成员，返回所有成员使用 zrangebyscore key -inf +inf withscores</span><br><span class="line">zrevrange key start end                     # 让索引在 start 和 end 之间的成员，分数由高到低返回</span><br><span class="line">zrevrangebyscore key max min [withscores]   # 返回指定分数在 max 到 min 之间的成员，由高到低排序</span><br><span class="line">zscore key member                           # 返回有序集合中成员的分数</span><br></pre></td></tr></table></figure><h4 id="补充：RedisObject"><a href="#补充：RedisObject" class="headerlink" title="补充：RedisObject"></a>补充：RedisObject</h4><p>​    redis 支持多个不同类型的数据存储，不同的数据类型都存在出了实际存储数据之外的元数据要存储，元数据可能会存储最后一次访问时间，引用的次数等等，所以 redis 使用了一个 RedisObject 的结构来统一元数据，以及实际数据的指向</p><p>​    对于一个 RedisObject 结构，包含了 8 个字节的元数据部分，以及 8 字节的实际数据位置指针</p><p>​    对于 redis 中 str 类型，这个 RedisObject 结构做了专门的设计，如果 str 类型存储的是 long 的整数，那么 RedisObject 的指针部分，其实会被直接复制为整数数据，这样就省去了指针的空间。如果存储的字符类型，redis 又设计两个情况处理，如果字符串小于等于 44 个字节，在 RedisObject 会和 sds 连续存储，来避免内存碎片。反之，则就将 sds 单独存储</p><p><img src="https://static001.geekbang.org/resource/image/ce/e3/ce83d1346c9642fdbbf5ffbe701bfbe3.jpg?wh=3072*1938" alt="img"></p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>​    对于内存型的数据库而言，redis 用作缓存时，就必定要面临数据因为断点造成服务宕机，数据丢失问题，所以 redis 通过两种方式来实现对持久化的支持</p><p>​    <strong>RDB（快照方式，redis database）：就是将某一时刻的数据通过二进制方式写入到文件中（dump.rdb），注意这个 RDB 的快照是一个 全量快照，目的就是为了不让快照时丢失数据</strong></p><p>​    <strong>AOF（文件追加，append only file）：默认情况下 redis 不开启 AOF 方式，相比 RDB 而言，AOF 会将执行的每一个写命令都追加写入到文件中（appendonly.aof）</strong></p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>​    <strong>redis 默认使用是 RBD 的持久化方式</strong>，可以通过手动或自动来触发持久化操作，手动方式可以通过 <code>save</code> 和 <code>bgsave</code> 两种命令触发，自动触发则是通过对配置文件进行配置，达到条件时自动触发</p><p>​    <strong>SAVE：</strong></p><p>​    <strong>虽然 6 的版本开始 redis 支持了多线程， 但是对于命令的执行依旧是单线程的形式</strong>，所以当一个客户端对 redis 服务发送 <code>save</code> 命令后，其他客户端此时无法对该 redis 服务进行操作，全部都进入到 <strong>阻塞</strong> 状态</p><p><img src="https://wei-foun.github.io/img/redis-save.jpg" alt="img"> </p><p>​    <strong>BGSAVE：</strong></p><p>​    可以看作是 <code>save</code> 命令的一个优化，<code>bgsave</code> 命令发起持久化操作，redis 主进程会先调用 <strong>fork 创建一个子进程</strong>，并将生成 rdb 文件的持久化操作交给该子进程来实现，此时 <strong>redis 服务不会被阻塞</strong> 住，依然接收其他客户端请求并响应</p><p>​    <strong>补充：bgsave 子进程虽然不会阻塞主进程，但是这仅限于读操作</strong>。然而对于 <strong>写操作，bgsave 在进行全量快照的时，redis 会将涉及写操作的数据进行拷贝，产生一个原数据的副本，bgsave 快照仅仅是对这个副本进行快照备份</strong>，所以 redis 的主线程不会因为 bgsave 而对写操作产生影响</p><p>​    另外 <strong>RDB 的快照只是在第一次进行一次 全量快照，后续的快照则是通过 增量快照 来备份数据</strong>。目的是防止短期内大量的全量快照，会造成磁盘压力增加导致性能损失，同时后续的增量快照会去判断在全量快照后，对之后被修改的数据进行增量快照，但是如果数据量很大，即使是增量快照同样会直接影响到性能，并且每次去标记判断数据是否被修改，还会需要额外的空间</p><p>​    <img src="https://wei-foun.github.io/img/redis-bgsave.jpg" alt="img"> </p><p>​    对于自动触发，则是在 redis 的 conf 中配置 save 选项，当条件满足后会自动触发，使用 <code>bgsave</code> 命令去进行持久化</p><p>​    save 的配置项为：<code>save m n</code>，m 表示秒数，n 表示次数，整个配置表示在 m 秒中执行 n 次命令就执行一次持久化，默认在 redis.conf 配置文件中有三种状态的持久化配置，其中任何一种状态满足就会自动去触发持久化操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>​    每次创建 rdb 文件后，服务器会自动将时间计数器和次数计数器置为零，并从新开始计数</p><p>​    <strong>恢复：</strong></p><p>​    当 redis 服务出现问题或宕机，再次启动后会 <strong>自动检测 dump.rdb 文件，通过加载来进行数据恢复</strong></p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>​    与 RDB 一样都是通过写入文件来创建持久化，但 <strong>AOF 默认是不开启的</strong>，所以要是用 AOF 持久化，需要设置配置项，在 <strong>conf 文件中设置 <code>appendonly yes</code> 开启 AOF</strong></p><p>​    对于 <strong>AOF 写入，实际上分成了两个步骤，首先操作命令会先被执行，再被写入到 <code>aof_buf</code> 缓存中，然后 redis 通过配置项中的设置来做不同的策略将缓冲区的命令继续追加写入到文件中</strong></p><p><img src="https://wei-foun.github.io/img/redis-aof.jpg" alt="img"></p><p>​    <strong>AOF 之所以先在内存中执行命令写入后，再去进行磁盘的追加写进行日志记录，其目的是为了防止在日志文件中记录不必要的错误命令，造成额外的存储与检查开销，以及在进行日志恢复时可能出现的错误</strong>；同时另一个好处是，”后写” 日志将不会阻塞命令的写入执行</p><p>​    <strong>但是 AOF 如果执行完命令，还没来及写日志就宕机，且 redis 不是做缓存而是直接作为数据库的话，就会导致数据丢失并无法恢复</strong>；并且，如果 AOF 在主线程中去执行日志写入，虽然不会阻塞当前命令，但是如果磁盘压力较大的话，还是会导致后续的命令执行会出现阻塞状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always</span><br><span class="line"># always 表示命令写入到 aof_buf 缓冲区后，立马调用 fsync 命令进行同步追加写到文件</span><br><span class="line"></span><br><span class="line">appendfsync everysec</span><br><span class="line"># everysec 表示先调用系统 write 操作，然后返回。fsync 的操作则由专门的线程每隔 1 秒执行一次文件写入</span><br><span class="line"></span><br><span class="line">appendfsync no</span><br><span class="line"># no 表示调用 write 后，不会进行 aof 文件的同步，同步操作由操作系统自己负责，周期最长为 30 秒</span><br></pre></td></tr></table></figure><p>​    always 对整体性能影响最大，会占用较多 IO 资源，因为 always 某种意义上其实 AOF 的两个写入阶段变成了一个阶段，类似命令写入到 buf 中就立即执行了文件的写入，显然对性能影响会较大，但是在数据安全性上，相比其他方式也更高</p><p>​    everysec 相对 always 来说不是立刻的实时操作，隔离了两个写入阶段，对真正的文件写入利用子线程做一秒一次的定时写入，所以对性能影响相对较小，但是数据安全性上就可能存在丢失一秒的数据</p><p>​    no 则是在 everysec 上更加分离开两个阶段，将 buf 的命令写入交给系统来控制，但在数据安全性上也最低</p><p>​    另外需要注意：<strong>everysec 和 no，调用 write 来写入缓冲区时，会触发延迟写机制，不会阻塞服务</strong>，当命令写完后会返回。而 <strong>always 则是直接用 fsync 强制执行磁盘同步，所以会阻塞住</strong>，直到缓存区的内容写入到磁盘文件中</p><p><img src="https://wei-foun.github.io/img/redis-aof%E7%AD%96%E7%95%A5.jpg" alt="img"></p><p>​    <strong>重写机制：</strong></p><p>​    重写机制本身并不是真的完全重写，而 <strong>是通过策略进行优化通过新的文件覆盖旧文件实现</strong></p><p>​    因为 AOF 是追加写入方式，所以会随着命令的不断写入，导致 AOF 文件的不断增大占用更多的磁盘空间，比如对一个 key 反复设置不同的 value，而真正有用的只有最后一次设置的 value，而之前的设置就都是无用的命令；又或者操作的 key 已经过期被删除，那文件记录的命令也是无效命令，以及对一个列表的元素添加命令是分开执行，而不是整合在一个命令，这样的情况都会额外增加文件的空间</p><p><img src="https://wei-foun.github.io/img/redis-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6.jpg" alt="img"></p><p>​    为了对此进行优化 redis 提供重写机制，将上面提到的重写策略进行优化，可以 <strong>通过手动启动使用命令 <code>bgrewriteaof</code></strong>，自动启动同样是在配置文件中进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># percentage 表示 aof 文件距离上次文件增长的超过多少的百分比来触发重写</span><br><span class="line"></span><br><span class="line">auto-aof-rerite-min-size 64mb</span><br><span class="line"># min-size 表示 aof 文件体积最小达到多少来触发重写</span><br></pre></td></tr></table></figure><p>​    当满足所有设置的条件，会自动触发 AOF 重写，redis 会扫描整个实例的数据，重新生成一个 aof 文件</p><p>​    <strong>进程 AOF 持久化时，redis 的主进程会 fork 出一个子进程来做操作，在此期间 redis 是阻塞状态，且 fork 出的子进程与主进程是公用一个内存的，为了避免 fork 期间阻塞无法接收写命令</strong></p><p>​    fork 完成后， <strong>redis 会开启 <code>aof_rewrite_buf</code> 重写缓冲区，由于 fork 的子进程和主进程是共享内存空间的，所以 fork 创建完子进程后，子进程会去拷贝数据到 <code>aof_rewrite_buf</code>，这样即不会阻塞主线程接收命令，同时也将数据做了一次备份，来确保数据不丢失</strong></p><p><img src="https://wei-foun.github.io/img/redis-%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><p>​    主进程会从 <code>aof_rewrite_buf</code> 获取命令根据重写策略来写入到子进程创建的 AOF 文件，随后利用这个新的文件将原本的 AOF 文件进行替换</p><p>​    <strong>补充：</strong>redis 的 aof 重写之所要创建一个新的 aof 文件，是因为如果重写机制是在原 aof 上做操作，那么最直接的问题就是主进程会和 fork 的子进程会产生操作的竞争，那么解决竞争问题就势必会影响主进程的性能；其次，使用同一个 aof 文件的话，也存在另一个问题，如果 aof 重写过程中出现错误，整个文件就基本作废了，那么无法在恢复到原来的数据</p><p>​    <strong>恢复：</strong></p><p>​    aof 实现恢复前，redis 需要先创建一个不带网络连接的伪客户端来实现，通过这个伪客户端来执行 aof 文件中的命令，将数据进行还原恢复。这意味着如果 aof 命令日志文件较大，那么需要执行的命令就会很多，要进行恢复的话就会要缓慢一些，从而影响到正常使用</p><p><img src="https://wei-foun.github.io/img/aof-%E6%81%A2%E5%A4%8D.jpg" alt="img"></p><p>​    需要注意的是，如果 <strong>同时使用了 RDB 和 AOF 两种持久化方式，那么在进行恢复时则是优先使用 AOF 文件</strong> 来进行恢复，如果没有开启 AOF 则就是加载读取 RDB 的文件来恢复</p><h4 id="两者的优缺点"><a href="#两者的优缺点" class="headerlink" title="两者的优缺点"></a>两者的优缺点</h4><p>​    <strong>RDB 的优点：</strong></p><p>​    <strong>1）文件体积会更小，因为文件内容是二进制存储的</strong></p><p>​    <strong>2）恢复速度要更快</strong>，能够很快的读取到数据直接恢复</p><p>​    <strong>RDB 的缺点：</strong></p><p>​    <strong>1）数据容易存在丢失，因为都是 RDB 持久化保存的都是某一时刻上的数据快照</strong>，如果在写入文件时出现异常崩溃，在进行恢复期间，无法接受和响应就容易造成数据丢失</p><p>​    <strong>2）性能和资源消耗更多</strong>，在 bgsave 方式下需要创建额外的进程单独执行文件写入，在持久化期间会消耗大量 CPU 和 内存资源，所以不能频繁地去进行备份</p><p>​    <strong>3）可能存在不同版本的 RDB 文件不兼容的情况</strong></p><p>​    <strong>AOF 的优点：</strong></p><p>​    <strong>1）数据完整性更好</strong>，追加写入命令的方式确保了完整性，<strong>减少了数据恢复时的丢失率</strong>，将数据丢失控制在秒级别</p><p>​    <strong>2）易读性更好， AOF 存储的原生命令使得可读性要比 RDB 的二进制要强</strong></p><p>​    <strong>AOF 的缺点：</strong></p><p>​    <strong>1）文件体积更大</strong>，命令都是直接写入文件，即便有重写机制，所生成的文件依旧比 RDB 要大，且在数据 <strong>恢复速度上也要比二进制的 RDB 要慢</strong></p><p>​    2）在 everysec 方式下，每隔一秒的写入，容易造成磁盘 IO 变高，降低整体性能</p><h4 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h4><p>​    顾名思义，就是将 <strong>RDB 与 AOF 两种持久化方式的混合</strong>，这是在 redis 4 的版本之后新增的功能，<strong>通过在配置文件的 <code>aof-use-rdb-preamble</code> 来设置开启，混合持久化的方式也是使用 AOF 的 <code>bgrewriteaof</code></strong></p><p>​    不过持久化的文件很特别，<strong>首先 fork 出的子进程会将缓存区的命令通过 RDB 的形式写入到 AOF 文件中，然后再将重写缓存区内的命令增量写入 AOF，也就是说混合持久化模式下，生成的文件也包含了两种格式</strong></p><p>​    所以混合持久化的方式中，将全量和增量备份进行了隔离，全量快照依旧是使用 RDB，而此之后增量的部分利用 AOF 来记录修改的数据。这样既避免了全量快照频繁操作下影响性能，同时使用 AOF 记录增量也避免了 AOF 的文件过大。最后当进行第二次的全量快照时，AOF 的记录就会被清空，因为第二次的全量快照记录所有此前更改后的数据</p><p>​    混合持久化兼容了 RDB 与 AOF 的优缺点，但是混合持久化默认也是不开启的，且混合持久化的文件在 4 之前的版本也无法识别读取</p><p>​    <strong>总结：</strong></p><p>​    <strong>如果数据不允许丢失，使用混合持久化会是最好的选择；如果允许分钟级数据丢失，使用 RDB 的效率和恢复都比较好；如果只是使用 AOF，应该优先选择 everysec 的配置</strong></p><h3 id="Redis-主从模式"><a href="#Redis-主从模式" class="headerlink" title="Redis 主从模式"></a>Redis 主从模式</h3><p>​    redis 的高可用，首要的两个指标就是数据尽可能少的丢失，同时服务要尽可能少中断。前者 redis 已经有了 RDB 和 AOF 来负责，对于服务中断问题，redis 的做法是增加副本，将一份数据拷贝给多个 redis 实例，如果某个单点故障，其他实例依然能够提供服务，即通过集群来避免服务异常中断</p><p>​    <strong>redis 的主从模式其实就是双实例，主从库采用的是 读写分离 的方式</strong>。对于所有的读操作，请求和访问主库，也可以访问从库；但是 <strong>对于写操作，首先需要在主库上执行，由主库将写操作同步发送给从句</strong>，从库执行得到新数据</p><p>​    之所以将写操作分离开，其实是如果一个客户端对一个 key 修改了多次，而恰好又都是发给了不同的实例，那就会导致各个实例上的数据不一致</p><p><img src="https://wei-foun.github.io/img/redis-%E4%B8%BB%E4%BB%8E.jpg" alt="img"></p><p><strong>主从配置：</strong></p><p>​    redis 的主从配置并不复杂，对于主库来说并不需要进行配置修改，只需要在从库的配置文件中加上 <code>slaveof 主库的 ip 地址 主库的端口</code> 即可</p><p>​    假设主库的端口是 6379，使用 cp 命令拷贝默认的 redis.conf 文件并将新文件命名为 redis-6379.conf，然后通过 <code>sed &quot;s/6379/6380/g&quot; redis-6379.conf &gt; redis-6380.conf</code>，linux 的 sed 命令会将 redis-6379.conf 中全局所有的 6379 替换为 6380，然后保存到文件 redis-6380.conf 中，同样的方法可以创建 redis-6381.conf 的配置，这样就有了两个从库</p><p>​    然后，可以通过 linux 的 echo 命令添加从库配置 <code>echo &quot;slaveof 127.0.0.1 6379&quot; &gt;&gt; redis-6380.conf</code>，这样就在 6380 中添加了主库的地址和端口，同样的操作给 6381 的配置文件，最后各自通过配置文件运行启动 redis-server 实例</p><p>​    运行后，通过客户端命令 <code>redis-cli -p 6379 info replication</code>，可以查看到主库的主从同步信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=140,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=140,lag=1</span><br></pre></td></tr></table></figure><p>​    同样可以查看从库的主从信息，只需要将 <code>redis-cli</code> 命令中的 <code>-p</code> 端口改为从库端口 <code>redis-cli -p 6380 info replication</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:238</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br></pre></td></tr></table></figure><p><strong>主从库的同步过程中会有三个阶段：</strong></p><p>​    <strong>1）从库向主库发出连接， 请求进行同步</strong>。首先，从库需要执行 <code>replicaof 172.16.19.3 6379</code></p><p>​    然后，从库会给主库发送 psync 命令，并携带 runID 和 offset，由于第一次做同步，从库不知道主库的唯一实例 ID，所以 runID 是 ？，同时 offset 的值为 -1 表示第一次拷贝</p><p>​    主库收到 psync 后回复 fullresync 响应表示第一次拷贝采用的全量复制，并且携带自己的唯一 ID，以及自己当前的复制进度 offset</p><p>​    <strong>2）主库通过 bgsave 生成 RDB 文件，并同步给从库</strong>。从库接收后，清空本地数据，并加载主库发送的 RDB，实现一致性</p><p>​    在主库同步文件给从库期间，主库自己不会被阻塞，依然接收请求。这也意味着发送给从库的 RDB 不会包含发送期间主库执行所产生的新数据，为了确保一致性，主库会将在生成 RDB 后的写命令都存放在 replication buffer 中</p><p>​    <strong>3）当从库接收了主库 RDB 后，主库会将 replication buffer 中记录的修改一并发给从库，从库只要重新执行操作，就能实现主从库的数据同步</strong></p><p><img src="https://wei-foun.github.io/img/redis-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.jpg" alt="img"></p><p>​    由此可见，在主从同步的过程中，对主库的压力会较大，主库不但要自己生成 RDB，还需要通过网络传输这个文件。如果在一个集群中，从库节点数量很多，全部都关联主库的话，主库在 fork 创建子进程并生成 RDB 的消耗会很大，而且 fork 这一操作还会伴随阻塞。而就传输而言，RDB 文件也会直接占用网络带宽</p><p>​    所以在集群架构下，要分摊掉主库的压力，可以使用级联从库来实现，即不让所有的从库实例全部关联自主库，让内存和性能较好的实例做主库的从库，其余从库各自以级联方式去关联到上层从库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  |--- 从库</span><br><span class="line">  | |--- 从库</span><br><span class="line">客户端 ----------------- 主库 -------- 从库 ------|</span><br><span class="line">  | |--- 从库</span><br><span class="line">  |--- 从库</span><br></pre></td></tr></table></figure><p>​    级联主从的 “主-从-从” 方式解决了 redis 主库的压力，但是网络阻塞或是主从断联的问题依然存在。2.8 版本之前 redis 主从在断开后，从库会重新与主库在进行一次全量拷贝，这使得整个动作的开销非常大</p><p>​    2.8 版本之后，主从库采用了增量拷贝的方式来对连接恢复后继续进行数据同步。前面说到，主从库实现数据同步时，主库会利用 replication buffer 去做增量的写操作记录，来将同步时接收的数据在 RDB 发送给从库后自己接收的写操作</p><p>​    而为了解决主从之间因为网络问题导致断连，使得恢复后同步数据，<strong>主库还有一个缓冲区 repl_backlog_buffer，该缓冲区会在主从断开后，记录恢复前主库接收的写操作，该缓冲区的目的是为了找出连接恢复后，主从之间命令执行的差异，防止连接恢复后从库做全量的拷贝</strong></p><p>​    <strong>repl_backlog_buffer 是一个环型的缓冲区，会记录两个指针位置，一个是主库自己会记录自己写到的位置，另一个是从库记录的自己写到的位置</strong></p><p><img src="https://wei-foun.github.io/img/redis-repl_backlog_buffer.jpg" alt="img"></p><p>​    随着命令的写入执行，repl_backlog_buffer 中主库的位置就会往后移动，那么新的位置与初始位置的偏移量就是 master_repl_offset，同理，对应从库也就是 slave_repl_offset，两个偏移量都随着命令执行而不断增加</p><p>​    当主从网络连接突然断开，在恢复后。从库会先发 psync 命令，同时携带自己当前的 slave_repl_offset 给主库，因为主从网络连接断开后，主库依然在接受命令，所以自己在 repl_backlog_buffer 缓冲区上的位置会继续往后移动，当主库根据自己的 master_repl_offset 和从库的 slave_repl_offset 判断偏移量的差距后，表面在网络断开和恢复期间，主库接收的命令是哪部分，此时主库再将两个偏移量差的部分同步给从库，由此实现断联恢复后数据的一致性</p><p>​    <strong>注意：</strong>repl_backlog_buffer 和 InnoDB 的 redo log 非常相似，所以共同存在的一个问题就是，一旦 repl_backlog_buffer 的空间写满了，主从之间连接还没恢复，那么主库的位置会继续往后移动，也就意味着会擦除数据来留出位置给新的数据。如果从库没有与主库重新连接上，或者从库的处理性能又比较慢跟不上主库新写入的数据速度，那就非常容易造成数据丢失或不一致</p><p>​    所以对于 repl_backlog_buffer 的缓存大小设置就需要仔细设置，一般可以设置 repl_backlog_size = 缓冲空间大小 * 2 </p><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>​    哨兵机制的出现，很显然就是去应对 redis 主从模式下出现的主库挂掉，导致服务中断或停止。在主从模式下，主库如果对写操作的服务中断，就会导致数据丢失，由此写操作就必须转给其他的从库，并且其他的从库还需要做数据同步</p><p>​    哨兵机制是一个运行在特殊模式下的 redis 进程，跟随主从库实例运行而运行，<strong>主要负责：监控、选择主库 以及 通知</strong></p><p>​    <strong>监控：</strong>哨兵进程运行后，会 <strong>周期性往所有主从库发送 ping 命令</strong>，对于响应超时的从库就会被哨兵认定为 “下线状态”；同理，主库也是如此，一旦主库没有响应，哨兵就需要切换主库</p><p>​    下线状态的判断，分为了两种：主观 和 客观下线。对于从库来说 ping 命令响应超时就可以主观判断为下线；但是对主库来说单纯使用 ping 去判断为主观下线会存在一定的问题</p><p>​    主库如果因为网络阻塞，或自身压力较大被单个哨兵误判为主观下线后，哨兵需要从新选主，以及后续的连接更改和从库同步，这一系列的过程的开销会很大。所以，对于主库而言，就不能使用单一哨兵去监控判断</p><p><img src="https://wei-foun.github.io/img/redis-%E4%B8%BB%E5%AE%A2%E8%A7%82%E5%88%A4%E6%96%AD.jpg" alt="img"></p><p>​    要避免对主库产生误判，哨兵的部署也可以使用集群方式，由多个哨兵对 redis 集群做监控判断，减少单个哨兵对主库判断的绝对决策权力，这样就可以使得主库被误判为下线的概率降低。多个哨兵按照 “少数服从多数” 的原则，即在 N 个哨兵实例下，建议是如果有 N/2+ 1 （这个数目并不是一定需要按照这个）个哨兵实例都认定主库处于下线状态，才能执行后续的重新选主，以及同步和重连，这样一来哨兵对主库的判断就变为客观判断了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 配置</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br><span class="line">sentinel monitor mymaster 192.168.13.1:6379 2</span><br><span class="line"></span><br><span class="line"># sentinel monitor 代表监控</span><br><span class="line"># mymaster 代表服务器的名称，可以自定义</span><br><span class="line"># 192.168.13.1 代表监控的主服务器，6379 代表端口</span><br><span class="line"># 2 代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行 failover (主从切换)操作</span><br></pre></td></tr></table></figure><p>​    启动时，需要使用 <code>redis-sentinel 哨兵的配置文件</code> 来运行哨兵</p><p>​    <strong>选主：</strong> <strong>哨兵选主大致分为两个部分 “筛选” 和 “打分”</strong></p><p>​    首先，肯定是要筛选掉下线的从库，其次还需要判断从库的网络连接状态，可以在配置文件中设置 down-after-milliseconds * 10 的配置项，表示实例与主库断开连接后尝试连接的最大超时时间，如果超出时间一直没有恢复主从连接，就认定为发生主从断连。10 表示就是发生断连的次数超过 10 次，那么可以认定当前实例的网络状态并不好，也就不适合作为新的主库，从而筛选掉</p><p>​    之后，就是 <strong>打分的环节，分为了三个阶段，依次是优先级、复制进度和从库自己的 ID</strong>。在任何一阶段中，得到最高分的从库就可以被作为新的主库，并退出后续的阶段，所以如果分数相同，就会进入下一阶段去打分</p><p>​    <strong>通知：</strong>当哨兵选出新的主库后，就需要将这个新主库发送给其他的从库，告知主库已经更换，那么从库就会通过执行 repliaof 来与新主库进行同步；除此之外，哨兵还需要通知连接的客户端，让他们与新主库进行连接</p><h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><p>​    <strong>配置哨兵集群下，各个哨兵的互相发现，利用就是 redis 的 pub/sub 机制</strong>。哨兵与主库建立连接后，就会获取到主库的 ip 和 端口，当主库开启了发布与订阅功能，各个哨兵实例就能通过主库知道其他哨兵的 ip 和 端口，这样一来哨兵集群就能实现消息传递，比如前面的主库是否下线的判断信息传递</p><p>​    发布订阅除了哨兵可以使用之外，自己编写的应用程序也能通过 redis 实现发布和订阅。那么为了区分开不同应用的消息，发布订阅模式就产生了频道，来进行区分。比如在主库上，所有的关联的哨兵都通过 <code>__sentinel__:hello</code> 频道交流，由此构建成哨兵集群</p><p>​    <strong>补充：</strong>哨兵集群中，<strong>当有哨兵实例认为主库处于主观下线后，会通过频道向其他哨兵发送 is-master-down-by-addr 的命令，其余哨兵会检测自己与主库的连接，返回 Y 或 N 表示自己与主句是否可连来做出投票</strong>。当最终赞成票数达到了配置 quorum 的设定值，那么就认定主库处于客观下线状态    </p><p><img src="https://wei-foun.github.io/img/redis-%E5%93%A8%E5%85%B5%E6%B2%9F%E9%80%9A.jpg" alt="img"></p><p>​    另外，哨兵集群完成了主库的下线判断，还需要选出一个哨兵做最后的主从切换，所以依然会通过发布订阅机制再去进行投票选出一个 leader。如果一个哨兵想成为 leader，它需要满足两个条件：1）拿到半数以上的投票  2）这个票数要大于等于 quorum 的值</p><p>​    当一个哨兵认为主库已经客观下线，并且自己想成为 leader，就会首先给自己投一票，并将发送命令给其余哨兵。其余哨兵如果同样判断主库是客观下线后，会是同样的操作。<strong>注意，每一个哨兵都只有一次投票机会，都是默认给自己投票，当有的哨兵没有判断主库客观下线后，会优先给第一个收到投票请求的哨兵投票，之后其余的哨兵全部都给反对票</strong></p><p>​    如果在一次选择 leader 中没有结果，哨兵集群会等待故障转移的 2 倍的时间，再次进行一轮 leader 的选举。注意，如果一个哨兵集群只有两个实例，一个哨兵要称为 leader 就需要得到 2 票，如果其中一个哨兵挂掉，那么就无法进行主从切换，所以一个哨兵集群最低保险是配置 3 个哨兵</p><p>​    前文说到，哨兵能够完成主从的切换，所以哨兵自然也需要和从库建立连接，它会发送 info 命令给主库，主库会将自己的从库列表发送哨兵，由此哨兵就能知道与主库连接的从库并与之建立连接</p><p>​    同时由于 pub/sub 的机制存在，使得客户端也能与哨兵进行交流，这样一来客户端就能通过频道知道主从之间的一些状态信息</p><p><img src="https://wei-foun.github.io/img/redis-pub-sub.jpg" alt="img"></p><p>​    那么哨兵完成主从切换后，客户端通过 switch_master 频道知道新的主库的 ip 和端口，从而实现与新主库的连接</p><h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><p>​    <strong>如果需要在 redis 中启动事务的方式，需要使用 <code>multi</code> 这个命令，之后的所有命令都会加入到事务的队列中，通过执行 <code>EXEC</code> 执行该事务队列中存放的命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) 1) <span class="string">&quot;Mastering Series&quot;</span></span><br><span class="line">   2) <span class="string">&quot;C++&quot;</span></span><br><span class="line">   3) <span class="string">&quot;Programming&quot;</span></span><br></pre></td></tr></table></figure><p>​    <strong>如果要取消事务，放弃事务队列中的命令，可以执行 <code>DISCARD</code></strong></p><p>​    <strong>原子性（Atomicity）</strong>： redis 中 <strong>单独执行一个命令是具有原子性的</strong>，但是在事务中，<strong>多个命令执行并不具有原子性，因为多个命令执行没有回滚机制来保证全成功和全失败，但是在 redis 的客户端对于错误的命令会进行提示，来告知命令错误，事务就不会执行</strong>。但如果事务执行时发生错误，此时就无法保证具有原子性了。另外，执行时发生故障，如果开启 aof， redis-check-aof 命令检查 aof 文件，会自动将不完整事务移除，这个恢复出来还是满足原子性</p><p>​    <strong>一致性（Consistency）</strong>：在  exec 前命令检查失败，这种不会执行不影响一致性，且如果是执行时报错，那么错误命令也不会影响一致性。然后就是执行中如果 redis 实例故障，rdb 下不会在事务过程中执行，所以恢复前后是一致的。aof 也是如此，但 <strong>如果 aof 中记录了事务里部分完成的命令后发生故障，那么恢复就会出现不一致，但 redis-check-aof 命令可以来保证一致性</strong></p><p>​    <strong>隔离性（lsolation）</strong>：<strong>基于 redis 单线程命令执行的特点，非并发下隔离性天然保证</strong>。对于 <strong>并发场景下，需要开启 watch 机制监听事务操作过程中是否有其他操作修改相同数据，否则无法保证隔离性</strong></p><p>​    <strong>持久性（Durablity）</strong>：虽然 redis 执行 <strong>RDB 与 AOF 进行数据持久化，但是两种方式依然不能完全保证数据不会丢失的情况</strong></p><p>​    redis 事务执行有三个重要保证：</p><p>​    1）批量执行多个命令前，这个操作会先被放入队列缓存中</p><p>​    2）执行 exec 命令进入事务执行，在事务执行期间，任意命令如果执行失败，不会干扰其他命令执行</p><p>​    3）事务执行过程中，其他客户端提交的命令不会插入到事务执行命令的序列中</p><p>​    <strong>要实现一致性，需要通过 <code>WATCH key [key1 ...]</code>，会将指定的 key 进行监控</strong>，此时如果 客户端 1 使用 <code>MULTI</code> 开启事务，并使用到被监控的 key 进行修改操作，但没有执行该事务，客户端 2 此时同样对被监控的 key 进行了修改，这个时候 客户端 2 上的命令都是可以正常执行的。之后如果 客户端 1 使用 <code>EXEC</code> 开始执行事务则不会有返回，命令不会生效，并且被监控的 key 都会被取消监控</p><p>​    另外，在 python 中实现事务的话，使用 pipline 方法中 transaction 参数为 True 表示开启事务，通过 pipline 对象的 execute 方法来执行事务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pipe.multi()</span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;alex&#x27;</span>)</span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&#x27;role&#x27;</span>, <span class="string">&#x27;sb&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure><h3 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h3><h4 id="单-redis-节点的分布式锁"><a href="#单-redis-节点的分布式锁" class="headerlink" title="单 redis 节点的分布式锁"></a>单 redis 节点的分布式锁</h4><p>​    在分布式系统中，锁是保存在一个共享存储系统上的，这就允许了可以被多个客户端去进行访问和获取，而 redis 本身就允许多个客户端进行访问，天生就可以作为一个共享存储系统，所以单个 redis 节点就能提供分布式锁的功能</p><p>​    分布式锁和一般单机程序逻辑上锁类似，使用 redis 来实现分布式锁，可以通过一个键值对来进行设置 <code>setnx key value</code>，可以将 key 的值设置为 0，0 表示没有客户端持有锁，当有客户端要上锁，就将值设为 1</p><p><img src="https://static001.geekbang.org/resource/image/1d/45/1d18742c1e5fc88835ec27f1becfc145.jpg" alt="img"> </p><p><img src="https://static001.geekbang.org/resource/image/c7/82/c7c413b47d42f06f08fce92404f31e82.jpg" alt="img"> </p><p>​    对于加锁操作，客户端通过 <code>setnx</code> 去设置，通过 <code>del</code> 删除 key 来释放锁。虽然 <code>del</code> 会删除 key，但是对于加锁的 <code>setnx</code> 来说，会先去判断 key 是否存在，不存在就创建。这样也很好解决了一个判断问题，因为原本设想的是 0 表示释放锁，1 表示加锁。但是当一个客户端创建并最后释放，锁的值被改为 0，其他的客户端要获得锁，要还需要查询一次进行一步判断是否 key 存在，不存在才能去申请锁</p><p>​    释放锁通过 <code>del</code> 操作，对于其他客户端而言，加锁的操作就不用多一步值的判断问题，<code>setnx</code> 会在锁的 key 存在情况下，不会执行操作来修改，这样即使客户端没有释放，其他客户端去执行加锁操作，通过判断到 key 的存在，而无法得到锁</p><p>​    但是仅仅通过 <code>setnx</code> 和 <code>del</code> 来做加锁和释放锁的操作依然有问题，如果一个客户端在获得锁后一直没有释放锁，就会导致其他客户端无法获取锁，所以在设置创建 key 的时候，同时加上 <strong>过期时间</strong>，比如 <code>set</code> 命令中的 <code>ex</code> 参数设置过期时间，这样即使一个客户端在获取锁后，可能因为异常导致一直占用着锁，但是一旦锁到期就被自动被释放，让其他的客户端去请求加锁</p><p>​    不过给 key 加上了过期时间，依然还是有问题存在，因为释放锁通过 <code>DEL</code> 来执行，如果 客户端 1 设了 key 获取到锁，但是却被 客户端 2 执行了 <code>DEL</code> 删除该 key，那么就会导致 客户端 1 的锁被误释放，其他客户端就会去申请创建 key 来加锁，一样会给业务处理带来问题</p><p>​    所以为了防止锁被误删，就需要改变 value，<strong>让 value 能具有代表加锁客户端的唯一标识作用，比如使用 uuid 等</strong>，这样每次释放锁就需要判断锁变量的值与唯一标识是否一致才能执行 <code>DEL</code> 将锁释放</p><h4 id="多-redis-节点的分布式锁"><a href="#多-redis-节点的分布式锁" class="headerlink" title="多 redis 节点的分布式锁"></a>多 redis 节点的分布式锁</h4><p>​    单节点虽然可以实现分布式锁，一旦 redis 出现单点故障异常宕机，那么整个分布式锁就无法使用。所以要想使得整个服务系统更加健壮，就不得不增加 redis 实例，可以利用 redis 主从模式来设置分布式锁，虽然相对而言比单点有了保障，但依旧不能彻底解决问题，master 如果出现异常，需要进行主从切换，这个时间内 redis 不能接收数据就会丢失这一时间段的所有数据</p><p>​    所以要实现高可靠的分布式锁，就需要使用更多的 redis 实例，redis 为了解决前面单点和主从模式下的问题，提供了一个 <strong>RedLock 的分布式锁算法</strong></p><p>​    <strong>RedLock 算法基本思路是，当客户端需要申请创建锁时，需要依次向所有的 redis 实例上去创建锁，如果能够在超过半数的节点上实现加锁操作则意味着客户端成功获取分布式锁，否则加锁就是失败的</strong></p><p>​    这样即使单个节点故障，设置的锁变量 key 在其他 redis 节点上也都有保存，客户端依然可以用相同的逻辑来获取</p><h5 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h5><p>​    对于 Redlock 算法的执行大致分为 3 个步骤：</p><p>​    1）获取当前的时间戳，单位是毫秒级</p><p>​    2）客户端依次向 N 个 redis 实例进行创建锁，同时给这个加锁过程设置超时时间，这样如果一个 redis 实例一直没有成功创建，客户端会跳过继续往后的 redis 实例进行创建，对于超时时间的设置肯定需要远小于锁的过期时间，这个超时时间一般可以设置为几十毫秒</p><p>​    3）只要客户端完成向所有的 redis 实例实现加锁操作后，客户端会立即计算整个加锁过程的总耗时</p><p>​    最后，<strong>对于是否加锁成功，其实有两个条件判断：</strong></p><p>​    1）超过 N/2+1 的 redis 实例上都成功加上了锁</p><p>​    2）客户端完成操作后的统计的总耗时没有超过锁设置的过期时间</p><p>​    <strong>同时满足两个后，还需要重新对锁的有效时间进行计算，通过锁原本的有效时间 - 客户端统计的总耗时 = 新的有效时间，要是无法同时满足两个条件，客户端会向所有实例去释放锁，删除已创建的 key</strong></p><p>​    如果锁的新的有效时间不足以完成数据的操作，则会将锁进行释放，防止出现数据没处理完，锁就因为到达过期时间而被自动释放</p><p>​    当一个客户端得到锁后，其他的客户端会不断轮询来尝试获取锁</p><h4 id="其他分布式锁方式"><a href="#其他分布式锁方式" class="headerlink" title="其他分布式锁方式"></a>其他分布式锁方式</h4><p>​    比如 Redisson ，Zookeeper 等</p><h3 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h3><p>​    缓存已经是现在任何应用系统都不可少的模块，也是高并发高性能架构中的一个重要的组件</p><p>​    使用缓存一是能够缓解对数据库的压力，而是能够提升系统的整体处理性能，比如热点数据，或是对实时性要求不高的数据放在缓存中，请求可以直接向缓存中获取，就不用对数据库进行查询操作</p><p>​    一般来说，<strong>缓存有三种模式：Cache Aside，Read / Write Through，Write Behind Caching</strong></p><h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p>​    表示 <strong>同时更新缓存和数据库</strong>，这是最常用的一种缓存方式，对于数据的查询操作，如果能从缓存中得到即命中，就直接返回；如果没有则表示获取操作失效，即需要查询数据库来获取，同时将得到的数据放到缓存中</p><p>​    但是对于更新操作，就需要避免数据一致性的问题，比如是先更新缓存还是先更新数据库</p><p>​    1）先更新数据库，再更新缓存</p><p>​    这种方式最容易遇到一个问题，就是在并发情况下，更新操作没有全部完成，请求就先从缓存中读到了数据，但是这个数据其实是脏数据，这样就出现数据库和缓存的数据不一致问题</p><p>​    2）先删除缓存，再更新数据库</p><p>​    和上面的方式一样会遇到不一致的问题，虽然缓存被删除，但是如果有另一个请求获取数据，对缓存来说就是失效的，请求就会从数据库上获取，如果数据库的更新操作还没执行，那么就会从数据库上读到旧数据</p><p>​    3）<strong>先更新数据库，再删除缓存</strong></p><p>​    相比前两种，先在数据库更新，然后将缓存删除这样的方式要更好，但是依然会有脏数据的问题，并发情况下，如果读操作没有命中缓存，读到了数据库中的旧数据，同时更新操作对数据库更新了，也将缓存删除了，而之前的读操作则又会将旧数据放到缓存中，那后续的读就是脏数据了</p><p>​    但是这样的情况概率很低，需要缓存失效同时有读写操作，一般情况读操作远远多于写的操作</p><h4 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read / Write Through"></a>Read / Write Through</h4><p>​    表示 <strong>先更新缓存，在通过缓存负责将数据 同步 到数据库上</strong></p><h4 id="Write-Behind-Caching"><a href="#Write-Behind-Caching" class="headerlink" title="Write Behind Caching"></a>Write Behind Caching</h4><p>​    表示 <strong>先更新缓存，在通过定期的方式 异步 更新数据到数据库上</strong></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>​    <strong>缓存与数据库中没有的数据被大量不断的请求，使得查询操作不能命中缓存，导致数据库的压力过大</strong></p><p>​    比如一些简单的爬虫根据标签或路由的 id 进行遍历发送请求，但是对于一些数据可能并不是按照 id 自增的方式创建的</p><p>​    <strong>解决方法：</strong>可以对查询不到的结果定义一个 None 返回，并将其放入到缓存；也可以前置布隆过滤器实现快速查看是否存在，拦截无效请求</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>​    <strong>缓存上的数据出现了批量的过期，导致原本在缓存上获取的请求突然全部打到数据库上，使得数据库压力瞬间增大</strong></p><p>​    击穿的问题是因为缓存上大量的 key 是相似时间创建的，并且所设置的过期时间也是一样的，导致会出现在某一时刻出现大量失效</p><p>​    <strong>解决方法：</strong>如果是热点的数据，且更新非常低，可将这些数据不设置过期时间；或是编写脚本异步后台定期对缓存上快过期的 key 进行刷新；也可以通过加锁的方式，让有锁的线程单独从数据库上拉取数据到缓存，其他的线程就会等待缓存中有数据了去缓存上取</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>​    <strong>缓存突然不可用，或是缓存上的不同类型的数据都出现大批量的失效，导致请求打到数据库</strong>，雪崩也很容易理解，相比击穿来说，失效的数据要远大于击穿中失效的数据</p><p>​    缓存节点可能因为各种原因出现异常挂机，那么此时这个缓存上的所有数据都无法被查询命中，大量的并发请求就甚至可能把数据库也打挂掉。另外，因为 redis 存储支持丰富的数据类型可以存放不同功能所需要的数据，当过期时间一致时就容易出现和击穿一样的问题</p><p>​    <strong>解决方法：</strong>对于不同类型或级别的数据，设置不同的超时时间，或者创建 key 的时候使用随机的超时时间，避免同一时刻大量的失效；对于缓存不可用，就需要提升系统整个健壮性，添加监控和报警，使用主从节点</p><p>​    </p><p>​    </p><p>​        </p>]]></content>
      
      
      <categories>
          
          <category> redis 重点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 整理</title>
      <link href="/2237286045/"/>
      <url>/2237286045/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    Elastic 本质上是一个 <strong>分布式</strong> 数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。同时是基于 java 开发，利用 RESTful web 接口来与服务器进行交互，虽说 Elastic 是一个数据库，不过最大的功能是作为一个分布式多用户的 <strong>全文搜索引擎</strong></p><p>​    先来分析一下，为什么对于传统像关系型数据库来说，无法提供搜索引擎的功能。首先，对于搜索引擎来说，需要对存储的数据以及搜索的内容进行分词，同时又需要对分词后的数据进行打分，分词的目的可以理解为提供搜索关键字，而打分的目的则是实现一个排序的功能，关系型数据库存储的一条条记录，并不能同时兼具这两者的实现，并且关系型数据在磁盘上读写都非常慢，这也是其不能做搜索引擎的一点</p><p>​    补充：<em>MongoDB 和 Elasticsearch 很相似都是 NoSQL 类型的数据库，简单来说两者都是文档型数据库，都支持 CRUD 以及全文检索；不同的是 Elasticsearch 是基于 java，MongoDB 是 C++，前者基本都用于检索，分析和查询的场景，后者更偏向与大规模数据下的增删改查，因为相比前者 CRUD 操作速度更快</em></p><h4 id="集群（Cluster）"><a href="#集群（Cluster）" class="headerlink" title="集群（Cluster）"></a>集群（Cluster）</h4><p>​    由多个节点组织在一起的群体，集群是分布式的代表</p><h4 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h4><p>​    是集群的一个成员，单个 Elastic 实例就是一个节点，每一个节点都是集群中的一台服务器</p><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>​    是一种将索引划分成多份的能力，允许了水平分割和扩展容量，多个分片的协作可以提高响应的性能和吞吐量</p><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>​    是一种创建分片或者备份的能力，可以提高服务器的健壮性，在遇到节点故障情况下，使用提前备份的副本来顶替，维持服务运行</p><h3 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h3><table><thead><tr><th>Elasticsearch</th><th>Mysql</th></tr></thead><tbody><tr><td>index（索引）</td><td>数据库</td></tr><tr><td>type（类型）</td><td>表</td></tr><tr><td>documents（文档）</td><td>行</td></tr><tr><td>fields</td><td>列</td></tr></tbody></table><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>​    ES 的 documents 要分组，就需要通过 type 去指定类型，相同类型的 type 类型应该是一致的，例如 id 字段，不能在这个组是字符串，在另一个组是数值</p><p>​    根据规划，Elastic 6.x 版只允许每个 Index 包含一个 type，7.x 版将会彻底移除 type </p><h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p>​    index 中的每一条记录称为 document，document 使用 json 格式来表示，对于同一个 index 来说，document 的结构要尽可能保持相同，这样能够提升检索效率</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>​    <strong>ES 使用的是一种 倒排索引 的结构来做全文搜索，也称为 反向索引（inverted index）</strong>，当然也有另一种就是正向索引（forward index）</p><p>​    简单理解 正向索引 一种 key-value 的形式查找的话，倒排索引 则是一种 value-key 的形式</p><p>​    正向索引结构：以文档为键，查找关键字的列表来获取出现的位置和次数，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;文档1&quot;ID -&gt; 关键词1：[出现位置]，次数; 关键词2：[出现位置], 次数; …</span><br><span class="line">&quot;文档2&quot;ID -&gt; 关键词1：[出现位置]，次数; 关键词2：[出现位置], 次数; …</span><br></pre></td></tr></table></figure><p>​    倒排索引结构：就是以关键字为键，通过关键字与文档 ID 映射，提高查询的效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID &quot;关键词1&quot; -&gt; [&quot;文档1&quot;ID, &quot;文档2&quot;ID, …]</span><br><span class="line">ID &quot;关键词2&quot; -&gt; [&quot;文档1&quot;ID, &quot;文档2&quot;ID, …]</span><br></pre></td></tr></table></figure><p>​    上面的结构是一种简单的倒排索引结构，同时倒排索引也可以添加词频</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID &quot;关键词1&quot; -&gt; [(&quot;文档1&quot;ID, 次数), (&quot;文档2&quot;ID, 次数), …]</span><br></pre></td></tr></table></figure><p>​    并且还可以统计关键词的文档频率，以及记录所在位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID &quot;关键词1&quot; -&gt; 文档频率：[(&quot;文档1&quot;ID, 次数, 位置), (&quot;文档2&quot;ID, 次数, 位置), …]</span><br></pre></td></tr></table></figure><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>​    使用 ES 前需要现行安装 Java 8，安装完成后可以在 ES 的官网去下载需要的版本进行安装。不过，官网提供的 ES 自身的插件会很少，对于中文分词等问题需要自行去寻找和下载需要的插件进行安装，在 github 上的一位大神提供了简单的即装即用的版本 <code>elasticsearch-rtf</code></p><p>​    clone 或解压 <code>elasticsearch-rtf</code> 后，可以 cmd 进入到项目所在目录，在 bin 文件下，使用 <code>elasticsearch.bat</code> 文件去启动 ES</p><p>​    启动后，ES 会在本地的 <strong>9200</strong> 端口开启服务并进行监听，此时可以是直接在浏览器中输入 <code>127.0.0.1:9200</code> 就会看到如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;atntrTf&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;tf9250XhQ6ee4h7YI11anA&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;5.5.1&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;19c13d0&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2017-07-18T20:44:24.823Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;6.6.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="elasticsearch-head"><a href="#elasticsearch-head" class="headerlink" title="elasticsearch-head"></a>elasticsearch-head</h3><p>​    该插件是一个页面式的数据可视化插件，可以根据 README 文件去进行安装，其中该插件使用 npm 这个包管理工具去启动的，也就是说使用该插件需要用 npm 去安装需要的依赖包，自然会需要先去安装好 nodejs</p><p>​    另外，使用 npm 去安装项目依赖会去国外服务器下载，可能会超时或是出现错误，所以可以先去安装 cnmp，这样就可以利用 cnpm 到淘宝镜像中去下载 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>​    <em>在启动 elasticsearch-head 前，需要修改 ES 的 配置文件，因为 ES 本身只允许本机访问，<strong>三方插件无法对其访问，所以需要在 ES 的 config 目录下修改 yml 的配置文件</strong>，在文件中添加以下配置</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">http.cors.allow-methods: OPTIONS, HEAD, GET, POST, DELETE, PUT</span><br><span class="line">http.cors.allow-headers: &quot;X-Requested-With, Content-Type, Content-Length, X-User&quot;</span><br></pre></td></tr></table></figure><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>​    是一个为 ES 设计的可视化平台，实现与 ES 索引的数据进行交互。安装 kibana 时，需要在官网选择和 ES 一致的版本</p><p>​    安装完成后，和 ES 一样，进入 kibana 的 bin 文件目录，使用 <code>kibana.bat</code> 去启动，默认会在 5601 端口上开启服务</p><p>​    kibana 的 Dev Tools 插件提供了用户界面来和 ES 的 RESTful API 进行交互</p><h4 id="索引初始化"><a href="#索引初始化" class="headerlink" title="索引初始化"></a>索引初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT test</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">PUT lagou</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &#123;</span><br><span class="line">      &quot;number_of_shards&quot;: 5,</span><br><span class="line">      &quot;number_of_replicas&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    PUT 表示方法，后面的 test（lagou）表示索引名（相当于创建一个数据库），索引初始化只能用 PUT 方法，如果使用 POST，会抛出 <code>No handler found for uri [/test] and method [POST]</code></p><p>​    ‘<strong>number_of_shards</strong>‘ 表示 <strong>分片数，默认是 5</strong>，<strong>注意这个值指定后就无法进行修改</strong>；’<strong>number_of_replicas</strong>‘ 表 <strong>副本数，默认是 1，后期可以去更改这个值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT lagou/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;number_of_replicas&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Dev Tools 的左侧输入完成，在 PUT 这一行的右边会有一个绿色的三角符号，点击后就会执行，然后右侧窗口会显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true,</span><br><span class="line">  &quot;shards_acknowledged&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面的方式都是使用 ES 的 RESTful API 对索引操作，同样在 Elasticsearch-rtf 提供的可视化界面中一样可以完成以上步骤</p><p>​    如果要获取索引信息，可直接使用 <code>get test</code>，会将该索引的信息返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">    &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;index&quot;: &#123;</span><br><span class="line">        &quot;creation_date&quot;: &quot;1607076218855&quot;,</span><br><span class="line">        &quot;number_of_shards&quot;: &quot;5&quot;,</span><br><span class="line">        &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;uuid&quot;: &quot;i_LTvZTOTO-nQ7XHfjgYQQ&quot;,</span><br><span class="line">        &quot;version&quot;: &#123;</span><br><span class="line">          &quot;created&quot;: &quot;5010199&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;provided_name&quot;: &quot;test&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果要获取索引的 settings，可以使用 <code>get test/_settings</code> 来指定，查看所有索引的话，可以直接使用 <code>get _settings</code>，也可以用  <code>get _all/settigs</code></p><p>​    如果要获取所有的索引信息，可以使用 <code>get test,lagou</code>，注意多个索引需要用逗号隔开</p><h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>​    <strong>增：</strong>可以使用 <strong>post 或 put</strong> 请求方式，<strong><em>使用 put 重复提交数据的话，会去判断是否有不同的地方，有的话就将其更新，同时 +1 更新  version 字段，没有改动的话直接更新 version；但是使用  post 重复提交时，即使数据都一样，也会单独创建，不会覆盖</em></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT lagou/job/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;python开发&quot;,</span><br><span class="line">  &quot;salary_min&quot;: 15000,</span><br><span class="line">  &quot;city&quot;: &quot;LongYou&quot;,</span><br><span class="line">  &quot;company&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Tianyimeng&quot;,</span><br><span class="line">    &quot;company_dir&quot;: &quot;龙游市软件园&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;publish_date&quot;: &quot;2020-04-07&quot;,</span><br><span class="line">  &quot;comments&quot;: 15</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;lagou&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;job&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong><em>注意，PUT index / type / id（id 可以不指定，不指定时会自动生成一个 uuid 做 id），但是如果不指定 id 的话，必须使用 POST</em></strong></p><p>​    <strong>删：</strong>使用 delete 去指定，但是 ES 5 之后的不支持使用 delete 去指定 type 删除，如果要清除一个 index 的所有 type，可以使用 post 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST lagou/job/_delete_by_query?conflicts=proceed</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    删除一个 document，只需要指明 id 即可，<code>DELETE lagou/job/2</code>，清除整个 index，则直接 <code>DELETE lagou</code></p><p>​    <strong>改：</strong>通常使用 POST  去更新，当然和新增数据一样使用 PUT 也是可以的，<em>同理， PUT 修改数据必须要与原来的 document 的每一个 field 一致，因为 PUT 是会完全覆盖的，所以如果缺少一个字段信息，那么原本对应的字段就会消失</em></p><p>​    因此，对于 document 某些字段更新，使用 POST 更加可靠，不过需要在请求最后加上 ‘_update’，且在要更新的字段需要写在 ‘doc’ 的内部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST lagou/job/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;comments&quot;: 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>查：</strong>就和前面查询索引是一样的了，使用 GET 方法，查询某一个 id 的 field，可以直接使用  <code>GET lagou/job/1?_source=city</code> 即只查询 id 为 1 的 document 里 city 的值</p><p>​    <strong>另一个注意点：kibana 的所有请求的方法被期望都是大写的，但是输入小写去执行并不会报错，但在代码左侧会给出提示</strong></p><h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><p>​    全文搜索 需要在指定 type 内查询所有满足匹配文本的 document，则要按照下面的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET lagou/job/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">       &quot;title&quot;: &quot;java&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个例子中指明了 title 字段，返回的结果将会 job 这个 type 下每一个 document 里 title 含有 java 的数据返回，且 hits 中 的 total 会显示满足的总条数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 291,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 3,</span><br><span class="line">    &quot;max_score&quot;: 0.6099695,</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">    &#123;...&#125;,</span><br><span class="line">    &#123;...&#125;,</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    默认情况下，全文搜索一次只会返回 10 条满足的结果，返回的数目可以通过 <code>size</code> 去指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET lagou/job/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">       &quot;title&quot;: &quot;java&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    同时，还可以指定位移，通过 <code>from</code> 参数设置，默认该值是 0</p><h4 id="mget"><a href="#mget" class="headerlink" title="_mget"></a>_mget</h4><p>​    提供对多个 index， document 或 type 进行查询，比如，如果要查询两个 index 的 type 中的第一和第二个 document</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type&quot;,</span><br><span class="line">      &quot;_id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest1&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type1&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest1&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type1&quot;,</span><br><span class="line">      &quot;_id&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果 _mget 要查询的是同一个 index 的不同 type ，则可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET  dbtest/_mget &#123;</span><br><span class="line">    &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_type&quot;: &quot;type1&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_type&quot;: &quot;type2&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果 _mget 查询的 index 是相同的， 且 type 也是相同，则是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET  dbtest/type1/_mget &#123;</span><br><span class="line">    &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    除了上面的方式，还有一种更简便的方式，通过   <code>ids</code> 参数指定查询的 id 集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET  dbtest/type1/_mget &#123;</span><br><span class="line">&quot;ids&quot;: [1,2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bulk"><a href="#bulk" class="headerlink" title="_bulk"></a>_bulk</h4><p>​    提供了批量操作的功能，会将多个操作合并在一起，相比起单条数据方式来操作多个数据，_bulk 则会更加高效，因为单数据操作，每一次请求响应后，都会将连接关闭 </p><p>​    注意，使用 _bulk 进行批量操作时，因为要求每一行最后会有一个换行，所以 json 格式必须写在一行。每一行都由两行组成（delete 除外），大致格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">action and meta_data \n</span><br><span class="line">optional source \n</span><br><span class="line"> </span><br><span class="line">action and meta_data \n</span><br><span class="line">optional source \n</span><br><span class="line"> </span><br><span class="line">action and meta_data \n</span><br><span class="line">optional source \n</span><br></pre></td></tr></table></figure><p>​    第一行是操作类型，即 index，create，update 以及 delete；第二行则是数据部分</p><p>​    <strong>批量添加：</strong>可以使用 index 和 create 两种，前者在数据存在情况下会进行覆盖，后者则不会，且会将执行信息显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;L.Messi&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;10&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;C.Ronaldo&quot;, &quot;team&quot;: &quot;JFC&quot;, &quot;number&quot;: &quot;7&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Neymar.jr&quot;, &quot;team&quot;: &quot;PSG&quot;, &quot;number&quot;: &quot;10&quot;&#125;</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;CM&quot;, &quot;_id&quot;: 1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;伊涅斯塔&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;8&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;CM&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;哈维&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;6&quot;&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>批量修改：</strong>使用 update，对于数据部分，则是将要更改的字段和值写在 <code>doc</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST football/_bulk</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;: &quot;L.Suarez&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;9&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;update&quot;: &#123;&quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;: &quot;皮克&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;3&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>批量删除：</strong>使用 delete，特别之处在于 _bulk 的批量删除是不需要数据行这部分的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST football/_bulk</span><br><span class="line">&#123;&quot;delete&quot;: &#123;&quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;: &#123;&quot;_type&quot;: &quot;CM&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="mapping-映射"><a href="#mapping-映射" class="headerlink" title="mapping 映射"></a>mapping 映射</h4><p>​    映射是定义文档以及其包含的字段如何存储和索引的过程，默认 ES 是会自动进行动态映射，会根据 json 中源数据的基础类型给字段映射类型，虽然动态映射很方便，但是对于后期如果 document 中出现一些改动，就不得不删除整个 index 重新去创建，因为前期添加的数据不会有后来新增的字段，并且某些映射类型可能并不符合期望</p><p>​    ES 字段的映射数据类型支持很丰富，包括以下这些 <strong>核心类型</strong> ：</p><p>​    <strong>字符串类型：text，keyword</strong>（ ES 5 以前还有 string，但之后的版本就没有了）；text 的文本在经过分析器后会对关键字进行倒排索引，keyword 类型则不会经过分析器直接原样存储</p><p>​    <strong>数字类型：long，integer，short，byte，double，float</strong></p><p>​    <strong>日期类型：date</strong></p><p>​    <strong>布尔类型：boolean</strong></p><p>​    <strong>二进制类型：binary</strong>（这个类型在搜索时不会被检索）</p><p>​    <strong>范围类型：integer_range ， float_range ， long_range ， double_range ， date_range</strong> </p><p>​    还包括 <strong>复杂类型</strong> ：</p><p>​    <strong>对象类型：object</strong>（可以看作是 python 的字典）</p><p>​    <strong>内嵌类型：nested</strong>（可以看作 python 列表中嵌套多个字典）</p><p>​    还有 <strong>地理类型</strong> ：</p><p>​    <strong>地理类型：包含 geo_point（记录经纬度坐标），geo_shape（多点坐标标记区域）</strong></p><p>​    以及 <strong>专业类型</strong> ：</p><p>​    <strong>IP 类型：包括 ipv4，ipv6</strong></p><p>​    <strong>Completion类型：completion（用来自动补全提示）</strong></p><p>​    在自定义 mapping 时，除了类型的设置，还可以设置一些属性和参数，常见的有：</p><table><thead><tr><th>属性</th><th>描述</th><th>适用类型</th></tr></thead><tbody><tr><td>store</td><td>值为 yes 表示存储，no 表示不存储，默认为 no</td><td>all</td></tr><tr><td>index</td><td>值为 true 表示分析，false 表示不分析，默认为 true</td><td>只适用于字符串的 text 类型</td></tr><tr><td>null_value</td><td>设置的值会作为字段值为空时的默认值</td><td>all</td></tr><tr><td>analyzer</td><td>用于设置索引和搜索的分析器，默认使用 standard 分析器，对于中文分析，使用 ik 分析器</td><td>all</td></tr><tr><td>include_in_all</td><td>默认会给每一个 document 定义一个特殊域 _all，目的是让每一个字段都能被搜索到，不想被搜索可将值设为 false</td><td>all</td></tr><tr><td>format</td><td>对时间类型的字符串格式化</td><td>date</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">PUT fb_player</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;player&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;, </span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;age&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;nation&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;team&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;career&quot;:&#123;</span><br><span class="line">          &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;team_name&quot;:&#123;</span><br><span class="line">              &quot;type&quot;: &quot;text&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;date&quot;:&#123;</span><br><span class="line">              &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">              &quot;format&quot;: &quot;yyyy-MM-dd&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果要查看一个 index 的映射信息，使用  <code>GET fb_player/_mapping</code></p><p>​    <em>另外，ES 是会对一些类型进行转换的，比如上面的 age 字段虽然是整型，但是在插入数据时如果给的是一个只有数字的字符串，依然可以成功执行</em></p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><pre><code>ES 中查询可以分成包括：基本查询，组合查询，以及过滤</code></pre><p>​    基本查询：使用 ES 内置的查询条件去查询</p><p>​    组合查询：则是将多个查询组合在一起去查询</p><p>​    过滤：即通过 filter 在不影响打分情况下筛选查询的数据</p><p>​    <strong>match 查询：</strong>会将指定的字段值交给分词器进行分析，再将分词器分析后的结果与索引中的文档去匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&quot;messi&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    分析器会将 ‘messi’ 进行分词，去 type 是 player 下的所有 document 里匹配，只要出现满足分词的结果就会将该数据返回</p><p>​    <strong>match_all 查询：</strong>最前面的查询中，也使用到了这个，与 match 不同，match_all 表示返回所有数据，没有指定字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>match_phrase 查询：</strong>格式上与 match 不同，查询的文本需要在 query 中去指明，并且也会使用分词器分析，然后去进行匹配查询，同时还有一个字段 <code>slop</code>，该参数表示分词后，两个字符串之间的最小距离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_phrase&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&#123;</span><br><span class="line">            &quot;query&quot;: &quot;分布式系统&quot;,      # 比如会分词为 [&#x27;分布式&#x27;，&#x27;系统&#x27;]</span><br><span class="line">        &quot;slop&quot;: 6                    # 如果&#x27;分布式&#x27;，&#x27;系统&#x27; 中间小于 6 个字的都不去匹配</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>term 查询：</strong>不会去使用分词器，而是直接将搜索文本拿到 document 去匹配查询</p><p>​    <strong>terms 查询：</strong>不同于 term 的是，这个字段的是一个 <strong>列表</strong> 类型，也就是说允许对多个字符串去查询，满足其中任何一个都会将数据返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;terms&quot;:[&quot;ham&quot;,&quot;il&quot;,&quot;ton&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>multi_match 查询：</strong> 与 match_phrase 一样要在 query 字段去定义查询字符串，同时可以通过字段 <code>fields</code> 去指定多个字段，将 query 的字符串分析后去指定的所有字段中去查询，满足指定的任何一个字段就会将内容返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">    &quot;multi_match&quot;:&#123;</span><br><span class="line">            &quot;query&quot;: &quot;system&quot;,   </span><br><span class="line">        &quot;fields&quot;: [&quot;title&quot;, &quot;desc&quot;]    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    ES 会自动给匹配的每条数据去打分，并从高到低返回，multi_match 还支持对指定字段设置一个权重，比如 <code>&quot;fields&quot;: [&quot;title^3&quot;, &quot;desc&quot;]</code>，那么 title 的权重就是 desc 的三陪，ES 分词器的打分也就会更倾向于 title 这个字段又满足的数据</p><h4 id="指定字段查询"><a href="#指定字段查询" class="headerlink" title="指定字段查询"></a>指定字段查询</h4><p>​    在所有的查询中，如果要指定返回的字段，只需要将这个字段放在   <code>stored_fields</code> 的列表中即可，但是有一点要注意，设置返回的指定字段，必须是在 mapping 映射时，设置了 <code>&quot;store&quot;: true</code> 才行，否则即使指定了，但是没有设置 store 也依然不会返回该字段的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;stored_fields&quot;: [&quot;name&quot;, &quot;team&quot;]</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&quot;messi&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定返回结果的排序"><a href="#指定返回结果的排序" class="headerlink" title="指定返回结果的排序"></a>指定返回结果的排序</h4><p>​    同时对查询的发挥也可以用     <code>sort</code> 字段进行指定字段的排序，在 <code>order</code> 中 asc 表示升序，desc 表示降序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指定范围查询"><a href="#指定范围查询" class="headerlink" title="指定范围查询"></a>指定范围查询</h4><p>​    通过在       <code>query</code> 中的 <code>range</code> 字段指定范围，gt 表示大于，gte 表示大于等于，lt 表示小于，lte 小于等于，<code>boost</code> 字段表示字段权重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;range&quot;:&#123;</span><br><span class="line">            &quot;age&quot;:&#123;</span><br><span class="line">                &quot;gte&quot;:22,</span><br><span class="line">                &quot;lte&quot;:30,</span><br><span class="line">                &quot;boost&quot;:2.0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    范围的查询还支持了日期类型，并且可以使用字符串 “now” 来表示当前日期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;range&quot;:&#123;</span><br><span class="line">            &quot;birth_date&quot;:&#123;</span><br><span class="line">                &quot;gte&quot;:&quot;2000-01-01&quot;,</span><br><span class="line">                &quot;lte&quot;:&quot;now&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h4><p>​    可以将通配符放在查询的字符串中，作为一种模糊匹配的方式，主要有两个通配符： <code>?</code> 表示匹配任意个字符，<code>*</code> 表示匹配 0 或 多个字符（包含空字符） </p><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>​    bool 查询支持四个选项属性字段：must，filter，should，must_not</p><p>​    <strong>must：</strong>表示搜索的条件必须是全部满足的情况下</p><p>​    <strong>filter：</strong>表示过滤的条件，且不参与最后的结果打分 </p><p>​    <strong>should：</strong>表示搜索的条件需要满足一个或是多个的情况下</p><p>​    <strong>must_not：</strong>与must相反，表示的是指定条件都不满足的情况下</p><p>​    比如查询一个字段的固定值的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,   # 这一行不是必须的，默认也会是全文搜索，这一行的目的是可以做一些特殊的字段定制</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;age&quot;:22</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <em>一般来说，对于精确的值做查询，都应使用 term 去匹配查询</em></p><p>​    如果 bool 查询是一个字段的多个值，那么上面的 term 即要改为 terms，且里的字段就需要改成一个列表，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;terms&quot;:&#123;</span><br><span class="line">                    &quot;age&quot;:[17,22]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <em>注意，这里比如使用 filter 去过滤 name 这个字段时，需要给一个小写的字母，因为虽然数据插入时给的是开头大写，但在过滤时会默认用小写来匹配。所以如果给了大写字母去查询，会无法查询到</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;name&quot;:&quot;Xavi&quot;    # 注意这里</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 1,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 0,</span><br><span class="line">    &quot;max_score&quot;: null,</span><br><span class="line">    &quot;hits&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;name&quot;:&quot;xavi&quot;    # 注意这里</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 1,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 1,</span><br><span class="line">    &quot;max_score&quot;: 1,</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;fb_player&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;player&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Xavi&quot;,</span><br><span class="line">          &quot;age&quot;: &quot;38&quot;,</span><br><span class="line">          &quot;nation&quot;: &quot;Spina&quot;,</span><br><span class="line">          &quot;team&quot;: &quot;FCB&quot;,</span><br><span class="line">          &quot;career&quot;: &#123;</span><br><span class="line">            &quot;team_name&quot;: &quot;FCB&quot;,</span><br><span class="line">            &quot;date&quot;: &quot;1998-01-01&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    组合查询中，也可能会有嵌套的查询，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">        &quot;should&quot;:[</span><br><span class="line">             &#123;&quot;term&quot;:&#123;&quot;team&quot;: &quot;fcb&quot;&#125;&#125;,</span><br><span class="line">                &#123;&quot;bool&quot;:&#123;</span><br><span class="line">                    &quot;must&quot;:[</span><br><span class="line">                        &#123;&quot;term&quot;: &#123;&quot;nation&quot;: &quot;spain&quot;&#125;&#125;,</span><br><span class="line">                        &#123;&quot;term&quot;: &#123;&quot;age&quot;:19&#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 上面是一个 bool 嵌套了一个 bool，如果要按照 sql 去理解就是：</span><br><span class="line">select * from player where team=&#x27;fcb&#x27; or (nation=&#x27;spain&#x27; and age=19)</span><br></pre></td></tr></table></figure><p>​    要去查询指定字段是否存在，会需要用到     <code>exists</code> 这个属性，并且内部指定字段必须是 <code>field</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player/player/_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;filter&quot;:&#123;           # 若查询不存在字段的数据，则是用 must_not</span><br><span class="line">                &quot;exists&quot;:&#123;</span><br><span class="line">                    &quot;field&quot;: &quot;age&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看分析器分析结果"><a href="#查看分析器分析结果" class="headerlink" title="查看分析器分析结果"></a>查看分析器分析结果</h3><p>​    在 get 方法后面，直接使用     <code>_analyze</code>，并通过 <code>analyze</code> 字段指明分词方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;汉密尔顿有限公司&quot;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;汉密尔顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;汉&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 1,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;密尔顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;密&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 2,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;尔&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 3,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 3,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;有限公司&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 8,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 6</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;有限&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 6,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 7</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;公司&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 6,</span><br><span class="line">      &quot;end_offset&quot;: 8,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 8</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;汉密尔顿有限公司&quot;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;汉密尔顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;有限公司&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 8,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    “ik_max_word” 会尽可能多的去将字符串拆开得到分词后的结果，”ik_smart” 则相比在结果数量上要少的多，会尽可能少的去分词不会像 “ik_max_word” 那样拆分的很细</p><h3 id="用-python-去创建"><a href="#用-python-去创建" class="headerlink" title="用 python 去创建"></a>用 python 去创建</h3><p>​    可以使用 <strong>elasticsearch-dsl</strong> 这个库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> DocType, Date, Integer, Keyword, Text, analyzer, Completion</span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.connections <span class="keyword">import</span> connections</span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.analysis <span class="keyword">import</span> CustomAnalyzer <span class="keyword">as</span> _CustomAnalyzer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Elasticsearch 连接</span></span><br><span class="line">connections.create_connection(hosts=[<span class="string">&quot;localhost&quot;</span>])    <span class="comment"># 可以连接多个服务器地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleAnalyzer</span>(<span class="title class_ inherited__">_CustomAnalyzer</span>):</span><br><span class="line">    <span class="comment"># Completion 指定分析器会有异常，所以需要手动建立这个类，复写 get_analysis_definition</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_analysis_definition</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ik_analyzer = ArticleAnalyzer(<span class="string">&quot;ik_max_word&quot;</span>, <span class="built_in">filter</span>=[<span class="string">&#x27;lowercase&#x27;</span>])</span><br><span class="line"><span class="comment"># filter 的参数会将字符串进行小写转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleType</span>(<span class="title class_ inherited__">DocType</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义索引字段, 创建mapping映射&quot;&quot;&quot;</span></span><br><span class="line">    suggest = Completion(analyzer=ik_analyzer)</span><br><span class="line">    <span class="comment"># 直接使用 &quot;ik_max_word&quot; 会抛出异常 get_analysis_definition，所以需要自己实现这个方法</span></span><br><span class="line">    artimg_url = Keyword()</span><br><span class="line">    title = Text(analyzer=<span class="string">&quot;ik_max_word&quot;</span>)</span><br><span class="line">    create_date = Date()</span><br><span class="line">    content = Text(analyzer=<span class="string">&quot;ik_max_word&quot;</span>)</span><br><span class="line">    tags = Text(analyzer=<span class="string">&quot;ik_max_word&quot;</span>)</span><br><span class="line">    comment_num = Integer()</span><br><span class="line">    view_num = Integer()</span><br><span class="line">    url = Keyword()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        index = <span class="string">&quot;cnblogs&quot;</span>     <span class="comment"># 定义index名称</span></span><br><span class="line">        doc_type = <span class="string">&quot;article&quot;</span>    <span class="comment"># 定义type名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># article = ArticleType()</span></span><br><span class="line">    <span class="comment"># article.init()</span></span><br><span class="line"></span><br><span class="line">    ArticleType.init()   <span class="comment"># 会初始化并进行 mapping 映射创建索引</span></span><br></pre></td></tr></table></figure><p>​    完成了索引的创建，就可以将内容进行保存，DocType 的对象有一个方法 save 会自动将数据给到 ES</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">es = connections.create_connection(ArticleType._doc_type.using)</span><br><span class="line"><span class="comment"># DocType 的 ._doc_type.using 可以直接建立 ES 连接，注意在 ES7 中 _doc_type 这个属性已经不能使用了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_es</span>(<span class="params">self</span>):</span><br><span class="line">article = ArticleType()</span><br><span class="line">article.artimg_url = self[<span class="string">&quot;artimg_url&quot;</span>][<span class="number">0</span>] <span class="keyword">if</span> self[<span class="string">&quot;artimg_url&quot;</span>] <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">article.title = self[<span class="string">&quot;title&quot;</span>]</span><br><span class="line">article.create_date = self[<span class="string">&quot;create_date&quot;</span>]</span><br><span class="line">article.content = remove_tags(self[<span class="string">&quot;content&quot;</span>])</span><br><span class="line">article.tags = self[<span class="string">&quot;tags&quot;</span>]</span><br><span class="line">article.comment_num = self[<span class="string">&quot;comment_num&quot;</span>]</span><br><span class="line">article.view_num = self[<span class="string">&quot;view_num&quot;</span>]</span><br><span class="line">article.url = self[<span class="string">&quot;url&quot;</span>]</span><br><span class="line"></span><br><span class="line">article.suggest = [&#123;<span class="string">&quot;input&quot;</span>: [], <span class="string">&quot;weight&quot;</span>: <span class="number">2</span>&#125;]   <span class="comment"># 定义搜索建议的输入处理</span></span><br><span class="line">article.suggest = gen_suggests(index=<span class="string">&quot;cnblogs&quot;</span>, info_tuple=((article.title, <span class="number">10</span>), (article.tags, <span class="number">7</span>)))</span><br><span class="line"></span><br><span class="line">article.save()</span><br></pre></td></tr></table></figure><p>​    suggest 的搜索建议，需要接受一个字典或一个数组，并且由两个参数 input 和 weight，input 是分析器返回的分词列表，weight 则是权重的设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT music/song/1?refresh</span><br><span class="line">&#123;</span><br><span class="line">    &quot;suggest&quot;:&#123;</span><br><span class="line">        &quot;input&quot;:[&quot;Nevermind&quot;, &quot;Dive&quot;],</span><br><span class="line">     &quot;weight&quot;:10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">    &quot;suggest&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;input&quot;:&quot;Nevermind&quot;,</span><br><span class="line">            &quot;weight&quot;:10</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;input&quot;:&quot;Dive&quot;,</span><br><span class="line">            &quot;weight&quot;:3</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_suggests</span>(<span class="params">index, info_tuple</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;分析输入字符串生成搜索建议数组&quot;&quot;&quot;</span></span><br><span class="line">    used_words = <span class="built_in">set</span>()     <span class="comment"># 去重，可能在标题和内容都会匹配到的文本，防止覆盖修改权重</span></span><br><span class="line">    suggests = []</span><br><span class="line">    <span class="keyword">for</span> text, weight <span class="keyword">in</span> info_tuple:</span><br><span class="line">        <span class="comment"># 调用es的analyzer的接口对文本进行分词</span></span><br><span class="line">        <span class="keyword">if</span> text:</span><br><span class="line">            words = es.indices.analyze(index=index, analyzer=<span class="string">&quot;ik_max_word&quot;</span>, body=text, params=&#123;<span class="string">&#x27;filter&#x27;</span>: [<span class="string">&#x27;lowercase&#x27;</span>]&#125;)</span><br><span class="line">            analyzed_words = <span class="built_in">set</span>([r[<span class="string">&#x27;token&#x27;</span>] <span class="keyword">for</span> r <span class="keyword">in</span> words[<span class="string">&#x27;tokens&#x27;</span>] <span class="keyword">if</span> <span class="built_in">len</span>(r[<span class="string">&#x27;token&#x27;</span>]) &gt; <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># ES 的 _analyze 分析返回的每个元素中 token 是每一个分词结果</span></span><br><span class="line">            new_words = analyzed_words - used_words</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_words = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> new_words:</span><br><span class="line">            suggests.append(&#123;<span class="string">&quot;input&quot;</span>: <span class="built_in">list</span>(new_words), <span class="string">&quot;weight&quot;</span>: weight&#125;)</span><br><span class="line">    <span class="keyword">return</span> suggests</span><br></pre></td></tr></table></figure><p>​    <strong>注意</strong>：<code>words = es.indices.analyze(index=index, analyzer=&quot;ik_max_word&quot;, body=text, params=&#123;&#39;filter&#39;: [&#39;lowercase&#39;]&#125;)</code> 在 7 版本之后无法使用了，需要改成 <code>es.indices.analyze(index=index, body=&#123;&#39;analyzer&#39;: &quot;ik_max_word&quot;, &#39;text&#39;: text&#125;, params=&#123;&#39;filter&#39; : [&quot;lowercase&quot;]&#125;)</code></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch 基本概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie池</title>
      <link href="/162388192/"/>
      <url>/162388192/</url>
      
        <content type="html"><![CDATA[<h3 id="Cookie-池设计"><a href="#Cookie-池设计" class="headerlink" title="Cookie 池设计"></a>Cookie 池设计</h3><p>​    对于现在基本都是需要用户登录才能访问数据的网站，通过单一的爬虫程序或是分布式爬虫，在根本上都会遇到很多问题</p><p>​    对于要求登录的网站，爬虫程序首先需要解决的就是模拟登录问题，那么通过了模拟登录就需要对登录账号获取的 Cookie 去进行保存和获取</p><p>​    并且使用单个 Cookie 去爬取，依然会面临频率限制，而且这对服务端而言更加容易控制，一旦 Cookie 被标识成爬虫就会导致账号被封，自然就需要考虑多个账号，来对多个 Cookie 进行管理</p><p>​    同时，对于不同网站来说，登录的验证方式也各不相同，例如：滑动验证，点选验证 等等，就这一点而言对于爬虫程序设计模拟登录的代码也不同。然而对于整个爬虫程序而言，真正的目的并不是去登录，而是得到登录的 Cookie 信息，本质依然是为了爬取目标网站的数据，通过实现 Cookie 池，就能将每个 spider 的登录模块从代码中抽离，利用 Cookie 池维护各个网站登录后的 Cookie 信息。这样做可以很大程度上对功能进行解耦，从而 spider 不用面临因为登录代码的问题而导致程序停止，提高了爬虫程序的健壮性</p><p>​    另外，对于开发来说，可能所使用的的语言并不同，依赖也各不一样，同时也可能面临一些依赖包的不维护导致版本的不兼容问题等。从项目中抽离出模拟登录功能，改为从 Cookie 池获取 Cookie 信息，一方面即使使用开发语言或方式不同，都能从同一的接口来获取需要的 Cookie，另一方面也不需要担心依赖问题</p><h3 id="使用-Cookie-池的优点"><a href="#使用-Cookie-池的优点" class="headerlink" title="使用 Cookie 池的优点"></a>使用 Cookie 池的优点</h3><p>​    通过上面的阐述，在爬虫项目里使用 Cookie 池有以下优点：</p><p>​    1）服务分离 —— 针对多语言开发，实现解耦</p><p>​    2）组件分离 —— cookie 信息不用在程序中维护，可以放在 redis 或是 mysql 等里做维护管理</p><p>​    3）抽离模拟登录，实现服务分别各自部署，防止了因为网站的变化导致程序的停止</p><h3 id="简单的实现结构图"><a href="#简单的实现结构图" class="headerlink" title="简单的实现结构图"></a>简单的实现结构图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">             获取 cookie                            &lt;---- 模拟登录服务</span><br><span class="line">爬虫程序 --------------------&gt; Redis（cookie 池） &lt;----&gt;|</span><br><span class="line">                 &lt;---- Cookie 检测服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    利用 redis 做中间件，作为 Cookie 池，用来存储不同网站的登录 cookie 信息</p><p>​    对于 Cookie 池中 cookie 获取则是分别交给两个服务来处理：</p><p>​    <strong>模拟登录服务</strong>，专门处理不同网站的登录逻辑，以及将成功登录的 cookie 信息返回</p><p>​    <strong>cookie 检测服务</strong>，因为对于获取的 cookie 来说，都是具有时效性的，一旦 cookie 失效，爬虫程序就无法通过该 cookie 去获取登录后目标网站的页面。所以对于 cookie 检测和模拟登录来说，两者都是对 cookie 做处理，可以进行绑定。cookie 检测服务通过从 Cookie 池获取 cookie 来检测当前 cookie 信息是否有效，如果无效则触发模拟登录重新获取 cookie，同时对于成功的 cookie 直接放回池中即可</p><p>​    最后，爬虫程序只需要从 redis 的接口中获取 cookie 池的信息，携带上 cookie 去请求目标网站，进行自己的分析和提取功能</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    从结构图中明确了两个功能，模拟登录和 cookie 验证，由于两者正好是一个顺序关系，所以可以将两者合并在一个类，创建一个 CookieServer 项目，并在该项目下创建不同网站的处理类，在这个类中定义两个方法，一是模拟登录，而是 cookie 检测</p><p>​    那么，对于 CookieServer 项目而言，它里面是会包含很多不同网站的处理文件的，但是每一个程序都用共同的两个目的，所以就可以利用接口类或是抽象类，直接先定义好基类，提供必须实现的抽象方法。这样一来不同网站程序就必须实现基类的抽象方法，这样做可以使得每一个程序更加规范</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseService</span>(metaclass=abc.ABCMeta):</span><br><span class="line">    <span class="comment"># 基类的 cookie 检查接口，用于判断 cookie 是否过期，创建类继承此类时，必须实现此方法，否则实例化对象会抛出异常</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_cookie</span>(<span class="params">self, cookie_dict</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基类的登录接口方法，创建类继承此类时，必须实现此 login 方法，否则实例化对象会抛出异常</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    有了基类，那么之前在 scrapy 框架实现的知乎的模拟登录，就需要一些改动，但是类中要去实现抽象方法</p><h4 id="模拟登录和-cookie-检测功能"><a href="#模拟登录和-cookie-检测功能" class="headerlink" title="模拟登录和 cookie 检测功能"></a>模拟登录和 cookie 检测功能</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> mouse <span class="keyword">import</span> move, click</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> YunDaMa <span class="keyword">import</span> getCodeDate    <span class="comment"># 云打码平台，但是已经跑路了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> services.base_service <span class="keyword">import</span> BaseService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZhihuLogin</span>(<span class="title class_ inherited__">BaseService</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理网站的模拟登录&quot;&quot;&quot;</span></span><br><span class="line">    name = <span class="string">&quot;zhihu&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, settings</span>):</span><br><span class="line">        <span class="comment"># 注意这个 0 是因为配置中只有一个账户，当配置多个账户后，可以根据列表长度随机获取</span></span><br><span class="line">        self.user_name = settings.ACCOUNT[self.name][<span class="number">0</span>][<span class="string">&quot;username&quot;</span>]  <span class="comment"># 配置文件的 ACCOUNT 是一个字典，包含不同网站的用户信息，每一个网站对应一个列表，每一个用户的账户和密码使用一个字典，即每一网站是列表嵌字典的结构</span></span><br><span class="line">        self.pass_word = settings.ACCOUNT[self.name][<span class="number">0</span>][<span class="string">&quot;password&quot;</span>]</span><br><span class="line"></span><br><span class="line">        self.ydm_user = settings.YDM_USERNAME</span><br><span class="line">        self.ydm_psw = settings.YDM_PASSWORD</span><br><span class="line"></span><br><span class="line">        chrome_option = ChromeOptions()</span><br><span class="line">        <span class="comment"># 添加参数，屏蔽掉chrome的扩展插件</span></span><br><span class="line">        chrome_option.add_argument(<span class="string">&quot;--disable-extensions&quot;</span>)</span><br><span class="line">        <span class="comment"># 添加测试使用的参数，设置端口</span></span><br><span class="line">        chrome_option.add_experimental_option(<span class="string">&quot;debuggerAddress&quot;</span>, <span class="string">&quot;127.0.0.1:9222&quot;</span>)</span><br><span class="line">        self.browser = webdriver.Chrome(</span><br><span class="line">            executable_path=<span class="string">r&quot;F:\Envs\article_spider\ArticleSpider\ArticleSpider\utils\chromedriver.exe&quot;</span>,</span><br><span class="line">            options=chrome_option)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最大化浏览器窗口，目的是为了方便获取坐标实现输入和点击</span></span><br><span class="line">        self.browser.maximize_window()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查是否登录成功&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.browser.find_element_by_id(<span class="string">&quot;Popover15-toggle&quot;</span>)  <span class="comment"># 这里判断通知样式是否存在，表示登录成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_cookie</span>(<span class="params">self, cookie_dict</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查cookie是否有效&quot;&quot;&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&quot;HOST&quot;</span>: <span class="string">&quot;www.zhihu.com&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://www.zhihu.com/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(</span><br><span class="line">            url=<span class="string">&quot;https://www.zhihu.com/&quot;</span>,</span><br><span class="line">            headers=headers,</span><br><span class="line">            cookies=cookie_dict,</span><br><span class="line">            allow_redirects=<span class="literal">False</span>)   <span class="comment"># allow_redirects 为 False 的目的是为了不让url进行重定向，由此得到状态码判断是否cookie有效</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            <span class="comment"># 使用 cookie 访问首页，如果被302重定向，说明 cookie 无效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果响应状态是200，表示 cookie 是有效的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;首页模拟登录处理&quot;&quot;&quot;</span></span><br><span class="line">        self.browser.get(<span class="string">&quot;https://www.zhihu.com/signin&quot;</span>)</span><br><span class="line">        self.browser.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;SignFlow-tabs&#x27;]//div[2]&quot;</span>).click()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.check_login():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ch_captcha_element = self.browser.find_element_by_class_name(<span class="string">&quot;Captcha-chineseImg&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                ch_captcha_element = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                en_captcha_element = self.browser.find_element_by_class_name(<span class="string">&quot;Captcha-englishImg&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                en_captcha_element = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ch_captcha_element:</span><br><span class="line">                <span class="string">&quot;&quot;&quot;中文倒立文字验证码处理&quot;&quot;&quot;</span></span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(</span><br><span class="line">                    Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(</span><br><span class="line">                    self.user_name)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(self.pass_word)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取得到验证码图片的 x 和 y 的坐标位置</span></span><br><span class="line">                x_relative = ch_captcha_element.location[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">                y_relative = ch_captcha_element.location[<span class="string">&quot;y&quot;</span>]</span><br><span class="line">                <span class="comment"># execute_script 方法执行 js 的语句，这里为了计算出浏览器的页面标签栏和搜索栏的 y 轴的宽度值</span></span><br><span class="line">                self.broswer_navigation_height = self.browser.execute_script(<span class="string">&quot;return window.outerHeight - window.innerHeight&quot;</span>)</span><br><span class="line"></span><br><span class="line">                base64_text = ch_captcha_element.get_attribute(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">                <span class="keyword">import</span> base64</span><br><span class="line">                <span class="comment"># 知乎的图片使用的 base64 和 固定参数 编码后的结果，所以需要先替换没用的文本内容</span></span><br><span class="line">                code = base64_text.replace(<span class="string">&quot;data:image/jpg;base64,&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;%0A&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="comment"># with open(&quot;ch_valid_code.jpeg&quot;, &quot;wb&quot;) as f:</span></span><br><span class="line">                <span class="comment">#     f.write(base64.b64decode(code))</span></span><br><span class="line">                fh = <span class="built_in">open</span>(<span class="string">&quot;ch_valid_code.jpeg&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">                fh.write(base64.b64decode(code))</span><br><span class="line">                fh.close()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">from</span> zheye <span class="keyword">import</span> zheye  <span class="comment"># 导入 zheye 的包，使用它的方法来获取倒立文字的坐标参数</span></span><br><span class="line">                z = zheye()</span><br><span class="line">                positions = z.Recognize(<span class="string">&#x27;ch_valid_code.jpeg&#x27;</span>)</span><br><span class="line">                last_position = []</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(positions) &gt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> positions[<span class="number">0</span>][<span class="number">1</span>] &gt; positions[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                        last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line">                        last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">                        last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">                    firstfront_position = [<span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, <span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">                    secondfront_position = [<span class="built_in">int</span>(last_position[<span class="number">1</span>][<span class="number">0</span>]) / <span class="number">2</span>, <span class="built_in">int</span>(last_position[<span class="number">1</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                    move(x_relative + firstfront_position[<span class="number">0</span>],</span><br><span class="line">                         y_relative + self.broswer_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">                    click()</span><br><span class="line"></span><br><span class="line">                    move(x_relative + secondfront_position[<span class="number">0</span>],</span><br><span class="line">                         y_relative + self.broswer_navigation_height + secondfront_position[<span class="number">1</span>])</span><br><span class="line">                    click()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">                    firstfront_position = [<span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, <span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">                    move(x_relative + firstfront_position[<span class="number">0</span>],</span><br><span class="line">                         y_relative + self.broswer_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">                    click()</span><br><span class="line"></span><br><span class="line">                move(<span class="number">960</span>, <span class="number">645</span>)</span><br><span class="line">                click()</span><br><span class="line">                time.sleep(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> en_captcha_element:</span><br><span class="line">                <span class="keyword">import</span> base64</span><br><span class="line">                base64_text = en_captcha_element.get_attribute(<span class="string">&quot;src&quot;</span>)</span><br><span class="line">                code = base64_text.replace(<span class="string">&quot;data:image/jpg;base64,&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;%0A&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;en_valid_code.jpeg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(base64.b64decode(code))</span><br><span class="line"></span><br><span class="line">                valid_code = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">not</span> valid_code:</span><br><span class="line">                    valid_code = getCodeDate(self.ydm_user, self.ydm_psw, <span class="string">&#x27;./en_valid_code.jpeg&#x27;</span>, <span class="number">1004</span>)</span><br><span class="line">                <span class="comment"># print(valid_code)</span></span><br><span class="line"></span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(</span><br><span class="line">                    Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(</span><br><span class="line">                    self.user_name)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(self.pass_word)</span><br><span class="line"></span><br><span class="line">                self.browser.find_element_by_xpath(</span><br><span class="line">                    <span class="string">&#x27;//*[@id=&quot;root&quot;]/div/main/div/div/div/div[1]/div/form/div[4]/div/div/label/input&#x27;</span>).send_keys(</span><br><span class="line">                    Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                self.browser.find_element_by_xpath(</span><br><span class="line">                    <span class="string">&#x27;//*[@id=&quot;root&quot;]/div/main/div/div/div/div[1]/div/form/div[4]/div/div/label/input&#x27;</span>).send_keys(valid_code)</span><br><span class="line"></span><br><span class="line">                move(<span class="number">960</span>, <span class="number">625</span>)</span><br><span class="line">                click()</span><br><span class="line">                time.sleep(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取cookie方便以后登录使用</span></span><br><span class="line">        COOKIES = self.browser.get_cookies()</span><br><span class="line">        cookies_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> cookie <span class="keyword">in</span> COOKIES:</span><br><span class="line">            cookies_dict[cookie[<span class="string">&#x27;name&#x27;</span>]] = cookie[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cookies_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> settings</span><br><span class="line">    zhihu = ZhihuLogin(settings)</span><br><span class="line">    zhihu.login()</span><br></pre></td></tr></table></figure><p>​    在 ZhihuLogin 这个类中，为了使得配置性更高，所以创建了一个 settings 文件，将该网站的用户名以及密码，包括大码程序的用户名和密码都放在配置文件中，将这些关键信息与逻辑代码进行分离</p><p>​    配置文件中创建了 ACCOUNT 这个字典变量来存储账户信息，字典的每一个 key 指的就是网站类中的 name 属性，通过这种方式可以将不同网站的账户进行分离</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对不同网站的登录账号配置信息</span></span><br><span class="line">ACCOUNT = &#123;</span><br><span class="line">    <span class="string">&quot;zhihu&quot;</span>: [</span><br><span class="line">        &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;xxxxxxxxxx&quot;</span>,</span><br><span class="line">         <span class="string">&quot;password&quot;</span>: <span class="string">&quot;xxxxxxxxx&quot;</span>,</span><br><span class="line">         <span class="string">&quot;cookie_key&quot;</span>: <span class="string">&quot;zhihu:cookies&quot;</span>,</span><br><span class="line">         <span class="string">&quot;max_cookie_num&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;bili&quot;</span>: [</span><br><span class="line">        &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;xxxxxxxxxx&quot;</span>,</span><br><span class="line">         <span class="string">&quot;password&quot;</span>: <span class="string">&quot;xxxxxxxxx&quot;</span>,</span><br><span class="line">         <span class="string">&quot;cookie_key&quot;</span>: <span class="string">&quot;bili:cookies&quot;</span>,</span><br><span class="line">         <span class="string">&quot;max_cookie_num&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里的 cookie_key 是用作 redis 中存储时使用的 key，而 max_cookie_num 表示是该网站设置的 Cookie 池最大数，因为当前只有一个账户，所以这个字段是直接放置在账户的字典中</p><p>​    通过以上的代码，可以实现具体的一个网站的模拟登录以及 cookie 校验的功能，但是对于一个服务而言，还并不算完成，需要创建一个 server 的程序，其目的是让每一个网站可以单独执行这两项功能</p><h4 id="Cookie-池服务"><a href="#Cookie-池服务" class="headerlink" title="Cookie 池服务"></a>Cookie 池服务</h4><p>​    可是如何才能使用一个程序来让每一个网站能够单独执行各自的处理？可以参考 scrapy 和 django 的中间件，scrapy 中只需要在 settings 中将需要的中间件配置到文件中，scrapy 的数据流在执行时就会进入到每一个启动的中间件内，去触发执行各自的操作</p><p>​    所以，同样可以在 server 这个程序内，去创建一个列表，而这个列表所要存储的，其实就和 scrapy 中间件一样，存储一个类。对于不同的网站来说，本质上都是继承了基类实现了 login 的模拟登录和 check_cookie 校验有效性两个方法，因此只需要将网站的类注册到 server 类的列表中去，这样 server 类可以通过自己的方法，从列表取出类，实例化后去调用他们自己的方法做处理就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial   <span class="comment"># 将带参数的函数转变为一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CookieServer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;检测cookie是否有效&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, settings</span>):</span><br><span class="line">        self.settings = settings</span><br><span class="line">        self.redis_cli = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.service_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self, cls</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;通过注册不同的类，来让各网站单独运行自己的处理功能&quot;&quot;&quot;</span></span><br><span class="line">        self.service_list.append(cls)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login_service</span>(<span class="params">self, srv</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;执行网站的登录功能，获取得到cookie并加入到redis中&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            srv_cli = srv(self.settings)</span><br><span class="line">            srv_name = srv_cli.name</span><br><span class="line">            count_cookie = self.redis_cli.scard(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">&quot;cookie_key&quot;</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断cookie池中的数量，小于配置的数值，则加入cookie池</span></span><br><span class="line">            <span class="keyword">if</span> count_cookie &lt; self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">&quot;max_cookie_num&quot;</span>]:</span><br><span class="line">                cookie_dict = srv_cli.login()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;本次获取得到cookie是：<span class="subst">&#123;cookie_dict&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 使用json将cookie序列化成字符串放入到redis的set中</span></span><br><span class="line">                self.redis_cli.sadd(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">&quot;cookie_key&quot;</span>], json.dumps(cookie_dict))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;cookie池已满&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_cookie_service</span>(<span class="params">self, srv</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查登录的cookie是否可用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            srv_cli = srv(self.settings)</span><br><span class="line">            srv_name = srv_cli.name</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从redis里拿出所有的cookie</span></span><br><span class="line">            all_cookies = self.redis_cli.smembers(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">&quot;cookie_key&quot;</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> cookie_str <span class="keyword">in</span> all_cookies:</span><br><span class="line">                cookie_dict = json.loads(cookie_str)</span><br><span class="line">                valid = srv_cli.check_cookie(cookie_dict)</span><br><span class="line">                <span class="keyword">if</span> valid:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;cookie 有效&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;cookie 已失效&quot;</span>)</span><br><span class="line">                    self.redis_cli.srem(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">&quot;cookie_key&quot;</span>], cookie_dict)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置一个延迟时间，防止因循环频繁对cookie进行校验导致可能的失效，或者被后台检测视为爬虫</span></span><br><span class="line">            time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用线程池来启动服务&quot;&quot;&quot;</span></span><br><span class="line">        task_list = []</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;启动模拟登录服务&quot;</span>)</span><br><span class="line">        <span class="comment"># ThreadPoolExecutor 线程池默认值就是开启5个线程</span></span><br><span class="line">        login_executor = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> self.service_list:</span><br><span class="line">            <span class="comment"># submit 将任务进行提交，参数是线程要执行的函数的名字</span></span><br><span class="line">            task = login_executor.submit(partial(self.login_service, srv))</span><br><span class="line">            task_list.append(task)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;启动cookie登录检测服务&quot;</span>)</span><br><span class="line">        cookie_check_executor = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> self.service_list:</span><br><span class="line">            task = cookie_check_executor.submit(partial(self.check_cookie_service, srv))</span><br><span class="line">            task_list.append(task)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> as_completed(task_list):</span><br><span class="line">            <span class="built_in">print</span>(task.result())</span><br></pre></td></tr></table></figure><p>​    这里在 CookieServer 类中创建了 start 方法，用于启动该服务，具体逻辑是分别开启 5 个线程的线程池，通过遍历注册到 service_list，通过 ThreadPoolExecutor 对象的 submit 方法，将得到类传给 login_service 方法去执行，以及传给 check_cookie_service 方法进行检测</p><p>​    而对于 login_service 和 check_cookie_service 这两个方法，login_service 目的是做模拟登录，在网站类中的 login 方法会去检查 cookie 是否可用，如果不可用则应该是执行模拟登录，所以 login_service 是一个 while 的死循环，但是内部需要去判断 cookie 池中的 cookie 数量，一旦达到了设置的最大数就不要再去执行登录逻辑获取 cookie，从而去根据 cookie 池的情况适当去进行获取，最终将 cookie 序列化放到 redis 中</p><p>​    check_cookie_service 方法就相对简单一些，从 redis 获取 cookie，执行网站类的 check_cookie 去判断 cookie 是否有效，但是有一点依然需要注意，网站类的 check_cookie 是利用 requests 的 get 发起请求来判断，所以每一次判断中间应该有一个间隔，不然仍旧可能会被网站检测到账户的频繁请求而标识为爬虫</p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>​    有了 CookieServer 的 start 方法，启动就非常方便了，可以直接新建一个程序，将网站的类注册到里面，再去调用 start 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> server <span class="keyword">import</span> CookieServer</span><br><span class="line"><span class="keyword">from</span> services.zhihu <span class="keyword">import</span> ZhihuLogin</span><br><span class="line"></span><br><span class="line">srv = CookieServer(settings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册需要登录的服务</span></span><br><span class="line">srv.register(ZhihuLogin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动cookie池服务</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;启动cookie池服务&quot;</span>)</span><br><span class="line">srv.start()</span><br></pre></td></tr></table></figure><h3 id="改进优化"><a href="#改进优化" class="headerlink" title="改进优化"></a>改进优化</h3><p>​    对于 Cookie 池来说，现在所有网站的 cookie 信息都保存在了 redis 中，都是通过 redis 接口来获取到数据信息。但是对于一个服务而言，更加方便的是通过请求方式，通过搭建一个网站服务，利用网站 API 请求数据来获取，这样一来对于存储服务器 redis 来说，端口，账户，数据库信息就不会对外直接暴露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">爬虫 --------&gt; django/flask 服务 --------&gt; redis(Cookie池)</span><br></pre></td></tr></table></figure><p>​    另外，CookieServer 中是利用了多线程来分别管理模拟登录和检测功能的，但是这一块都是受限制的，并不能一直频繁地去执行，所以这一部分的功能可以通过管理中间件去实现。例如通过 linux 的 crontab 去编写定时脚本，进行自动执行。也可以利用 celery 去管理，通过发送定时任务交给执行单元自己获取执行</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> Cookie池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 基本命令和配置</title>
      <link href="/645115729/"/>
      <url>/645115729/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    Redis 支持五种数据类型：<strong>string（字符串）</strong>，<strong>hash（哈希）</strong>，l<strong>ist（列表）</strong>，<strong>set（集合）</strong>及 <strong>zset (sorted set：有序集合)</strong> </p><p>​    其中， string 类型是二进制安全的，所以在 redis 中 string 可以存储任何类型，比如序列化对象或是图片二进制字节，且 string 最大能存储 512M</p><p>​    redis 中默认所有的命令都是大写，但是小写也没有问题，且 redis 默认使用的索引为 0 的库，如果要切换库，在终端内通过命令 <code>select 1</code>，表示切换到索引为 1 的库</p><p>​    查看当前库下，所有的 key，可以使用 <code>keys *</code>在，这里的 * 是一个正则格式</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>​    <strong><em>注意，string 类型设置时，普通值是不用自己加双引号的，但是如果值中间有空格，还是需要自己加上双引号</em></strong></p><p>​    设置指定 key 的值：<code>set key value</code>，设置多个 key-value 可用：<code>mset key value [key value]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set str luziyu</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set str lu ziyu</span><br><span class="line">(error) ERR syntax error</span><br></pre></td></tr></table></figure><p>​    获取指定 key 的值：<code>get key</code>，设置多个 key-value 可用：<code>mget key [key]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;luziyu&quot;</span><br></pre></td></tr></table></figure><p>​    获取 key 中子字符串（类似切片操作）：<code>getrang key start end</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETRANGE str 1 3</span><br><span class="line">&quot;uzi&quot;</span><br></pre></td></tr></table></figure><p>​    <strong>将指定 key 的值修改成 value：<code>getset key value</code>，getset 就是先 get 的修改前的值并返回，再用 set 修改这个值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETSET str ziyu</span><br><span class="line">&quot;luziyu&quot;</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;ziyu&quot;</span><br></pre></td></tr></table></figure><p>​    <strong><em>如果指定的 key 不存在，则会创建这个 key，结果就和使用 set 一样</em></strong></p><p>​    如果 key 不存在，设置 key：<code>setnx key value</code>，如果 key 存在，则不做 value 更新操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;luziyu&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETNX str alexham</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;luziyu&quot;</span><br></pre></td></tr></table></figure><p>​    对 key 的值，递增 +1：<code>incr key</code>，<em>前提是这个 key 的值可以转为数字，比如字符串的 1，如果这个 key 没有设置，则会创建这个 key 并赋值为 1</em>，如果是要按照指定的数值做自增使用 <code>incrby key num</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCR str</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; INCR str</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure><p>​    对 key 的值，递减 -1：<code>decr key</code></p><p>​    对指定 key 的值，减去给定的量：<code>decrby key decrement</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCR str</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; DECRBY str 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure><p>​    <strong>设置一个 key 的失效，超时后会自动删除：<code>setex key seconds value</code></strong></p><p>​    获取 key 的 长度：<code>strlen key</code></p><p>​    删除 key：<code>del key</code></p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>​    是一个字符串名字 key 包含 filed 和 value 的映射表，其中每一个 hash 都可以存储 2³² - 1 个键值对，大约 40 多亿</p><p>​    在哈希表 key 中设置一对键值对：<code>hset key field value</code>，如果要设置多对键值对，使用 <code>hmset</code></p><p>​    获取哈希表 key 中的指定字段值：<code>hget key field</code>，获取多个字段使用 <code>hmget</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET hash f1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGET hash f1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; HmSET hash f2 v2 f3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET hash f1 f2 f3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br></pre></td></tr></table></figure><p>​    获取哈希表 key 里的所有 value：<code>hvals key</code>，获取所有的 field 和 value 使用 <code>hgetall key</code>，获取所有 filed 使用 <code>hkeys key</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;f2&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;f3&quot;</span><br><span class="line">6) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS hash</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;f2&quot;</span><br><span class="line">3) &quot;f3&quot;</span><br></pre></td></tr></table></figure><p>​    <strong>判断哈希表 key 的指定 field 是否存在：<code>hexists key field</code>，返回 0 或 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS hash f2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS hash f4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>​    获取整个哈希表的长度：<code>hlen key</code></p><p>​    判断 field 是否存在，不存在则设置该字段的 value：<code>hsetnx key field value</code>，同样如果存在，则不会更新</p><p>​    指定 field 的 value 增加指定的数值：<code>hincrby key field increment</code></p><p>​    删除哈希表 key 中指定 field：<code>hdel key field</code>，可以指定多个字段，这样会一起进行删除，当哈希表中没有数据时，会返回一个为空结果，且这个表会被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL hash f4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS hash</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;f2&quot;</span><br><span class="line">3) &quot;f3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HDEL hash f1 f2 f3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>​    是一个简单的字符串列表，但是允许在列表的两端进行操作，一个列表同样可以 2³² - 1 个元素</p><p>​    在列表 key 左端插入指定元素：<code>lpush key value</code>，放入多个元素，则是依次后面添加，使用空格隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH li 1 2 3 4</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><p>​    从列表 key 左端将元素移除：<code>lpop key</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lPOP li</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; lPOP li</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>​    同理，也可以在列表 key 的右端进行元素的添加和移除，分别是 <code>rpush</code> 和 <code>rpop</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPUSH li 8 9</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; RPOP li</span><br><span class="line">&quot;9&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP li</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure><p>​    <strong>获取列表 key 中指定范围内的所有元素，即使元素长度不满足范围，也不会出现错误：<code>lrange key start end</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE li 0 10</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LLEN li</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>​    <strong>通过索引获取列表 key 中的元素：<code>lindex key index</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LINDEX li 1</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><p>​    通过索引来设置列表中的元素：<code>lset key index value</code></p><p>​    对列表进行裁剪，只留下索引在指定范围内的所有元素：<code>ltrim key start stop</code></p><p>​    从列表 key 的左端移除移除第一个元素，如果没有元素则阻塞住列表，同时等待超时时间，超时就结束，或者在超时时间内列表出现元素，则将该元素从左端移除：<code>blpop key1 [key2] timout</code></p><p>​    同理，从列表 key 的右端移除元素，也可设置超时：<code>brpop key1 [key2] timout</code></p><p>​    <strong>给已存在的列表末尾添加元素：<code>rpushx key value</code>，如要要在头部则是 <code>lpushx</code>，且如果列表不存在不会进行创建和元素的添加操作</strong></p><p>​    <strong>对于 list 类型来说，如果为空，并不会删除，所以如果要删除创建的列表，通过使用 <code>del key</code></strong> </p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>​    redis 的 set 是一个 string 类型的 <strong>无序集合</strong>，其实也是通过 hash 表实现的，即添加，删除，查找都是 O(1)，同样可存储 2³² - 1 个元素</p><p>​    向一个集合添加一个或多个元素：<code>sadd key member1 [member2]</code></p><p>​    获取一个集合中的所有元素：<code>smembers key</code></p><p>​    获取一个集合的元素个数：<code>scard key</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set one two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SCARD set</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br></pre></td></tr></table></figure><p>​    <em>因为这里是添加了三个元素，所以看不出是无序，可以再增加几个元素，就可以明显看出是无序的</em></p><p>​    判断一个元素是否在集合中：<code>sismember key member</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SISMEMBER set four</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER set three</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>​    从集合中随机 <strong>移除并返回</strong> 一个或多个元素：<code>spop key [count]</code>，如果不给参数 count，则默认从集合中随机移除一个元素并返回，给出 count 就从里面移除 count 个元素。如果要移除所有，count 可以大于 scard 统计的总个数，如果集合为空，则会删除这个集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop set</span><br><span class="line">&quot;seven&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop set 2</span><br><span class="line">1) &quot;eight&quot;</span><br><span class="line">2) &quot;nine&quot;</span><br></pre></td></tr></table></figure><p>​    从集合中 <strong>随机获取</strong> 一个或多个元素：<code>srandmember key [count]</code>，和上面的 spop 类似，但是并不会将元素从集合中删除</p><p>​    从集合中 <strong>直接移除</strong> 一个或多个元素：<code>srem key member1 [member2]</code></p><p>​    返回两个集合的 <strong>交集（即共有部分）</strong>：<code>sinter key1 [key2]</code> </p><p>​    返回两个集合的 <strong>并集（即两个集合所有元素，重复元素只出现一次）</strong>：<code>sunion key1 [key2]</code></p><p>​    返回两个集合的 <strong>差集</strong>：<code>sdiff key1 [key2]</code> ，返回结果是 key1 - key2，如果是 <code>sdiff key2 [key1]</code> 就是 key2 - key1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SINTER set set2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;six&quot;</span><br><span class="line">3) &quot;four&quot;</span><br><span class="line">4) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION set set2</span><br><span class="line"> 1) &quot;ten&quot;</span><br><span class="line"> 2) &quot;eight&quot;</span><br><span class="line"> 3) &quot;three&quot;</span><br><span class="line"> 4) &quot;one&quot;</span><br><span class="line"> 5) &quot;four&quot;</span><br><span class="line"> 6) &quot;seven&quot;</span><br><span class="line"> 7) &quot;two&quot;</span><br><span class="line"> 8) &quot;six&quot;</span><br><span class="line"> 9) &quot;zero&quot;</span><br><span class="line">10) &quot;five&quot;</span><br><span class="line">11) &quot;nine&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF set set2</span><br><span class="line">1) &quot;ten&quot;</span><br><span class="line">2) &quot;eight&quot;</span><br><span class="line">3) &quot;seven&quot;</span><br><span class="line">4) &quot;three&quot;</span><br><span class="line">5) &quot;five&quot;</span><br><span class="line">6) &quot;nine&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF set2 set</span><br><span class="line">1) &quot;zero&quot;</span><br></pre></td></tr></table></figure><h4 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h4><p>​    有序集合基本和 set 是一致的，不同的是除了元素是有顺序之外，每一个元素都会 <strong>关联一个 double 类型的分数，并通过这个设置的分数来进行从小到大排序</strong></p><p>​    向有序数组中添加元素，注意元素前面需要加上分数：<code>zadd key score1 member1 [score2 member2]</code>，如果元素存在则会更新设置的 score</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD zset 10 one 20 two 30 three 40 four 50 five</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p>​    返回有序数组中指定元素所设置的分数：<code>zscore key member</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE zset one</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE zset two</span><br><span class="line">&quot;20&quot;</span><br></pre></td></tr></table></figure><p>​    通过索引(从 0 开始)，返回指定范围内的有序元素：<code>zrange key start stop</code>，如果要获取某一个元素的索引，可以使用 <code>zrank key member</code>，如果需要从大到小排序则是使用 <code>zrevrange key start stop</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE zset 2 4</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;four&quot;</span><br><span class="line">3) &quot;five&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANK zset four</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>​    除了索引获取元素，还可以通过设置的分数，去获取指定范围内的元素：<code>zrangebyscore key min max</code>，同样如果要将结果从大到小排序，使用 <code>zrevrangebyscore key min max</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE zset 20 40</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">3) &quot;four&quot;</span><br></pre></td></tr></table></figure><p>​    给指定的元素的分数增加指定的值：<code>zincrby key incrme member</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY zset 60 five</span><br><span class="line">&quot;110&quot;</span><br></pre></td></tr></table></figure><p>​    从有序数组从移除一个或多个元素：<code>zrem key member [member]</code></p><p>​    从有序数组中通过指定分数范围移除一个或多个元素：<code>zremrangebyscore key min max</code></p><h3 id="redis-的配置"><a href="#redis-的配置" class="headerlink" title="redis 的配置"></a>redis 的配置</h3><p>​    安装好 redis 后，在 redis 的文件夹下会有一个 opt 文件夹，其中包含一个文件 redis.conf，这就是 redis 默认的配置文件，通常情况下不会对这个初始默认配置文件去修改，而是将和这个文件拷贝一份，放在 etc 目录的 redis 文件夹下去做配置</p><p>​    INCLUDES 配置项的目的主要是，如果 redis 是多人的开发和维护，那么会需要存在多个 redis.conf 的文件，那么在该配置中就需要使用 include 来设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br></pre></td></tr></table></figure><p>​    GENERAL 配置项中会包含一些 redis 服务默认的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">daemonize  no</span><br><span class="line"><span class="comment"># daemonize 设为 yes 表示将 redis 作为守护进程在后台启动，默认是 no</span></span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"><span class="comment"># pidfile 是当 redis 作为守护进程运行时，将 pid 进程 id 记录到指定文件中</span></span><br><span class="line"></span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"><span class="comment"># port 用来设置 redis 服务在哪个端口上运行</span></span><br><span class="line"></span><br><span class="line">loglevel notice</span><br><span class="line"><span class="comment"># loglevel 用来配置 redis 服务记录的日志级别：</span></span><br><span class="line"><span class="comment"># debug，会记录大量日志信息，适用于开发和测试环境</span></span><br><span class="line"><span class="comment"># verbose，会记录较多的信息，但不会像 debug 那样混乱</span></span><br><span class="line"><span class="comment"># notice，比较详细的日志信息，适用于生产环境</span></span><br><span class="line"><span class="comment"># warning，会记录重要的错误型信息</span></span><br><span class="line"></span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># logfile 配置 redis 的 log 日志文件的地址，默认是空字符，就是将信息全部在终端上显示</span></span><br><span class="line"></span><br><span class="line">databases <span class="number">16</span></span><br><span class="line"><span class="comment"># 设置 redis 上数据库的数量，默认是 16 个数据库，redis 的客户端连接默认使用的是 0 库</span></span><br></pre></td></tr></table></figure><p>​    SNAPSHOTTING 配置项是用来对 redis 持久化进行配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># redis 默认使用的 rdb 的持久化方式，rdb 持久化的触发是根据配置参数来决定</span></span><br><span class="line"><span class="comment"># save 900 1 表示 900 秒（15分钟）内，有 1 个 key 被改变，就触发 save 进行持久化</span></span><br><span class="line"><span class="comment"># save 300 10 表示 300 秒（5分钟）内，有 10 个 key 发生变化，就触发 save</span></span><br><span class="line"><span class="comment"># save 60 10000 表示 60 秒内，有 10000 个 key 发生变化，就触发 save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># save 的手动触发，是命令行输入 save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># save &quot;&quot;</span></span><br><span class="line"><span class="comment"># 如果只使用 redis 做数据缓存，不需要持久化，可以将 save 的值给一个空字符</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="comment"># stop-writes-on-bgsave-error 字面意思就是说在 bgsave 持久化失败时，redis 将拒绝写操作。这样做的目的是让用户能够知道 redis 持久化出现异常，好及时处理</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># rdbcompression 表示对 rdb 的文件是否进行压缩，来减少占用的磁盘空间</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment"># rdbchecksum 表示对 rdb 的数据进行校验，但是这样做大概会增加 10% 的性能损耗</span></span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># dbfilename 就是 rdb 生成的数据文件的文件名，默认就是 dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"><span class="comment"># dir 表示 rdb 快照文件的存储位置，dir 的参数必须是一个目录</span></span><br></pre></td></tr></table></figure><p>​    REPLICATION 主要是配置主从同步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data  yes</span><br><span class="line"><span class="comment"># slave-server-stale-data 配置为 yes，表示如果主从在同步时连接被断开，从库依然可以接受客户端的读请求，但是返回的数据就是同步前的数据，或者是空数据，因为主从同步没有完成</span></span><br><span class="line"><span class="comment"># 如果配置为 no，从库只能执行 info 和 saveof 两个命令，其余的命令都会返回 &quot;SYNC with master in progress&quot; 的错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个从库要隶属于主库，需要命令行输入  slaveof &lt;master-ip&gt; &lt;master-port&gt;</span></span><br><span class="line"></span><br><span class="line">slave-read-only yes</span><br><span class="line"><span class="comment"># slave-read-only 表示从库只接收客户端的读操作，也就是说从库 redis 只能返回数据，不能写入，默认是 yes</span></span><br><span class="line"></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"><span class="comment"># repl-diskless-sync 表示主从同步 rdb 时，不是将 rdb 保存在磁盘上，而是直接通过网络将 rdb 文件发送，适用于磁盘性能较差，但是网络较好的环境，默认是不开启的，也就是说还是会将 rdb 放在磁盘上，再去同步</span></span><br><span class="line"></span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br><span class="line"><span class="comment"># 如果使用了 无磁盘的 同步，那么需要设置一个 repl-diskless-sync-delay 同步的延迟时间，目的是为了尽可能在延迟的时间内，为尽可能多的从库去发送 rdb 文件</span></span><br></pre></td></tr></table></figure><p>​    APPEND ONLY MODE 配置项是用来设置 aof 持久化的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">appendonly no</span><br><span class="line"><span class="comment"># appendonly 默认是 no，也就是默认不开启 aof 持久化</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># appendfilename 是 aof 持久化的文件名，后缀是 .aof</span></span><br><span class="line"></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync 是 aof 持久化的策略，有三种方式</span></span><br><span class="line"><span class="comment"># always，表示命令写入 aof-buffer 后，立即通过 fsync 做同步，将命令写入到 aof 的文件中</span></span><br><span class="line">    <span class="comment"># everysec，表示每一秒中，执行一次 fsync 来同步</span></span><br><span class="line">    <span class="comment"># no，表示不使用 redis 的 fsync 同步，将 aof 的控制交给系统来操作</span></span><br><span class="line">    </span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="comment"># no-appendfsync-no-rewrite 表示当时 aof 触发 重写机制，并且 aof 使用的又是 alway 或 everysec 的策略下，两个磁盘的写操作在数据量很大的情况下会造成磁盘 IO 压力过大，或是出现阻塞。如果配置为 no，则表示在重写机制操作时，aof 的策略是 no，也就说放弃 aof 的快速持久，把磁盘操作权都分给重写机制，这样的方式会造成数据出现部分丢失，因为 no 方式下，虽然性能损耗最低，但是 aof-buffer 的命令不能快速写到 aof 文件，就会导致丢失</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="comment"># 重写机制的触发条件之一，当重写机制的 aof 文件比上次体积增长达到 100% 就触发一次重写</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-<span class="built_in">min</span>-size 64mb</span><br><span class="line"><span class="comment"># 重写机制的触发条件之二，重写机制最小的大小是 64m，一旦超过就会触发新的重写</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis 整理 </category>
          
          <category> 数据类型和使用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-整理-二</title>
      <link href="/3927654560/"/>
      <url>/3927654560/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL设计架构"><a href="#MySQL设计架构" class="headerlink" title="MySQL设计架构"></a>MySQL设计架构</h2><p>文章内容来自林晓斌的《MYSQL实战45讲》和个人的整理</p><p>​    大体上来说，可以将 MySQL 框架分成两部分：<strong>server 层 和 存储引擎层</strong></p><p>​    <strong>Server 层</strong> 包括 <strong>连接器、查询缓存、分析器、优化器、执行器</strong> 等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</p><p>​    <strong>存储引擎层</strong> 负责数据的存储和提取操作，其架构模式是 <strong>插件式</strong> 的，支持如 <strong>InnoDB、MyISAM、Memory 等</strong>多个存储引擎，MySQL 从 5.5.5 的版本后默认以 InnoDB 为默认引擎，也可以在使用 sql 语法 create table 的语句中通过 engine 来指定不同的存储引擎</p><p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="image"></p><h3 id="查询语句的执行"><a href="#查询语句的执行" class="headerlink" title="查询语句的执行"></a>查询语句的执行</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>​    这是一条 sql 语句处理的第一步，因为 MySQL 是 C/S 架构，意味着通过 client 端 来操作 server 端 ，所以首先需要的就是连接到数据库，<strong>连接器负责的就是服务端和客户端的连接建立，获取权限，维持和管理连接</strong>，连接的命令一般写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>​    首先，在客户端和服务端完成 TCP连接 后，连接器就开始对输入的用户名进行认证。如果认证失败，则会返回 <code>&quot;Access denied for user&quot;</code> 的错误</p><p>​    如果认证成功，连接器将会到权限表中查询用户拥有的权限，并且在此之后的权限判断，都是依赖于此次连接读取的权限。这意味着在使用 root 修改当前登录用户的权限后，是不会影响当前的权限的，只有该用户退出后，再次创建连接登录后才会是用新的权限</p><p>​    同时，在连接之后没有后续动作，当前的连接会处于空闲状态，可以使用命令 <code>&quot;show processlist&quot;</code> 查看连接状态，”Command” 列显示 “Sleep” 都表示连接为空闲中</p><p>​    如果长时间依然没有操作，连接器会释放当前的连接，默认的时间是 8 小时，通过参数 wait_timeout 可以更改设置，一旦连接被断开，再去发送指令就会返回 “Lost connection to MySQL server during query”，要求重新建立连接</p><p>​    最后，有一点需要注意的是一般连接数据库时都是使用长连接，这会导致 MySQL 的内存使用很高，是因为在操作数据库时会优先从临时内存中进行操作，而这些都由连接对象进行管理，资源只有在长连接断开后才会进行释放，所以会导致内存占用过高</p><p>​    长连接的两个方法可以进行优化：</p><p>​    1、定期断开长连接，使用了一段时间后，判断内存使用情况，从而进行断开，并在再次查询时连接</p><p>​    2、MySQL 5.7 以上的版本中，可以通过执行 <code>mysql_reset_connection</code> 来初始化连接资源，释放占用的空间</p><h4 id="查询缓存（8-0的版本开始没有此功能）"><a href="#查询缓存（8-0的版本开始没有此功能）" class="headerlink" title="查询缓存（8.0的版本开始没有此功能）"></a>查询缓存（8.0的版本开始没有此功能）</h4><p>​    当连接建立完成后，就要开始对 sql 语句进行操作了，在此执行查询的操作后，会优先在查询缓存中查看，是否该 sql 在历史记录中</p><p>​    1、在查询缓存中，表示缓存命中，则将缓存中的结果返回</p><p>​    2、不在查询缓存中，则将该语句交给下一阶段，完成后续操作，且在得到结果后，该结果会被加入到查询缓存中</p><p>​    查询缓存虽看似有提高效率，但实则非常容易失效，<strong>只要对一个表进行了更新，会将缓存的查询全部清空，这使得对于频繁更新数据的服务来说，查询缓存的命中率非常低</strong></p><p>​    因此，MySQL 提供了一个命令可以让 sql 语句不使用查询缓存，<code>query_cache_type</code> 参数设置为 <code>DEMAND</code> 即可，那对于确定需要使用查询缓存的语句，则可以通过 SQL_CACHE 来显式的指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><h4 id="分析器（做什么）"><a href="#分析器（做什么）" class="headerlink" title="分析器（做什么）"></a>分析器（做什么）</h4><p>​    这一个阶段才算是真正开始处理 sql 语句，<strong>分析器会对语句做单词分析，判断出关键字，以及将字符串识别为表或是表中的列</strong></p><p>​    完成识别后，进行语法分析，判断语句是否符合 MySQL 的语法规则，如果发生错误会将错误进行显示，并会告知一个 “use near” 来表示可能出现问题的语句所在位置</p><h4 id="优化器（怎么做）"><a href="#优化器（怎么做）" class="headerlink" title="优化器（怎么做）"></a>优化器（怎么做）</h4><p>​    语句通过分析器后，进入优化器。在该阶段，<strong>优化器会决定例如使用什么索引，关联的顺序等等</strong></p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>​    完成前两个阶段，语句就需要开始执行操作了，但在开始之前，会进行判断是否有权限，如果没有对应的操作权限，会抛出错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure><p>​    如果有权限，再调用引擎的接口进行操作，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=17;</span><br></pre></td></tr></table></figure><p>​    1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 17，如果不是则跳过，如果是则将这行存在结果集中</p><p>​    2、 调用引擎接口取 “下一行”，重复相同的判断逻辑，直到取到这个表的最后一行</p><p>​    3、 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</p><p>​    补充，在数据库的 <code>explain</code> 慢查询日志中会有一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行，这个字段的值是在执行器每次调用引擎获取数据行的时候累加的。但是在有些场景下，<strong>执行器调用一次，可能在引擎内部则扫描了多行</strong>，因此 <strong>引擎扫描行数跟 <code>rows_examined</code> 并不是完全相同的</strong></p><h3 id="更新语句的执行"><a href="#更新语句的执行" class="headerlink" title="更新语句的执行"></a>更新语句的执行</h3><p>​    与查询语句一样，更新操作在 server 层 的流程是相同的</p><p>​    1、连接器去连接数据库</p><p>​    2、由于查询缓存对于更新的操作会将之前的缓存记录清空，所以一般不使用查询缓存</p><p>​    3、分析器通过词法和语法对语句分析，判断是更新的语句操作</p><p>​    4、优化器决定使用什么索引</p><p>​    5、完成上述步骤，就是执行器，找到具体的数据进行更新操作</p><p>​    <em>注意：更新的流程还不止如此，还会经历两个重要的日志模块，分别是：*</em>redo log（重做日志）<strong>和 **binlog（归档日志）</strong>，需要知道的是 <strong>redo log 是 InnoDB 引擎特有的*</strong></p><h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h4><p>​    redo log 的目的就是为了提高效率，因为每一条更新的操作都需要查询到具体的那一行数据，再对其做修改更新，这其中的 IO 成本，查找成本都很高</p><p>​    为了提升更新操作的效率，使用了 <strong>WAL技术（write-ahead logging），指先写日志，再写磁盘</strong>，redo log 主要记录的是数据做了什么改动，并在磁盘上写入，且是顺序写入，而对于更新操作要先在磁盘上寻址再去更新，但这是一个随机寻址过程，要比顺序写入日志的方式慢</p><p>​    也就是说当执行更新时， InnoDB 引擎会先把记录写入 redo log，同时将对应的记录加载到内存并进行更新，此时其实更新就算完成了，之后 <strong>引擎会在空闲时，将日志中的记录再进行写入到磁盘中</strong></p><p>​    redo log 并不会记录数据页的完整数据，所以 redo log 自己并没有能力去更新磁盘的数据页，当一个数据页被修改后，内存会将自己的数据页写入，来覆盖磁盘上的旧数据</p><p><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt="img"></p><p>​    <strong>通常 redo log 日志是有限制的</strong>，如图这里分了 4 个文件做日志存储，write pos 是当前记录的位置，每一次写入日志就会向后移动。check point 是要擦除的位置，同样会跟随操作往后移动，在擦除之前会将记录更新到数据文件</p><p>​    一旦最后 write pos 和 check point 重合，也就说明没有剩余的空间在进行日志的记录，check point 就会往后擦除一部分日志。不过一般情况下都不会出现这种情况，因为后台的线程会定期做刷脏页</p><p>​    redo log 使得 InnoDB 即使遇到异常重启，依然可以保证在之前提交的记录不会丢失，这个能力称为 <strong>crash-safe</strong></p><p>​    <strong>补充：</strong>一个事务中多次实现更新，那么日志就是多次写入，但是 <strong>如果事务还没有 commit 的时候，这些日志记录不会真正被写入进 redo log 文件中（文件名是 ib_logfile + 数字），而是先将内存中的数据进行更新，并在 redo log buffer 中先写入日志</strong> </p><h4 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h4><p>​    redo log 是 InnoDB 引擎层的日志模块，而 binlog 则是位于 server 层的日志模块。在最开始的 MySQL 中由于没有 InnoDB 提供 crash-safe 的支持，binlog 只能用于归档</p><p>​    <strong>redo log 和 binlog 的区别：</strong></p><p>​    1、<strong>redo log 是 InnoDB 特有；binlog 由于是 server 层</strong>，对于所有引擎都可用</p><p>​    2、<strong>redo log 是物理日志</strong>，记录的是 “在某个数据页上做什么修改”；<strong>binlog 是逻辑日志</strong>，记录的是语句的原始逻辑，<strong>有两种格式：statement 和 row，statement 记录执行的 sql 语句，row 会记录更新前后的两种内容</strong></p><p>​    3、<strong>redo log 是循环写入</strong>，空间会有使用完的情况； <strong>binlog 是可以追加写入的</strong>，就是写入的数据到了一定大小后会切换到下一个文件，而不是覆盖以前的日志记录</p><h4 id="更新的完整流程"><a href="#更新的完整流程" class="headerlink" title="更新的完整流程"></a>更新的完整流程</h4><p><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"> </p><p>​    深色部分是 执行器 的操作，浅色部分是 InnoDB 执行的操作</p><p>​    1、执行器通过引擎找到指定的数据，并判断数据所在的数据页是否存在内存中，存在就返回给执行器，不在就从磁盘读到内存中后再返回</p><p>​    2、执行器在获取到引擎返回的数据页中找到行数据，将对应字段的值进行修改，得到一行新的数据，再调用引擎接口写入这行数据</p><p>​    3、引擎接着将这行数据在内存的数据页里进行更新，同时将操作记录写入到 redo log 中，此时 redo log 的状态处于 prepare，然后告知执行器操作执行完成，随时可以进行事务提交</p><p>​    4、执行器生成这个操作的 binlog ，并写入到磁盘文件中</p><p>​    5、执行器调用引擎的提交事务的接口，把 redo log 的状态改为 commit，最后整个更新操作完成</p><p>​    所以，<strong>redo log 的写入有两个状态：prepare 和 commit，也就是 “两阶段提交”，这样做的目的是为了让两份日志的逻辑保持一致</strong></p><p>​    因为，如果事务在 redo log 完成 prepare 后，就出现异常，而此时 binlog 还没有写入，那么该事务会进行回滚，因为事务最后没有 commit，用 redo log 回滚后依然和 binlog 恢复的结果是一致的</p><p>​    redo log 和 binlog 之间都会包含数据行 ID，使得两者能够关联，如果 redo log 完成 prepare ，且 binlog 也进行了记录，但是事务最后在 commit 时出现错误，虽然没有 commit 但是 redo log 和 binlog 中记录是完整的，恢复后会自动进行 commit 将事务提交，这样前后结果依然是一致</p><p>​    对于 binlog 的完整判断，statement 格式下的 binlog 日志最后会有 COMMIT；而 row 格式下，最后则是一个 XID event</p><p>​    同时，5.6.2 之后的 MySQL 中引入了 <code>binlog-checksum</code> 参数对 binlog 进行校验</p><p>​    <strong>补充：</strong></p><p>​    如果 MySQL 要更新一行的某一个值，但是该值和原来的值相同，MySQL 是否会执行修改？还是看到值相同就直接返回？</p><p>​    一般情况下，当去更新一个值与原值一样的情况下，执行后的返回信息会看到 <code>&quot;Rows matched：1 Changed：0 Warnings：0&quot;</code>，从信息上看没有做修改的操作，但并不能代表更新不会执行修改或是覆盖</p><p>​    1）是否判断语句相同，就直接返回？</p><p><img src="https://static001.geekbang.org/resource/image/6d/90/6d9d8837560d01b57d252c470157ea90.png" alt="img"> </p><p>​    这里例子，假设有一样数据就是 (1,2) ，并启用了两个会话，会话A 首先执行更新的语句，但是并不提交，同时 会话B 也要去更新并且值相同，但从图中可以看到 会话B 是被阻塞了，因为 <strong>会话A 中的事务执行更新时，InnoDB 给加上了 行锁 来确保一致性，由此可见即使更新操作的值一样，语句依然是会执行的</strong></p><p>​    2）调用更新接口，判断值一样，不做操作，直接返回？</p><p><img src="https://static001.geekbang.org/resource/image/44/96/441682b64a3f5dd50f35b12ca4b87c96.png" alt="img">     </p><p>​    同样这个例子，会话A 一开始执行一个查询，然后 会话B 执行更新操作，将值从 2 改为 3，然后自动提交。在 会话A 中，也执行更新操作，修改值与 会话B 的一致，返回的信息中显示没有做修改，但是内部还是得到了 (1, 3) ，<strong>由于事务一致性视图的规则，会话A 最后执行的查询语句得到返回结果其实是自己事务执行更新的数据版本</strong>，这个返回结果并不来自与 会话B 的修改</p><p>​    <strong>所以更新的语句中，操作是一定会执行的，该修改就修改，该加锁就加锁</strong></p><p>​    3）MySQL 自己就不能判断值一样，就不执行更新吗？</p><p><img src="https://static001.geekbang.org/resource/image/63/c1/63dd6df32dacdb827d256e5acb9837c1.png" alt="img"> </p><p>​    从图中可以看出，其实 MySQL 是会进行一个 “判断” 的，这里的 会话A 更新的语句附加了一个 “a=3”，从而使得 会话A 的更新 id 和 a 时，发现要修改的的是 “set a=3”，也就是说 <strong>where 的条件和 update set 的值一样时，则不会去执行这个更新操作，最后由于一致性视图就读到的是 (1, 2)</strong></p><p>​    <strong>注意：上面的结果都是 binlog_format = statement 的格式</strong></p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>​    两阶段提交是经典的分布式系统的一个方案，对于 InnoDB 引擎，redo log 提交完成后，事务就不能进行回滚了，否则就会覆盖掉其他事务所提交的操作，而 redo log 仅仅适用于 InnoDB 引擎，对于 MySQL 本身的 binlog 来说其本身并不具备恢复能力，因此在 redo log 完成后，如果 binlog 出现异常失败，那对于 InnoDB 而言就无法去回滚了，这样数据和 binlog 的日志就会不一致</p><p>​    所以 redo log 的两种状态 prepare 和 commit 实际上留出一个缓冲时间，让 binlog 进行记录。对于两个状态中任何一方出现问题，都能进行回滚或是判断 binlog 去完成恢复时提交，这样一来可以确保异常后的恢复可以使得数据保持一致，即数据要么是异常前的状态，要么则是事务提交后的状态</p><p>​    对于 binlog 来说，并不是两阶段提交中完全必不可少的部分，如果关掉 binlog，对于数据库的数据依然可以进行回滚来确保数据一致性</p><p>​    但是 <strong>binlog 的归档可以记录 redo log 会删除的历史记录</strong>，同时 MySQL 系统是依赖 binlog 的，是 MySQL 实现高可用的基础，比如主从同步</p><p>​    MySQL 正常的更新不会用 redo log 去刷磁盘的数据，更新的内容会记录在内存中然后去进行刷盘写入，但是对于异常崩溃时，InnoDB 会判断数据页是否丢失，并恢复时读取到内存然后利用 redo log 来实现数据更新，注意这一切依旧是在内存中更新</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​    InnoDB 引擎的一个特点就是支持事务，因此事务支持是在引擎层实现的。所谓事务其目的是为了保证一组数据库操作，要么全部成功，或者全部失败，如果某一个操作出现异常即为操作失败，这一系列的操作会进行回滚，将数据复原会操作之前的样子</p><h4 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h4><p>​    <strong>事务的四个隔离性（ACID）</strong>分别是：<strong>原子性（A），一致性（C），隔离性（I），持久性（D）</strong></p><p>​    <strong>原子性：</strong>即上述中的事务的结果只有两种状态，成功与失败，失败就执行回滚</p><p>​    <strong>一致性：</strong>事务完成后，与执行前的完整性和字段约束不会被破坏</p><p>​    <strong>隔离性：</strong>其目的是为了确保在并发的环境下事务操作之间是彼此独立的。SQL 标准的事务隔离又分为四种：<strong>读未提交（read uncommitted），读提交（read committed），可重复读（repeatable read），串行化（serializable）</strong></p><p>​        <strong>读未提交：</strong>一个事务还没提交时，它所作的变更会被其他事务看到，这就是 <strong>“脏读”</strong></p><p>​        <strong>读提交：</strong>一个事务只有在提交之后，所作的变更才会被其他事务看到，这样 <strong>导致数据是”不可重复读”</strong> 的，因为一个事务如果多次查询会得到不同结果，这也是因为在并发中有其他的事务对被查询的数据做了修改，而该隔离等级只能读到最后的结果值</p><p>​        <strong>可重复读：</strong>一个事务执行过程中看到的数据，总是与它在启动时看到的数据是一致的，对于未提交的变更同样对其他事务是不可见的。<strong>可重复读禁止了不可重复读和脏读的发生，但也会有问题发生即 “幻读”</strong></p><p>​        <strong>串行化：</strong>其实就是为事务的执行添加了加锁和释放锁的过程，使得事务的执行必须要先获取锁得到执行权限，其他的事务只能处于等待</p><p>​    <strong>持久性：</strong>表示事务一旦提交后，其产生的结果是永久性的，即使数据库发生故障，也能进行恢复</p><h4 id="事务隔离的视图"><a href="#事务隔离的视图" class="headerlink" title="事务隔离的视图"></a>事务隔离的视图</h4><p>​    在执行时，数据库内部会创建一个视图（一致性视图），具体访问得到的返回结果是以视图的逻辑结果为准</p><p>​    <strong>可重复读：视图是在事务启动时创建，整个事务存在期间都使用这个视图</strong></p><p>​    <strong>读提交：视图是在每个 SQL 语句执行时创建</strong></p><p>​    <strong>读未提交：</strong>与上述两个不同，该级别下其实并 <strong>不使用到视图</strong>，直接将记录的最新值进行返回</p><p>​    <strong>串行化：直接使用加锁来做到隔离避免并行访问</strong></p><p>​    不同的隔离级别都是有其存在意义的，因为每个隔离级别对数据库行为会有不同的影响，所以根据业务来选择隔离级别很重要。<strong>Oracle 数据库中使用的默认隔离级别是 “读提交”，MySQL 使用的则是 “可重复读”</strong>，所以对于 Oracle 迁移到 MySQL 的应用，就需要保证隔离的级别一致，所以需要将 MySQL 设置为”读提交”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别</span><br><span class="line">show variables like &#x27;transaction_isolation&#x27;</span><br><span class="line"></span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.08 sec)</span><br><span class="line"></span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name         | Value          |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>​    在 RR 级别下，查询按照一致性视图，都是快照读，但是如果事务中使用了当前读，且读到了一致性视图之外的查询数据，就称为幻读，也就是说前后两次查询同一范围的时候，前后两次的结果不一致，后一次查询看到了前一次查询没有的结果</p><p>​    幻读的影响，首先就是破话了 MySQL 的语义，假设 事务A 查询了一行记录，并使用了 <code>for update</code> 给这样记录加了写锁，但是 会话B 却没有受到影响，依然执行了更新语句，会话C 同样如此</p><p><img src="https://static001.geekbang.org/resource/image/7a/07/7a9ffa90ac3cc78db6a51ff9b9075607.png?wh=940*545" alt="img"></p><p>​    这里 Q2 的查询可以读到 会话B 更新后的结果，因为这里是 <code>for update</code> 用了当前读，也就是说 会话A 对字段 d 值为 5 的记录加上的写锁被破坏了</p><p>​    其次，就是一致性的问题，加锁是为了保持一致性同步，但是假设 会话A 在查询后，使用了更新语句，对 d=5 的记录更新，会话A 的T1 相当于是表明，自己要对 d=5 加锁，目的是为了做更新。那么 会话A 的三个结果分别是 (5,5,100)，(0,5,5)，[(1,5,5)，(5,5,100)，(0,5,5)]，其中 id=5 的结果是在事务提交后才产生的</p><p><img src="https://static001.geekbang.org/resource/image/dc/92/dcea7845ff0bdbee2622bf3c67d31d92.png?wh=937*568" alt="img"></p><p>​    这三个会话执行上没有什么问题，但是对于 binlog 来说就不同了，由于 会话A 的事务是最后提交的，也就是说 会话A 的 <code>update t set d=100 where id=5</code> 会被最后写入到日志里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br><span class="line"></span><br><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br></pre></td></tr></table></figure><p>​    此时，如果用这个 binlog 去到备库执行，或克隆一个库，再去按照 会话A 去查询，那么结果就变成了 (0,5,100)、(1,5,100) 和 (5,5,100)，很显然这里数据就产生了不一致，id=0 和 id=1 的结果都产生错误，这是因为只是假设对 d=5 的记录加了行锁</p><p>​    如果是将扫描匹配的每一个记录都加上行锁呢？</p><p>​    <img src="https://static001.geekbang.org/resource/image/34/47/34ad6478281709da833856084a1e3447.png?wh=935*598" alt="img"></p><p>​    那么对于 会话B 来说就会被阻塞，要等到 会话A 提交后才能执行，而对于 会话C 来说，这个插入语句依然正常执行</p><p>​    那最后对于 binlog 来说，依然会有不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br><span class="line"></span><br><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br></pre></td></tr></table></figure><p>​    可见，虽然 id=0 的记录是正常了，但是 id=1 的记录，最后结果还是 (1,5,100)，也就是说给所有记录加上行锁，并不能解决插入新数据导致的幻读</p><p>​    所以，InnoDB 引入了 Gap lock（间隙锁），顾名思义就是对索引的间隙范围加上锁，并且间隙锁之间并不互斥，只有往间隙锁的范围中间插入数据时，才会产生冲突。间隙锁和行锁合称为 next-key lock，每一个  next-key lock 范围都是前开后闭区间</p><p>​    但是间隙锁依然也存在问题，就是会导致死锁，因为事务执行时，加上间隙锁后，只允许自己在间隙范围内去加锁，如果这个间隙被其他事务同样加了间隙锁，那个事务也同样想要插入数据，那么就出现了相互等待对方释放间隙锁，这时 InnoDB 就会检测到死锁，后一个想要插入数据的事务的插入语句就会返回错误</p><p>​    <strong>注意，间隙锁只有 RR 隔离级别下才会有，RC 级别则没有，所以如果使用的是 RC 级别，想要解决一致性问题，就需要把 binlog 格式改为 row</strong></p><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>​    在 MySQL 中，<strong>每条记录在更新时都会同时记录一条回滚操作（更新语句的逆过程）到 undo log，出现异常就会通过执行回滚操作来回到上一个状态的值</strong></p><p>​    以 “可重复读” 为例，在查询时就会启动事务，在不同的时间启动的事务会有不同 read-view，例如某一条的数据要进行值的修改，那么就会存在记录这个值修改操作的多个回滚版本，也就是数据库的多版本并发控制（MVCC），且各个视图中的回滚互相不会冲突</p><p><img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" alt="img"> </p><p>​    当回滚的日志越来越多时，数据库通常会判断当没有事务需要用到这个 回滚日志(undo log) 的情况下，会将一些回滚日志删除，也就是在系统中没有比当前回滚日志更早的 read-view 时会进行删除操作，比如 read-view A 没有事务使用，且比 read-view A 更早的回滚日志已经不存在，那么这个 read-view A 就会被删除</p><h4 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h4><p>​    长事务意味着系统中会有很久之前的事务视图，而这些事务里可能随时会去访问数据库获取数据，那么在执行的事务进行提交前，数据库就需要将可能用到的回滚记录进行保留，这会非常占用系统的存储空间，并且由于长事务的问题，<strong>容易造成大量阻塞和锁冲突的情况发生</strong></p><p>​    在 5.5 以前的版本中，回滚的日志记录是与数据字典一起存储在 ibdata 文件中，那么即使长事务最后提交了，回滚阶段被清理，文件的使用空间也不会减小，物理空间不会减小，只是日志的记录可以重写</p><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><p>​    MySQL的启动方式有两种：</p><p>​    1. 显式启动事务语句，<strong>begin 或 start transaction</strong>（<strong>这两个命令并不是事务的起点，在执行到它们之后的第一个操作表的语句，事务才是真正的启动，如果要立刻启动一个事务，可以使用 start transaction with consistent snapshot</strong>）<strong>，一般情况下一致性视图是在执行第一个快照读语句的时候才创建，立即启动事务的一致性视图则是随着语句执行创建；提交语句 commit；回滚语句 rollback</strong></p><p>​    2.   <strong>当设置<code>set autocommit = 0</code>，就不会进行自动提交</strong>，意味着只执行一个 select 语句时，事务就启动了，并且不会自动提交。除非主动进行 commit 或是 rollback 语句，又或者是将连接断开</p><p>​    第二种方式显然会引起长事务的产生，只不过在每个事务的开始不需要主动执行一次 begin</p><p>​    在 <strong>InnoDB 中默认是自动提交事务</strong>，也就是每执行一条语句，都会被自动地提交生效，这样的弊端就是大量的数据插入时，会导致每一次插入都需要发一个请求去执行，这样非常影响效率</p><p>​    而关闭自动提交，显式地使用 begin 可以将语句放在一个事务里进行提交，但是如果大量的语句执行并且未提交也会产生长事务的问题</p><p>​    <strong>为了避免长事务可以通过 set autocommit = 1 ，但使用 begin 来显示启动事务，用 commit 来提交</strong>，也可以使用 commit work and chain 这个语法，该语法会将当前事务进行提交并自动启动下一个事务，这样也就省去了下一次启动的 begin 语句，并且这样做可以很明确的知道语法是否处于事务中</p><h4 id="长事务的查询"><a href="#长事务的查询" class="headerlink" title="长事务的查询"></a>长事务的查询</h4><p>​    长事务的结果存储在 information_schema 库中的 <code>innodb_trx</code> 表里，可以通过查询这个表来得到长事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询时长超过 <span class="number">60</span>s 的事务</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><p>​    所以对于长事务的问题，也可以通过监控这个 <code>innodb_trx</code> 表里的事务来判断，将过长事务进行提交执行</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>​    索引的目的就是为了提高数据的查询速度，就像书本的目录一样，通过建立索引可以高效的定位一条数据的位置</p><h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>​    对于索引的实现有很多方式，因为能用于提高读写效率的数据结构有很多，<strong>常见的有 哈希表，有序数组 和 搜索树</strong></p><h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><p>​    哈希表是一种以键值（key-value）的存储结构，通过输入的 key 来查找对应的 value 值，哈希的思路也很简单，将值存储在一个数组中，通过哈希函数把键 key 换算成一个确定的位置，在将 value 放在数组的那个位置上</p><p>​    使用哈希的一个问题就是，<strong>多个 key 值可能在经过 hash 换算后，得到的结果值是相同的情况，也就是 hash 冲突</strong>，一个处理方法就是使用一个链表来存储相同 hash 的 key 对应的 value，也还有其他方法，比如二次哈希等</p><p><img src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" alt="img"> </p><p>​    比如图中的 user4 和 user2 他们的 key 是 id_card_n4 和 id_card_n2 在 hash 后得到位置都是 N，就是用一个链表存储，当要查询 user2 的时候，首先是将 id_card_n2 这个 key 哈希得到 N，然后按照顺序遍历，找到 user2</p><p>​    图中的 4 个 id_card 并不是递增的，这样的好处是如果新增一个 user 时，速度会很快，只需要进行追加即可；但问题是，因为 key 不是有序排列的，所以在使用这样的 hash索引 做区间查询的情况下速度就很慢，一旦是 <strong>查区间，就需要对所有的索引进行一次扫描</strong></p><p>​    因此，hash 表这样的数据结构适用于以查询为主的业务场景，一些 NoSQL 引擎就是使用这样的结构</p><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>​    有序数组在等值查询和范围查询的场景下性能更好，比如 id_card 的 索引 是按递增来排序的，那么每一新 user 插入，使用的 id_card 只需要在上一个的基础递增再追加到最后即可，查找时使用二分法就能快速的查询到结果，查询的时间复杂度是 O(logN)</p><p><img src="https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png" alt="img"> </p><p>​    就单从查询效率来说，有序数组是较好的数据结构，但是如果是要做更新的操作的时候，问题就来，当要在这个数组中间插入一个新数据，需要将该数据的之后的所有数据都要向后移动一位，数据量越大带来的成本就越高</p><p>​    所以，<strong>有序数组只适用于静态存储引擎</strong>，对于那些要保存的数据时不会修改的情况下使用有序数组是最好的方式</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>​    二叉搜索树也是非常经典的数据结构之一，特点就是使用节点来关联节点，由两个子节点关联一个父节点，左节点的值小于父节点，右节点的值大于父节点，二叉搜索树的查询的时间复杂度也是 O(logN)，前提是这个树是一个 <strong>平衡二叉树（AVL树），即左右两边的节点树高度差要 &lt;= 1</strong></p><p><img src="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" alt="img"> </p><p>​    二叉树是搜索效率最高的，但在实际使用的数据库中使用的并不是二叉树，因为索引不只是存在内存中，还需要写入到磁盘上，如果一个树有 20 层，意味着查询一个数据可能需要进行 20 个数据块的访问，机械硬盘时代从磁盘读一个数据块需要 10ms 左右的寻址时间，也就说此时需要 20 个 10ms 的时间</p><p>​    而且数据量越大，伴随的就是树的层级增多，因此使用二叉树存储大体量的数据需要访问的节点（磁盘）就会越多，而且二叉树结构查找时，每一次指针查找很大概率是触发随机磁盘读取</p><p>​    那么为了减少对数据磁盘的读取，就需要使用 <strong>‘N叉树’（B树，B+树）</strong>，而这个 N 取决于数据块的大小，以 InnoDB 的一个 bigint 字段索引为例，这个 N 为 16*1024/(8+6)≈1200（一个节点 16k，bigint 索引 8b，每个索引指针 6b），假设树高是 4，那么就可以存储 1200³ 大约 17 亿条的数据</p><p>​    在 <strong>InnoDB 中 b+树 的每一个叶子节点存储的是页</strong>，默认每一页是 16k，指针的大小是 6b，大部分情况下根节点的数据块会放在内存中，第二层的节点也有可能放在内存里，所以使用 b+树 的查询最多也就需要访问 3 次磁盘</p><h4 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h4><p>​    在 InnoDB 中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表，因为 InnoDB 使用了 b+树 索引模型，所以数据都是存储在 b+树 中，每一个索引在 InnoDB 里也就对应一棵 b+树</p><p>​    假设，现在有一张表，主键为 id，以及字段 k 和 name，并且给 k 设置索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k)</span><br><span class="line">)engin<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>​    往表中加入 5 条数据，得到两棵树，类型分别是：<strong>主键索引 *<em>和 *</em>非主键索引</strong></p><p>​    <strong>主键索引 中叶子节点存放整行数据，主键索引 也被叫做 聚簇索引</strong>，一张表只能有一个主键索引</p><p>​    <strong>非主键索引，也被叫做 二级索引 或 非聚簇索引，在叶子节点中会存放主键的值，依次指向对应的主键</strong>，一张表允许多个非主键索引</p><p><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img"> </p><p>​    如果查询语句使用 <code>where id=500</code>，就会按照主键进行查询，只需要搜索 id 这棵 b+树</p><p>​    如果查询语句使用 <code>where k=5</code>，就是用普通索引查询，会先搜索 k 这棵 b+树，查询得到 id 的值是 500 后，在使用 id 索引树搜索，这个过程称为 <strong>回表</strong>，也就是说基于非主键的索引查询会需要多扫描一棵索引树，因此在应用中尽量使用主键索引进行查询</p><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>​    b+树 为了维护索引的有序性，在插入新的数据后需要做必要的维护，上图中如果插入新数据的行 id 是 800，那只需要在 R5 那行后面插入这条新记录，如果 id 的值是 400，就需要挪动后面的数据，将位置空出</p><h5 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h5><p>​    相比起挪动数据，更加麻烦的是如果 R5 所在的数据页已经满了，根据 b+树 的算法，就需要申请一个新的数据页，然后再挪动部分数据过去。这个过程称为 <strong>页分裂</strong>，这种情况下，性能自然会受影响，除此之外还会影响数据页的利用率，比如原本在一个数据页中的数据，被分到两个页中，整体空间利用率就降低了大约 50%，范围查询就不得不查两个数据页</p><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>​    当相邻两个页由于数据的删除，利用率很低之后，会将数据页做一个合并</p><h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><p>​    在建表时， 使用 <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code> ，那么这个就符合自增主键，新记录在插入的时候可以不用指定 id 的值，系统会获取当前 id 最大的值进行 +1 作为下一条记录的 id 值</p><p>​    自增主键的插入数据方式，都是以追加进行，不会涉及到挪动其他的记录，也就 <strong>不会触发叶子节点的分裂</strong></p><p>​    另外，<strong>索引的优化除了考虑性能之外，也需要考虑存储空间</strong>，如果一张表中有一个唯一字段，比如像身份证号这样的信息，如果用来做主键，会导致其他非主键的索引的叶子节点都存储了主键的值，这样一来每一个二级索引的叶子节点会占用约 20 个字节，如果使用整型自增就会省去一部分空间的占用</p><p>​    所以，<strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong> </p><p>​    相对于某些情况下，比如一张表就有一个字段是要求唯一的，并且不会建立其他的字段索引，那么使用主键索引就会是更好的选择。因为如果还是使用自增主键做索引，在查询时就必定需要查找两棵树，会涉及到一个回表搜索的过程，效率上就低了</p><h4 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h4><p>​    <strong>对于操作频繁的表，可能会删除一些非常旧的数据，数据虽然被删除，但是 mysql 中的 数据文件 和 索引文件 大小并不会改变，也就是说 mysql 并不会将删除的内容所占的空间进行回收，而是直接将新的数据使用这个位置</strong></p><p>​    由此，删除了数据之后，需要对表进行优化，通过执行 <code>optimize table ad_visit_history;</code>，另外由于索引删除，或者页分裂，会导致数据页中有空洞，这就需要重建索引，创建新的索引来将数据顺序插入，使得索引更加紧凑，更省空间</p><p>​    如果要重建一个索引，可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> index k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> index(k);</span><br></pre></td></tr></table></figure><p>​    不过重建索引时，最好不要将普通索引的重建与主键索引重建放在一起，因为这样做会导致整表进行重建，那么对于先前普通索引的重建就白费了，因此可以使用 <code>alter table T engine=InnoDB</code> 来替换两个索引的重建</p><h3 id="索引执行"><a href="#索引执行" class="headerlink" title="索引执行"></a>索引执行</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">index k(k))</span><br><span class="line">engine<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img">     </p><p>​    在上述的表中，给字段 k 加了普通索引，并插入了 6 条记录，由此可以得到上图两个搜索树，并执行下面的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>​    对此，这条语句的执行流程是：</p><p>​    1）在 k 的索引树上先找 k = 3 的这条记录，通过索引得到对应对应的主键 id = 300</p><p>​    2）由 id = 300 ，去主键索引树中查询对应的数据行是 R3</p><p>​    3） 依次往下，在 k 索引树上找到 k = 5，得到 id = 500</p><p>​    4） 回到主键的 id 索引树，得到 id 为 500 的对应的行 R4</p><p>​    5） 在 k 索引树取下一个值 k = 6，不满足条件，结束循环</p><p>​    上面的过程中，这条 SQL 执行中从 k 索引树中读取了 3 条记录，并且回表了两次</p><p>​    <strong>注意：回表并不是必须的，取决于查询的非主键索引中是否有包含需要查询的字段，且回表操作是影响查询效率的</strong></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>​    依旧是上面的 SQL，但是稍加改动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>​    将查询的字段改为只查找 ID 的值，此时 ID 的值已经在 k 的索引树上了，所以执行后可以直接得到查询结果，因此并没有回表，即索引 k ‘覆盖了’ 查询的需求，就称为覆盖索引</p><p>​    简单来说，当查询的字段在普通索引上，就能够使用覆盖索引，避免回表</p><p>​    <strong>覆盖索引可以减少对索引树的搜索查询，提升查询性能，所以覆盖索引是一个常用的性能优化手段</strong></p><p>​    在引擎内部使用覆盖索引在 k 的索引树上是读取了 3 条记录，也就是索引 k 上的 3，5，6 记录项，但是对于 MySQL 的 server 层来说，引擎拿到的只有 2 条记录，所以 MySQL 认为扫描的行数是 2</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>​    比如现在有一张居民信息表，存有身份证号，姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tuser` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `id_card` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure><p>​    这张表中给 id_card 加上了非主键索引，给 name，age 使用了联合索引，通常意义下对于单个的查询，使用 id_card 索引就可以满足查找具体的个人信息</p><p>​    但是如果有一个高频需求，只是利用身份证号查询名字和年龄，如果只使用 id_card 这一个索引就必定要回表，此时 <strong>id_card 与 name 的联合索引就使用覆盖索引的功能，不再回表查询整行记录</strong>，也就减少了语句的执行时间；同时需要注意的是索引字段的维护总归是有代价的，需要根据场景来建立相对来说是冗余的索引去支持覆盖索引</p><h4 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h4><p>​    <strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong></p><p>​    例如上面的例子中的（name,age）这个联合索引，假如现在索引项是按照索引定义里出现的字段顺序排序如图</p><p><img src="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img"> </p><p>​    此时，去针对性查找 ‘张三’ 名字的记录，可以快速定位到 ID4 的位置并向后遍历；如果使用的是模糊查询 <code>like &quot;张%&quot;</code> 的话，同样能使用这个索引，只要当条件是满足了联合索引的最左前缀，就能利用索引起到加速检索的作用</p><p>​    所以在联合索引中，索引内的字段顺序的第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。比如已经建立了（a，b）这样一个联合索引通过最左前缀支持，就可以不需要单独再去在字段 a 上建立索引了</p><p>​    可是如果当查询条件只有 b 的语句，联合索引就无法使用了，这个时候就不得不维护两个索引</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>​    现在又有了一个新的需求，不仅要查名字是张开头，还对年龄和性别有了限制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    那么按照索引最左前缀的规则，这个语句在索引搜索树中只能用到 “张”，去找到满足条件的记录 ID3，在此之后就只能一个个判断其他条件是否满足</p><p>​    在 5.6 之前的版本，得到 ID3 之后就只能一个个进行回表操作，到主键索引上拿到数据行，然后对比条件</p><p><img src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="img"> </p><p>​    <strong>在 5.6 之后，出现了 ‘索引下推’ 的优化，可以在索引遍历的过程中，就预先对索引中包含的字段做判断，来过滤不满足条件的记录，这样一来进一步减少了回表的次数</strong></p><p><img src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img"> </p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    MySQL 中锁大致可以分为三类：<strong>全局锁，表级锁，行锁</strong></p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>​    <strong>全局锁 即对整个数据库实例加锁</strong>，MySQL 提供的加全局锁的命令是 <code>Flush tables with read lock(FTWRL)</code>，当需要让 <strong>整个库处于只读状态</strong> 的时候，可以使用这个命令加全局锁，之后的其他线程在执行语句包括：数据的增删改查，建表或修改表结构等或是更新类事务的提交语句时都会被阻塞</p><p>​    <strong>全局锁的经典使用场景就是做全库逻辑备份</strong>，即把整个库每个表都 select 出来存入文本</p><p>​    使用全局锁会导致整个库只读，通常情况下会出现两个问题：</p><p>​    1）如果要主库上做备份，那么在备份期间就不能执行更新的操作，那么业务就基本上相当于停摆</p><p>​    2）如果要在从库上备份，那么在备份期间从库不能执行主库同步过来的 binlog，会导致主从产生延迟</p><p>​    可是如果不加锁去做备份系统，那么备份得到的库则不是一个逻辑时间点，也就是视图的逻辑是不一致的</p><p>​    假设现在需要备份一个课程购买系统的两张表：用户余额表和用户课程表，现在发起一个逻辑备份，假设备份期间，有一个用户购买了一门课程，执行对应业务逻辑，修改余额，添加课程。如果时间备份上的顺序是先备份余额表，等对应业务执行完成后，在执行用户课程备份</p><p><img src="https://static001.geekbang.org/resource/image/cb/cd/cbfd4a0bbb1210792064bcea4e49b0cd.png" alt="img"> </p><p>​    图中可以看到，在最后用户的备份状态中，余额没有扣除，但是在自己的课程列表中却已经有了课程，如果之后用和这个备份去恢复数据，那么用户就会白白得到一门课；相反如果先是备份课程，在业务完成后，再备份余额，可想而知最后用户可能明明扣除了钱却没有得到相应的课程</p><p>​    所以如果不使用全局锁，最后得到的备份结果在视图逻辑上不一致，除了使用 FTWRL 命令外，可重复读的隔离下开启下一个事务，也可以保证得到的视图一致性，<strong>官方自带的逻辑备份工具是 <code>mysqldump</code>，在使用参数 <code>-single-transaction</code> 的时候，在导出数据之前会开启一个事务，来保证视图一致性，且由于 MVCC 多版本并发控制，在此过程中数据是可以正常执行更新操作的</strong></p><p>​    注意：虽然可重复读的隔离级别下使用 <code>-single-transaction</code> 可以做到备份后得到一致性的结果，但是 <strong>前提是使用的引擎是支持这个隔离级别（即需要引擎支持事务）</strong> 的，相比对于 MyISAM 就不支持事务，自然也就只能使用 FTWRL 命令</p><p>​    除此之外，如果要对 <strong>全库设置只读，也可以使用 <code>set global readonly = true</code></strong>，但是如果使用这个命令去实现备份会遇到一下问题：    </p><p>​    1）在有些系统中 <code>readonly</code> 会被用来做其他逻辑，比如用来判断是主库还是从库等，因此用 global 修改变量的方式影响面会更大</p><p>​    2）在异常处理机制上，FTWRL 命令在执行后如果由于客户端发生异常断开，MySQL 会自动释放掉这个全局锁，让整个库恢复到正常更新的状态；但使用 <code>readonly</code> 后，<strong>即使客户端发生问题，数据库依然会保持 <code>readonly</code> 的状态，从而导致整个库都处于不可写状态，造成数据丢失</strong></p><p>​    3）如果在从库上使用 <code>readonly</code>，并且执行用户拥有超级权限的情况下 <code>readonly</code> 是失效的</p><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>​    MySQL 中表级锁有两种类别：<strong>表锁，元数据锁（meta data lock，MDL）</strong></p><p>​    表锁的语法是 <code>lock tables … read/write</code>，与 FTWRL 命令一样，可以使用 <code>unlock tables</code> 来主动释放锁，也可以在客户端断开时自动释放，但是 <code>lock tables</code> 语法除了会限制别的线程的读写操作外，也会对本线程接下来的操作有所限定，在没有更细颗粒度的锁的时候，通常使用表锁来处理并发的方式</p><p>​    对于 InnoDB 这样支持行锁的引擎，一般都不会使用 <code>lock tables</code> 命令去控制并发，因为通过锁住整张表的影响太大</p><p>​    例如 <code>lock tables t1 read, t2 write;</code> 执行这条语句后，其他的线程在写 t1，读写 t2 都会被阻塞住；同时当前的线程在执行 <code>unlock tables</code> 释放之前，当前线程也只能执行读 t1，读写 t2 的操作</p><p>​    <strong>读锁（共享锁）允许其他线程可读，但会阻塞写入；写锁（排它锁）不允许其他线程进行读写</strong></p><p>​    另一类的表级锁是 <strong>MDL，它并不需要显式使用，在访问一个表的时候会被自动的加上，MDL 的作用是保证数据读写的正确性</strong></p><p>​    在 MySQL 5.5 的版本中引入了 MDL，来对一张表进行 <strong>增删改查</strong> 的操作时加上 <strong>MDL读锁</strong> ；而如果对 <strong>表做结构的更改</strong> 操作则会加上 <strong>MDL写锁</strong>，这里的 ‘读锁’ 针对 <strong>DML(数据库操作语言，增删改查的语句)</strong>，’写锁’ 指 <strong>DDL(数据库定义语言，建表、视图、索引等之类的操作语句)</strong></p><p>​    有两点需要注意：</p><p>​    1）<strong>读锁之间并不互斥</strong>，所以允许多个线程来对同一张表做增删改查操作</p><p>​    2）<strong>读写锁之间、写锁之间是互斥的</strong>，目的是保证更改表结构的操作的安全性，如果有两个线程同时对一张表添加字段，那么其中一个就必须等待另一个线程执行完成后才开始执行</p><p>​    所以 <strong>MDL 的目的是为了防止并发情况下 DDL 与 DML 语句的冲突</strong>，例如下图的例子</p><p><img src="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" alt="img"> </p><p>​    这个事务中，session A 最先启动执行，这个时候该表会自动加上 MDL读锁，紧接着 session B 也是同样的语句，也需要使用到 MDL读锁，因此一样正常执行，但执行到 session C 时，由于该语句是更改结构，需要获取 MDL写锁，但是由于前面的事务没有提交，导致开始时 MDL读锁 没有释放，因此 session C 的语句会被 block 阻塞住（读写锁互斥），之后的语句也同样无法执行，这就相当于在 session C 执行后，整个表处于不可读写的状态，如果该表的查询语句频繁，并且客户端有重试机制，在超时后又会发起一个请求，这个库就会爆满</p><p>​    注意，这里 <strong>session D 之所以会被阻塞，是因为 MDL锁 的申请会生成一个队列，队列中 写锁 的优先级要高于 读锁</strong>，因此当 session C 修改结构获取 写锁 后，因为 读写锁 互斥，必须要等待前面的 写锁 进行释放，所以虽然这里 session D 获取的是 读锁，但是因为在队列中 D 在 C 后进入，而表在 C 这就已经锁住了</p><p>​    因此，<strong>事务中一旦开始进行 MDL 锁的申请，即使涉及锁的语句执行结束，也不会立刻释放该锁，必须在事务提交后，才能将锁释放</strong>。所以对于一个已上线的表有需求要做结构的更改，需要注意 MDL锁，可行的方法是可以在 <code>alter</code> 语句上设置等待时间，避免对线上数据写读造成影响，如果超时可以反复重试，或是在低谷期进行修改</p><h5 id="online-DDL"><a href="#online-DDL" class="headerlink" title="online DDL"></a>online DDL</h5><p>​    <strong>online DDL 是 mysql 5.6 版本中引入的，目的是解决锁的 读写互斥 而造成效率问题</strong>。同样在上面的例子中，A 和 B 两个会话被自动 commit 之后，会发现 C 依然在阻塞，而将 D 提交后，C 才能继续执行</p><p>​    online DDL 实际上对 写锁 做一系列操作，大致如下：</p><p>​    <strong>1）当会话中涉及结构修改的 sql 获取到 MDL写锁</strong></p><p>​    <strong>2）该会话将 写锁 进行降级，变为 MDL读锁</strong></p><p>​    <strong>3）执行 sql，完成 DDL</strong>（该步骤是最耗时的部分）</p><p>​    <strong>4）完成后，会重新将锁升级为 MDL写锁</strong></p><p>​    <strong>5）事务提交，来释放 MDL写锁</strong> </p><p>​    这样就可以解释为什么 A 和 B 释放了 读锁 后，C 依然阻塞的问题。因为当 C 获取到 写锁 后，首先确保队列中没有其他 DDL 在执行，然后因为 锁 的降级操作 ，使得 C 中 写锁 变为 读锁，此阶段会处于阻塞状态，而此时 D 的操作则需要等带获取 读锁，且 读读锁 之间不会产生互斥问题，那么 C 还在做自己操作的时候，可以理解为 读锁 已经从 C 转移到了 D 上，由于 D 最后没有 commit 提交，读锁 没有被 D 释放，因此 C 就处在了阻塞中</p><p>​    所以最后，只有 D 事务提交了，C 才能继续做 online DDL 的第 4 步操作直到最后提交</p><p>​    下面的图能够更加明确这个过程：<a href="https://blog.csdn.net/q2878948/article/details/96430129">https://blog.csdn.net/q2878948/article/details/96430129</a></p><p><img src="https://img-blog.csdnimg.cn/2019071820433258.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3EyODc4OTQ4,size_16,color_FFFFFF,t_70" alt="img"> </p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>​    MySQL 中的行锁与上面的 <strong>全局锁 和 表级锁</strong> 不同，后两个 <strong>是在 server 层中实现</strong> 的，<strong>行锁 则是由引擎层自己实现，但并不是所有的引擎都支持行锁</strong>，例如 MyISAM 就不支持，所以并发的控制只能通过表锁实现</p><p>​    行锁即对表中的行记录进行加锁，当 事务A 更新了一行，而 事务B 也需要更新这一行，就需要等待 事务A 提交之后才能执行自己的操作，所以 InnoDB 中的行锁会在需要的时候加上，但并不是不需要了就会自动释放，还是需要等事务结束后才会释放行锁，这就是 <strong>两阶段锁协议</strong>（加锁与解锁阶段）</p><p><img src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" alt="img"> </p><p>​    例如，同时 事务A 执行两条语句的更新，因此这两行都会被加上行锁，此时 事务B 开始执行，发现要更新的行在 事务A 中加上了行锁，所以 事务B 会等待，等到 事务A 提交后，事务结束将行锁释放再去执行</p><p>​    <strong>注意：在并发情况下，如果需要对多行上锁，以及如果对某一行上锁后会导致多个锁冲突，或是操作的数据行相对其他操作更影响并发度时，这些会有行锁的操作应放在事务的靠后位置</strong></p><p>​    比如多个用户短时间给同一个用户转账，对比前两个用户来说，后面接收转账的用户就涉及到自己的余额更新两次记录，也就是说会加两次行锁。如果将接受转账用户的余额更新放在后面，这就减少了这个用户余额的锁时间，并发事务下其他的事务也就减少了锁等待</p><p>​    在 <strong>InnoDB 中行锁默认等待时间是 50s，超时会抛出错误</strong></p><p>​    <strong>补充：InnoDB 的行锁是通过扫描索引来实现的，如果字段没有添加索引，那么即使只是更新一行记录，InnoDB 会将整个表锁住</strong></p><h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>​    行锁同样也会有问题产生，那就是 死锁，在上面的案例中，事务A 和 事务B 中都对某一行数据进行更新导致了 事务B 被阻塞，如果 事务A 中出现了需要等待 事务B 操作后的某一行，或者是 事务B 需要等待事务A 去释放某一行的行锁，这就导致了 <strong>两个线程中的锁都进入了无限等待对方释放的状态，这就是死锁</strong></p><p><img src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" alt="img"> </p><p>​    出现了 <strong>死锁，有两种策略</strong>：</p><p>​    1）<strong>直接进入等待，直到超时</strong>，这个超时时间是可以通过参数进行设置的 <code>innodb_lock_wait_timeout</code></p><p>​    2)  <strong>设置 死锁检测</strong>，当发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。可以将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，来开启死锁检测逻辑，<strong>会去判断自己要加锁的这行记录是否已经有锁，会去遍历一般当前事务，一旦事务链表出现环路就会停止，所以不会扫描所有的事务</strong></p><p>​    <strong>InnoDB 中的 <code>innodb_lock_wait_timeout</code> 默认值是 50s</strong>，也就是说在并发下，出现死锁后，第一个被锁住的线程需要等待 50 秒才会被超时退出，然后其他的线程再继续执行，但是这个等待时间对于在线服务来说几乎不能接受；同时 <strong>这个参数的值也不能设置的过小</strong>，例如 1s，这样一出现死锁，确实可以快速释放掉，但是 <strong>对于一些不是死锁的情况，只是简单的锁等待，就会被误伤</strong></p><p>​    因此，一般还是采用 <strong>死锁检测 的方式</strong>，这种主动的方式能够在死锁被发现后快速进行处理，但这也是有额外负担的，因为每当一个事务执行时被加上锁，就会判断所依赖的线程有没有被其他线程锁住，每加入一个线程就要去循环遍历，<strong>如果是大体量的线程需要对同一行来做更新，这个时间复杂度会是一个 O(n²)，会消耗大量 CPU 资源</strong></p><p>​    如果对于热点的表，在死锁检测方式下，想减少 CPU 消耗，也可通过其他的方法。比如使用中间件，或者是在服务端做并发量的控制，即尽可能在线程进入引擎层操作之前，降低 InnoDB 内部死锁的产生</p><p>​    对于汇总的表，也可以将数据分 n 段，每一次随机选择一条记录做增加，汇总时就对所有分段的值做统计即可，这样 InnoDB 中行锁的冲突就变成了原来的 1/n</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>​    MySQL 中有两个 视图 概念：</p><p>​    1）<strong>常规的 view，就是查询语句定义的一张模拟表，在调用的时候执行查询语句并生成结果</strong>，视图的创建语句是 <code>create view ...</code>，查询方法和表是一样的</p><p>​    2）是 InnoDB 实现 MVCC 时用到的 <strong>‘一致性视图’，即 consistent read view， 用于支持 RC(read committed，读提交) 和 RR(repeatable read，可重复读) 隔离级别的实现</strong></p><p>​    <strong>视图并没有物理结构，它的作用是为了定义事务在执行期间应该读到什么样的数据</strong></p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>​    全称 <strong>Multi-Version Concurrency Control，即多版本并发控制</strong>。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。所以在 <strong>InnoDB 中 MVCC 就是为了提高数据的并发性能，尽可能做到能不加锁就不使用锁，来解决 读 - 写 会发生的冲突</strong></p><p>​    <strong>对于 InnoDB 中的数据读取有两种方式，当前读 和 快照读</strong></p><p>​    <strong>当前读</strong>，即读取到的记录最新版本，要保证读取时不会因为并发造成数据被修改，需要对记录加锁，比如 select … lock in share mode (共享锁)，select … for update；insert ；delete (排他锁) 这些操作，所以 <strong>数据要修改的话，总是当前读，去读到该记录的最新的版本</strong></p><p>​    <strong>快照读</strong>，即 <strong>读取到的数据是事务启动时刻的数据版本，对于 select 的操作就可以是不加锁的非阻塞方式读取，从而避免了很多开销，但是产生的问题就是并发下快照读的数据版本不一定会是最新版本，而是历史版本数据</strong></p><p>​    <strong>MVCC 正是利用了快照读，防止读写操作存在的冲突问题，避免了写操作需要加锁导致阻塞，提高了并发读写性能，并且可以根据多版本控制，解决脏读、幻读、不可重复读等事务隔离问题</strong></p><p>​    <strong>补充：对于 update 操作，并不是原地就直接更新了，该是转为了 insert + delete。delete 的操作也不是说就直接将旧版本数据删除，只是将旧版本数据的 deleted_bit 标记为了删除，之所以不直接删除旧数据，是为了在并发事务下能够通过版本号去回滚到之前的版本</strong></p><p>​    由于 delete 的操作不会直接删除，所以 InnoDB 会在后台开一个 purge 线程来对专门来进行清理 deleted_bit 被标为 true 的记录</p><h4 id="“快照”-在-MVCC-里怎么工作"><a href="#“快照”-在-MVCC-里怎么工作" class="headerlink" title="“快照” 在 MVCC 里怎么工作"></a>“快照” 在 MVCC 里怎么工作</h4><p>​    <strong>可重复读隔离的级别下，事务在启动的时候就相当于”拍了个快照”，这个”快照”是基于整个库的</strong></p><p>​    <strong>InnoDB 中每一个事务会有一个唯一的 事务ID，即 “transaction id”</strong>，由事务开始时向事务系统申请获取，并且申请 <strong>顺序严格递增</strong></p><p>​    而每行的数据又会存在多个版本，每次事务更新数据的时候，会生成一个新的数据版本，transaction id 会被赋值给每一个版本，即 “row trx_id”。同时，旧的数据版本也会保留，且要新的数据版本中能后有信息可以直接取到它。所以在表中的一行数据可能有多个版本 (row)，而每一个 row 又会有一个自己的 row trx_id</p><p><img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" alt="img"> </p><p>​    图中是一行数据被多个事务连续执行后，产生了四个版本，得到的 k 的最新值是 22，执行得到最新值的事务 ID 和最新值行版本的 ID 是一致的，图中从 k=1 到最新值 k=22 中做了三次更新，因此会有 U1，U2，U3 三条更新记录的 undo log（回滚日志）</p><p>​    <strong>注意：V1，V2，V3 并不物理存在，如果要回滚 k=1，需要从 V4 依次根据 当前版本 和 undo log 进行计算，由此 V4 执行计算然后到达 V3，再同理依次计算回到 V1</strong></p><p>​    在可重复读的定义中，事务启动时，能够看到其他事务提交的结果，但是在该事务执行期间，其他的事务的更新操作对其不可见；也就是说可重复读的隔离级别下，一个事务会以启动时刻获取的数据版本为准，即使发现数据在其他事务执行中出现了最新版本，一样不会采用，只会去获取事务启动所见版本的版本，如果依然往上的版本是不可见的，那就继续找上一个版本，如果一直不可见到最后只能是发现自己本事务执行的更新版本</p><p>​    在实现上， <strong>InnoDB 会给每一个事务构造一个数组，保存着这个事务启动瞬间，当前状态是 “活跃” 的所有事务的ID，也就是启动了但是还没有提交的事务</strong></p><p>​    在这个数组中，因为事务 ID 是严格自增的，所以事务 ID 的最小值记作为 “低水位”，事务 ID 的最大值+1 则被记为 “高水位”</p><p>​    <strong>这个数组和高水位，就组成了当前事务的 “一致性视图”，而数据版本的可见性规则，是基于数据的 row trx_id 和 一致性视图 的对比结果得到的</strong></p><p>​    对于这个视图数组，会将所有的 row trx_id 分成三种不同情况：</p><p><img src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" alt="img"> </p><p>​    1）如果启动瞬间，数据版本的 row trx_id 处于绿色部分，表示该版本是已提交的事务或是当前事务执行生成的，该数据是可见的</p><p>​    2）如果在红色部分，表示这个版本是由将来启动的事务生成的，因此肯定是不可见的</p><p>​    3）在 <strong>黄色部分</strong> 包括了两种情况：    </p><p>​        1）如果 <strong>row trx_id 是在数组中，且数据版本由还没提交的事务生成，因此不可见</strong>，即黄色区域中的某个正在执行的事务产生了新的数据，但是因为没有提交，对于当前执行的事务而言这个数据自然不可见</p><p>​        2）如果 <strong>row trx_id 不在数组中，但版本是已提交的事务生成的，数据是可见的</strong>，因为整个数组中的 id 是严格自增排序，比如现在黄色区域中有 [5，6，8] 三个正在执行的事务，9 为当前执行事务，而 7 是已经提交的事务，在搜集黄色区域时，7 是在 [5，6，8] 数组范围内，但是 7 这个事务已经提交了，那么对于当前事务 9 而言，7 所提交的版本自然可见</p><p>​    所以对于发生在当前事务之后的更新，所生成的版本一定是处于 (2) 或是 (3(1)) 中，因此对于当前来说新的数据版本是不存在的，InnoDB 利用了数据有多个版本的特性，做到了”秒级创建快照”的能力</p><h4 id="查询返回结果"><a href="#查询返回结果" class="headerlink" title="查询返回结果"></a>查询返回结果</h4><p><img src="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png" alt="img"> </p><p>​    假设现在有一张表，有三个事务进行操作，且在三个事务开始前系统中只存在了一个活跃事务 ID 是 99，事务A，B，C 的版本号分别是 100，101，102，并且假设当前状态中只要这四个事务，三个事务开始之前存在一行数据（1,1）且 row trx_id 为 90</p><p>​    事务A 的视图数组就是 [99, 100]，B 的视图数组就是 [99, 100, 101]，C 为 [99，100，101，102]</p><p><img src="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png" alt="img"> </p><p>​    这里的提交使用默认的自动提交，事务C 在更新后直接自动提交，将得到（1,2）的数据作为了最新版本，所以此时数据的 row trx_id 是 102，而 row trx_id = 90 的数据成为了历史版本</p><p>​    <strong>接着在 事务B 中，同样进行更新（当前读），得到新数据（1,3）</strong>且 row trx_id 为 101，之前的 102 成为了历史版本，但是 事务B 此时还没提交，这时 事务A 执行了查询语句，但是（1,3）这个最新数据对 事务A 来说必须是不可见的，否则就成了脏读</p><p>​    事务A 查询语句的读数据流程：</p><p>​    1）首先获取的是当前版本，也就是（1,3），判断其 row trx_id 是 101 &gt; 高水位，所以是在处于了红色的区域，因此这个版本的数据是不可见</p><p>​    2）往上找上一版本，得到 row trx_id = 102，还是一样大于高水位，该版本数据不可见</p><p>​    3）继续向上一版本找，得到（1,1）的 row trx_id = 90，很明显低于低水位，也就是说这个版本的数据是可见的</p><p>​    那么最后三个事务执行下来，其实 事务A 最后得到的查询结果是 k=1，所以即使数据是被改过，但是 事务A 不论什么时候去查询都会得到这个结果，这就是 “一致性读取”</p><p>​    <strong>总结：</strong></p><p><strong>​    一个数据的版本对于一个事务视图来说，除了在当前事务做的更新操作数据是可见的，还有三种情况要判断：</strong></p><p>​    <strong>1）获取的数据版本是没有提交的，自然不可见</strong></p><p>​    <strong>2）数据版本是由已经提交的事务更改的，但是在本事务视图创建后做的提交修改，该版本数据不可见</strong></p><p><strong>​    3）数据版本是已提交状态，且该版本是在本事务视图启动前就已经提交的，自然可见</strong>    </p><h4 id="更新返回结果"><a href="#更新返回结果" class="headerlink" title="更新返回结果"></a>更新返回结果</h4><p>​    在上面的例子里，事务A 会因为一致性读取的原因只能读到最初版本的数据。但是更新的语句，则不是这样，事务B 的更新和查询是在 事务C 已经提交后做的操作，如果按照一致性读取，事务B 的更改就不能是使用 C 之前历史版本做修改，否则 C 的修改版本就失效了，所以 事务B 的更新操作其实是在 102 的版本上进行了自己的更新</p><p><img src="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png" alt="img"> </p><p>​    <strong>对于更新语句的规则是：数据是先读后写，这个读，只能是读当前的值，称为 “当前读” (current read)</strong>，所以 事务B 的更新得到的数据会是（1,3）且版本是 101，之后的查询语句则会按照一致性读取，所以得到 k=3</p><p>​    <strong>要注意的是：事务B 如果在更新语句前先执行的查询语句，那么这个查询的返回值会是 k=1</strong></p><p>​    但是除了更新的情况会是 “当前读” 之外，<strong>如果查询的语句加上了锁，同样会是 “当前读”</strong>，如果把 事务A 的查询语句 <code>select * from t where id=1</code> 修改一下，加上 <code>lock in share mode（共享锁）</code> 或 <code>for update（排他锁）</code>，也是都可以读到版本号是 101 的数据，返回的 k 的值是 3 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;  <span class="comment">-- 读锁（S锁，共享锁）</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;  <span class="comment">-- 写锁（X锁，排他锁）</span></span><br></pre></td></tr></table></figure><p>​    在上面的例子中，事务C 是自动提交的，如果 事务C 不是更新后就立即提交，而此时 事务B 开始了更新操作，事务B 的值会如何读取？</p><p><img src="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png" alt="img"> </p><p>​    这里需要再次回到 “两阶段锁”， 事务C’ 执行更新语句，对于数据行会加上行锁，执行后得到数据（1,2），由于还没提交且 事务B 开始执行更新，按照 “当前读” ，事务B 应该是会读到到最新版本的值，但是发现 （1,2）这个数据的版本上的写锁还没释放，所以需要等待，等到这个锁被释放，才可以继续执行它的 “当前读”</p><p><img src="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png" alt="img"> </p><h3 id="可重复读的实现"><a href="#可重复读的实现" class="headerlink" title="可重复读的实现"></a>可重复读的实现</h3><p>​    总结而言：<strong>可重复读 的核心就是 一致性读取，但如果当前的记录的行锁是被其他事务占用的，就进入锁等待</strong></p><h3 id="读提交的实现"><a href="#读提交的实现" class="headerlink" title="读提交的实现"></a>读提交的实现</h3><p>​    整体上与可重复读的逻辑类似，两者主要的区别是：</p><p>​    1）<strong>可重复读下，事务开始时会建一个一致性视图，然后事务里的查询都使用这个视图</strong></p><p>​    2）<strong>读提交下，每一个语句的执行会是一个视图</strong></p><p>​    对于 <strong>命令 <code>start transaction with consistent snapshot;</code> 会创建一个一致性视图，但是在读提交的隔离级别下，这个命令其实就是没有意义了</strong></p><p>​    同样是一开始的例子，这次用读提交的隔离级别，事务A 的结果就会不同了；事务C 更新后自动提交，生成了新版本数据 102，事务B 开始执行更新语句，按照 当前读 的性质，会读取最新值进行更新生成新的一个版本数据同时在当前的视图中查询得到 k=3，而此时还没有提交，事务A 就开始了查询，但是（1,3）的版本在 事务B 中还没提交，因此对 事务A 而言不可见，所以会取到（1,2）的版本，且这个版本是已提交的，所以 事务A 的查询是 k=2</p><p><img src="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg" alt="img"> </p><p>​    所以，就 <strong>查询语句而言：</strong></p><p>​    1）<strong>可重复读级别下（RR），查询语句只会承认当前事务开始前就已经提交完成的数据</strong></p><p>​    2）<strong>读提交级别下（RC），查询语句只承认语句执行前就已经提交完成的数据</strong></p><p>​    对于 <strong>更新的语句：总是会先使用当前读，去读取已经提交完成的最新版本</strong></p><h3 id="order-by-的过程"><a href="#order-by-的过程" class="headerlink" title="order by 的过程"></a>order by 的过程</h3><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>​    假设现有一张公民表，包含城市，姓名，年龄，地址等信息，且表中以保存有 4000 行数据，并通过指定城市来查询公民信息，并且通过排序取出前 1000 个人的姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `addr` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>​    为了避免全表的扫描，因此给 city 字段添加索引，通过 explain 来分析查询语句</p><p><img src="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png" alt="img"> </p><p>​    图中的 Extra 中显示 <code>Using index condition; Using filesort</code>，其中 <code>Using filesort</code> 即表示语句的执行中需要排序，<strong>MySQL 会给每一个线程分配一块内存用于排序，称为 sort_buffer</strong></p><p><img src="https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png" alt="img"> </p><p>​    通过 city 的索引，现在查询执行的 <code>city=&#39;杭州&#39;</code>，那么满足的就是从 ID_X 到 ID_(X+N) 的记录，因此整个过程如下：</p><p>​    1）初始化 sort_buffer，确定放入 name，city，age 这三个查询的字段</p><p>​    2）从索引 city 中找到第一个满足的指定的条件的主键 id，即图中的 ID_X</p><p>​    3）然后回表，到 id 的主键索引中取出 ID_X 的整行记录，将 name，city，age 三个字段的值放入到 sort_buffer 中</p><p>​    4）接下来，继续到 city 的索引中去取下一条记录的主键 id</p><p>​    5）重复 3）和 4）的步骤，直到最后 city 的值不满足查询的条件为止，也就是当取到 ID_Y 的时候因为条件不满足则停止向后遍历</p><p>​    6）对 sort_buffer 中的数据按照字段 name 做快速排序</p><p>​    7）按最后排好序的结果，取出前面的 1000 行将结果集放回客户端</p><p><img src="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg" alt="img"> </p><p>​    图中的 <strong>“按 name 排序” 这一步骤，可能会内存中完成，也可能会使用 外部排序</strong>，这取决于排序所需的 <strong>内存 和参数 sort_buffer_size</strong>，该参数即 MySQL 在初始化时给排序分配的内存大小，<strong>如果排序的数据量小于 sort_buffer_size，那么整个排序就会在内存中进行并完成；如果数据量太大，内存中无法放下就会用磁盘临时文件去辅助排序</strong></p><p>​    对于是否使用到了临时文件帮助排序，可以使用 optimizer_trace 去判断结果，流程如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure><p>​    <strong>optimizer_trace 其实是一张表，存在于  information_schema 的数据库中，默认设置的是关闭状态</strong>。该表包含四列，QUERY（即查询语句），TRACE（优化过程的 json 文本），MISSING_BYTES_BEYOND_MAX_MEM_SIZE （该字段用于展示优化中，因为输出太多而将超出部分不显示的文本字节数），INSUFFICIENT_PRIVILEGES（表示是否有权限查看优化过程，默认是0）</p><p><img src="https://static001.geekbang.org/resource/image/89/95/89baf99cdeefe90a22370e1d6f5e6495.png" alt="img"></p><p>​    红框中的 <strong>“number_of_tmp_files” 表示排序过程中使用的临时文件的个数</strong>，当内存中无法放下大量需要排序的数据时，就会使用外部排序，而 <strong>外部排序一般使用的是 归并排序 算法</strong>，这里的 <strong>12 表示 MySQL 将外部排序的数据分成了 12 份，每一份单独进行排序后将结果放在各自的临时文件中，最后会将这 12 个有序的文件再合并为最终所有数据的有序文件</strong></p><p>​    如果内存可以处理排序过程，即 <strong>实际需要排序的数据量是小于 sort_buffer_size 的大小，那么这里的 “number_of_tmp_files” 就会返回 0</strong></p><p>​    概括来说，初始化赋予的 <strong>sort_buffer_size 的值越小</strong>，那么在排序时超出该值的话，就会导致使用的 <strong>临时文件的数量越多</strong>，也就是说 “number_of_tmp_files” 的值会越大</p><p>​    “examined_rows” 的值表示参与排序的行数的是 4000，与 “rows” 一样，所以对所有的满足记录进行排序</p><p>​     “sort_mode” 中 “packed_additional_fields” 的意思是在排序的过程中对字符串做了 “紧凑” 的处理，因为在表结构的定义中 name 字段设置的长度是 varchar(16)， 但是在排序的过程中还是去按照实际长度去对字段的值来分配空间</p><p>​    上面最后的一个语句 <code>select @b-@a</code> 返回的结果是 4000，表示整个执行的过程只扫描了 4000 行；但是这个 4000 行，是因为 “internal_tmp_disk_storage_engine” 设置为了 MyISAM；该参数的默认是使用 InnoDB ，但是 <strong>InnoDB 引擎在将数据从临时表读取时，会对 “Innodb_rows_read” +1，也就会返回 4001 行</strong></p><h4 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h4><p>​    在全字段排序这个方式中，对原表的数据只读了一遍，剩下的操作就在 sort_buffer 和 临时文件 中进行。并且全字段排序效率容易受 sort_buffer 的大小影响，同时如果一个要排序的查询语句中，结果集中要求的字段比较多，这也会占用 sort_buffer 的空间，进一步导致可能内存中可以放入的行记录会更少，从而临时文件数增多，继而性能就受影响，所以针对这样的情况就可以使用 rowid 来进行排序</p><p>​    <strong>MySQL 中有一个参数用来控制行数据的长度 “max_length_for_sort_data” ，如果排序中字段的长度超出这个参数值，就会认为行中的数据太大，从而使用 rowid 排序</strong></p><p>​    假设还是之前例子一样的查询语句，但是这一次将允许行的最大值修改为 16，在原表定义中的三个字段 city ，name，age 的总长是 36</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>​    这一次与全字段排序就不一样了，在 sort_buffer 中只有 排序的列（即 name 字段）和 主键 id，流程如下：</p><p>​    1） 初始化 sort_buffer，确定将 name 和 id 放入</p><p>​    2）从 city 的索引中找到满足条件是 “杭州” 的主键 id，即 ID_X</p><p>​    3）到主键 id 索引中取出 ID_X 这一行，同时取出字段 name 和 id，一起放入 sort_buffer</p><p>​    4）回到 city 索引，继续匹配下一个满足条件的主键 id</p><p>​    5）重复 3）和 4）的步骤，直到取到条件不满足的行 id 即 ID_Y，停止遍历</p><p>​    6）对 sort_buffer 中的数据按照 name 字段进行排序</p><p>​    7）遍历排序的结果，取出前 1000 行的记录，并按照 id 的值回到原表取出 city， name 和 age 字段返回给客户端</p><p><img src="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg" alt="img"> </p><p>​    和全字段排序对比来看，rowid 的方式会多一次通过主键索引回表的操作；对于结果集，在 MySQL 服务端排好序后，会依次取出 sort_buffer 中的 id，然后在原表查询出 city，name，age 字段结果后，直接返回客户端，不会在服务器中消耗资源将排序结果保存</p><p>​    对于 rowid 排序，同样使用 optimizer_trace 方式最后执行 <code>select @b-@a</code>，optimizer_trace 返回的结果之中，rows 与 examined_rows 依然都是 4000，说明 4000 行数据被排序，但是 <code>select @b-@a</code> 查询的语句中值却为 5000，这是因为执行器首先根据 limit 来取出 id，再调用引擎的接口去读这些 id 的数据，也就是两次查询，排序前会扫描整表 4000 行的记录加入临时表，在利用 limit 扫描排好序的前 1000 行，故最后总共扫描 5000 行</p><p><img src="https://static001.geekbang.org/resource/image/27/9b/27f164804d1a4689718291be5d10f89b.png" alt="img"></p><p>​    除此之外，sort_mode 的信息也进行了改变，&lt;sort_key, rowid&gt; 即表示参与排序的只有 name 和 id 两个字段；同时 number_of_tmp_files 的值从之前的 12 变为 10，因为与之前相比，这一次在 sort_buffer 中的字段减少了，即使依旧是 4000 行的数据，但是其中每一行的大小减小了，自然需要的临时文件也会减少</p><h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><p>​    <strong>无论使用 全字段排序 还是 rowid 排序，都取决于内存大小</strong>。如果执行时 MySQL 认为内存太小了，就会采用 rowid 方式排序，这样可以在内存中排序更多的行，但是在返回结果集前需要回原表取出要返回的字段信息；如果执行时 MySQL 认为内存足够的话，就会使用全字段排序，把要返回的字段都放入 sort_buffer 中，在排完序后就直接从内存中返回查询的结果</p><p>​    这也是 MySQL 设计的一个思想：如果 <strong>内存足够，就优先内存使用，而减少磁盘的访问</strong>；对于 InnoDB 来说，rowid 的排序方式会由于回原表造成磁盘的读取，所以不会被优先选择</p><h4 id="本身就是有序的查询"><a href="#本身就是有序的查询" class="headerlink" title="本身就是有序的查询"></a>本身就是有序的查询</h4><p>​    对于 MySQL 来说做一次排序的成本是比较高的操作，所以对于本身就是有序的结果，其执行的消耗会小很多，时间也更短。在 全字段 和 rowid 排序中，两者都需要生成一张临时表，保留信息并在自身做排序，这是因为在原表中的数据就是无序的，才会这么使用</p><p>​    依然是一样的例子和查询语句，但是对 city 和 name 做联合索引，相比原来只有一个字段的 city 的索引结构，这一次的索引还存储了 name，且这一次假设数据库中的数据是按照 name 递增排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user(city, name);</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/f9/bf/f980201372b676893647fb17fac4e2bf.png" alt="img"> </p><p>​    由于使用了 city 和 name 的联合索引，所以查询的遍历中只要 city 是满足条件的，那么得到的 name 就一定为有序结果，整个流程如下：</p><p>​    1）从联合索引 (city, name) 中，找到满足 <code>city=&quot;杭州&quot;</code> 条件的主键 id</p><p>​    2）在主键 id 的索引上，获取对应的 id，取出返回需要的 name，city，age 三个字段的值，加入到结果集中</p><p>​    3）回到联合索引中，继续取出下一个主键 id</p><p>​    4）重复 2）和 3）的步骤，直到查询到第 1000 行记录，或者 city 的值不满足条件，停止遍历</p><p><img src="https://static001.geekbang.org/resource/image/3f/92/3f590c3a14f9236f2d8e1e2cb9686692.jpg" alt="img"> </p><p>​    在这个过程中，既没有临时表的生成，也没有排序的操作，通过 explain 分析，可以看到 Extra 中也没有了 <code>Using filesort</code>，证明了操作没有执行排序。并且查询的语句也不需要把 4000 行全部都读一遍，只需要将满足条件的前 1000 行返回，也就是说只扫描 1000 次</p><p><img src="https://static001.geekbang.org/resource/image/fc/8a/fc53de303811ba3c46d344595743358a.png" alt="img"> </p><p>​    <strong>进一步的优化：</strong></p><p>​    在这个例子中，要返回的字段有三个 city，name，age。对于本身数据就是按照 name 字段进行递增排序的，要返回前 1000 行的结果，可以用覆盖索引应用这个例子，<strong>创建三个字段的联合索引 (city, name, age)</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure><p>​    在这个索引中，直接将需要返回的字段的包含了，也就是说查询的值都包含在了这个联合索引中，因此就不需要在通过索引记录的 id 去回表到原表中将值取出，而是利用这个索引将查询的值返回</p><p><img src="https://static001.geekbang.org/resource/image/df/d6/df4b8e445a59c53df1f2e0f115f02cd6.jpg" alt="img"> </p><p>​    通过 explain 返回的结果中，Extra 中加入了 <code>Using index</code>，这证明使用到了覆盖索引，所以这个查询的效率会快很多；但是索引的添加需要根据字段使用率去判断添加，并不能为了一个查询使用索引快，去给多个字段建上联合索引，维护的代价也是很高的</p><p><img src="https://static001.geekbang.org/resource/image/9e/23/9e40b7b8f0e3f81126a9171cc22e3423.png" alt="img"> </p><h4 id="order-by-rand"><a href="#order-by-rand" class="headerlink" title="order by rand()"></a>order by rand()</h4><p>​    比如现在有一张单词表，并含有 10000 行的数据，每一次查询要从中随机取出三个单词</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `words` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `word` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">  while i<span class="operator">&lt;</span><span class="number">10000</span> do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(concat(<span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i div <span class="number">1000</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">1000</span> div <span class="number">100</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">100</span> div <span class="number">10</span>)), <span class="type">char</span>(<span class="number">97</span><span class="operator">+</span>(i <span class="operator">%</span> <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><p>​    查询语句就是：<code>select word from words order by rand() limit 3;</code></p><p><img src="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"> </p><p>​    使用 explain 命令分析后，可以看到 extra 中出现 <code>Using temporary; Using filesort</code>，表示这个查询命令使用了临时表，并且经过了排序步骤</p><p>​    对于 InnoDB 的表而言，排序的操作使用 全字段排序，因为这样可以减少回表操作对磁盘的访问，所以优化器会选择这个方式；<strong>但是对于 临时表，其实是在内存中的，那么回表操作实际上也是直接在内存中完成的，也就不会导致磁盘的访问，所以优化器对于这个查询语句选择的其实是 rowid 的方式</strong></p><p>​    那整个查询语句的执行流程就是：</p><p>​    1）创建一个临时表，这个表使用的是 memory 引擎，表中有两个字段，第一个记为 R，double 类型，第二个记为 W，是 varchar(64) 类型。这个表没有建立索引</p><p>​    2）从单词表中，按主键依次取出 word，每一个单词都调用 rand() 函数得到一个 0-1 之间的随机小数，然后将这个小数和 word 都放入到临时表中的 R 与 W 字段中。单词表有 10000 行，所以完成这个操作后，执行扫描的行数就是 10000</p><p>​    3）临时表有了数据后，就是对 R 这个字段进行排序</p><p>​    4）初始化 sort_buffer，这里面也会有两个字段，一个是 double 类型，另一个则是整型</p><p>​    5）先从内存表依次取出 R 和 位置信息 放入到  sort_buffer 的两个字段中。这次操作同样对内存表的所有行进行了一次遍历，所以完成后扫描行数就变成了 20000</p><p>​    6）sort_buffer 对第一个字段保存的 R 值进行排序。因为是在内存的操作，所以不涉及回表，也就不会增加扫描行数</p><p>​    7）排序完成后，按照查询要求的 limit，取出最前面的 3 行的位置信息，然后到内存表中用这个值取出 word 的值，最后加入结果集返回给客户端。这个操作访问了表的 3 行，所以扫描行数变为 20003</p><p>​    最后通过查看慢查询日志，其中 <code>Rows_examined: 20003</code> 与分析的流程结果行数一致</p><p><img src="https://static001.geekbang.org/resource/image/2a/fc/2abe849faa7dcad0189b61238b849ffc.png" alt="img"> </p><p>​    图中 sort_buffer 的 pos 即 位置信息（可以理解为内存临时表的行信息），MySQL 中通过 id 字段去定位一行记录，但是如果 id 主键被删除了，InnoDB 也会自己生成一个 6 字节长的 rowid 作为主键，rowid 排序实际就是指这个生成的 rowid 标识</p><p>​    至此， 在 <strong>查询语句中的 <code>order by rand()</code> 实际上就是使用了内存表，并对这个表进行 rowid 排序</strong></p><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><p>​    上面的例子中，排序过程是使用了临时表，不过 <strong>临时表的位置不一定只是在内存中，也可能在磁盘上。</strong>参数 <code>tmp_table_size</code> 用来设置内存的临时表大小，这个值默认是 16777216（16M=16*1024*1024），如果数据过大超出阈值，那么这个临时表就会被转成磁盘上的临时表</p><p>​    磁盘的临时表默认使用 InnoDB 引擎，同样可以用参数  <code>internal_tmp_disk_storage_engine</code> 去指定，当时使用磁盘临时表进行排序时，排序就是一个没有显式索引的 InnoDB 表的排序过程</p><p>​    上面的例子可以通过修改设置，来实现使用磁盘临时表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size<span class="operator">=</span><span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size<span class="operator">=</span><span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data<span class="operator">=</span><span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/78/ab/78d2db9a4fdba81feadccf6e878b4aab.png" alt="img"></p><p>​    <code>max_length_for_sort_data=16</code>，这个 16 要小于 word 字段的长度，所以 sort_mode 会显示使用 rowid 排序， 但是 <code>number_of_tmp_files</code> 的值却是 0，按理来说 sort_buffer 中 R 是 double 类型就是 8 个字节，自己生成的 rowid 是 6 个长度的字节，所有数据计算后应该是 140000 个字节，这个值也远远超过了之前设置的 <code>sort_buffer_size=32768</code>，为什么最后这个查询没有使用临时文件？</p><h4 id="优先队列排序算法"><a href="#优先队列排序算法" class="headerlink" title="优先队列排序算法"></a>优先队列排序算法</h4><p>​    上面的排序没有使用临时文件正式因为在 5.6 版本中引入的这个算法，OPTIMIZER_TRACE 结果中，<code>filesort_priority_queue_optimization</code> 这个部分的 <code>chosen=true</code>，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的 <code>number_of_tmp_files</code> 是 0 </p><p>​    <strong>之前的排序都是利用临时文件做 归并排序</strong>，但最终都是根据 limit 的设置去取出行，也就是说 10000 行排好序后，只有最前面的 3 行是最后要的结果，之而后 9997 的有序行却并不需要，但是却加在了整个排序过程中，这就浪费了非常多的计算量</p><p>​    而 <strong>优先队列算法，同样可以得到需要的三个最小值（实现上是通过堆排序）</strong>：</p><p>​    1）首先从 sort_buffer 中取出前三行，并构建一个大根堆结构</p><p>​    2）然后，依次然后取出每一行（R’，rowid），与堆中最大的（R，rowid）进行比较，如果 R’ &lt; R，则让 R’ 进入堆，将原本的 R 从堆中移除。如果 R’ &gt; R 就继续往后取出在进行比较</p><p><img src="https://static001.geekbang.org/resource/image/e9/97/e9c29cb20bf9668deba8981e444f6897.png" alt="img"> </p><pre><code>最后，sort-buffer 得到的堆结构中，就是 limit 要取出的 3 行，再回到内存的 临时表 中根据堆结构的 rowid 去取出结果，加入到结果集中返回</code></pre><p>​    <strong>优先队列排序算法也容易受到限制，比如之前 <code>limit 1000</code> 的时候，优先队列算法需要维护一个 1000 行的堆，而这些数据的空间超过了 sort_buffer_size 的大小，所以只能使用归并排序利用临时文件来操作</strong></p><h4 id="随机排序"><a href="#随机排序" class="headerlink" title="随机排序"></a>随机排序</h4><p>​    <code>order by rand()</code> 用来做随机排序时，无论哪一种方法都会遇到大量的计算和扫描，造成很多的资源消耗</p><p>​    如果现在是需要随机选择一个 word，可以直接取出 id 最大值 M 和最小值 N，利用随机函数生成一个一个数值，直接取不小于这个值的第一个 id 即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(id),<span class="built_in">min</span>(id) <span class="keyword">into</span> <span class="variable">@M</span>,<span class="variable">@N</span> <span class="keyword">from</span> t ;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@X</span><span class="operator">=</span> <span class="built_in">floor</span>((<span class="variable">@M</span><span class="operator">-</span><span class="variable">@N</span><span class="operator">+</span><span class="number">1</span>)<span class="operator">*</span>rand() <span class="operator">+</span> <span class="variable">@N</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="variable">@X</span> limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>​    max 和 min 都不需要扫描索引，得到计算后的值用 floor 取整，然后在 select 中利用索引就能快速定位需要的行，所以大致上需要扫描 3 行。但这个算法并不完全具有随机性，因为一张表中主键 id 之间可能会出现很多空洞，如果空洞过大会直接造成不同行被获取的概率大大不同</p><p>​    比如有四个 id，分别是 1，2，40000，40001，那在使用这个算法就基本算是一个 bug 了</p><p>​    所以为了可以严格随机结果，可以得到整表的行数，用这个值计算随机值后取整，再用 limit 去取出后一行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@sql</span> <span class="operator">=</span> concat(&quot;select * from t limit &quot;, <span class="variable">@Y</span>, &quot;,1&quot;);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> <span class="variable">@sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure><p>​    MySQL 处理   <code>limit Y,1</code> 时，会一个个按顺序取出来，然后丢掉前面的 Y 个，将下一个记录做为返回结果，所以这一步需要扫描 Y+1 行</p><p>​    除此之外，一开始统计表的行数时会需要扫描 C 行，也就是说最后的总扫描行数是 C+Y+1 行，这个代价比上面的算法要高，但是相比起 order by rand() 而言要小不少了，因为这个算法直接根据原表的主键 id 索引进行获取，而 order by rand() 还需要建临时表以及读取行</p><p>​    有了这个算法，那对于原本的 limit 3 就可以计算得到三个 Y，然后再用 limit 去获取</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@C</span> <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y1</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y2</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@Y3</span> <span class="operator">=</span> <span class="built_in">floor</span>(<span class="variable">@C</span> <span class="operator">*</span> rand());</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y1</span>，<span class="number">1</span>； <span class="comment">-- 在应用代码里面取 Y1、Y2、Y3 值，拼出 SQL 后执行</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y2</span>，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t limit <span class="variable">@Y3</span>，<span class="number">1</span>；</span><br></pre></td></tr></table></figure><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>​    <strong>分库分表是随着系统的不断演进，需求的增加，数据的大量累计后的一种分布式架构处理方案</strong>。分库分表所要处理的问题主要就是数据库在数据存储上的压力，当数据量达到千万或是上亿的规模，单一的服务器就必然面临 CPU，IO，内存，磁盘各种资源有限的问题，使用分库分表的分布式处理就是最好的思路</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>​    <strong>分库简单来说，就是将一个数据库的多张表，放在其他服务器的数据库上</strong>。这是一种最简单的处理方式，直接将对单个数据库的所有访问，拆分成根据需要访问指定的服务器，同时也 <strong>将单个数据库的存储压力分摊</strong> 了。但是有好就有坏，<strong>弊端是，原本一个事务可以通过 join 将在同一个服务器上的两张表关联起来就可以查询结果的操作，分库之后，就不得不更改原本的查询逻辑，需要从不同的数据库上查询，并且事务从原本简单的本地事务，需要改进成分布式事务，这样大大增加了整个系统的复杂度</strong></p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>​    即使去使用分库了，但是依然还是会遇到数据量过大的问题，这时候分表的工作就开始了，<strong>分表分为两种方式：垂直和水平分表</strong></p><h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><p>​    正如所说，就是垂直将表切成两块，也就说 <strong>将原本的一张表，直接 “剁” 成两张表，两张表根据需要将原本表中的列做拆分</strong>，比如原本用户表中，存在用户 id，昵称，手机号，邮箱，地址，简介等字段，按照平常的查询情况，比如邮箱，地址，简介是不常查询的字段，就可以单独合为一张表，将用户 id，昵称，手机号作为一张表的字段。</p><p>​    垂直分表可分库有异曲同工之处，两者都是在垂直方向上将资源分开，所以垂直分表同样存在的问题就是，原本一张表就可以查询所有的用户信息，但是分表之后同样需求的查询就不得不通过两次查询，才能查询得到用户的完整信息</p><h5 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h5><p>​    顾名思义，就是在水平方向上对表做切分，<strong>将一张表水平分成多个不同范围的表，所以水平分表适用于单表行记录非常多的情况</strong>。比如一张 5000 万行的表，可以横向切成 5 块，每块负责管理 1000 万行的记录，不过这也需要考虑表的实际复杂情况，如果表很复杂的话，可能需要提早做好分表的打算，一般当行数超过千万了就可以根据性能分析，来判断是否需要做水平分表</p><p>​    <strong>1）按照 id 作为范围来实现水平分表</strong></p><p>​    比如，还是那张 5000 万行的表，那么分成 5 个表，每个表按照 id 做范围存储，第一个表负责 1 - 999 万的行，第二张表就是 1000 - 1999 万的行数，以此类推。这样的分表是最简单除暴的，但是最需要注意的一点就是范围的选择</p><p>​    水平分表容易实现，也容易管理，如果之后数据还在不断增加，需要加上新的表做存储即可，新增的数据分表不会对已经分好的表产生影响，扩充简单</p><p>​    但是同样也会有问题，对于新数据而言，如果出现大量的写入和查询，那么请求会大量集中在一张表上，造成 IO 瓶颈</p><p>​    <strong>2）按照 hash 算法来水平切分</strong></p><p>​    比如用户表可以通过用户 id 与 hash 算法做计算，简单来说比如 1500 取余 8，结果是 4，那就把这个 id 的记录存放在 user_4 的表上。使用 hash 来切分表也可以将每个表的数据分的很均匀，即使新增大量的数据，也是会分散在不同的表上，这样对于读写操作而言，不会集中在某一张表上，从而避免了 IO 瓶颈问题</p><p>​    但是 hash 也存在问题，因为数据是先通过计算后，再分散在不同的表上。数据大量增加，需要创建新的表时，原本计算好的存储位置的数据就不得不需要进行再次计算，调整自己的位置</p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy 整理</title>
      <link href="/1649325139/"/>
      <url>/1649325139/</url>
      
        <content type="html"><![CDATA[<h3 id="Scrapy-框架"><a href="#Scrapy-框架" class="headerlink" title="Scrapy 框架"></a>Scrapy 框架</h3><p>​    Scrapy 是一个为了爬取网站数据，提取结构性数据而编写的应用框架。其最初是为了页面抓取 (更确切来说是网络抓取) 所设计的， 也可以应用在获取 API 所返回的数据 (例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy 用途广泛，可以用于数据挖掘、监测和自动化测试，是纯 python 实现的，<strong>基于 Twisted 的异步处理框架</strong></p><p>​    安装：可以直接使用 pip 去安装   <code>pip install scrapy</code></p><h4 id="创建一个-scrapy-项目"><a href="#创建一个-scrapy-项目" class="headerlink" title="创建一个 scrapy 项目"></a>创建一个 scrapy 项目</h4><p>​    安装完成后，可以直接使用命令  <code>scrapy startproject 项目名称</code> 来创建一个项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">项目名称</span><br><span class="line">   - 项目名称</span><br><span class="line">      - spiders              # 所有该项目的爬虫目录</span><br><span class="line">         - ...               # 爬虫程序文件</span><br><span class="line">      - items.py             # 设置数据存储模板，用来提取并结构化数据</span><br><span class="line">      - pipelines.py         # 数据行为处理，比如对数据进行持久化</span><br><span class="line">      - middlewares.py       # 中间件处理</span><br><span class="line">      - settings.py          # 项目爬虫所用的配置文件，例如递归层数，并发数，延迟下载等</span><br><span class="line">   - scrapy.cfg              # 项目的配置信息</span><br></pre></td></tr></table></figure><h4 id="创建一个爬虫"><a href="#创建一个爬虫" class="headerlink" title="创建一个爬虫"></a>创建一个爬虫</h4><p>​    需要进入到项目目录下，使用命令   <code>scrapy genspider 名称 [域名]</code>， 域名 这个参数是可选项，如果使用这个参数，那么不要写前面的 www，比如  <code>scrapy genspider baidu baidu.com</code> ，完成后则会在 spiders 文件夹下就会出现对应的爬虫文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovieSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;movie&#x27;</span></span><br><span class="line">    <span class="comment"># allowed_domains = [&#x27;xxx.com&#x27;]</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.4567tv.tv/index.php/vod/show/area/%E7%BE%8E%E5%9B%BD/id/1/year/2019.html&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        li_list = response.xpath(<span class="string">&quot;//ul[@class=&#x27;stui-vodlist clearfix&#x27;]/li&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(li_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    spider 会根据命令中的名称，生成一个 py 文件，并创建一个类，同时继承 spider.Spider，其中 <strong>name 属性是必不可少的且是唯一的</strong>，用来区分 spider 目录下各个不同的爬虫文件</p><p>​    allowed_domains 属性则是可选属性，包含允许爬取的域名列表，当   <code>OffsiteMiddleware</code> 启用时， 域名不在列表中的 url 不会被跟进爬取</p><p>​    start_urls 则是作为 spider 程序启动的初始爬取 url；同时会默认创建一个方法 parse，并且包含一个参数 response 表示下载器得到的响应结果，parse 方法用来对 response 进行处理或是继续跟进新的 url</p><h4 id="启动一个爬虫程序"><a href="#启动一个爬虫程序" class="headerlink" title="启动一个爬虫程序"></a>启动一个爬虫程序</h4><p>​    命令行输入  <code>scrapy crawl 爬虫文件名</code>，但是这样所有的状态信息返回都是在命令行工具中，并不是十分方便查看，另外如要爬取的内容要保存的到指定类型的文件，在该命令中可以使用 <code>-o</code>  参数指定，例如 json，csv，xml 等等</p><p>​    为了可以在 pycharm 中进行调试，可以去创建一个 main.py 脚本文件来作为爬虫程序的启动文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line"></span><br><span class="line">sys.path.append(os.path.abspath(os.path.dirname(__file__)))</span><br><span class="line"><span class="comment"># 将当前文件目录加入到 python 的 sys 搜索目录中</span></span><br><span class="line"></span><br><span class="line">execute([<span class="string">&quot;scrapy&quot;</span>,<span class="string">&quot;crawl&quot;</span>, <span class="string">&quot;baidu&quot;</span>])</span><br></pre></td></tr></table></figure><h4 id="架构组件"><a href="#架构组件" class="headerlink" title="架构组件"></a>架构组件</h4><p>​    <img src="https://wei-foun.github.io/img/scrapy-%E6%9E%B6%E6%9E%84.jpg" alt="img"> </p><p>​    <strong>scrapy engine：</strong>整个框架的中心处理引擎，用来处理整个系统的数据流，触发事务操作</p><p>​    <strong>scheduler：</strong>调度器负责从引擎中接收 request 并将他们加入到队列，然后再由引擎请求时返回</p><p>​    <strong>downloader：</strong>下载器的任务就是从 scheduler 中发送的网址在网络上进行下载，并将响应的内容进行返回交给 spider，而且 <strong>scrapy 的下载器是基于 twisted 异步模块实现</strong>，由此提升下载效率</p><p>​    <strong>spider：</strong>用于分析响应的 response 并提取 item，或是将要跟进的 url 再交给 scheduler 去跟进下载</p><p>​    <strong>item pipeline：</strong>负责处理被 spider 提取的 item，比如做数据持久化，验证有效性，或是清除不必要的信息</p><p>​    <strong>downloader middlewares：</strong>下载中间件是引擎与下载器之间特定钩子（specific hook），用于全局修改来自引擎给出的 request 和返回给引擎的 response</p><p>​    <strong>spider middlewares：</strong>则是介于引擎与 spider 之间的特定钩子，用于修改处理得到的 response 和需要跟进 request 以及提取的 item</p><h4 id="一个-spider-数据流执行过程"><a href="#一个-spider-数据流执行过程" class="headerlink" title="一个 spider 数据流执行过程"></a>一个 spider 数据流执行过程</h4><p>​    1）引擎会根据网站，找到对应的 spider 并向这个 spider 请求第一要爬取的 url</p><p>​    2）引擎从 spider 中拿到 url 后，送到调度器中</p><p>​    3）引擎向调度器请求爬取的 url，并将其封装成一个 request，通过下载中间件后，交给下载器进行网页下载</p><p>​    4）下载器完成对应 url 的网站页面下载后，得到响应的 response，再经由下载中间件返回给引擎</p><p>​    5）引擎接收到下载器返回的响应，将 response 通过 spider 中间件交给 spider 进行处理</p><p>​    6）spider 处理后，从 response 中提取需要得到 item 和需要跟进的 url 继续返回给引擎</p><p>​    7）引擎将 spider 给的 item 给到 item pipeline 做后续处理，url 则是继续之前的步骤给调度器完成之后的爬取和提取，直到最后整个引擎关闭</p><h3 id="提取方式"><a href="#提取方式" class="headerlink" title="提取方式"></a>提取方式</h3><p>​    scrapy 的 response 即支持 xpath 提取 item，也可以使用 css 选择器去提取，<strong>另外也支持通过 re 方法使用正则进行提取，前提是 re 方法不能直接在返回的 response 上使用，会排除没有 re 方法的错误，如果使用 re 可以先使用 xpath 选中全文，在通过 re 正则进行解析提取</strong></p><h4 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h4><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>article</td><td>选取所有article元素的所有子节点</td></tr><tr><td>/article</td><td>选取根元素article</td></tr><tr><td>article/a</td><td>选取所有article下的是a元素的<strong>子元素</strong></td></tr><tr><td>//div</td><td>选取所有div子元素（ // 表示不论是在文档任何位置）</td></tr><tr><td>article//div</td><td>选取所有article元素下只要是div元素的，无论是子代还是后代，无论在article下的任何位置 a</td></tr><tr><td>//@class</td><td>选取所有class属性的元素</td></tr><tr><td>/article/div[1]</td><td>选取article子元素下的第一个div元素</td></tr><tr><td>/article/div[last()]</td><td>选取article子元素下的最后一个div元素</td></tr><tr><td>/article/div[last()-1]</td><td>选取article子元素下的倒数第二个div元素</td></tr><tr><td>//div[@lang]</td><td>选取所有含有属性lang的div元素</td></tr><tr><td>//div[@lang=’eng’]</td><td>选取所有lang属性，且值是eng的div元素</td></tr><tr><td>/div/*</td><td>选取所有属于div元素的子节点</td></tr><tr><td>//*</td><td>选取所有元素</td></tr><tr><td>/div/a | /div/p</td><td>选取所有属于div下子元素的a和p元素</td></tr><tr><td>//span | //ul</td><td>选取所有span和ul的元素</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 属性定位</span><br><span class="line">//div[@class=&quot;song&quot;]     找到class是song的div元素</span><br><span class="line"></span><br><span class="line"># 层级和索引定位</span><br><span class="line">//div[@class=&quot;song&quot;]/ul/li[2]/a     找到class是song的div元素的直系子标签ul下第二个li标签下的a元素，xpath中索引的开始为是从1开始</span><br><span class="line"></span><br><span class="line"># 逻辑运算</span><br><span class="line">//a[@href=&quot;&quot; and @clss=&quot;song&quot;]     找到href属性为空，且class属性是song的a元素</span><br><span class="line"></span><br><span class="line"># 模糊匹配</span><br><span class="line">//div[contains(@class, &quot;ng&quot;)]     找到class属性值中包含 ng 的所有div元素</span><br><span class="line">//div[starts_with(@class, &quot;so&quot;)]     找到class属性值是 so 开头的所有div元素</span><br><span class="line"></span><br><span class="line"># 提取标签的文本内容</span><br><span class="line">//div[@class=&quot;song&quot;]/p[1]/text()     提取class是song的div下第一个p标签的所有文本内容</span><br><span class="line"></span><br><span class="line"># 提取属性的值</span><br><span class="line">//div[@class=&quot;song&quot;]/a/@herf     提取class是song的div下a标签中的href属性的值</span><br></pre></td></tr></table></figure><h4 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h4><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>*</td><td>选取所有节点</td></tr><tr><td>#container</td><td>选取id为container的节点</td></tr><tr><td>.container</td><td>选取class包含的container节点</td></tr><tr><td>li a</td><td>选取所有li下的a节点（这包含了li的子代以及孙代）</td></tr><tr><td>ul+p</td><td>选取ul标签的兄弟节点p元素，+表示的是平级的兄弟关系</td></tr><tr><td>div#container&gt;ul</td><td>选取父级是div，且id是container的ul子元素，&gt;在这只去选择子代</td></tr><tr><td>p~ul</td><td>选取p元素后面的每一个ul元素</td></tr><tr><td>a[little]</td><td>选取有title属性的a元素</td></tr><tr><td>a[href=”http”]</td><td>选取href属性是http的a元素</td></tr><tr><td>a[href*=”ham”]</td><td>选取href属性中包含ham的a元素</td></tr><tr><td>a[href^=”http”]</td><td>选取href属性开头是http的a元素</td></tr><tr><td>a[href$=”ham”]</td><td>选取href属性结尾是ham的a元素</td></tr><tr><td>input[type=radio]:checked t</td><td>选取被选中的单选按钮的元素</td></tr><tr><td>div:not(#container)</td><td>选取所有id不是container的div元素</td></tr><tr><td>li:nth-child(3)</td><td>选取第三个li元素</td></tr><tr><td>li:nth-child(2n)</td><td>选取第偶数个的li元素</td></tr><tr><td>a::attr(href)</td><td>获取a标签的href属性值</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 xpath 和 css 选择器进行提取</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    url = response.xpath(<span class="string">&#x27;//h2[@class=&quot;news_entry&quot;]/a/@href&#x27;</span>).extract_first(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    url = response.css(<span class="string">&#x27;//h2[class=&quot;news_entry&quot;] a::attr(href)&#x27;</span>).extract_first(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    因为 <strong>response.xpath 和 response.css 都会构建 Selector 选择器对象</strong>，会返回出一个满足匹配的所有元素集合，所以如果进行后续的每一个元素的单独处理就需要获取每一个元素。对于这个 selector 对象也可以使用 scrapy.Selector(response) 去自行构建，只需要将下载后的 html 文档作为 response 参数传入即可 </p><p>​    <strong><code>extract_first(&quot;&quot;)</code> 方法，表示返回从匹配的元素集合中第一个元素，这里还给了个空字符串的参数，表示如果没有获取到元素则给一个空字符</strong></p><p>​    <code>extract()</code> 方法，则是就是直接返回列表，不过要注意使用 extract 后通过索引方式获取第一个节点，如果是空列表会抛出异常，所以只为了获取第一个节点元素推荐使用 extract_first 方法</p><p>​    另外，<strong>在爬取页面时，需要将 settings 配置文件的 ROBOTSTXT_OBEY 的值改为 False</strong>，因为有些网站会有 robots 一些，规定了网站的哪些页面是拒绝爬取的，可以直接在网站的 url 后，加上 “robots.txt” 查看。所以 scrapy 默认是 ROBOTSTXT_OBEY = True，会遵守这个 robots 协议，那可能会导致某些内容不能爬取，所以需要将个参数的值改为 False</p><h3 id="跟进爬取"><a href="#跟进爬取" class="headerlink" title="跟进爬取"></a>跟进爬取</h3><p>​    在 spider 中爬虫类默认只给了一个 parse 的方法去对 response 进行提取，但是通常来说，都需要对其中有用的 url 去进行跟进爬取来获得更多数据。常见的比如分页，当给定一个初始页的 url 之后，需要对后续的页面也进行提取，所以在 parse 的方法中就可以使用 python 的 yield 方式抛出请求让引擎去继续调度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以博客园的新闻页为例</span></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request   <span class="comment"># 或则 from scrapy.http import Request</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1.获取新闻列表页中的新闻url并交给scrapy进行下载后调用对应的解析方法</span></span><br><span class="line"><span class="string">        2.获取下一页的url并交给scrapy下载，完成后交给parse继续跟进</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># next_url = response.css(&quot;div.pager a:last-child::text&quot;).extract_first(&quot;&quot;)  # css选择器提取文本使用 ::text</span></span><br><span class="line">        <span class="comment"># if next_url == &quot;Next &gt;&quot;:</span></span><br><span class="line">        <span class="comment">#     next_url = response.css(&quot;div.pager a:last-child::attr(href)&quot;).extract_first(&quot;&quot;)</span></span><br><span class="line">        <span class="comment">#     yield Request(parse.urljoin(response.url, next_url), callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        next_url = response.xpath(<span class="string">&quot;//a[contains(text(), &#x27;Next &gt;&#x27;)]/@href&quot;</span>).extract_first(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> Request(parse.urljoin(response.url, next_url), callback=self.parse)</span><br></pre></td></tr></table></figure><p>​    当 response 在 spider 进行解析时，如果最后使用 yield 返回，那么 yield 的 Request 对象会立即发给引擎然后紧接着继续进行解析操作。另外，这里的 Request 的对象中包含一个必要的参数 callback，这个参数用来设置得到 response 后是到哪一个解析方法中进行处理，因为这里只是提取下一页所以依然回调的是 parse 方法，如果是要对详情页的分析，就需要自定义一个解析方法专门处理对应的 response 对象进行解析</p><p>​    对于现在很多数据都是通过请求等方式进行动态获取的，也就意味着使用初始的 start_urls 中下载得到的 response 实际上不会包含需要的动态数据，那么就需要通过在浏览器的开发者工具里去判断哪一个请求可能是包含这些数据的，得到 url 后再去进行拼接并发起请求，这样就可以得到 json 序列化的动态数据</p><p>​    但是已经说了 <strong>scrapy 是一个异步框架，那么如果使用 Request 去封装发起请求，就会将 parse 方法变成了同步代码，也就会造成阻塞</strong>。所以 parse 的 yield 就又一次凸显功能了，<strong>利用 yield 返回，通过 callback 去执行回调，那么 yield 返回的 Request 就会利用到异步</strong>，但与此同时，编写就会更加麻烦，需要多编写其他的解析方法，同时考虑到持久化，还需要将已得到的数据传递到之后的解析方法中</p><p>​    需要注意的是，这里使用了 urljoin 这个方法，目的是为了进行路由的拼接，因为有些网站中，比如图片的 href 属性中其实只会有一个子路由，所以如果是要用跳到这个图片地址，需要手动拼接上域名，得到完整的 url</p><p>​    一种方法就是判断是否分析得到的头部是否含有 http 或 https，然后再手动用字符串拼接成完整 url。这里则是用 <strong>urllib 的 parse 模块，其中的 urljoin 方法可以自行去判断，如果 url 中有域名不会改动第二个 url 参数，如果没有则会将参数中的域名和 url 拼接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">&#x27;https://www.wei-foun.github.io/article/123&#x27;</span></span><br><span class="line">path_url = <span class="string">&#x27;/news/12333&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(parse.urljoin(base_url, path_url))    <span class="comment"># https://www.wei-foun.github.io/news/12333</span></span><br><span class="line"></span><br><span class="line">path_url = <span class="string">&#x27;https://www.wei-foun.github.io/news/12333&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(parse.urljoin(base_url, path_url))    <span class="comment"># https://www.wei-foun.github.io/news/12333</span></span><br></pre></td></tr></table></figure><p>​    <strong>注意：上面的 path_url 中第一个字符是 ‘/‘，如果使用 urljoin 方法，path_url 的第一个字符不是 ‘/‘，会造成 urljoin 直接将 path_url 当做子路径加在 base_url 之后，例如 <code>https://www.wei-foun.github.io/article/123/news/12333</code></strong></p><h3 id="命令行的调试"><a href="#命令行的调试" class="headerlink" title="命令行的调试"></a>命令行的调试</h3><p>​    命令行 cd 进入到项目录下，输入  <code>scrapy shell 完整的 url</code>。既然 pycharm 可以有办法调试，为什么还要使用命令行呢？因为在 pycharm 中定义的 main 调试文件，每一次去 debug 时都会重新去发起一个请求来得到响应的结果，这意味着如果频繁在 pycharm 中边写边 debug 容易出现被服务端发现然后被禁的问题。所以对于解析的步骤如果要进行调试判断，可以在命令行使用 shell 参数去获取 response 对象，以此在命令行里使用 xpath 或 css 去进行元素解析，这样相比在 pycharm 中 debug 会去发新请求而言，使用 shell 参数去获取响应后，去测试是否正确解析到元素时，不会导致反复的发送请求</p><h3 id="item-数据传递"><a href="#item-数据传递" class="headerlink" title="item 数据传递"></a>item 数据传递</h3><p>​    scrapy 的 items 可以理解成对爬取数据进行持久化保存的时候前对所有提取数据的容器，类似字典的形式存储。而且 <strong>items 中只有一种类型字段就是 Field()</strong></p><p>​    对于需要多次 yield 来提交 Request 给到下载器进行像动态数据或是详情页面的数据页面，通常需要将已经解析得到的数据进行传递，对于创建的 spider 类中 parse 方法，yield 可以将请求返回，也可以直接返回 item。如果是 yield Request 则就是交给下载器去下载，yield item 对象时，则会将这个 item 对象给到 pipelines.py 做后续持久化相关操作</p><p>​    使用命令创建一个 spider 时，items.py 会自动生成一个 item 的类，<strong>默认继承 scrapy.Item</strong>。那么就只需要在这里将需要的信息创建一个字段即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArticlespiderItem</span>(scrapy.Item):</span><br><span class="line">    artimg_url = scrapy.Field()</span><br><span class="line">    artimg_path = scrapy.Field()</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    create_date = scrapy.Field()</span><br><span class="line">    content = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br><span class="line">    comment_num = scrapy.Field()</span><br><span class="line">    view_num = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    url_object_id = scrapy.Field()</span><br></pre></td></tr></table></figure><p>​    那么在 spider 类中，只需要导入整个 items 的模块，实例化这个类后，就可以将解析到的数据赋值给这个 item，然后在 yield 时，使用 meta 参数将这个 item 通过字典传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> items <span class="keyword">import</span> ArticlespiderItem</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">...</span><br><span class="line">    artice_item = ArticlespiderItem()    <span class="comment"># 实例化定义的 item 对象，将解析的内容赋值给属性</span></span><br><span class="line">    artice_item[title] = response.xpath(<span class="string">&quot;//*[@id=&#x27;news_title&#x27;]//a/text()&quot;</span>).extract_first(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">yield</span> Request(url=url, meta=&#123;<span class="string">&quot;artice_item&quot;</span>,artice_item&#125;, callback=parse_detail)</span><br><span class="line">    <span class="comment"># meta 参数可以将 item 对象继续往后续的请求传递，让后面的解析使用</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_detail</span>(<span class="params">self, response</span>):</span><br><span class="line">    artice_item = response.meta.get(<span class="string">&quot;artice_item&quot;</span>, <span class="string">&quot;&quot;</span>)   <span class="comment"># response.meta.get 获取携带的 item 对象</span></span><br><span class="line">    content = response.xpath(<span class="string">&quot;//*[@id=&#x27;news_content&#x27;]&quot;</span>).extract()[<span class="number">0</span>]</span><br><span class="line">    artice_item[content] = content</span><br><span class="line">    <span class="keyword">yield</span> artice_item</span><br></pre></td></tr></table></figure><h3 id="图片自动下载"><a href="#图片自动下载" class="headerlink" title="图片自动下载"></a>图片自动下载</h3><p>​    scrapy 本身提供了对图片和文件的自动下载，前提需要在 items 类中创建两个字段   <code>image_urls = scrapy.Field()</code> 和 <code>images = scrapy.Field()</code>，前者用来存储图片的 url，后者用来保存图片数据</p><p>​    然后， <strong>settings 配置中设置 <code>ITEM_PIPELINES = &#123;&#39;scrapy.contrib.pipeline.images.ImagesPipeline&#39;: 1&#125;</code>，同时需要配置一个图片的保存目录 <code>IMAGES_STORE = &#39;/path/to/valid/dir&#39;</code></strong></p><p>​    <strong>注意，在 parse 方法中给 item 实例的 image_urls 必须是一个 列表</strong>，当 spider 执行到管道时，会进入到启用的 ImagesPipeline，会去对 item 实例的 image_urls 进行遍历，取出图片的 url ，交给下载器去下载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> response.meta.get(<span class="string">&quot;artimg_url&quot;</span>, <span class="string">&quot;&quot;</span>):</span><br><span class="line"><span class="comment"># 判断封面图是否存在，存在就加入到列表中，因为使用自动爬取图片时，会进行循环，直接是否字符串会引发错误</span></span><br><span class="line">article_item[<span class="string">&quot;artimg_url&quot;</span>] = [response.meta.get(<span class="string">&quot;artimg_url&quot;</span>, <span class="string">&quot;&quot;</span>)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 不存在，直接赋空列表</span></span><br><span class="line">article_item[<span class="string">&quot;artimg_url&quot;</span>] = []</span><br></pre></td></tr></table></figure><p>​    如果 image_urls 字段的值不是列表类型，只是一个 url 的字符串，那么遍历就只会得到第一个字符，并抛出一个 ValueError</p><p>​    不过，通常情况下不会直接在配置文件中直接复制图片目录的绝对路径，所以可以通过创建 main 调试文件那样，在 settings 文件中导入根目录，然后和图片目录进行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line">project_img = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">IMAGES_STORE = os.path.join(project_img, <span class="string">&quot;images&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    同样，根据需要可以对自带的 ImagesPipeline 进行定制，可以在 pipelines 文件中自定义一个 pipeline 类去继承，同时需要将 settings 的 <code>ITEM_PIPELINES</code> 中的配置改成自己设置的 pipeline 类 <code>&#39;ArticleSpider.pipelines.ArticleImgPipeline&#39;: 1</code>，<strong>配置后面的数字表示优先级，数字越小，越优先执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleImgPipeline</span>(<span class="title class_ inherited__">ImagesPipeline</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自动去下载文章封面图，并获取图片的保存路径&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">item_completed</span>(<span class="params">self, results, item, info</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;artimg_url&quot;</span> <span class="keyword">in</span> item:</span><br><span class="line">            artimg_path = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> ok, value <span class="keyword">in</span> results:</span><br><span class="line">                artimg_path = value[<span class="string">&quot;path&quot;</span>]    <span class="comment"># 获取图片的保存路径</span></span><br><span class="line">            item[<span class="string">&quot;artimg_path&quot;</span>] = artimg_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item   <span class="comment"># pipeline 类中方法最后一定要将 item 进行返回，否则其余开启的 pipeline 就无法获取这个 item</span></span><br></pre></td></tr></table></figure><p>​    当图片的 url 发出请求后，会被管道处理，进入到 item_completed 方法中，图片的下载会返回 True 和 False 来表示，另外 image_info_or_error 的字典，也就是参数的 results 会包含三个字段，url 表示图片的 url，path 是图片保存的路径，checksum 是图片的 md5 值</p><h3 id="Json-文件存储"><a href="#Json-文件存储" class="headerlink" title="Json 文件存储"></a>Json 文件存储</h3><p>​    同样需要在 pipelines 文件中去实现，并在 settings 中进行配置，对于 json 方式保存数据，可以自己定义，也可以使用 scrapy 自带的专门用于 json 存储的 pipeline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JsonWithEncodingPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将解析的item数据存储在json文档中&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.f = codecs.<span class="built_in">open</span>(<span class="string">&quot;article.json&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="comment"># codecs 是一个内置库，使用 codecs.open 来打开文件时，会自动将内容先转换为 unicode 编码，然后根据所给的编码参数，将内容编码到文件</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        lines = json.dumps(<span class="built_in">dict</span>(item), ensure_ascii=<span class="literal">False</span>) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">        <span class="comment"># ensure_ascii=False 是为了防止出现中文乱码</span></span><br><span class="line">        self.f.write(lines)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure><p>​    一般操作文件会使用两个方法：<strong>open_spider(self, spider)</strong> 和 <strong>close_spider(self, spider)</strong>，分别用来开启文件上下文，和操作完成后关闭文件。如果要对 item 中数据保存到 json，需要先将 item 转换为 字典 形式，才能使用 json.dumps</p><p>​    scrapy 中也提供了  <strong>JsonExporterPipeline</strong> ，这个类用于存储 json 的内容 <code>from scrapy.exporters import JsonItemExporter</code>，除此之外还有其他各种文件类型存储的 pipeline</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> JsonItemExporter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JsonExporterPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用自带的export的一些方法实现对items的json序列化&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.f = <span class="literal">None</span></span><br><span class="line">        self.exporter = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.f = <span class="built_in">open</span>(<span class="string">&quot;article_exporter.json&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">        self.exporter = JsonItemExporter(self.f, encoding=<span class="string">&quot;utf8&quot;</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        self.exporter.start_exporting()  <span class="comment"># 自带的 item export 需要调用 start_exporting() 开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        self.exporter.export_item(item)  <span class="comment"># 并通过 export_item 方法将 item 参数序列化，并写入文件</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.exporter.finish_exporting() <span class="comment"># 最后调用 finish_exporting() 来关闭 export</span></span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure><p>​    对于所有的 item exporter，scrapy  都提供了三个方法进行一次完整的处理，但是调用前，需要先实例化使用的 item exporter 类</p><p>​    1）调用方法   <code>start_exporting()</code> 以标识 exporting 过程的开始</p><p>​    2）对要导出的每个项目调用   <code>export_item()</code> 方法，并将需要序列化的 item 作为参数传入</p><p>​    3）最后调用   <code>finish_exporting()</code> 表示 exporting 过程的结束</p><p>​    另外 JsonItemExporter 这个类，会将所有的字典结果都放在一个列表里，JsonLinesItemExporter 则是将每一个 json 后的字典单独放入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># JsonItemExporter </span><br><span class="line">[&#123;&quot;name&quot;: &quot;Color TV&quot;, &quot;price&quot;: &quot;1200&quot;&#125;,</span><br><span class="line">&#123;&quot;name&quot;: &quot;DVD player&quot;, &quot;price&quot;: &quot;200&quot;&#125;]</span><br><span class="line"></span><br><span class="line"># JsonLinesItemExporter </span><br><span class="line">&#123;&quot;name&quot;: &quot;Color TV&quot;, &quot;price&quot;: &quot;1200&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;DVD player&quot;, &quot;price&quot;: &quot;200&quot;&#125;</span><br></pre></td></tr></table></figure><p>​    注意，对于主体逻辑部分的 process_item 方法，结束是必须将 item 返回，因为在配置文件中   <code>ITEM_PIPELINES</code> 可能配置多个 pipeline，所以如果不返回 item 其余的管道就不能进一步做后续处理</p><p>​    但是如果明确不希望返回 item 让后续 pipeline 去执行自己的 process_item 方法，<strong>通过导入 <code>from scrapy.exception import DropItem</code> 可以抛出 <code>DropItem()</code> 异常，将当前 item 丢弃，这样其余的 pipeline 就不会去执行自己的 process_item 方法来处理</strong></p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>​    以最常见的 mysql 为例，在 pipeline 中就要运用 mysql 的第三方库去实现数据的插入，最常见的库有 pymysql 和 mysqlclient，两个都是由统一作者编写的。pymysql 是纯 Python 实现的，安装和使用都方便，但是插入效率上要比 mysqlclient 慢；<strong>mysqlclient 在 Python3 中的包名是 MySQLdb，是一个 C 语言扩展模块</strong>，在安装编译上会有一些问题，但是在插入效率上基本和 mysql 的效率一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.douban.com/simple pymysql</span><br><span class="line">pip install -i https://pypi.douban.com/simple mysqlclient</span><br></pre></td></tr></table></figure><p>​    使用 pip 去安装 mysqlclient 时，可能会出现安装问题，可以直接从  <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/</code> 网站中搜索 mysqlclient 选择匹配的版本进行下载，然后直接使用 <code>pip install [下载的 whl 文件]</code> 也能实现安装</p><p>​    有了第三方库的支持，接下来的 mysql 写入就和之前的 json 文件持久化类似了，根据提供的方法创建连接并插入执行 sql 语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb    <span class="comment"># 注意 mysqlclient 的包名是 MySQLdb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MysqlPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;连接mysql进行数据存储&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line">        self.cur = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">open_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.conn = MySQLdb.connect(       <span class="comment"># 使用 MySQLdb.connect 建立 mysql 连接</span></span><br><span class="line">            host=<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">            port=<span class="number">3306</span>,</span><br><span class="line">            user=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            password=<span class="string">&quot;123456&quot;</span>,</span><br><span class="line">            db=<span class="string">&quot;test_spider&quot;</span>,</span><br><span class="line">            charset=<span class="string">&quot;utf8&quot;</span>,                <span class="comment"># 设置编码</span></span><br><span class="line">            use_unicode=<span class="literal">True</span>               <span class="comment"># 如果设置了 charset 则会默认使用 use_unicode=True，作用是对文本内容进行编码，True 表示将内容作为 unicode 对象，False 则是作为字符串对象</span></span><br><span class="line">        )</span><br><span class="line">        self.cur = self.conn.cursor()      <span class="comment"># 创建游标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        insert_sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            insert into cnblogs_article(url_object_id, title, url, artimg_url, artimg_path, tags, comment_num,</span></span><br><span class="line"><span class="string">            view_num, content, create_date) </span></span><br><span class="line"><span class="string">            values(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        params = []</span><br><span class="line">        params.append(item.get(<span class="string">&quot;url_object_id&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        params.append(<span class="string">&#x27;,&#x27;</span>.join(item.get(<span class="string">&quot;artimg_url&quot;</span>, [])))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;artimg_path&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;tags&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;comment_num&quot;</span>, <span class="number">0</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;view_num&quot;</span>, <span class="number">0</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        params.append(item.get(<span class="string">&quot;create_date&quot;</span>, <span class="string">&quot;1970-07-01&quot;</span>))</span><br><span class="line">        self.cur.execute(insert_sql, <span class="built_in">tuple</span>(params))     <span class="comment"># cur.execute 来执行 sql</span></span><br><span class="line">        self.conn.commit()                 <span class="comment"># 用 conn 去 commit 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close_spider</span>(<span class="params">self, spider</span>):</span><br><span class="line">        self.cur.close()</span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure><h4 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h4><p>​    注意：在数据库建表的时候，这里是将 url_object_id 用 md5 方法将一个随机值作为了主键。当 spider 在 debug 或二次爬取时，数据库就会存在与插入语句的 url_object_id 相同的数据，这时就会抛出主键冲突的异常，因此需要对 insert 的 sql 语句进行修改，一旦数据已经存在，就对数据中的某些字段进行更新操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on duplicate key update 是 mysql 的特有语法，目的是在进行数据插入时相同数据会出现的异常情况下对数据进行更新操作</span></span><br><span class="line">insert_sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            insert into cnblogs_article(url_object_id, title, url, artimg_url, artimg_path, tags, comment_num,</span></span><br><span class="line"><span class="string">            view_num, content, create_date) </span></span><br><span class="line"><span class="string">            values(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)</span></span><br><span class="line"><span class="string">            on duplicate key update </span></span><br><span class="line"><span class="string">            view_num=values(view_num)，</span></span><br><span class="line"><span class="string">            comment_num=values(comment_num);</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="异步入库"><a href="#异步入库" class="headerlink" title="异步入库"></a>异步入库</h4><p>​    上面使用 mysqlclient 已经可以完成对数据的持久化，但是因为 scrapy 是异步框架，对于 mysqlclient 来说这样的插入依然是同步代码，scrapy 的爬取速度远远大于将数据插入到数据库的速度，所以可以对同步的入库进行优化改为异步方式。<strong>twisted 的 enterprise 模块提供一个 adbapi 的接口，专门用于实现数据的异步入库</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MysqlTwistedPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用twisted实现异步状态录入数据到mysql数据库&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dbpool</span>):</span><br><span class="line">        self.dbpool = dbpool</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_settings</span>(<span class="params">cls, settings</span>):</span><br><span class="line">        <span class="comment"># 使用settings文件，定义配置变量</span></span><br><span class="line">        <span class="keyword">from</span> MySQLdb.cursors <span class="keyword">import</span> DictCursor</span><br><span class="line">        db_params = <span class="built_in">dict</span>(</span><br><span class="line">            host=settings[<span class="string">&quot;MYSQL_HOST&quot;</span>],</span><br><span class="line">            user=settings[<span class="string">&quot;MYSQL_USER&quot;</span>],</span><br><span class="line">            password=settings[<span class="string">&quot;MYSQL_PASSWORD&quot;</span>],</span><br><span class="line">            port=<span class="number">3306</span>,</span><br><span class="line">            db=settings[<span class="string">&quot;MYSQL_DBNAME&quot;</span>],</span><br><span class="line">            use_unicode=<span class="literal">True</span>,</span><br><span class="line">            charset=<span class="string">&quot;utf8&quot;</span>,</span><br><span class="line">            cursorclass=DictCursor   <span class="comment"># 以字典的形式将记录返回显示，默认使用的元组形式返回</span></span><br><span class="line">        )</span><br><span class="line">        db_pool = adbapi.ConnectionPool(<span class="string">&quot;MySQLdb&quot;</span>, **db_params)  <span class="comment"># 使用 adbapi 连接数据库，创建连接池</span></span><br><span class="line">        <span class="keyword">return</span> cls(db_pool)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert, item)</span><br><span class="line">        <span class="comment"># dbpool.runInteraction 方法会以异步方式调用 do_insert 函数，并将参数 item 传给 do_insert 函数</span></span><br><span class="line"></span><br><span class="line">        query.addErrback(self.handle_error, item, spider)</span><br><span class="line">        <span class="comment"># addErrback 是执行插入时如果报错则调用 handle_error 的函数用来查看错误</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_error</span>(<span class="params">self, failure, item, spider</span>):</span><br><span class="line">        <span class="comment"># 错误回调函数的第一种参数 failure 是默认传递的，表示错误信息，其余参数则可根据需要添加，后面 item 和 spider 可根据需要传递</span></span><br><span class="line">        <span class="built_in">print</span>(failure)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_insert</span>(<span class="params">self, cursor, item</span>):</span><br><span class="line">        <span class="comment"># 这里把和之前同步入库的 sql 全部放在了 item 中的 get_insert_sql 方法里，该方法只需返回 insert_sql, params 去交给 cursor 进行执行即可</span></span><br><span class="line">        insert_sql, params = item.get_insert_sql()</span><br><span class="line">        cursor.execute(insert_sql, params)</span><br></pre></td></tr></table></figure><p>​    这个类中使用一个 <strong>类方法 from_setting，默认需要一个参数 setting，表示的就是全局配置的 settings 文件</strong>。利用这个方法，可以将数据库的连接配置放在 settings 文件中，实现配置信息与逻辑代码分离</p><p>​    <strong>twisted 的 adbapi 提供了异步入库的支持，首先需要通过 adbapi.ConnectionPool 来创建一个连接池，第一个参数是一个字符串表示使用的 mysql 模块，第二个参数则是数据库的连接配置设置</strong>。然后使用 cls 方法实例化连接池对象并返回，那么在 pipeline 类的 init 方法中既可以得到这个异步连接池对象</p><p>​    process_item 方法中，只需要使用得到的连接池对象 self.dbpool 去调用 runInteraction 方法，然后连接池对象会自动传入 cursor 给第一个参数 do_insert 的方法，同时需要将 item 给这个方法，对于 sql 的执行就可以在 do_insert 中实现</p><p>​    针对入库中可能遇到的错误，可以将 runInteraction 方法的结果赋值给 query，通过 <strong>query.addErrback() 方法对异常处理进行回调，第一个参数是出错的回调方法</strong>，item 和 spider 可根据需要传递，一旦出现异常错误，信息会赋给参数 failure，这个参数是定义 addErrback 的回调方法时，会自动进行传递的</p><h3 id="item-loaders"><a href="#item-loaders" class="headerlink" title="item loaders"></a>item loaders</h3><p>​    直接在 response 上使用 xpath 和 css 进行解析提取的元素，返回结果都是一个列表的形式，因此会有很多解析都会使用到 extract_first 这样的方法，并且对于一些解析后的字符串，甚至还需要利用正则或是其他方式再去进行一个提取，这就使得 parse 中的解析操作会随着需要提取的数据增多，而导致这个方法的内容非常繁琐</p><p>​    scrapy 提供的 Item Loaders 就可以很好的对解析提取进行一个优化，并且也方便扩展和维护。简单来说，ItemLoader 实现了原本 页面解析 与 item 实例对象属性赋值 的整合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.contrib.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> myproject.items <span class="keyword">import</span> Product</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    l = ItemLoader(item=Product(), response=response)</span><br><span class="line">    l.add_xpath(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;//div[@class=&quot;product_name&quot;]&#x27;</span>)</span><br><span class="line">    l.add_xpath(<span class="string">&#x27;price&#x27;</span>, <span class="string">&#x27;//p[@id=&quot;price&quot;]&#x27;</span>)</span><br><span class="line">    l.add_css(<span class="string">&#x27;stock&#x27;</span>, <span class="string">&#x27;p#stock]&#x27;</span>)</span><br><span class="line">    l.add_value(<span class="string">&#x27;last_updated&#x27;</span>, <span class="string">&#x27;today&#x27;</span>) <span class="comment"># you can also use literal values</span></span><br><span class="line">    <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure><p>​    <strong>导入 ItemLoader 类后，需要进行实例化，第一个参数就是 item，第二个参数则是下载器得到的 response</strong>。从官网的例子可以看到，这个实例对象可以通过 <strong>add_xpath，add_css，add_value</strong> 三种方式去数据获取，比如要获取 url，<code>l.add_value(&quot;url&quot;, response.url)</code>，且 <strong>默认得到的形式都是一个列表的形式</strong></p><p>​    当数据都被解析后，需要   <strong>调用 ItemLoader 的 <code>load_item()</code> 方法将数据填充到 item 中</strong>，最后只需要将这个 item 对象返回即可</p><h4 id="Field-的定制"><a href="#Field-的定制" class="headerlink" title="Field 的定制"></a>Field 的定制</h4><p>​    上面使用 item loader 去自动解析数据，但获取的都是列表对象，这样形式并不能直接入库，因此就需要对 item 中的内容做进一步的处理，<strong>items 中 <code>scrapy.Field()</code> 的字段都其实包含两个参数，input_processor 和 output_processor</strong> 两个处理器，来对进入和输出进行各自的处理</p><p>​    通常情况下，item loader 解析获取的列表的内容会需要进行多种操作，因此 <strong>scrapy 的 processor 提供了一个类 MapCompose，它可以接受多个参数（函数），并且在处理时，会按照顺序依次初始的列表数据通过设定函数做处理</strong></p><p>​    除此之外，对于大部分只有一个元素的列表而言，只需要提取第一个字符串元素这样的 item，processor 也提供了一个 TakeFirst 类，方便做提取</p><p>​    另外，对于含有多个元素的列表，如果是要通过     <code>&#39;,&#39;.join()</code> 来做一个拼接的话，processor 中也有 <code>Join</code> 来做这类的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> TakeFirst，MapCompose, Join</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filter_price</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">if</span> value.isdigit():</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>(scrapy.Item):</span><br><span class="line">    name = scrapy.Field(</span><br><span class="line">        input_processor=MapCompose(remove_tags),</span><br><span class="line">        output_processor=Join(),</span><br><span class="line">    )</span><br><span class="line">    price = scrapy.Field(</span><br><span class="line">        input_processor=MapCompose(remove_tags, filter_price),</span><br><span class="line">        output_processor=TakeFirst(),</span><br><span class="line">    )</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scrapy.contrib.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il = ItemLoader(item=Product())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il.add_value(<span class="string">&#x27;name&#x27;</span>, [<span class="string">u&#x27;Welcome to my&#x27;</span>, <span class="string">u&#x27;&lt;strong&gt;website&lt;/strong&gt;&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il.add_value(<span class="string">&#x27;price&#x27;</span>, [<span class="string">u&#x27;&amp;euro;&#x27;</span>, <span class="string">u&#x27;&lt;span&gt;1000&lt;/span&gt;&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il.load_item()</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">u&#x27;Welcome to my website&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="string">u&#x27;1000&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>​    如果自定义的 item 类中很多字段其实都是只要从列表中提取第一个，虽然给每一个 Field 中添加一个 TakeFirst 方法可以完成，但这就显得代码不够简洁。因此可以通过继承提供的 ItemLoader 类去修改默认的使用方法可以更方便的去做修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleItemLoader</span>(<span class="title class_ inherited__">ItemLoader</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义itemloader类，让所有item类型都只取第一个，即每一个值的类型都是str&quot;&quot;&quot;</span></span><br><span class="line">    default_output_processor = TakeFirst()</span><br></pre></td></tr></table></figure><p>​    <strong>ItemLoader 类中默认的 input_processor 和 output_processor 使用都是 Identity()，也就是返回一个列表形式</strong>。通过修改 <code>default_output_processor</code> 就可以让 item 每一个字段都默认去提取列表的第一个字符串元素，于此同时，在 parse 方法中修改更改实例的 ItemLoader 改为自定义的 ArticleItemLoader 类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    l = ArticleItemLoader(item=Product(), response=response)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>​    通过这样的方法，item 每个字段都会变成 str 类型。但是对于 url 这样的类型，会需要遍历去给下载器，就必须要是原来的 list 类型，那就可以单独在 itme 类中，设置 Field 参数为默认的 Identity()</p><h3 id="scrapy-的-url-去重"><a href="#scrapy-的-url-去重" class="headerlink" title="scrapy 的 url 去重"></a>scrapy 的 url 去重</h3><p>​    默认在 scrapy.dupefilters 中有两个类，一个是 BaseDupeFilter，一个是基于 BaseDupeFilter 实现的 RFPDupeFIlter 类，这个类默认是实现 Base 中的方法完成对请求 URL 的去重，只需要在 <strong>settings 文件中配置 <code>DUPEFILTER_CLASS = &#39;scrapy.dupefilters.RFPDupeFilter&#39;</code></strong>，这样在发送请求下载时，就会自动对 url 去重，而 BaseDupeFilter 中的 request_seen 方法是去重的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.utils.request <span class="keyword">import</span> request_fingerprint</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_seen</span>(<span class="params">self, request</span>):</span><br><span class="line">    fp = self.request_fingerprint(request)</span><br><span class="line">    <span class="keyword">if</span> fp <span class="keyword">in</span> self.fingerprints:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    self.fingerprints.add(fp)</span><br><span class="line">    <span class="keyword">if</span> self.file:</span><br><span class="line">        self.file.write(fp + os.linesep)</span><br></pre></td></tr></table></figure><p>​    调度器会执行 enqueue_requests 方法，在内部判断 dont_filter 这个参数以及判断 dupefilter 模块的 request_seen 方法</p><p>​    request_seen 中通过 <strong>request_fingerprint</strong> 方法对每一个请求的做一个 hashlib.sha1 编码处理，其中包含了请求方式，请求 url，请求体，对三者进行编码得到唯一标识</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp = hashlib.sha1()</span><br><span class="line">fp.update(to_bytes(request.method))</span><br><span class="line">fp.update(to_bytes(canonicalize_url(request.url, keep_fragments=keep_fragments)))</span><br><span class="line">fp.update(request.body <span class="keyword">or</span> <span class="string">b&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    并且加入到 fingerprints 这个集合中，每一个标识符会在 fingerprints 中判断，True 就说明是重复 url，跳过下载继续往后执行其他操作，False 则是将 url 加入到集合里</p><p>​    除此之外，也可以 <strong>在 yield 的 Request 时，设置 dont_filter = True 来实现去重</strong></p><h4 id="去重策略"><a href="#去重策略" class="headerlink" title="去重策略"></a>去重策略</h4><p>​    1）最方便的一种方式，就是直接将爬取的 url 入库，然后每一次对新的 url 都去到数据库中查询一遍，来判断是否已经存在。但显然这种方式虽然简单，但是效率并不高，需要遍历一遍表来查询，且数据量一旦变大，所占用的空间也会非常大</p><p>​    2）直接将 url 放到 set 集合中，这样只需要 O(1) 的代价就能查询到 url，但是这种方式也会随着数据量增多，而导致占用更多内存空间</p><p>​    3）将 url 进行算法编码，来生成一个固定长度的 hash 值，然后在放入到 set 中，这样相比直接保存 url 在空间占用上是成倍的减少</p><p>​    4）使用 bitmap 算法（位图算法），将 url 通过 hash 函数映射到某一位（bit）上，这样在存储空间占用上就是成几十倍的减小，能大大压缩使用的内存空间，但问题是 hash 函数会导致不同的 url 会映射在相同的位置上</p><p>​    5）使用 bloomfilter（布隆过滤器），它在 bitmap 上做了进一步的优化，<strong>使用了多重 hash 来降低可能的结果冲突</strong></p><h3 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h3><p>​    和 spider 一样都是 scrapy 中的爬虫类，但是 crawlspider 是 spider 的子类，相比 spider，它的功能要比父类更多</p><p>​    spider 类的设计原则只是为了获得 start_url 也就是给的起始网页链接返回的响应数据，crawlspider 类则是可以定义规则（rules）提供对初始 url 返回中所有可能进一步获取数据的 url 进行下载爬取，比如获取每一页的页码数据。spider 中本身也支持跟进下载爬取，只是说需要自己去实现在初始返回的 response 提取到跟进 url 并通过 yield Request 来将 url 交给下载器获取响应，但是在 <strong>CrawlSpider 中就可以利用规则中的设置 LinkExtra 链接提取器，去自动获取到符合规则的 url，来触发 callback 获取下载后的 response</strong></p><h4 id="创建一个-CrawlSpider"><a href="#创建一个-CrawlSpider" class="headerlink" title="创建一个 CrawlSpider"></a>创建一个 CrawlSpider</h4><p>​    使用命令行进行创建前，依然需要先 cd 到项目目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider -t crawl 爬虫项目名称 域名</span><br></pre></td></tr></table></figure><pre><code>创建完成后在 spiders 目录下会创建对应的爬虫文件，且文件中的爬虫类继承 spiders 下的 CrawlSpider，同时在类中会有一个 rules 的元组，其中放置需要进行匹配的规则 Rule，以及一个 parse_item 方法</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.contrib.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> scrapy.contrib.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySpider</span>(<span class="title class_ inherited__">CrawlSpider</span>):</span><br><span class="line">    name = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;example.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;http://www.example.com&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=(<span class="string">&#x27;category\.php&#x27;</span>, ), deny=(<span class="string">&#x27;subsection\.php&#x27;</span>, )))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_item</span>(<span class="params">self, response</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    需要注意的是 crawlspider 的类中已经实现了原本 spider 的 <strong>parse 方法</strong>，所以 <strong>在创建的 crawlspider 类中不需要去复写</strong> 该方法，<strong>否则运行会出错</strong>。crawlspider 中 parse 方法则是去调用 _parse_response(response, self.parse_start_url, cb_kwargs={}, follow=True) 这个方法</p><p>​    _parse_response 方法其中又会去调用 process_results，而默认 process_results 接受了两个参数 response 和 results，且直接将 results 返回，而这个 results 就是执行 callback 后的结果，所以也可以通过复写 process_results 方法来进行一些自定义</p><p>​    <strong>如果需要对 parse 去做处理，可以使用 parse_start_url 这个方法</strong>，这个方法和 parse 一样都会接受一个 response 参数，crawlspider 中 parse_start_url 方法默认是返回了一个空列表</p><h4 id="提取规则"><a href="#提取规则" class="headerlink" title="提取规则"></a>提取规则</h4><p>​    Rule 可以称作是规则提取器，有三个主要参数，第一个参数 <strong>link_extractor</strong> 这个代表就是链接提取器，第二个参数 <strong>callback</strong> 代表对匹配链接提取器的链接的响应内容进行解析的回调函数，第三个参数 <strong>follow</strong> 代表对满足匹配的响应中是否跟进其中再次符合链接提取器的内容，这个参数的值是一个布尔值，默认当使用 callback 参数时，follow 的值为 True</p><p>​    对于 <strong>LinkExtractor 链接提取对象，支持三种提取方式：正则（创建默认使用的是正则），css，xpath</strong>。allow 参数就是允许匹配的内容，deny 参数是拒绝匹配的内容，两者选一即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则提取：默认创建时会自动使用正则</span></span><br><span class="line">Rule(LinkExtractor(allow=<span class="string">r&#x27;Items/&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># xpath提取：</span></span><br><span class="line">Rule(LinkExtractor(restrict_xpaths=<span class="string">&#x27;//div[@class=&quot;page_num&quot;]/a&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># css提取：</span></span><br><span class="line">Rule(LinkExtractor(restrict_css=<span class="string">&#x27;.page_num &gt; a&#x27;</span>), callback=<span class="string">&#x27;parse_item&#x27;</span>, follow=<span class="literal">True</span>),</span><br></pre></td></tr></table></figure><p>​    对于一个网站来说，其中会包含很多不同的 url，所以在 Rule 中可以创建多个 link_extractor 提取对象，在匹配时则会按照定义的顺序，使用第一个满足匹配的 callback 去执行</p><h3 id="反爬机制与反爬策略"><a href="#反爬机制与反爬策略" class="headerlink" title="反爬机制与反爬策略"></a>反爬机制与反爬策略</h3><p>​    爬虫：自动获取（批量获取）网站数据的程序</p><p>​    反爬虫：使用技术手段阻止爬虫程序的方法和机制</p><p>​    误伤：服务端的反爬技术将普通用户识别成了爬虫，导致用户不能正常访问</p><p>​    成本：指网站为了应对爬虫程序，投入的人力以及机器成本</p><p>​    拦截：即对识别到的爬虫程序进行请求拦截，拦截率越高，也会导致误伤率较高</p><h4 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h4><p>​    对于一些网站可能会对爬虫做一些频率上的限制，如果爬虫程序执行太快，频繁的请求就会被服务端检测并标识为爬虫，可能就会出现非 200 的状态码，来要求做验证，或是对 ip 限制时间访问防止本机一定时间内对网站发起请求。不过对服务端而言，设置 ip 限制很容易造成误伤</p><p>​    所以对于频率的限制来说，就需要对爬虫程序做一些改进，如果是对 ip 做限制（一般都不会 ip 做限制，因为局部网来说，对外 ip 只有几个），则可以用一些代理通过使用这些 ip 去对网站发请求，但这种方式对于一些小服务来说也会有损害，因为异步的 scrapy 可以短时间发起大量的请求，小型的服务可能在并发上不会做过多设置，会导致给服务端很大的压力</p><p>​    除了使用代理，scrapy 中还可以通过设置请求间隔的时间来做到不会频繁发起请求，而被检测到为爬虫。可以在 settings 中配置 <code>DOWNLOAD_DELAY=10</code> ，可以实现每隔 10 秒才发起一次请求，这个具体时间可以根据服务端的设置来设定</p><p>​    但是这个配置也依然可能会被检测到，因为服务端收到的请求的间隔时间都是完全一致 10 秒，也可能被认为是爬虫，所以 scrapy 还有另外一个配置 <code>RANDOMIZE_DOWNLOAD_DELAY=True</code>，该配置会在 0.5 - 1.5 之间产生一个随机值并乘以 <code>DOWNLOAD_DELAY</code> 所设置的时间，来实现不规律的请求时间间隔</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>​    <strong>用户代理，会包含在请求头部信息中</strong>，使服务端可以识别客户端，<strong>其中包括用户端的操作系统及版本，CPU类型，浏览器及版本等等一些信息</strong>。这是反爬最简单的一种设置，因为使用 Request 或是 Scrapy 等去请求页面时，请求信息中的 UA 信息不会自己表名或是使用本地浏览器的，而对于不同的浏览器，都有各自的 UA 信息</p><p>​    如果服务端会对 UA 进行检测，最简单的方式可以在 settings 中去设置一个 UA 的列表，然后在 yield 之前，随机从配置中获取一条 UA 并放入到字典后，给到 Request 的 headers 参数。这种方式的问题是需要自己去维护一个 UA 列表，且对于多个 spider 来说，同样的操作可能需要在多个 spider 实现</p><p>​    还有一种方式是直接使用 github 的随机获取 UA 的项目 fake-useragent，可以使用 pip 去安装  <code>pip intsall fake-useragent</code>，这个库提供了一个 UserAgent 类，可以实例化这个类，去调用不同的浏览器获取不同的 UA，同时还可以直接调用它的 random 方法来随机获取 UA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line"></span><br><span class="line">ua.ie</span><br><span class="line"><span class="comment"># Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US);</span></span><br><span class="line">ua.msie</span><br><span class="line"><span class="comment"># Mozilla/5.0 (compatible; MSIE 10.0; Macintosh; Intel Mac OS X 10_7_3; Trident/6.0)&#x27;</span></span><br><span class="line">ua[<span class="string">&#x27;Internet Explorer&#x27;</span>]</span><br><span class="line"><span class="comment"># Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.2; SV1; .NET CLR 3.3.69573; WOW64; en-US)</span></span><br><span class="line">ua.opera</span><br><span class="line"><span class="comment"># Opera/9.80 (X11; Linux i686; U; ru) Presto/2.8.131 Version/11.11</span></span><br><span class="line">ua.chrome</span><br><span class="line"><span class="comment"># Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2&#x27;</span></span><br></pre></td></tr></table></figure><p>​    有了这个库，就省去自己去维护一个列表，并且可以很方便的去获取，但还有一点前面说到可能会有多个 spider 都会需要这个 UA，即使获取很方便了，但是这样依然还需要给每个 spider 单独操作</p><h5 id="下载器中间件"><a href="#下载器中间件" class="headerlink" title="下载器中间件"></a>下载器中间件</h5><p>​    请求和响应从引擎到下载器中间会经过一个下载中间件 download middleware，所以可以自己创建一个 middleware 来对 request 去进行 UA 头部信息添加的操作，这样每一个 spider 的请求在经过下载器中间时都会触发这个 middleware 来自动加上 UA，最后只需要在 settings 的 <code>DOWNLOADER_MIDDLEWARES</code> 中配置上创建的 middleware 即可</p><p>​    <strong>下载中间件，提供了 process_request，process_response，process_exception 三个方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomUserAgentMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;随机产生user-agent&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, crawler</span>):</span><br><span class="line">        <span class="comment"># 调用父类初始化</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line">        self.ua_type = crawler.settings.get(<span class="string">&quot;USER_AGENT_TYPE&quot;</span>, <span class="string">&quot;random&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler</span>):</span><br><span class="line">        <span class="comment"># from_crawler 方法是 scrapy 用来创建一个爬虫的起点</span></span><br><span class="line">        s = cls(crawler)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        <span class="comment"># 爬虫会先执行 process_request 方法在进入下载器之前</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_ua</span>():</span><br><span class="line">            <span class="comment"># 在函数内部定义函数，类执行 ua.ua_type 方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(self.ua, self.ua_type)</span><br><span class="line">        request.headers.setdefault(<span class="string">&quot;User-Agent&quot;</span>, get_ua())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>​    使用 fake-useragent 并不绝对有用的，因为这个项目自己维护了一个 UA 信息，虽然是会更新但也可能有很多浏览器版本很老的 UA，某些网站可能会将很老版本的浏览器 UA 给禁掉，那么获取的 UA 也就无法使用了</p><p>​    <strong><code>process_request(request, spider)</code> 方法可以返回三个值，分别是 None ， Response 和 Request，或者抛出异常 IgnoreRequest</strong></p><p>​    返回 None，scrapy 将继续处理该 request，并执行其他 downloader middleware 中 process_request 方法，直到最后执行完成得到 response 才结束</p><p>​    返回 Response，那么 Downloader middleware 中优先级低的中间件，他们中的 process_request 和 process_exception 方法都不会被继续调用执行，然后 Downloader middleware 中每一个中间件的 process_response 方法则会被依次调用执行做各自的处理，最后将这个 response 返回给 spider</p><p>​    返回 Request，则这个对象会再次被放入到调度队列中，等待 scheduler 调用后，会再一次按照 Downloader middleware 中的优先级顺序去执行 process_request 方法</p><p>​    如果中间件中有 lgnoreRequest 被抛出，会依次执行 process_exception 方法去处理这个异常，如果没有被处理，则会触发 Request 的 errorback 方法回调，直到最后没有一个中间件处理它就会被忽略</p><h3 id="定制-spider-配置"><a href="#定制-spider-配置" class="headerlink" title="定制 spider 配置"></a>定制 spider 配置</h3><p>​    settings 文件的配置是应用于项目中创建的所有的 spider 的，这就可能会一个问题，对于不同的 spider 爬取的网站是不同的，比如最简单的 COOKIES_ENABLED 的配置。对于不用登陆网站，将改配置设为默认 False 是没问题，而对于需要登录的网站，如果禁止 cookie 携带，那爬虫程序就会无法去正常执行</p><p>​    所以，scrapy 中也提供对不同 spider 进行一些配置的私有定制， <strong>scrapy 中 spider 的 <code>__init__.py</code> 的源码中有一个属性 <code>custom_settings</code>，并且会去调用 <code>update_settings</code> 类方法将类和该属性的值更新到 settings</strong></p><p>​    因此，可以在一些需要定制配置的 spider 爬虫类中，创建一个  <code>custom_settings</code> 字典，将定制的配置加入进去</p><p>​    scrapy 的 settings 常见配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOT_NAME = <span class="string">&#x27;xxx&#x27;</span>       <span class="comment"># 配置项目名称</span></span><br><span class="line">SPIDER_MODULES = [<span class="string">&#x27;Amazon.spiders&#x27;</span>]      <span class="comment"># 配置爬虫应用的路径</span></span><br><span class="line">NEWSPIDER_MODULE = <span class="string">&#x27;Amazon.spiders&#x27;</span></span><br><span class="line">USER_AGENT = <span class="string">&#x27;xxxxxxxx&#x27;</span>     <span class="comment"># 设置请求头的用户代理信息</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span>      <span class="comment"># 是否遵循爬取的网站设置的爬虫协议，网站会有 robots.txt 文件固定爬取的限制</span></span><br><span class="line">COOKIES_ENABLED = <span class="literal">False</span>     <span class="comment"># 不使用 scrapy 的 cookie 中间件，开启的话请求都会 cookie 携带设置项，关闭的话，也可以 yield 的时候，自定义 headers</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">3</span>     <span class="comment"># 设置固定的下载延迟时间</span></span><br><span class="line">RANDOMIZE_DOWNLOAD_DELAY = <span class="literal">True</span>    <span class="comment"># 设置一个 0.5 - 1.5 的随机值和 DOWNLOAD_DELAY 的值相乘，做随机延迟</span></span><br><span class="line">DEPTH_LIMIT = <span class="number">3</span>    <span class="comment"># 设置爬取的深度，从初始页面开始，跟进几次新的页面</span></span><br><span class="line">SPIDER_MIDDLEWARES = &#123;<span class="string">&#x27;中间件&#x27;</span>: 优先级&#125;    <span class="comment"># 配置 spider 的中间件，对请求和响应做处理</span></span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;<span class="string">&#x27;中间件&#x27;</span>: 优先级&#125;    <span class="comment"># 配置下载器的中间件</span></span><br></pre></td></tr></table></figure><h3 id="spider-中间件"><a href="#spider-中间件" class="headerlink" title="spider 中间件"></a>spider 中间件</h3><p>​    是 scrapy 中一个重要组件，介于 engine 和 spider，用来处理 engine 发送过来的 response 对象，以及返回 spider 中产生的 item 和 request  对象，即：</p><p>​    1）在 Downloader 生成 response 发送给 spider 之前，对 response 做处理</p><p>​    2）在 spider 生成的 request 发送给 scheduler 之前，对 request 做处理</p><p>​    3）在 spider 生成 item 发送给 item pipeline 之前，对 item 进行处理 </p><p>​    当一个 spider 类被创建时，在 middleware.py 中会自动生成一个 spider 的 middleware 类，并将方法全部列举出来，大体上来说和 Downloader middleware 一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArticlespiderSpiderMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># Not all methods need to be defined. If a method is not defined,</span></span><br><span class="line">    <span class="comment"># scrapy acts as if the spider middleware does not modify the</span></span><br><span class="line">    <span class="comment"># passed objects.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler</span>):</span><br><span class="line">        <span class="comment"># This method is used by Scrapy to create your spiders.</span></span><br><span class="line">        s = cls()</span><br><span class="line">        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_spider_input</span>(<span class="params">self, response, spider</span>):</span><br><span class="line">        <span class="comment"># Called for each response that goes through the spider</span></span><br><span class="line">        <span class="comment"># middleware and into the spider.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Should return None or raise an exception.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_spider_output</span>(<span class="params">self, response, result, spider</span>):</span><br><span class="line">        <span class="comment"># Called with the results returned from the Spider, after</span></span><br><span class="line">        <span class="comment"># it has processed the response.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Must return an iterable of Request, dict or Item objects.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_spider_exception</span>(<span class="params">self, response, exception, spider</span>):</span><br><span class="line">        <span class="comment"># Called when a spider or process_spider_input() method</span></span><br><span class="line">        <span class="comment"># (from other spider middleware) raises an exception.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Should return either None or an iterable of Request, dict</span></span><br><span class="line">        <span class="comment"># or Item objects.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_start_requests</span>(<span class="params">self, start_requests, spider</span>):</span><br><span class="line">        <span class="comment"># Called with the start requests of the spider, and works</span></span><br><span class="line">        <span class="comment"># similarly to the process_spider_output() method, except</span></span><br><span class="line">        <span class="comment"># that it doesn’t have a response associated.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Must return only requests (not items).</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> start_requests:</span><br><span class="line">            <span class="keyword">yield</span> r</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spider_opened</span>(<span class="params">self, spider</span>):</span><br><span class="line">        spider.logger.info(<span class="string">&#x27;Spider opened: %s&#x27;</span> % spider.name)</span><br></pre></td></tr></table></figure><p>​    如果要启用 spider middleware，同样需要在 settings 中去进行配置 SPIDER_MIDDLEWARES，如果 spider middleware 中有不使用的，可以使用注释，也可以将 middleware 的值赋值为 None</p><p>​    process_spider_input 方法用来处理 response，结果要么返回 None 去继续通过其他的中间件，要么是抛出异常。process_spider_output 方法则是在处理 response 返回 result 时，会被调用，且返回结果必须是 request 或是 item 对象</p><h4 id="深度控制"><a href="#深度控制" class="headerlink" title="深度控制"></a>深度控制</h4><p>​    DepthMiddleware 是 scrapy 内置的一个 spider middleware，用来跟踪每个 Request 在爬取网站中的深度。DepthMiddleware 提供了一个配置 DEPTH_LIMIT，去设置深度值，注意这个深度是相对初始的 start_urls 的，如果该值为 0 表示不做深度限制，start_urls 中 url 是第一层，也就是说 DEPTH_LIMIT = 2，就只允许爬取到 start_urls 中 url 的下层 url</p><p>​    DEPTH_PRIORITY 配置用根据深度调整 Request 的优先级，默认是 0，即不根据深度调整</p><h3 id="嵌入-selenium"><a href="#嵌入-selenium" class="headerlink" title="嵌入 selenium"></a>嵌入 selenium</h3><p>​    scrapy 本身获取到的 response 中其实是不包含动态数据部分的，这也就意味着对于这部分的内容要么通过 yield 将动态数据的 url 给下载器去下载获取 json 数据，要么就是通过利用 selenium 的 webdirver 来启动一个浏览器实例来获取包含动态数据内容的 response</p><p>​    同样，对于可能的多个 spider 都会利用到 selenium 获取动态数据的 response，那么将 selenium 直接嵌入到 middleware 中，是最方便的一种做法。如果要另做区分，可以在中间件中通过 spider 的 name 来判断是否使用 selenium，另外，在中间件中使用 selenium 的 webdriver 请求一个页面后，就无需再将请求给下载器了，所以在中间件中就可以 return 返回 webdriver 得到的页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSPageMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;通过嵌入selenium来使用chromedriver来获取动态页面&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        <span class="comment"># process_request 处理引擎发送过来的 request</span></span><br><span class="line">        <span class="keyword">if</span> spider.name == <span class="string">&quot;blogs&quot;</span>:</span><br><span class="line">            <span class="comment"># 通过 name 判断哪个 spider 采取使用 webdriver 去获取</span></span><br><span class="line">            spider.browser.get(request.url)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">import</span> time</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;访问<span class="subst">&#123;request.url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 但是用这个中间去获取动态页面后，那解析文件中则不需在去发起请求，所以直接返回response</span></span><br><span class="line">            <span class="keyword">return</span> HtmlResponse(url=spider.browser.current_url, body=spider.browser.page_source, encoding=<span class="string">&quot;utf8&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    上面的代码中并没有出现 selenium 和 webdirver 的实例，是因为如果将 webdirver 的实例过程放在 middleware 中，每个 spider 都会经过这个中间件，这就会导致，每一个请求过来都会实例化一个 webdriver 对象，这显然不合理。所以上面的 webdriver 实例这一步骤就可以放到 spider 类中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlogsSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;blogs&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;news.blogs.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://news.cnblogs.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在初始化方法中定义 webdirver&quot;&quot;&quot;</span></span><br><span class="line">        self.browser = webdriver.Chrome(executable_path=<span class="string">r&#x27;./utils/chromedriver.exe&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(CnblogsSpider, self).__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    通过直接在 spider 类的 init 中去实例化 webdirver 对象，再在 middleware 中的 process_request 方法里通过传入 spider 参数，就可以实现用实例化的浏览器对象去 get 页面</p><p>​     middleware 中 return 使用 HTTPResponse 来返回获取的页面，不用在 HTTPResponse 的参数中需要指明 url，body，encoding。body 直接调用 page_source 即可，而 encoding 则需要根据网页自己的编码去设置</p><p>​    最后，很重要的一点，就是当爬取完成后，需要关闭 webdriver。因为 webdirver 对象是在 spider 类的初始化方法里实现的，所以就可以通过 from_crawl 这个类方法来对 webdirver 的浏览器进行关闭，scrapy 中提供了信号量去对爬虫的不同状态做针对处理</p><p>​    <strong>from_crawler 方法的参数 crawler 代表的是 Crawler 的实例对象，Crawler 这个类是 Scrapy API 的主要入口，提供了对核心组件的访问，每一个创建 spider 类的执行都会先走 from_crawler 去创建出 spider 的对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlogsSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;blogs&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;news.blogs.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&#x27;https://news.cnblogs.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在初始化方法中定义 webdirver&quot;&quot;&quot;</span></span><br><span class="line">        self.browser = webdriver.Chrome(executable_path=<span class="string">r&#x27;./utils/chromedriver.exe&#x27;</span>)</span><br><span class="line">        <span class="built_in">super</span>(CnblogsSpider, self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重写方法来实现爬虫结束后，自动将 webdirver 的浏览器关闭&quot;&quot;&quot;</span></span><br><span class="line">        spider = <span class="built_in">super</span>(BlogsSpider, cls).from_crawler(crawler, *args, **kwargs)</span><br><span class="line">        crawler.signals.connect(spider.closed, signal=signals.spider_closed)</span><br><span class="line">        <span class="keyword">return</span> spider</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closed</span>(<span class="params">self</span>):</span><br><span class="line">        self.browser.quit()</span><br></pre></td></tr></table></figure><p>​    from_crawler 方法最后需要返回 spider 对象，所以可以使用 super 去继承默认创建的 spider，然后通过参数 crawler 去调用 signals.connect 方法，connect 需要接受两个参数 receiver 和 signal。receiver 是一个函数，signal 就是一个信号。当 spider 的执行结束后，会自动关闭，触发 spider_closed 的信号，然后回调自定义的 closed 方法去关闭 webdriver 的实例</p><h3 id="暂停与启动"><a href="#暂停与启动" class="headerlink" title="暂停与启动"></a>暂停与启动</h3><p>​    对于一些数据会做定期更细的网页来说，当 spider 执行完成一次持久化数据后，或则是 spider 执行到某一阶段需要暂停，在此之后还需要再次运行 spider 或是重新运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy  crawl  spider[爬虫名]  -s  JOBDIR=info/001</span><br></pre></td></tr></table></figure><p>​    -s 参数指定存储目录 JOBDIR，并加上用来存储当前爬取的状态信息目录（例如这里的 info 文件夹，是在项目目录下创建），对于目录设置也可以放到 settings 文件或在 <code>custom_settings</code> 属性中配置，然后在 main 的 debug 中将参数和配置加上    </p><p>​    上面的命令被执行后，和正常情况一样去执行，不过一旦需要暂停，需要通过按下  <code>Ctrl + C</code>来执行（如果连按下两次 <code>Ctrl + C</code> 则会强制退出，后台的进程会被强制杀死）。另外，暂停不是立刻就停下的，后台依然会做一些处理，包括调度器还没执行的 request，过滤器的数据，spider 本身的状态，这些状态的信息在暂停时需要保存</p><p>​    不过 <strong>scrapy 中不同的 spider 不能使用同一个目录去存储状态信息数据</strong>，所以需要另外给出一个目录。当 spider 被暂停后，给出 info/001 目录下会自动生成状态储存文件</p><p>​    request.seen：表示已经访问的 url</p><p>​    request.state：表示 spider 的状态信息</p><p>​    requests.queue：是一个文件夹，包含两个文件，active.json 和 p0；active.json：是一个序列化后的 json 文件；p0：表示需要继续完成的 request，当再次运行时且全部运行完成，这个文件就会被删除</p><p>​    对于暂停来说，还需要注意一点，就是网站的 cookie 信息，这个是有时效性的，如果在一段时间内没有恢复，可能在再次恢复启动时，就会遇到问题</p><h3 id="Telnet-服务"><a href="#Telnet-服务" class="headerlink" title="Telnet 服务"></a>Telnet 服务</h3><p>​    简单来说，就是利用 telent 来实现远程操作，也就是说可将整个 scrapy 放到服务器上，通过本地使用 telent 去操控 scrapy 的 spider。前提是本地需要通过控制面板，去安装 telent 这个功能服务</p><p>​    spider 在运行时，其实默认会去监听 telent 的服务，每次执行命令行中都会输出的这个信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scrapy.extensions.telnet] INFO: Telnet console listening on 127.0.0.1:6023</span><br></pre></td></tr></table></figure><p>​    从提示信息可知，默认会在本地的 6023 端口去监听 telent 服务，这时可以在命令行在开启一个窗口，输入 <code>telent localhost 6023</code> 就可连接到 scrapy</p><p>​    监听的接口，是由 TELNETCONSOLE_HOST 配置决定，默认值就是 127.0.0.1；监听的端口则是由 </p><p>TELNETCONSOLE_PORT 控制，默认是一个范围 [6023,6073]，当配置为 None 或 0，则是动态分配一个端口</p><p>​    且在 telent 的终端上，输入   <code>est()</code> 就会返回一系列的 scrapy 的状态信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 6023</span><br><span class="line">&gt;&gt;&gt; est()</span><br><span class="line">Execution engine status</span><br><span class="line"></span><br><span class="line"># 启动的时长</span><br><span class="line">time()-engine.start_time                        : 8.62972998619</span><br><span class="line">engine.has_capacity()                           : False</span><br><span class="line">len(engine.downloader.active)                   : 16</span><br><span class="line">engine.scraper.is_idle()                        : False</span><br><span class="line">engine.spider.name                              : followall</span><br><span class="line">engine.spider_is_idle(engine.spider)            : False</span><br><span class="line">engine.slot.closing                             : False</span><br><span class="line">len(engine.slot.inprogress)                     : 16</span><br><span class="line">len(engine.slot.scheduler.dqs or [])            : 0</span><br><span class="line">len(engine.slot.scheduler.mqs)                  : 92</span><br><span class="line">len(engine.scraper.slot.queue)                  : 0</span><br><span class="line">len(engine.scraper.slot.active)                 : 0</span><br><span class="line">engine.scraper.slot.active_size                 : 0</span><br><span class="line">engine.scraper.slot.itemproc_size               : 0</span><br><span class="line">engine.scraper.slot.needs_backout()             : False</span><br></pre></td></tr></table></figure><pre><code>除此之外，Telnet 终端也提供了一些变量，来方便查看一些信息</code></pre><table><thead><tr><th>快捷名称</th><th>描述</th></tr></thead><tbody><tr><td><code>crawler</code></td><td>Scrapy Crawler (<code>scrapy.crawler.Crawler</code>对象)</td></tr><tr><td><code>engine</code></td><td>Crawler.engine属性</td></tr><tr><td><code>spider</code></td><td>当前激活的爬虫(spider)</td></tr><tr><td><code>slot</code></td><td>the engine slot</td></tr><tr><td><code>extensions</code></td><td>扩展管理器(manager) (Crawler.extensions属性)</td></tr><tr><td><code>stats</code></td><td>状态收集器 (Crawler.stats属性)</td></tr><tr><td><code>settings</code></td><td>Scrapy设置(setting)对象 (Crawler.settings属性)</td></tr><tr><td><code>est</code></td><td>打印引擎状态的报告</td></tr><tr><td><code>prefs</code></td><td>针对内存调试</td></tr><tr><td><code>p</code></td><td><a href="http://docs.python.org/library/pprint.html#pprint.pprint">pprint.pprint</a> 函数的简写</td></tr><tr><td><code>hpy</code></td><td>针对内存调试</td></tr></tbody></table><p>​    其中，通过 engine 这个变量可以实现远程操作 scrapy 的暂停，恢复以及停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 控制引擎暂停</span><br><span class="line">engine.pause()</span><br><span class="line"># 恢复</span><br><span class="line">engine.unpause()</span><br><span class="line"># 停止</span><br><span class="line">engine.stop()</span><br></pre></td></tr></table></figure><h3 id="状态数据收集（stats-collection）"><a href="#状态数据收集（stats-collection）" class="headerlink" title="状态数据收集（stats collection）"></a>状态数据收集（stats collection）</h3><p>​    <strong>scrapy 提供的状态收集机制都是以 key-value 存储的</strong> 计数型的，通过 crawl 类去调用 stats 来使用，且 stats collection 无论是开启还是关闭都是可以使用的</p><p>​    设置一个数据，使用     <code>stats.set_value(&#39;xxx&#39;,xxx())</code>；如果需要每次累加，则是 <code>stats.inc_value(&#39;xxx&#39;)</code>；想要获取数据，使用 <code>stats.get_value(&#39;xxx&#39;)</code>；如果是要获取所有的数据，使用 <code>stats.get_stats()</code></p><p>​    当要设置一个比原来值大的时候，<code>stats.max_value(&#39;max_items_scraped&#39;, value)</code>，反之则是 <code>stats.min_value(&#39;min_free_memory_percent&#39;, value)</code></p><h3 id="分布式爬取"><a href="#分布式爬取" class="headerlink" title="分布式爬取"></a>分布式爬取</h3><p>​    分布式爬取的目的就是为了将单独的爬虫程序部署在多台服务器上，但是单个的 scrapy 爬虫如果要部署到多台服务器上，就会面临一些问题。比如，多个爬虫之间怎么知道当前的 url 是否爬取过，这就涉及到多个爬虫如何获取 url，以及在分布式下如何做到 url 的去重</p><p>​    对于分布式来说，最常见的一种方式，通过设置一个队列，让多台服务器去对其进行监听，当队列中有数据时，监听的调度器会自动获取一个数据，然后开始处理。而对于 url 的去重，本质上 scrapy 也是将 url 放到 set 实现的，但在分布式情况下，就需要一个统一容器来存放多台服务器爬取过的 url，实现上虽然都是 set ，但是从原本的数据结构的方式，变为了数据库存储的形式</p><p>​    对于这个队列的实现，scrapy-redis 的 queue 中包含了三个基本的队列：FIFO 队列，LIFO 队列，Priority 队类，三者都通过继承 Base 基类去实现，其中基类定义基本的接口方法，要求子类去实现</p><p>​    <strong>Base 基类中还有两个又来序列化和反序列化的方法：_encode_request 和 _decode_request</strong>，前者用来对 Request 对象进行序列化，这样才能保存到数据库上，后者就是读取保存的序列化对象进行反序列化得到原本的 Request 对象，而序列化和反序列化的方式是利用 pickle 模块去实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Per-spider base queue class&quot;&quot;&quot;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server, spider, key, serializer=<span class="literal">None</span></span>): </span><br><span class="line">        <span class="keyword">if</span> serializer <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            serializer = picklecompat </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(serializer, <span class="string">&#x27;loads&#x27;</span>): </span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;serializer does not implement &#x27;loads&#x27; function: % r&quot;</span> % serializer) </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(serializer, <span class="string">&#x27;dumps&#x27;</span>): </span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;serializer &#x27;% s&#x27; does not implement &#x27;dumps&#x27; function: % r&quot;</span> % serializer) </span><br><span class="line">        self.server = server </span><br><span class="line">        self.spider = spider </span><br><span class="line">        self.key = key % &#123;<span class="string">&#x27;spider&#x27;</span>: spider.name&#125; </span><br><span class="line">        self.serializer = serializer </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode_request</span>(<span class="params">self, request</span>): </span><br><span class="line">        obj = request_to_dict(request, self.spider) </span><br><span class="line">        <span class="keyword">return</span> self.serializer.dumps(obj) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode_request</span>(<span class="params">self, encoded_request</span>): </span><br><span class="line">        obj = self.serializer.loads(encoded_request) </span><br><span class="line">        <span class="keyword">return</span> request_from_dict(obj, self.spider) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the length of the queue&quot;&quot;&quot;</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, request</span>): </span><br><span class="line">        <span class="string">&quot;&quot;&quot;Push a request&quot;&quot;&quot;</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, timeout=<span class="number">0</span></span>): </span><br><span class="line">        <span class="string">&quot;&quot;&quot;Pop a request&quot;&quot;&quot;</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="string">&quot;&quot;&quot;Clear queue/stack&quot;&quot;&quot;</span> </span><br><span class="line">        self.server.delete(self.key) </span><br></pre></td></tr></table></figure><p>​    利用分布式爬取的特点也很明显，在爬取效率和速度上，多台服务器的带宽可以大大提高爬取的速度；同时利用多台服务器爬取，也减少了 ip 地址被检测爬虫的概率</p><p>​    对于 scrapy 框架来说，有一个专门用于分布式爬取的项目 <em>scrapy-redis</em>，它将 requests 的状态管理以及 url 的去重全部放在 redis 上实现</p><p>​    <strong>使用步骤：</strong></p><p>​    1）确保环境中安装了 redis，可以简单点直接使用   <code>pip install redis</code></p><p>​    2）从 github 上 clone 项目： <code>git clone https://github.com/rmax/scrapy-redis.git</code>，也可以直接下载压缩包</p><p>​    3）将 clone 的 scrapy-redis 项目下 src 目录下的 scrapy_redis 文件夹复制到爬虫项目中</p><p>​    5） 按照 scrapy-redis 项目要求，修改爬虫项目的 settings 中的 SCHEDULER，DUPEFILTER_CLASS 以及 ITEM_PIPELINES，ITEM_PIPELINES 的目的是为了将 item 存储在 redis 上，这样可以实现一个共享，且因为数据都在 item 中，如果要实现持久化，可以直接从 redis 中获取去做数据入库</p><p>​     对于爬虫项目的编写，使用 scrapy_redis 和不使用都是一样的，不同之处是 scrapy_redis 中 spider 继承了 scrapy_redis.spiders.RedisSpider 这个类，同时这个类还继承了 RedisMixin 和原本 scrapy 的 Spider 类，所以本身 spider 的编写也就是用的 scrapy 的</p><p>​    其中，对于每一个 spider 类，都会额外有一个属性叫做 <strong>redis_key</strong>，默认格式是 spider 名加上初始的 start_urls，中间使用冒号隔开</p><p>​    scrapy_redis 会在 redis 服务中创建两个 key，分别是：    <code>myspider:requests</code> 和 <code>myspider:dupefilter</code>。前者是一个有序集合 zset，因为 scrapy 支持对爬取设置优先级，而 redis 可以通过有序集合设置分数来实现排序，同时监听 redis 的 spider 会依次从里面去取序列化的 Request，后者就是普通的无序字典 set，用来存储爬取过的 url 的 fingerprint</p><p>​    <strong>运行步骤：</strong></p><p>​    <strong>1）使用 <code>scrapy runspier myspider.py</code> 来运行爬虫文件，启动后 scrapy 会对本地的 redis 进行监听，分布式下，这个 redis 可以在任意一个服务器上</strong></p><p>​    <strong>2）使用 <code>redis-cli lpush myspider:start_urls https://xxxxxx.com</code>，通过 lpush 将初始 url 将入到 redis 队列中，让正在监听的 spider 去获取</strong></p><h3 id="增量式爬虫"><a href="#增量式爬虫" class="headerlink" title="增量式爬虫"></a>增量式爬虫</h3><p>​    增量式爬虫与一般爬虫程序本质上没有太大区别，但是增量式的关注点不只是进行爬取，而是判别数据是否已经爬过，从而判断内容是否更新以至于需要再次爬取</p><p>​    同时 <strong>增量式爬取也可能涉及两种不同状态：一种是全量的爬虫程序还没有停止，二是如果爬虫程序关闭</strong></p><p>​    对于第一种情况，可以在全量爬虫进行时，另外开启一个服务启动爬虫程序来做为增量爬取，或者是利用 scrapy-redis，但是需要对这个源码进行改动。对于正在执行的全量爬虫来说，一旦网站出现了新的数据都会将 Request 发出来，scrapy-redis 原本都会将其加入队列中，所以可以使用优先级队列，来给新增的 Request 的参数中加上优先级，这样自动会去优先对新出现的内容去进行爬取</p><p>​    使用 scrapy-redis 的优先级队列，需要在 settings 文件中配置  <code>SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.PriorityQueue&quot;</code></p><p>​    对于第二种情况，爬虫程序结束了的话，毫无疑问需要再次启动，但是为了方便管理，可以通过第三方组件或是脚本程序来设置定时启动，因为对于网站的内容而言，发布过的数据内容更新频率不会太高（但是这依然需要根据网站的设计去单独讨论，这样的方式不能适用于所有的网站）。还有一种情况就是半关闭（暂停或等待）状态，这种情况也非常好处理，因为 scrapy-redis 默认要从队列里取请求，等待状态下，只需要将 url 通过 push 加入 redis 中即可</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> scrapy 整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/3797262603/"/>
      <url>/3797262603/</url>
      
        <content type="html"><![CDATA[<h3 id="一条-url-所经历的过程"><a href="#一条-url-所经历的过程" class="headerlink" title="一条 url 所经历的过程"></a>一条 url 所经历的过程</h3><p>​    大致的简单流程是：</p><p>​    <strong>DNS 查询</strong> -&gt; <strong>TCP 三次握手</strong> -&gt; <strong>HTTP 请求</strong> -&gt; <strong>Nginx 服务器</strong> -&gt; <strong>uWSGI 服务器</strong> -&gt; <strong>web 应用程序响应</strong> -&gt; <strong>TCP 四次挥手</strong></p><p>​    当浏览器中输入一个 url 时，首先会在本地的 dns 缓存上进行查询，如果浏览器内部没有，会再去本地系统的 hosts 文件查询。如果依然没有，再往上层去查询，比如查询路由器缓存，没有就往上去查询 dns 服务器</p><p>​    当查询得到目标的 ip 地址之后，就需要通过 tcp 协议去建立连接，即常说的 “三次握手”，建立好连接就下去就是开始通信</p><p>​    请求来到应用层上，通过 http 协议向目标地址发起请求，但是这个请求通常不会直接直接进入到 web 应用程序中进行处理，请求可能进过一系列的路由跳转，会先到达一个 “中转站”，像是 Nginx 服务器上，来对大量请求做负载均衡，或是反向代理</p><p>​    经过 Nginx 的分发，请求来到 uWSGI 服务器上，因为应用程序可能是利用各个不同的开发语言和程序框架去开发的，比如 python 的 django，flask 或 tornado 等等，http 协议请求进入到他们内部不方便被处理来获取需要的信息，所以需要通过 uWSGI 服务器的 uwsgi 协议（是一种线路协议，而不是通信协议）将请求变为各个框架可以处理的形式。简单来说，uWSGI 服务器其实是 Nginx 服务器 和 web 应用程序服务器的中间桥梁，提供了两者能交流的一个统一接口进行适配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         uwsgi             WSGI</span><br><span class="line">Nginx &lt;---------&gt; uWSGI &lt;---------&gt; django</span><br></pre></td></tr></table></figure><p>​    最后，请求终于跋山涉水来到了 web 应用程序服务器上，开始进行业务逻辑上的处理，同时将最后返回的响应按照之前过来的步骤再返回到浏览器上，并在请求响应结束后，通过 tcp 协议的 “四次挥手” 断开连接</p><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>​     OSI（Open System Interconnect），即 <strong>开放式系统互联</strong>，是 ISO（国际标准化组织）组织研究的网络互连模型。 ISO 为了更好的使网络应用更为普及，推出了 OSI 参考模型，其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，在同一套标准下进行相互沟通。简而言之，OSI 就像是现实生活的中语言体系，比如英语作为全世界的一套通用语言一样，OSI 参考模型就是为了建立友好的交流方式而制定的一套标准协议</p><p>​    OSI 定义了网络互连的七层框架（自下而上）：<strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</strong>。每一层都分工明确，拥有自己标准和任务</p><p><img src="https://wei-foun.github.io/img/osi-7.jpg" alt="img"> </p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​    应用层是最接近实际用户的一层，为计算机用户提供应用接口以及网络服务。在应该层中常见的标准协议有：HTTP（超文本传输协议），HTTPS（超文本传输安全协议），FTP（文本传输协议），DNS（域名解析），SMTP（简单的邮件传输协议），POP3（邮局协议版本3）等等</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>​    提供各种用于应用层数据的编码和转化功能，确保数据的安全性和可被其他应用层识别，比如，对数据的加密与解密，图片的编码与解码，以及压缩和解压</p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>​    负责建立，管理和终止表示层实体之间的通信会话。可以把会话层想象是以前战争时期的电话接线员，当中央司令向战区指挥官下达指令，拨打电话后，会先接到接线员的地方，这个地方会有大量的线路通向各个战区，接线员知道目标战区后，将电话线转接到战区线路上，当指令下达完成挂断后，接线员负责断开中央线路和该战区线路的通话，那接线员就相当于是一个会话层，管理着发送与接收方之间的会话</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>​    是这七层中尤为重要的一层，同样在上面的例子里，电话接线员所在的转接室就相当于传输层，由它负责端到端的连接与传输。传输层的作用是通过匹配进程和端口，为上层协议提供端到端可靠和透明的传输服务，处理差错问题或是流量控制等问题</p><p>​    在传输层中，<strong>数据的传输形式被称为 段，即 数据段（segment）</strong></p><p>​    在传输层上，最常见的协议就是：<strong>TCP（传输控制协议），UDP（用户数据报协议）</strong></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>​    同样也是非常重要的一层，依旧是上面的例子，接线员是会话，转接室是负责连接传输，网络层就相当于中央线路和战区线路的线路连接，比如要是连接偏远战区可能就需要先转到附近的转接室，然后再去选择，这其中可能会需要连接多个转接室才能到达目的战区。也就是通过 ip 地址进行节点的连接，同时网络层需要根据需要选择最优路由和交换节点，确保数据可以传输到目的的 ip 地址</p><p>​    在网络层中，<strong>数据的形式被称为 包，或是分组（packet）</strong></p><p>​    网络层最常见的协议就是 IP（互联网协议），常见的网络设备像是路由器，交换机等</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>​    <strong>将来自 物理层 的数据组成 字节，再由字节组合成 数据帧（frame），或将来自 网络层 的数据拆分为 帧。</strong>数据链路层主要是在不可靠的物理介质上提供可靠的传输，包括，物理地址寻址、流量控制，数据检错或重发</p><p>​    数据链路层中 <strong>主要的设备包括二层交换机，网桥等，</strong>包含的协议有 SDLC，HDLC，PPP，STP，帧中继等</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​    规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接，用来传输实际的信号</p><p>​    <strong>数据在物理层中的表现形式称为 比特（bit）</strong>，主要的设备包括同轴电缆，双绞线，集线器，中继器，调制解调器等</p><h4 id="发送与接收"><a href="#发送与接收" class="headerlink" title="发送与接收"></a>发送与接收</h4><p>​    数据在 OSI 七层模型中的发送和接收，其实就是一次打包和拆包的操作，因为各层会分别在整合的数据上进行头部的添加，用来进行校验</p><p>​    <img src="https://wei-foun.github.io/img/osi-s-r.jpg" alt="img"> </p><p>​    数据在 <strong>传输层 的 TCP 协议上会加上一个头部，包含 源端口 和 目标端口</strong></p><p>​    数据封装后在 <strong>网络层 的 IP 协议上又会加一个头部，包含 源 ip 和 目标 ip</strong></p><p>​    在 <strong>数据链路层上添加的头部信息，会包含 源 mac 地址 和 目标 mac 地址</strong></p><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>​    和 OSI 七层模型 是一致的，只是将高层进行整合，合并为了应用层，除此之外，还有四层模型，本质上都是对 OSI 七层的整合，四层模型是将 物理层 和 数据链路层 合并为了一层</p><p><img src="https://wei-foun.github.io/img/tcp-ip.jpg" alt="img"></p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>​    <strong>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong></p><p>​    面向字节流指的是，<strong>TCP 协议的 socket 会给连接双方留有一个固定大小的缓冲区，且应用程序会将数据块分成合适大小的 字节放入缓冲区</strong>，由缓冲区进行 TCP 报文段的发送以及将接受的 TCP 报文段放入到缓冲区，防止连接中一方发送过快，另一方接收和处理很慢的情况下，导致 TCP 报文段 在接收方出现读取无序情况，或是因为读取处理慢造成缓冲区的字节数据溢出而丢失 TCP 报文。基于字节流的传输，从意识上理解就相当于， TCP 发送报文段的字节数据在接收方来说都是有序的且没有丢失的，发送与接收没有中断产生</p><p>​    <strong>优点：</strong>可靠，稳定</p><p>​    <strong>缺点：</strong>效率低，慢</p><h4 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><img src="https://wei-foun.github.io/img/tcp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="img"></p><p>​    之前的七层模型中说到，每一层都会对数据进行封装并加上各自可以用来识别的头部信息，传输层的 TCP 协议会给头部信息中加上 源端口 和 目标端口，但除此之外还有很多其他的参数信息</p><p>​    序列号（seq）：序列号的值是随机生成的，通信时是顺序递增，来确保数据传输的有序的</p><p>​    确认号（ack）：服务端收到客户端序列号，进行响应时，通过客户端发送的序列号 +1 表示确认收到数据包</p><p>​    数据偏移：长度是 4 位，即 32 个字节。TCP首部长度在不包含选项的话，是 20 个字节，20 / 4 = 5，也就是说这个报头长度（数据偏移）是 5，那最大就是 40 个字节，因此对于整个 TCP 封装的首部长度最大就是 20 + 40 = 60 个字节，对于这个字段最大可设置的值是 60 / 4 = 15</p><p>​    保留位：用来作为以后的扩展使用，整个长度是 6 位，一般设置是 0</p><p>​    标志位：总长是 6 位，从左到右依次是 URG，ACK，PSH，RST，SYN，FIN</p><p>​        URG：紧急指针是否有效，值为 1 时，表示某一位需要优先处理</p><p>​        ACK：确认号是否有效，一般值为 1</p><p>​        PSH：值为 1 时，提示接收端程序立即从 TCP 缓冲区把数据读走</p><p>​        RST：值为 1 时，表示对方要求重新建立连接，或复位</p><p>​        SYN：值为 1 时，表示请求建立连接，并在其序列号的字段进行序列号的初始值设定</p><p>​        FIN：值为 1 时，表示断开连接</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>​    <strong>意识理解：</strong>所谓三次握手，指的是客户端与服务端需要通过三次之间的联系才确保两者之间达成有效连接。第一次握手，由客户端向服务端发起连接请求，等待服务器响应。第二次握手，由服务端回应客户端的连接请求，即响应客户端已经收到连接请求并允许进行连接，等待客户端收到消息和回应。第三次握手，即客户端收到服务端的连接请求许可，并响应服务端，建立与服务端的连接</p><p>​    这就是基于概念上最简单的理解，就好像是现实中两个人握手一样，通常两人见面伸手并握手后，都习惯性地上下晃动两三下一样</p><p>​    <strong>概念理解：</strong>上面的说明只是为了简单描述三次握手是怎样的三次握手，具体的 TCP 协议连接的三次握手中，其实包含了很多参数来表示状态</p><p><img src="https://wei-foun.github.io/img/tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="img">  </p><p>​    从图可知，客户端与服务端的连接过程中，共发送了 3 个数据包，这分别表示三次握手过程</p><p>​    <strong>第一次握手</strong>，客户端处于主动状态，请求连接服务端，发送给服务端的 tcp 数据包中设置了标志位 SYN 的值，该值被设置为 1，来表示请求进行连接，并且会生成一个随机值 （X）作为 序列号（seq） 在这个 tcp 包的头部信息中，请求发送后客户端会进入到发送等待状态，即 SYN_SENT</p><p><img src="https://wei-foun.github.io/img/tcp-1.jpg" alt="img"></p><p>​    <strong>第二次握手</strong>，服务端从监听状态中，发现连接请求，为了确认客户端身份和是否确认连接，所以发送自己的响应给客户端。首先，在回应的 tcp 的头部信息中，将 ACK 设置为 1，表示确认并允许客户端的连接请求，且 SYN 的值不进行改变，并将接收到的 tcp 头部信息中的序列号进行 + 1（X+1）作为确认序列号，同时会另外自己生成随机值（Y）作为这次响应的序列号。完成后，服务端进入 SYN_RCVD 状态等待客户端对这次响应的确认</p><p><img src="https://wei-foun.github.io/img/tcp-2.jpg" alt="img"></p><p>​    <strong>第三次握手</strong>，就是最后一步的确认请求，客户端收到服务端允许连接的响应后，需要再次发送一个请求来表示自己确认收到允许连接的响应，因此在这次的 tcp 头部信息中，会将响应的 序列号 +1 作为这次的 确认序列号，而这次包的序列号则是在第一次的 X 上 +1 表示是自己后续的发送包，且一样还是将 ACK 的值设为 1 表示确认。然后将这次请求发送刚给服务端，并进入 ESTABLISHED 状态，服务端收到确认请求后也会进入 ESTABLISHED 状态来表示 tcp 请求连接成功，最后这样就完成了由客户端到服务端的三次握手过程</p><p><img src="https://wei-foun.github.io/img/tcp-3.jpg" alt="img"></p><p>​    <strong>一个常见的问题：为什么必须是三次握手，两次不行吗？</strong></p><p>​    通过上面的解释知道了三次握手中后两次的其实都是用来做确认了，假设现在将三次握手合并为两次，一个问题就是如何在第二次握手完成客户端与服务端对连接请求的确认，当客户端一开始请求连接发送了一个 SYN 包后，服务端允许连接并同样需要回一个数据包，同时服务端为了确认客户端收到，会等待客户端再给自己一个响应来确认对方。如果只有两次，服务端发送响应后就结束了，这样一直无法知道客户端是否收到自己允许客户端连接的响应</p><p>​    其次，如果服务端响应的允许连接的数据包发出后被拦截掉，客户端没有收到响应会一直发送 SYN 数据包来请求连接，假设服务端的响应的 SYN+ACK 的响应数据包一直被拦截，而客户端会不断发送 SYN 来请求，从而导致服务端可能会出现崩溃，因为服务端会维持住一个没有确认回复的半连接状态的连接，如果没有回应会进行重试，并维持这样的半连接大概 30s - 2m 才会丢弃这样的半连接，在一直无法收到服务端的响应的话，且又不断有大量的连接请求过来，导致服务端需要维护这些大量没有意义的半连接，到最后无法承受而挂掉，这就是常说的 “<strong>SYN 洪水攻击</strong>“</p><p>​    并且，因为如果只有两次握手来建立连接，假设服务端的响应被客户端收到了，但是对于服务端而言，它永远不知道对方是否有收到，依然会维持半连接或是重试来浪费无端的开销。所以，三次握手中的每一次握手都是必不可少的</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>​    <strong>意识理解：</strong> 在数据传输过程中，客户端想要与服务端断开连接，所以发送一个断开连接的请求给服务端，这是第一次挥手。服务端收到后，进行响应表示自己收到请求并允许断开，这是第二次挥手。紧接着，服务端会立刻看之前通信的数据是否传输完成，如果数据都发给服务端了，服务端会再次发送一个响应表示自己已经连接断开，这是第三次挥手。客户端在收到允许断开的响应，以及服务端断开连接的响应后，会回复一个响应，来通知服务端自己收到了服务端发送的响应，并最后彻底断开连接，这是第四次挥手</p><p>​    简单一个例子，你去银行取钱，要取 50w，坐到柜台对面说 “老子要取 50w”，然后柜台服务员忙忙碌碌开始取钱，并一万一万封装给你，这是一个双发的数据通信过程。然后，你发现今天交易所今天有个新基发售，要到结束时间了，你赶着去做韭菜，然后对柜台人员说，”哎呀！还没好吗，算了，我先取 25w 吧”，即第一次挥手，柜台服务员心想，你个土包子，买基直接网上交易不就可以了，还来去现金，祝你早日被割韭菜，嘴上说 “好的”，即第二次挥手。然后柜台服务员将 25w 里最后的 1w 给到你，还在问你还有其他需要帮助的，没有了就会说 “请对本次服务评分，谢谢”，即第三次挥手。赶着当韭菜的你说，”没了没了”，然后不情愿的在评分机器上给了一个 “炸鸡棒” 的评价就离开了，即第四次挥手</p><p>​    <strong>概念理解：</strong>在说三次握手的时候，已经知道了 tcp 的数据头部中是含有参数和标志来表示请求类型的，同时对于双方而言也会有状态上的变化</p><p><img src="https://wei-foun.github.io/img/tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="img">  </p><p>​    <strong>第一次挥手</strong>，客户端会发送一个 FIN 的数据包来表示请求断开，和三次握手一样，除了本次请求的标志位是 FIN 之外，也会生成一个随机值作为 seq 的序列号，然后进入到 FIN_WAIT1 等待状态，等待服务端的响应</p><p>​    <strong>第二次挥手</strong>，服务端收到客户端的 FIN 后，需要发送响应表示收到断开连接的请求，即会回复一个 ACK 的确认包，且数据包的确认序列号是请求的 FIN 包里的 seq 序列号 + 1，并且进入到等待断开的状态 CLOSE_WAIT，且客户端收到 ACK 后，会进入 FIN_WAIT2 等待状态</p><p>​    <strong>第三次挥手</strong>，服务端会确认自己的数据是否有在传输的，有的话需要等待传输完成，这相当于在用百度限速盘和迅雷在下载一个任务一样，数据在下载过程中选择关闭程序后，会有提示说 “当前仍有任务在下载”，确认了之后，后台的下载进程其实并没有立即关闭程序，而是在等待最后的数据包传输。当没有数据传输了，服务端会发送一个 FIN 的包给客户端，对于服务端的状态而言则是进入 LAST_ACK 最后确认状态，也就是说第二次挥手和第三次挥手都是由服务端发送的，且此时客户端会进入 TIME_WAIT 状态</p><p>​    <strong>第四次挥手</strong>，客户端在等待连接关闭的整个状态中，接收到服务端的 FIN 后处在 TIME_WAIT 状态中，会需要对 FIN 包回复一个 ACK 表示确认，如果服务端没收到会进行重试，或是等待 2MSL 的时间，然后进入到 CLOSED 状态，表示连接断开</p><p>​    客户端进收到服务端最后的 FIN 后发送 ACK 确认，之所以没有直接断开连接，而是进入到 TIME_WAIT 的状态并等待 2MSL，也是出于可能的网络不稳定的因素。因为，假设客户端最后的 ACK 丢失，导致服务端始终无法收到最后的 ACK，服务端会以为自己的 FIN 没有被收到，会进行重发。并且对于客户端而言，如果在 2MSL 的时间中再次收到服务端的 FIN，那么当前的连接就不能断开，客户端会再次发送 FIN，并在 TIME_WAIT 状态下再去等待 2MSL，如果指定时间内，没再收到服务端的 last_ack 的 FIN，才会进入到 ClOSE 状态断开连接</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>​    上面提到了，在 TCP 的收发时，可能存在发送方发送的速度过快，接收方来不及接收的情况，这样会导致数据的丢失，所以在 TCP 连接双方的缓冲区中，<strong>接收方可以通过 滑动窗口 的机制来限制 TCP 通信时，对数据流量的控制</strong></p><p>​    在双方通信时，<strong>接收方可以在 数据接收窗口 rwnd 中设置自己能够接受的数据大小</strong>，这样发送方在数据发送时，一旦发出的数据达到了 rwnd 的限制，就无法继续发送</p><p><img src="https://wei-foun.github.io/img/tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="img"></p><p>​    图中，一开始接收方 B 设置了接收窗口 rwnd=400 做限制，所以发送方 A 第一次发送和第二次分别发送的 100 个字节的数据，都会被 B 接收，而此时 B 根据 rwnd 的限制，还能接收 200 的字节数据，即 rwnd=200</p><p>​    接着 A 开始发送 201 开始的第 3 个 100 字节数据，假设出现网络不稳定，B 没有接收到这次的数据，而此时 B 发送新的响应，并对 rwnd 重新修改了限制，设置为 rwnd=300。A 收到后继续往后发送数据，即 301 和 401 开始的 200 个字节的数据，此时 rwnd=100，且由于之前 201 的数据没有收到接收响应，A 会对 201 的数据进行重试，再次发送。完成后，根据 B 设置的窗口限制，此时的 <strong>rwnd=0，A 无法继续在向 B 发送新的数据</strong></p><p>​    B 在处理数据后，再次发送响应将 窗口大小 设为 100，表示还能接受一次数据发送，A 收到后继续往后发送 501 的数据，当 B 收到后又将 rwnd 改为 0，表示让 A 停止发送，不再接收新的数据了</p><p>​    另外，<strong>在 TCP 通讯时，每个连接都会持有一个 持续计时器（persistence timer），当其中一方收到另一方发送的 rwnd=0 的滑动窗口通知时，会启动这个计时器，当计时器内部设置的时间到期，会主动发送一个零窗口控测报文段（携带 1 个字节数据），如果不被接收则会重置这个计时器</strong></p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>​    上面提到，当数据从发送方被发出，可能会因为各种网络问题导致丢包，或者是延迟很高，而导致接收方会认为某一段数据没有被收到。比如，客户端发送了 6，7，8，9 四个数据段，而服务端按顺序正常接收后，<strong>发现 7 没有收到，而直接收到了 8，此时就会认为 7 这个数据段丢失了，会要求客户端进行重传，假设 9 也被成功收到，那么就会发送三个重复的数据段 6 的 ack 确认，客户端接收后到三个重复的 ack，就会立即在将对应需要的数据段进行快速重传，而不是去等待 ack 超时再去将缺失的数据段重发</strong></p><h4 id="累计-ACK"><a href="#累计-ACK" class="headerlink" title="累计 ACK"></a>累计 ACK</h4><p>​    累计确认机制，实际上为了对响应 ack 的优化。在规定的传输通信中，每一次发送，都对应一次 ack 的响应，但是在不稳定的网络环境中，延时和数据包的丢失是不可避免的，再根据 tcp 的快速重传机制，如果丢失数据段，会连发三次 ack 来要求重发数据，这就是的 ack 的响应可能会非常频繁和冗余，导致占用网络带宽</p><p>​    <strong>累计 ack 确认机制允许了接收方能用一个 ack 包回复多个连续的数据的成功接收</strong>。这样的目的就使得 ack 的回复可以降低</p><p>​    比如，客户端连续发送 6，7，8，9 四个数据段给服务端，服务端的接收中可能会丢失 7 号数据段，但却受到了后面的 8 和 9，如果服务端在发送 三次冗余 ack 前，第 7 号的数据段到达了服务端，那么此时服务端就成功接收了滑动窗口的所有数据，就会直接回复一个 ack 10。客户端收到 ack 10 的响应包，就表示自己发送的数据全部都被成功接收</p><p>​    因此，累计确认机制就可以省去服务端对于 8 的单独 ack 回应，以及对 7 号数据段可能的三次冗余 ack</p><p>​    <strong>累计确认机制的实现，就是在 ack 的响应上做了延迟，主要的目的是为了等待后续的数据段的到达，来接收成功收到的数据段并缓存住，如果丢失的段能在这个延迟内被就接收，就只需要用最后一次的 ack 来响应，替代所接收的每一次数据段的 ack 确认</strong></p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>​    上面的 TCP 的 滑动窗口，是接收方对通信可能问题的一种控制机制，而 <strong>拥塞控制，则是由发送方去设置的，发送方会根据设置的 cwnd（congestion windows）控制数据的发送</strong>，拥塞窗口的大小取决于网络的拥塞程度，并以此进行动态的调整</p><p>​    <strong>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大，以便把更多的分组发送出去，一旦网络出现拥塞，拥塞窗口就减小一些，减少加入到网络中的分组数</strong></p><p>​    所以，发送方对于 <strong>拥塞窗口 的控制会有两个状态：正常发送状态下，使用 慢算法 逐步增大发送量；拥塞状态下，利用 拥塞避免，减缓发送量</strong></p><p>​    慢启动的通信开始时，发送方会对网络状况做一个探测，并设置一个最大报文数 MSS，当发送的数据收到确认响应后，会将拥塞窗口的 MSS +1，这样就能实现逐步增加发送的 cwnd，提升发送的效率</p><p>​    并且，每经历一个发送和响应的轮次，发送方就会将 cwnd  * 2（注意：一个轮次必须要是数据段是连续发出，并都接收到确认响应）</p><p>​    为了避免 慢开始 中 cwnd 指数级增加得过快，导致短时间就引起拥塞情况，还需要设置一个 ssthresh 作为慢启动最后的阈值，一旦 cwnd &gt; ssthresh 就会进入到拥塞避免的状态下</p><p>​    拥塞避免，即在 cwnd 到达 ssthresh 的阈值，为了避免继续的指数级增加发送量，触发的一种机制，数据通信过程进入到该状态下，会取消每一个请求响应后轮次的倍数增加，让发送量变成线性递增的形式，而一旦最后网络出现了阻塞，发送方会重新修改 cwnd</p><p><img src="https://wei-foun.github.io/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="img"></p><p><img src="https://wei-foun.github.io/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B62.jpg" alt="img"></p><h4 id="长连接-与-短连接"><a href="#长连接-与-短连接" class="headerlink" title="长连接 与 短连接"></a>长连接 与 短连接</h4><p>​    短连接：即在通过 tcp 三次握手后，发送 http 请求，得到了服务端的响应，便会立刻进行四次挥手，断开 tcp 连接。也就是说每一次需要请求资源前，都需要进行一次 tcp 连接</p><p>​    长连接：简单来说，就是在第一次请求建立好 tcp 连接，在得到响应资源后不会立刻进行断开，这样做可以大大节省请求资源浪费在连接上的开销。对于长连接的设置，也很简单，就是 <strong>在 http 的头部中添加 <code>Connection:keep-alive</code></strong></p><p>​    需要注意的是长连接并不是意味着一开始的请求建立的 tcp 连接是永久连接，可以通过在头部中添加 <code>Keep-alive:timeout=20</code>，来设置一个长连接的最大维持时间是 20 秒，防止一致维持长连接造成浪费</p><p>​    另外，对于 <strong>http 1.1 版本开始，默认都是使用的是长连接</strong></p><h4 id="长轮询-与-短轮询"><a href="#长轮询-与-短轮询" class="headerlink" title="长轮询 与 短轮询"></a>长轮询 与 短轮询</h4><p>​    长短轮询在实际的操作上都是一致的，两者都是通过进行一个循环，来对内容进行请求，通常可以通过 js 来设定一个定时器，通过固定时间来发送请求，从而获取新的资源</p><p>​    <strong>短轮询：更加偏向设定的轮询时间，一旦到时间，不管请求到的数据是否会有变化都会立即发出请求</strong></p><p>​    <strong>长轮询：更加关注数据内容，如果到达设置时间，数据发生了改变才会立即将新结果返回，如果数据没有变动，则是保持原本的数据。同时长轮询会有一个超时时间，数据没有改动，会继续维持长轮询，直到最后超出设定的超时时间，期间如果数据发生改动，会立即返回并开启下一个长轮询，如果依然没有，则会关闭当前的长轮询，重新再开一个</strong></p><p>​    轮询所设置的时间，可以某种程度上减少来自客户端的快速频繁请求，但是同样也会带来问题，对于客户端数目非常庞大的网站，如果同一时刻有非常多的长轮询，也就意味着服务端的压力就会很大</p><p>​    所以 <strong>长短连接 是对于 tcp 连接角度来做的设置，长短轮询 则是通过编程方式来实现</strong></p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>​    <strong>用户数据报协议（UDP User Datagram Protocol），是传输层中一种面向无连接的协议</strong>，它主要用于不要求分组顺序到达的传输，分组传输顺序的检查与排序由应用层完成 ，用在对质量要求不高，要求速度接收的场景，像是视频通话服务等</p><p>​    与 TCP 基于字节流不同，UDP 数据包在传输前，应用层的数据不会进入到一个缓冲区中，而是在传输层中加上 UDP 的头部直接交给下一层处理然后发送，所以对于接受方而言，接收的 UDP 数据报不会像 TCP 那样是有序的，也会有丢失的情况</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>​    不像 TCP 传输前必须要经历三次握手来进行确认，UDP 面向无连接的方式，不需要去关注那些确认序列号和标识符，简单来说就是只管发不管收，就传输效率上来说要比 TCP 高</p><h4 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h4><p>​    与 TCP 就像是混沌的两面一样，UDP 简化了数据传输通信前的效率，带来的是自己的不可靠性，因为没有连接双方的确认，使得数据报在网络中以任何路径去发往目的地，且由于可能的网络不稳定，因此不关注是否最后数据报到达了目的地，也就会产生丢包的现象，但是 UDP 适用的场景而言，像是视频通话等，丢失几帧的画面或是一小段声音都不会产生太大的影响</p><h4 id="数据包结构-1"><a href="#数据包结构-1" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><img src="https://wei-foun.github.io/img/udp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="img"></p><p>​    伪首部：和 TCP 一样是 12 个字节，目的是为了来进行校验，判断数据包是否是发给本机的，但对于 UDP 面向无连接的特性，伪首部的内容并不是实际有效的部分，只是一个虚拟的数据结构</p><p>​    校验和：在 UDP 中是一个可选项，通过判断接收到的数据包的 校验和 的 值是否为全 1，来判断是否丢弃收到的该数据包</p><p>​    UDP 长度：则是包含了 UDP 首部 和 数据 的字节长度</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>​    <strong>超文本传输协议（Hyper Text Transfer Protocol）</strong>，是 w3c 组织 的对网络通信的一种基于 tcp 协议传输层上的应用层协议，也可以说是一套通信标准，规定了客户端与服务器之间的通信格式，http 协议的 <strong>默认端口是 80</strong></p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>​    http 协议本身不会对请求和响应之间的通信状态进行保存，简单来说每次 http 请求都不存储着上次所得到响应内容的参数信息，即每一次请求都是独立的。但是随着 web 不断发展，无状态的 http 请求对于业务来说存在很多问题，所以在 <strong>HTTP/1.1 中有引入了 Cookie 来存储一些认证信息，维持用户对于网站的登录状态</strong></p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>​    指的是 htttp 协议对处理的限制，要求每一次建立的 tcp 连接上只能处理一个请求，当响应了请求后，随即断开连接，以此来节省传输时间，提供并发性能。但在 HTTP/1.1 开始就不是直接立刻断开连接，而是通过参数 <code>Connection:keep-alive</code> 维持一个长连接，又或是再通过 <code>keep-alive:timeout=num</code> 来设置一个最大等待时长，目的是如果一个客户端在得到响应后可能会立刻再次请求获取新的内容，那么就可以依然使用同一个连接来进行数据的传输，减少大量反复建立连接的开销</p><p>​    那如果使用了长连接，且发送很多不同该请求，需要怎么区分开呢？可以有两种方式一种就是，一种是在头部信息中加上 <code>Content-Length</code> 字段来告知发送数据有多长，服务端根据长度判断，比如接收文件时，当请求的 <code>Content-Length</code> 为 0 那么就代表客户端的文件上传结束了。但是会有两个问题，如果值设置小于传输的数据大小，会造成数据被截断，如果设置的值小于文件大小，会使接收一致存在处于 Padding 挂起状态</p><p>​    那对于动态的数据无法得知长度时，使用 <code>Transfer-Encoding：chunked</code> 表示对数据进行分块编码，对于每一个分块而言，会包含一个 16 进制的数据长度值，且这个数据长度独占一行，通过 ‘\r\n’ 与真实数据隔开，当最后数据长度值为 0 表示当前请求的内容数据传输结束</p><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>​    http 协议上的数据全是明文方式进行传输的，这也使得数据在传输过程中是不安全的</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>​    包含三部分：<strong>请求行，请求头，请求体</strong></p><p><img src="https://wei-foun.github.io/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="img"></p><p><img src="https://wei-foun.github.io/img/get%E8%AF%B7%E6%B1%82.jpg" alt="img/md5.jpg"></p><p>​    通过直接在浏览器中，也可以看到关于请求头的信息，不过请求行的部分不会直接显示，只需要点击一下请求头旁边的 view source 就可以看到请求行。另外一般对于 GET 请求来说，都是为了获取数据，所以一般没有请求体的内容，但是不代表 GET 请求就完全没有请求体</p><h5 id="常见的请求头首部字段"><a href="#常见的请求头首部字段" class="headerlink" title="常见的请求头首部字段"></a>常见的请求头首部字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept：可接受的媒体类型（*/*表示支持所有text/html,application/xhtml+xml,application/xml 等）</span><br><span class="line">Accept-Encoding：内容的编码类型（gizp，br，deflate）</span><br><span class="line">Authorization：用户认证信息</span><br><span class="line">Host：请求资源所在服务器</span><br><span class="line">User-Agent：http 客户端程序信息（使用什么设备，浏览器版本等等）</span><br><span class="line">Cookie：每次请求会携带这个值做状态检查</span><br></pre></td></tr></table></figure><p>​    媒体类型的形式是，”/“ 前面是顶级媒体类型，描述通用的类型信息和处理规则，有：application，image，text和multipart； “/“ 后面是子类型，表示一个具体数据格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text/html: HTML格式的文本文档</span><br><span class="line">text/plain: 普通的ASCII文本文档</span><br><span class="line">text/xml: XML格</span><br><span class="line">image/png、image/jpeg、image/gif：图片类型</span><br><span class="line">application/xml: XML数据格式 </span><br><span class="line">application/json: JSON数据格式 </span><br><span class="line">application/x-www-form-urlencoded: form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</span><br><span class="line">multipart/form-data: 表单中进行文件上传时，需要使用该格式</span><br></pre></td></tr></table></figure><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>​    包含三部分：<strong>响应行，响应头，响应体</strong></p><p><img src="https://wei-foun.github.io/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="img"></p><h5 id="常见的响应头首部字段"><a href="#常见的响应头首部字段" class="headerlink" title="常见的响应头首部字段"></a>常见的响应头首部字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges：是否接受字节范围请求</span><br><span class="line">Age：推算资源创建经过的时间</span><br><span class="line">Location：令客户端重定向到指定的url（通常300状态的时候会出现）</span><br><span class="line">Server：http服务器的信息</span><br></pre></td></tr></table></figure><h4 id="请求和响应头中通用的首部字段"><a href="#请求和响应头中通用的首部字段" class="headerlink" title="请求和响应头中通用的首部字段"></a>请求和响应头中通用的首部字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control：控制缓存行为</span><br><span class="line">Date：创建报文的日期时间</span><br><span class="line">Pragma：报文指令</span><br><span class="line">Transfer-Encoding：指定报文主体的传输编码方式</span><br></pre></td></tr></table></figure><h4 id="请求和响应头中的实体首部字段"><a href="#请求和响应头中的实体首部字段" class="headerlink" title="请求和响应头中的实体首部字段"></a>请求和响应头中的实体首部字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Allow：支持的http的方法</span><br><span class="line">Content-Encoding：主体使用的编码方式</span><br><span class="line">Content-Length：实体内容的长度，单位是字节</span><br><span class="line">Content-Type：主体的媒体类型（json，form，jpeg等等）</span><br><span class="line">Connection：设置持久连接（keep-alive）</span><br></pre></td></tr></table></figure><p>​    content_type 通常是服务器告诉客户端，这次数据的类型，accept 通常是表示客户端请求资源时，自己支持哪些类型</p><p>​    常见的 Content-Type 类型有：</p><p>​    <strong>application/x-www-form-urlencoded</strong>：表示浏览器原生的 form 表单提交，数据格式是按照 key1=val1&amp;key2=val2，且对 key 和 val 都会进行 url 编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 </span><br></pre></td></tr></table></figure><p>​    <strong>multipart/form-data</strong>：常见的 post 数据提交方法，在提交文件的时候，需要在 form 表单标签中的设置 <code>enctype=&quot;multipart/form-data&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;description&quot; value=&quot;some text&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;myFile&quot;&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>​    <strong>application/json</strong>：表示消息的主体是经过序列化后的 json 字符串，这种方式可以很方便提交结构复杂的结构化数据，也因此很适合 RESTful 的接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/json;charset=utf-8 </span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>text/xml</strong>：是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范，结构上相似与 html，但是相对使用 json 序列化后的结构话数据来说，这样方式会更占用空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST [http://www.example.com](http://www.example.com) HTTP/1.1 </span><br><span class="line">Content-Type: text/xml </span><br><span class="line">&lt;!--?xml version=&quot;1.0&quot;?--&gt; </span><br><span class="line">&lt;methodcall&gt; </span><br><span class="line">    &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; </span><br><span class="line">    &lt;params&gt; </span><br><span class="line">        &lt;param&gt; </span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; </span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt; </span><br><span class="line">&lt;/methodcall&gt; </span><br></pre></td></tr></table></figure><h4 id="HTTP-的发展"><a href="#HTTP-的发展" class="headerlink" title="HTTP 的发展"></a>HTTP 的发展</h4><p>​    0.9 版本：91 年发布，只有 GET，返回 html 内容</p><p>​    1.0 版本：96 年 5 月发布，增加 POST，HEAD，格式内容不再限于 html，报文中规定了字符集，状态码，编码等</p><p>​    <strong>1.1 版本：</strong>97 年 1 月，增加了 PUT，PATCH，DELETE 等，加入了新的机制有：<strong>持久连接（keep-alive），管道机制（pipelining）</strong>，Host 字段</p><p>​    <strong>管道机制（pipelining）</strong>，正是因为 1.1 版本实现了长连接，使得产生了管道传输的机制。简单来说，管道机制实现了请求和相应的连续性，因为相比原本的通信方式，一个请求只有收到响应后，才能继续发送下一个请求，而 <strong>管道机制允许了请求发送后，可以不用等待该请求的响应返回，从而继续发送后续的请求</strong>，也就说从原本的单向发送阻塞的通信，变成了双向非阻塞的通信传递</p><p>​    不过，虽然发送方的请求允许了不等待响应，非阻塞的发送后续请求，但是对于服务端来说，响应的返回依然是与顺序的，严格按照请求的顺序一一进行响应的返回，如果第一个请求的响应比较耗时，<strong>会导致造成队头阻塞的问题</strong></p><p>​    <strong>2.0 版本：</strong>15 年，在 09 年 SPDY 草案版本上做了修改来提升效率，加入了：</p><p>​    <strong>二进制协议，</strong>1.1 中头信息是文本格式，数据体可以是文本或二进制，在 <strong>2.0 的版本中头部信息以及数据体一律都是二进制，并统称为 “帧”，叫头信息帧和数据帧</strong></p><p>​    <strong>多路复用，</strong>复用 TCP 实现双向实时通信，双发都可以发送多个请求和响应，如果服务器收到两个请求，第一个处理上较慢，会先响应第一个，并同时去响应第二个，然后回过头来继续响应第一个请求还没回复的数据</p><p>​    由此可见，2.0 的 多工传输 和 1.1 的 管道机制的不同之处，1.1 的 pipelining 的通信当原本的单发，改成了多发来提升效率，但是对于响应接收依旧是顺序的，会出现队头阻塞问题；<strong>2.0 的 多路复用</strong> 则对该问题的进行一步优化，<strong>允许了响应的返回不按照接收请求的顺序</strong>，达到了一个类似异步的效果</p><p>​    但是，<strong>多路复用本质上解决了 http 层面上出现的队头阻塞，但是对于 TCP 连接而言，依然存在队头阻塞问题</strong>，因为数据包的抵达可能是无序的，TCP 需要对接收数据报文校验和排序整合之后在传给上层，<strong>如果某个报文丢失，需要等待这个报文重传，因此 TCP 的连接通信会阻塞</strong></p><p>​    <strong>头信息压缩，</strong>使用 gzip 等算法压缩头信息，且双方维护一张头信息表，从而提高速度，比如对头部信息中占用较多且重复的 <code>Cookie</code> 和 <code>User Agent</code> 将这些信息压缩到各自的表里，通过检查索引号，来减少一样信息的发送</p><p>​    <strong>数据流，</strong>由于多工传输实现的双方可以发送和响应多个数据，所以在 2 的版本中数据包的接收就是没有顺序的，比如同一个连接中，发起的多个请求可能属于多个不同的响应，<strong>在 2 的版本中将每个请求或回应的所有数据包，称为一个 数据流，用一个唯一编号来标识进行区分，且客户端可以对数据流设置优先级</strong></p><p><img src="https://wei-foun.github.io/img/http1.jpg" alt="img"> </p><h4 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h4><table><thead><tr><th>方法名</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>用于获取资源</td></tr><tr><td>POST</td><td>用于提交数据</td></tr><tr><td>PUT</td><td>用于提交新内容，实现数据更新</td></tr><tr><td>DELETE</td><td>用于删除指定数据</td></tr><tr><td>HEAD</td><td>用于获取报文首部</td></tr><tr><td>OPTIONS</td><td>用于询问服务器支持的请求方法</td></tr><tr><td>TRACK</td><td>用于测试或debug，将服务端收到请求返回给客户端</td></tr><tr><td>PATCH</td><td>用于对数据进行局部更新</td></tr></tbody></table><p>​    对于 GET 请求来说，请求特定资源时，资源的关键字是直接跟在请求的 url 之后，指定资源与 url 部分使用 ‘?’ 进行隔开，如果有多个指定参数则是以 ‘&amp;’ 进行连接；而对于 POST 来说，比如表单内容，都是放在 POST 的请求体的进行提交，前提是表单提交的类型是 form-data</p><p>​    除此之外，GET 请求的 url 是有长度限制的，POST 因为数据放在请求体里，所以没有长度限制，但这只是理论上的，如果真的不做限制，对服务端而言处理也是个麻烦</p><p>​    POST，PUT，两者也有相似的地方，都可以用来进行数据创建或是进行更新，但要符合 RESTful 规范的要求，还是利用 POST 来做数据创建操作，PUT 用来对数据进行更新</p><p>​    另外，PUT 已经是更新了，但是为什么还有个 PATCH ？因为 <strong>PUT 更新接收的是修改后的完整对象</strong>，<strong>PATCH 是局部的更新，</strong>即通过 <strong>接收指定的修改信息对该对象的这个信息进行更新操作</strong></p><p>​    也就是说如果只修改一个用户的一个手机号，使用 PUT 必须将这个用户对象的所有信息（修改过手机号后）传入，最后在结果上看的就是一个局部的更新效果，但因此会浪费带宽。而如果使用 PUT 只传入要修改字段的信息，那么该用户的其他字段数据会被清空，只留下修改的字段数据</p><h5 id="幂等性（idempotent）"><a href="#幂等性（idempotent）" class="headerlink" title="幂等性（idempotent）"></a>幂等性（idempotent）</h5><p>​    指的是系统的接口对外的一种承诺，也就是说当外部调用接口成功后，<strong>无论之后外部调用几次这个接口，给系统带来的影响都是一样的，这样这个接口就是幂等性的</strong>。也就是说，如果一个客户端调用接口，将数据进行修改，成功后有反复去发送相同操作请求，那么这个结果无论执行多少次，也只有第一次的修改是生效的，之后的相同操作对系统而言结果都是一致，那么这个操作称为是幂等性操作，反之就称为是非幂等性操作</p><p>​    <strong>GET</strong>：目的是为了获取资源，比如：<a href="http://www.alexander/news">http://www.alexander/news</a> 。所以不论执行多少次，对于服务端的数据来说不会有任何副作用，所以自然是一个 <strong>幂等性操作</strong></p><p>​    <strong>POST</strong>：用来创建资源，本身而言每一次执行，都会去生成一个新的资源，比如：<a href="http://www.alexander/article，即使每一次使用">http://www.alexander/article，即使每一次使用</a> POST 提交的数据是完全一致的，但是各自的 URI 并不相同，也就是说对服务器来说 POST 请求提交的数据是有副作用的，所以POST 是一个 <strong>非幂等性操作</strong>。对于非幂等性操作而言，提交的数据需要在服务端进行校验处理</p><p>​    <strong>PUT</strong>：其实也可以用来作为数据创建，但是和 POST 的区别在于，POST 针对的是像一个资源的集合体，比如上面创建一篇文章的 url 是 <a href="http://www.alexander/article，而">http://www.alexander/article，而</a> PUT 则是针对每一个单独个体，目的是进行个体的数据更新操作，url 是 <a href="http://www.alexander/article/1。所以对于">http://www.alexander/article/1。所以对于</a> PUT 来说，反复进行一个资源的修改对于服务器而言也没有副作用，是一个<strong>幂等性操作</strong></p><p>​    <strong>DELETE</strong>：和 PUT 一样，使用 DELETE 去反复对一个资源进行删除，其实最后成效的次数只有一次，对服务器没有副作用，自然是一个 <strong>幂等性操作</strong></p><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p><img src="https://wei-foun.github.io/img/http2.jpg" alt="img"> </p><p>​    常见的一些状态码：</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>201</td><td>创建或修改数据成功</td></tr><tr><td>204</td><td>删除数据成功</td></tr><tr><td>301</td><td>永久重定向，资源已被永久转移至其他 url 并转到新 url</td></tr><tr><td>302</td><td>暂时重定向，资源位置临时改变</td></tr><tr><td>304</td><td>自上次请求后，缓存资源没有变化，继续使用缓存资源</td></tr><tr><td>401</td><td>没有授权，表示要求验证身份</td></tr><tr><td>403</td><td>服务端接受请求，但拒绝执行，缺少 token 或 token 不匹配</td></tr><tr><td>404</td><td>页面资源丢失，无法得到指定资源</td></tr><tr><td>405</td><td>请求方法被禁用</td></tr><tr><td>501</td><td>请求方法对服务器不支持，无法完成资源响应</td></tr><tr><td>502</td><td>服务器作为网关或代理服务尝试执行请求时，从上游的服务器收到无效响应</td></tr><tr><td>503</td><td>服务器目前无法使用，比如暂时停机维护等</td></tr><tr><td>504</td><td>服务器作为网关或代理服务器，没有及时收到上游服务器响应，超时</td></tr><tr><td>505</td><td>服务器不支持请求中使用的 HTTP 协议版本</td></tr></tbody></table><p>​    301 永久重定向，常用与比如网站域名发生变更，当访问旧域名时就会跳转到新域名下，对于搜索引擎来说，会将原本旧域名下的原有外部链接转移到新域名下，不会损失网站对于搜索引擎的权重</p><p>​    302 临时重定向，通常就是临时做跳转，比如匿名用户点击用户中心，跳转登录页面，发生的跳转就是临时跳转，一般在这种情况下搜索引擎不会传递页面权重，但有些情况下 302 的临时重定向也可能会被计入新网址的网站下，这就导致网站域名的流量可能被链接数量分摊，使得网站在搜索引擎的排名降低</p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><p>​    <strong>安全超文本传输协议（Hypertext Transfer Protocol Secure，HTTPS），基于 HTTP 协议，通过 SSL (Secure Socket Layer，安全套接字协议) / TLS (Transport Layer Security，传输层安全)  提供 加密处理数据、验证对方身份 以及 数据完整性保护，即加密 (Encryption)、认证 (Verification)、鉴定 (Identification) 三种功能</strong></p><p><img src="https://wei-foun.github.io/img/https1.jpg" alt="img"></p><h4 id="对称加密技术（symmetrical-encryption）"><a href="#对称加密技术（symmetrical-encryption）" class="headerlink" title="对称加密技术（symmetrical encryption）"></a>对称加密技术（symmetrical encryption）</h4><p>​    <strong>加密和解密使用的是同一个密钥</strong>，那么这就是 “对称密钥加解密”，<strong>SSL 在传输阶段对数据进行加密使用的就是对称加密。</strong>对称加密并不安全，一旦唯一的密钥会获取，那个对于加密的数据其实就和明文传输没什么区别了</p><p><img src="https://wei-foun.github.io/img/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="img">  </p><p>​    对称加密的优点是，它的加密算法计算量要小，使得加密与解密过程更快，但缺点就是因为发送时，密钥会和加密数据一同发给接收方，导致任何一个人拦截了数据，就能获得密钥进行解密</p><h4 id="非对称加密技术（asymmetrical-encryption）"><a href="#非对称加密技术（asymmetrical-encryption）" class="headerlink" title="非对称加密技术（asymmetrical encryption）"></a>非对称加密技术（asymmetrical encryption）</h4><p>​    <strong>加密和解密使用的是两个不同的密钥</strong>，那么这就是 “非对称密钥加解密”，对于这两密钥来说，<strong>公钥 与 私钥</strong> 都是由服务器向 CA 认证中心申请的数字证书中所以包含的，服务器会将 公钥 发送给客户端，将 私钥 进行保存，并对接收到数据用自己的 私钥 进行解密，所以在 <strong>SSL 的握手阶段使用的就是 非对称加密</strong></p><p><img src="https://wei-foun.github.io/img/%E9%9D%9E%E5%AF%B9%E7%A7%B0.jpg" alt="img"></p><p>​    补充：密钥的生成可以通过 openssl 去创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建私钥</span></span><br><span class="line">$ openssl genrsa -out server.key 1024   <span class="comment"># 生成服务端的 rsa 私钥文件</span></span><br><span class="line">$ openssl genrsa -out client.key 1024   <span class="comment"># 生成客户端的 rsa 私钥文件</span></span><br><span class="line"><span class="comment"># 创建公钥</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> server.key -pubout -out server.pem  </span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> client.key -pubout -out client.pem</span><br></pre></td></tr></table></figure><p>​    非对称加密，同样也不是绝对安全的，如果中间人进行抓取，扮演双向角色，对服务端假装自己是客户端，在客户端面向假装自己是服务端，就可以在真正的服务端与客户端交换公钥的时候获取到双方的公钥。然后中间人将自己的公钥发给服务端和客户端，这样客户端无法知道公钥是否是真正的服务端公钥，而导致加密数据其实被中间人通过自己的私钥解开</p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>​    <strong>即结合 非对称加密 和 对称加密 技术</strong>，对于服务端而言，需要将自己的公钥发送给客户端，客户端使用随机数和对称算法得到会话密钥，并用服务端公钥加密，所以在握手阶段时，主要目的是交换密钥（会话密钥），服务端先用自己的私钥解开第一层，获取到客户端制定的通信用的会话密钥。而在数据通信阶段，则使用会话密钥进行双方的数据通信</p><p>​    由此，<strong>混合加密中，非对称加密的第一阶段，密钥交换的目的是为了保证密钥的安全性，而第二阶段的对称加密，使得双方可以在加密与解密更加高效</strong></p><p>​    混合加密 也不意味着一定安全，一旦中间人攻击，密钥仍然会泄露，那中间人就能获取到数据并解密得到会话密钥，利用这个会话密钥与服务端通信。所以 <strong>https 中出现了数字证书，服务端的公钥需要在权威的 CA 认证机构（Certificate Authority ）申请获取，由此解决公钥的信任问题</strong></p><h4 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h4><p>​    通过 <strong>单向（即不可回推出原文）hash 函数对原文进行哈希</strong>，将需加密的明文 “摘要” 成一串固定长度 (如128 bit) 的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且为了提升 hash 的强度，密码学的 “加盐” 策略允许使用随机数据，对原数据做附加输入，来增强算法</p><h4 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h4><p>​    数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥 加密技术（非对称加密）和 数字摘要 结合起来，形成了实用的 数字签名技术</p><p>​    在 https 中通过 CA（Certificate Authority）数字认证中心来为站点颁发证书，这个证书中具有 CA 自己的公私钥实现的密钥签名，还会包含颁发机构的信息，公钥，公司信息，域名，指纹等等，为了防止中间人攻击，客户端会去验证证书的合法性，包括：验证域名，有效期；判断证书来源是否合法；与 CA 服务器校验判断证书是否被篡改等</p><p>​    为了获取 CA 证书，服务端还需通过自己的私钥去生成一个 CSR（Certificate Signing Request）证书签名请求文件。不过要从 CA 机构获取证书是付费的，所以对于中小企业，通常会是使用自签名证书，就是自己拟作为 CA 机构给自己的服务器颁发证书</p><p>​    自签名证书同样需要生成私钥，以及 CSR 文件，通过这两个再去生成证书</p><p><img src="https://wei-foun.github.io/img/%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsas -out ca.key 1024</span><br><span class="line">$ openssl req -new -key ca.key -out ca.csr</span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure><p>​    完成后，对于服务器来说，就需要去向自己模拟的 CA 申请证书，再此之前需要服务器先生成自己的 CSR 文件 <code>openssl req -new -key server.key -out server.csr</code>，需要注意在这个过程中 Common name 要匹配服务器的域名</p><p>​    所以，在 SSL 握手阶段，客户端会收到服务器发送的证书来做校验。即使因为证书中公钥是公开的，中间人虽然获取到证书，但是不能得到服务器自己的私钥，就算进行伪装修改证书，在客户端向服务端验证时，也会去验证请求域名等，如果中间人换回了合法的证书，会因为证书域名和请求域名不一致，而认为不通过</p><p><img src="https://wei-foun.github.io/img/ca%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>​    https 实现了数据通信的加密，使得常规状态下利用抓包工具所抓取到的内容都是密文状态，但是对于浏览器来说，当发现证书存在问题后，只是提示会有安全风险，如果用户授权了是可以继续访问网站的</p><p>​    通常对于 https 的抓包工具都会去生成一个证书，用户手动安装这个证书到本地客户端中，那么之后浏览器发出的请求就不直接是与服务端之间通信，而是像走了一个代理，直接使用生成的证书与抓包工具进行数据通信，抓包工具会将请求转发到服务器，这样一来服务端的返回都会经过抓包工具在返回到浏览器</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><p>​    <img src="https://wei-foun.github.io/img/http3.jpg" alt="img">  </p><p>​    从图中明显可知，在 http 3.0 使用的就不再是 TCP 协议，而是使用 UDP，并且在基于 UDP 之上，使用了 QUIC，并使用 TLS 1.3 的版本</p><p>​    google 选择使用 UDP，也不是没有原因的。即使是在 2.0 下，基于 TCP 的通信依旧是会有建立连接时间较长，以及可能的队头阻塞问题等，而要对 TCP 进行改造并不容易，因为 TCP 协议栈时 linux 内部重要组成部分，导致修改和升级所要的成本代价太大</p><p>​    相对，<strong>UDP 本身是无连接的，没有建立和关闭连接的过程，并且数据报文的传输不会有队头阻塞问题，也使得对 UDP 的改造会更加方便，所要付出的成本要小</strong></p><h5 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h5><p>​    QUIC 其实是 <strong>Quick UDP Internet Connections</strong> 的缩写，即 <strong>快速 UDP 互联网连接</strong>。<strong>简单来说 QUIC 集成了 拥塞控制，多路复用，安全加密 与一身，基于 UDP 的快速连接</strong></p><p><img src="https://wei-foun.github.io/img/quic.jpg" alt="img"></p><p>​    QUIC 基于 UDP 实现了 <strong>允许一条连接上可以有多个流，流与流之间不会相互影响</strong>，这样就解决了原本使用 TCP 层面上会遇到的队头阻塞问题</p><p>​    另外，以 UDP 为基础，天然的达到了允许在第一次通信时，就可以发送应用数据。相对比 TCP，https 的下需要建立 TCP 握手，以及 TLS 加密握手，至少需要 2-3 个 RRT（轮次），http 下也要至少 1 个 RRT，而 UDP 能做实现 0 RRT</p><p>​    RRT （Round-Trip Time）是衡量网络连接的指标，表示数据包一次来回的耗时，包括三部分：往返传播时间，网络设备内部排队时间，应用程序数据处理时间</p><p><img src="https://wei-foun.github.io/img/quic2.gif" alt="img"></p><p>​    虽然，QUIC 协议下可以做都 0 RRT，但是有前提条件的，因为要保证密文和密钥安全，就不得不需要 1 个 RRT来实现密钥交换，为数据通信阶段的加密做准备（即首次连接）。但是 QUIC 中，密钥交换时，在客户端会将服务端发送的 config 包保存，也就说如果客户端有服务端发送的 config，那么就可以直接进行数据传递（非首次连接）</p><p>​    另外，客户端对 config 信息的保存也是有时效性的，一旦过期就需要再次进行首次连接，重新交换会话密钥</p><h3 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h3><p>​    <strong>websocket 是一种全双工的通信协议</strong>，也就是允许了服务端能够进行主动的响应，相比于 http 或者是 ajax 的轮询方式做请求和响应，websocket 的开销要小得多，因为不会存在频繁的 tcp 的握手和挥手，所以 websocket 适用于实时通信，协同编辑等场景</p><p><img src="https://wei-foun.github.io/img/websocket%E9%80%9A%E4%BF%A1.jpg" alt="img"></p><p>​    websocket 的实现是基于 http 去实现的，<strong>websocket 最开始依然是需要通过 tcp 的三次握手来建立 http 进行协议升级，可以当做是 websocket 的握手阶段，握手完成后则通过 websocket 的数据帧协议进行数据通信</strong></p><p>​    <strong>在 http 协议升级的请求头中会有两个字段，分别是 Connection 和 Upgrade，其中 Upgrade 字段的值就是 websocket，也就是表示要从 http 协议升级为 websocket 协议，Connection 的值是 Upgrade</strong>，除了这两个字段外，<strong>请求头还有一种重要的字段就是 sec-websocket-key 这个字段，它的值是一串 base64 的编码值</strong></p><p>​    <strong>服务端接收到 http 请求头的 key 后，会将这个 key 和 websocket 的一个固定的 uuid 做拼接，通过 sha1 计算后在利用base64 编码，然后给到响应字段 sec-websocket-accept</strong>，表示接收客户端的 http 的升级，并且响应的状态码是101，表示升级成功</p><p>​    <strong>补充：因为 websocket 是基于 http 实现的，所以 ws 的端口和 http 是一致的</strong></p><h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>​    属于七层模型中的网络层协议，IP 协议在网络层的主要作用，<strong>是实现主机与主机之间的通信，即点对点通信</strong>。最常见的 ip 版本就是 IPv4，后来为了对全球可分配的 ip 进行扩充，出现了 IPv6 的版本</p><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>​    网际协议第4版（Internet Protocol version4，IPv4），是一个用点分隔开的四组十进制数的一个主机网络地址标识，每一组的范围是 0 - 255，所以最大位 255，换成二进制是 8 个 1</p><p>​    且 IPv4 又分了 5 大类，每一类中的第一组都有各自范围，整个 <strong>ip 地址又有两部分组成，即 网络地址 和 主机地址</strong>，网络地址用来识别设备所在的网络，主机地址用于设备该网络中的设备。IPv4 分出的 5 类，每一类范围都不同即能标识最大主机数也不同，用于不同级别的大，中，小型网络</p><p>​    其中，网络地址在数据发送时，会根据路由器和主机的各自的路由控制表进行转发</p><p><img src="https://wei-foun.github.io/img/ip.jpg" alt="img">  </p><p>​    <strong>ip 地址的分类：</strong></p><p>​    <strong>A类：</strong>1 - 127 开头，换成二进制的首位就是 0 [0000001]，默认的掩码是 255.0.0.0 / 8</p><p>​    <strong>B类：</strong>128 - 191 开头，换成二进制首位是 10 [000000]，默认的掩码是 255.255.0.0 / 16</p><p>​    <strong>C类：</strong>192 - 223 开头，二进制首位是 110 [00000]，默认的掩码是 255.255.255.0 / 24</p><p>​    D类：224 - 239 开头，二进制首位是 1110 [0000]，<strong>组播地址</strong>，代表一组特定的主机。组播地址 只能做为 IP 报文的目的地址，所以不会被分配给任意主机，通常用于多点广播或视频会议等场景</p><p>​    E类：240 - 255 开头，二进制首位是 1111 [0000]，作为保留地址用来以后使用</p><p><img src="https://wei-foun.github.io/img/ip%E5%88%92%E5%88%86.jpg" alt="img"></p><p>​    同时 A，B，C 三类 ip 中还分有私有的 ip 地址，一般向家庭局域网，公司办公以及学校网络，都是使用私有 ip 地址，而公有 ip 地址则是由专门机构分配的，需要申请购买</p><p><img src="https://wei-foun.github.io/img/ip2.jpg" alt="img">  </p><p>​    <strong>特殊的地址：</strong></p><p>​    0.0.0.0 本身其实是一个无效地址，但是在服务器上，可以用来指服务器上的所有地址，如果一个服务器有多个地址，且有一个服务监听的是 0.0.0.0，那么任何地址都能访问服务</p><p>​    其中 127 开头的都作为 回送地址，也叫 <strong>回环地址</strong>，最常见的就是 127.0.0.1 ，数据不会被发送到网络上，而是直接返回给主机，通常用于进行测试连通性</p><p>​    <strong>广播地址</strong>，其中 ip 地址中 <strong>主机号 部分全为 1 的地址，称为 直接广播地址</strong>，<strong>所有部分全为 1 称为 有限广播地址 或 本地网广播地址</strong>。广播地址同样不会被分配给任意主机</p><p>​    一台主机使用 直接广播地址，可以像任意指定的网络广播它的数据报；本地网广播地址 则是主机用于向所在网络的其他主机发送广播数据表</p><p><img src="https://wei-foun.github.io/img/%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80.jpg" alt="img"> </p><p><img src="https://wei-foun.github.io/img/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" alt="img"> </p><p>​    <strong>子网掩码：</strong></p><p>​    <strong>子网掩码 (subnet mask) 又叫网络掩码，它的作用就是用来分开 ip 地址的网络地址和主机地址</strong>，对于 A，B，C 三类的 ip 地址，默认的子网掩码位分别是 8，16，24 位</p><p>​    <strong>练习 &amp; 计算：</strong></p><p>​    如果 ip 为 193.6.7.0 / 24，网络前缀（位）是 24，子网掩码是 255.255.255.0</p><p>​    如果网络位是 26，子网掩码是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">24 位  255.255.255.0    即 11111111.11111111.11111111.00000000</span><br><span class="line">26 位  255.255.255.192  即 11111111.11111111.11111111.11000000</span><br><span class="line"></span><br><span class="line">11000000 是 8 位，下标从左到右是 7 - 0</span><br><span class="line">所以 192 = 2^7 + 2^6 </span><br><span class="line">= 128 + 64</span><br><span class="line">子网地址为 255.255.255.192</span><br></pre></td></tr></table></figure><p>​    该地址的默认网关地址是？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的网关地址是指 主机位 中除了最后一位是 0，其余全是 1 得到的</span><br><span class="line">193.6.7.0 / 24，主机位 是 8 位，即 11111110</span><br><span class="line">  2^7 + 2^6 + 2^5 +2^4 + 2^3 + 2^2 + 2^1 + 0</span><br><span class="line">= 128 + 64 + 32 + 16 + 8 + 4 + 2 + 0</span><br><span class="line">= 254</span><br><span class="line">所以 ip 193.6.7.0 / 24，默认网关地址是，193.6.7.254 / 24</span><br></pre></td></tr></table></figure><p>​    如果还是 26 位的网络位，默认网关又是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">193.6.7.0 / 26，主机位 是 6（32-26） 位，最后一部分即 11 | 111110</span><br><span class="line">  2^5 +2^4 + 2^3 + 2^2 + 2^1 + 0</span><br><span class="line">= 32 + 16 + 8 + 4 + 2 + 0</span><br><span class="line">= 62</span><br><span class="line">所以 ip 193.6.7.0 / 26，默认网关地址是，193.6.7.62 / 24</span><br></pre></td></tr></table></figure><p>​    如果要将该 ip 划分 4 个子网，每一个范围是多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设 2^N ≥ 4，即 N = 2，那掩码也就默认 24 位上 + 2 位 = 26 位，那主机位就是 6</span><br><span class="line">每一子网段中主机数 = 2^6 = 64，所以分 4 个子网的范围是：</span><br><span class="line">193.6.7.0   - 193.6.7.63</span><br><span class="line">193.6.7.64  - 193.6.7.127</span><br><span class="line">193.6.7.128 - 193.6.7.191</span><br><span class="line">193.6.7.192 - 193.6.7.255</span><br></pre></td></tr></table></figure><p>​    ip 为 203.123.1.135，子网掩码是：255.255.255.192，子网地址是什么？广播地址是什么？该地址的 ip 范围是多少？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子网地址 = ip 地址 与 子网掩码 进行 与 运算</span><br><span class="line"></span><br><span class="line">135：10000111  </span><br><span class="line">192：11000000</span><br><span class="line">---------------</span><br><span class="line">     10000000 = 128</span><br><span class="line"></span><br><span class="line">C类 默认网络位 24，192：11000000，所以该 ip 的真正网络位是 24 + 2 = 26</span><br><span class="line"></span><br><span class="line">ip 为 203.123.1.135，子网掩码是：255.255.255.192 的子网地址是：</span><br><span class="line">203.123.1.128 / 26</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">广播地址 = 网络地址 与 子网掩码取反 进行 或 运算</span><br><span class="line"></span><br><span class="line">子网掩码最后一组是 192，即 11000000，取反可得 00111111</span><br><span class="line">128：10000000</span><br><span class="line">192: 00111111</span><br><span class="line">---------------</span><br><span class="line">     10111111 = 191</span><br><span class="line"></span><br><span class="line">所以该 ip 的广播地址是：203.123.1.191</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">通过子网掩码最后一组是 192，即 256 - 192 = 64，即每一个可分组可以有 64 个 ip，但是实际可分配的地址是 64 - 2 = 62 个，因为要去掉 全为1 和 全为0 的两个主机号的地址，所以分组的范围是：</span><br><span class="line">203.123.1.0   - 203.123.1.63</span><br><span class="line">203.123.1.64  - 203.123.1.127</span><br><span class="line">203.123.1.128 - 203.123.1.191    203.123.1.135 在这个范围内</span><br><span class="line">203.123.1.192 - 203.123.1.255</span><br><span class="line"></span><br><span class="line">所以 203.123.1.135 所在的可分配范围是 203.123.1.129 - 203.123.1.190</span><br></pre></td></tr></table></figure><pre><code>**掩码位数，ip 总数，子网掩码对照表**</code></pre><table><thead><tr><th>掩码位数</th><th>IP总数</th><th>子网掩码</th></tr></thead><tbody><tr><td>30</td><td>4</td><td>255.255.255.252</td></tr><tr><td>29</td><td>8</td><td>255.255.255.248</td></tr><tr><td>28</td><td>16</td><td>255.255.255.240</td></tr><tr><td>27</td><td>32</td><td>255.255.255.224</td></tr><tr><td>26</td><td>64</td><td>255.255.255.192</td></tr><tr><td>25</td><td>128</td><td>255.255.255.127</td></tr><tr><td>24</td><td>256</td><td>255.255.255.0</td></tr></tbody></table><h5 id="IPv4-数据报"><a href="#IPv4-数据报" class="headerlink" title="IPv4 数据报"></a>IPv4 数据报</h5><p><img src="https://wei-foun.github.io/img/ipv4.jpg" alt="img"></p><p>​    版本号：占 4 位，通信双方在通信前必须要保证 ip 协议版本一致，IPv4 的版本就是 4</p><p>​    首部长度：占 4 位，即 4 bit，最大值为 1111（15），也就是说最大可以是 60 个字节</p><p>​    总长度：占 16 位，是 首部 和 数据 的综合长度，也就是最大可以是 2^16 - 1 = 65535 个字节，如果超出就会进行分片</p><p>​    标识：占 16 位，就是用来标识数据报，ip 会在存储器中维持一个计数器，每次产生一个 ip 数据报时，对计数器 + 1 赋值给这个标识字段。当数据报过大被分片时，这个标识会被复制，然后给被分片的数据包，接收方在按照标识判断重组数据报即可</p><p>​    标志：占 3 位，其中 最低位 叫 MF，值为 1 标识有若干个数据报，值为 0 标识当前是最后一个数据报，中间位 叫 DF，DF 表示的是不能进行分片，值为 0 时表示可以进行分片</p><p>​    片偏移：占 13 位，用于表示数据报在分片后，在原分组中的相对位置</p><p>​    生存时间：占 8 位，表示数据报在网络中存在的寿命，该字段的值是数据报在转发过程中的跳数，经过一个路由器，计数值就会 - 1，最大的跳数是 255</p><p>​    协议：占 8 位，用来之命名数据报携带的协议</p><p>​    首部检验和：占 16 位，用来校验数据报的首段，值为 0 则保留数据报，否则就丢弃</p><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>​    Internet Protocol Version 6（互联网协议第6版）， 用于替代 IPv4 的下一代 IP 协议。随着科技水平和网络世界的迅速发展，空前的变化使得 IPv4 的编制设计在可用的网络地址和主机地址上的数目开始无法满足需求，虽然出现 地址转换技术（NAT）来缓解这个问题，但是同样造成其他方面的问题</p><p>​    IPv6 在最大的区别点就是相比 IPv4 的 32 位地址而言，<strong>直接扩大到了 128 位</strong>，使得理论上的地址空间扩大了 2^96 倍，并且解决了 IPv4 在实际场景中的诸多问题。<strong>使用 8 个 16 位的无符号整数，每个整数用 4 个十六进制表示，数与数之间用冒号隔开</strong>，例如：3ffe:3201:1401:1:280:c8ff:fe4d:db39</p><p>​    不过也会有 ip 地址中间会有很多 0，例如：1080:0000:0000:0000:0008:0800:200C:417A，0000:0000:0000:0000:0000:0000:0A00:0001。为了简化，在不影响数值表示情况下，可对每一段的多个 0 简写为 1 个 0，也可以将数字前面的 0 省去，当中间有多个连续的 0 的分段，可以将多个如 :0:0:0 称为 ::，即 1080::8:800:200C:417A，::A00:1。对于网络地址位数表示则是和 IPv4 一样使用 “/“ 隔开，然后表示网络位的位数，例如，0020:0250:f002::/48 </p><p>​    与 IPv4 的 A，B，C 三类网络类似，IPv6 也定义三种地址类型：</p><p>​    <strong>单播地址：用来唯一标识一个接口，实现一对一通讯</strong>，其中 <strong>回环地址是 ::1/123</strong>。同时对于单播地址，根据场景范围又分为 3 类，链路本地单播地址：在同一链路单播通信，不用经过路由器；唯一本地地址：在内网实现单播通信，类似 IPv4 的私有地址；全局单播地址：用于互联网通信，类似 IPv4 的公有地址</p><p><img src="https://wei-foun.github.io/img/%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" alt="img">  </p><p>​    <strong>组播地址：用来指定到一群不同的接口，实现一对多通讯</strong>，组播地址起始字节为 FF00::/8 </p><p>​    <strong>任（意）播地址：用来表示一组接口，用于对最近的节点进行通讯，最近的节点通过路由协议来指定</strong></p><p><img src="https://wei-foun.github.io/img/ipv6.jpg" alt="img">  </p><h5 id="IPv6-数据报"><a href="#IPv6-数据报" class="headerlink" title="IPv6 数据报"></a>IPv6 数据报</h5><p>​    对比 IPv4 的协议报，IPv6 做了很多调整</p><p><img src="https://wei-foun.github.io/img/ipv4-6.jpg" alt="img">   </p><p>​    取消了首部长度，因为整个首部的长度是固定 40 个字节</p><p>​    取消了服务类型，而利用流标签和优先级结合的方式来实现</p><p>​    取消了总长度字段，改为使用有效载荷长度</p><p>​    取消了标识，标志 和 片偏移，将这些实现放在了扩展首部中</p><p>​    取消了协议字段，改为下一个首部</p><p>​    取消生存时间，改为跳数限制</p><p>​    取消首部检验和，将数据报的校验放在了数据链路层和传输层上</p><p>​    取消了选项字段，将其归并到扩展首部里</p><h3 id="URI-，URL，URN"><a href="#URI-，URL，URN" class="headerlink" title="URI ，URL，URN"></a>URI ，URL，URN</h3><p>​    <strong>URI</strong> uniform resource identifier，<strong>统一资源标识符，用来唯一的标识一个资源</strong>，比如一张纸，一本书，一份文件</p><p>​    <strong>URL</strong> uniform resource locator，<strong>统一资源定位器，它是一种具体的 URI</strong>，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源，它的目的是告诉你如何访问到指定的资源。如果把 uri 比作一本字典，url 可以看作是每一个字的页码</p><p>​    <strong>URN</strong> uniform resource name，<strong>统一资源命名，是通过名字来标识资源</strong>，如果 uri 是字典，urn  可以看作是开始的目录 </p><p><img src="https://wei-foun.github.io/img/url-uri-urn.jpg" alt="img">   </p><p>​    从图中可知，所有的 url 都可以是 uri，但并不是所有的 uri 都可以作为 url</p><h3 id="WSGI，uwsgi，uWSGI"><a href="#WSGI，uwsgi，uWSGI" class="headerlink" title="WSGI，uwsgi，uWSGI"></a>WSGI，uwsgi，uWSGI</h3><p>​    <strong>WSGI：web service getaway interface，web 服务器网关接口</strong>，是一个 web 服务器与应用服务器通信的一种规范协议，WSGI 是 web服务器 与 web 应用程序或应用框架之间的一种的接口</p><p>​    <strong>uwsgi：用于在 uWSGI 服务器与其他网络服务器的数据通信</strong></p><p>​    <strong>uWSGI：是一个 web 服务器，实现了 WSGI，uwsgi，http 协议</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx &lt;--- uwsgi ---&gt; uWSGI 服务器 &lt;--- WSGI ---&gt; web 应用程序</span><br></pre></td></tr></table></figure><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>​    Representational State Transfer，即 “表现层状态转化”，而这个 “表现层” 指的就是一个具体的资源。对于互联网的任何一个实体或信息，都是有唯一标识的，也就是可以通过 URI 指向这个资源</p><p>​    但是表现层如果只是为了表示资源，显然还不够。因为互联网上的信息是多样的，不同的资源表现的形式也不同，比如图片、网页、音乐等等，图片会有 jpg 等不同格式表现，网页使用 html 展现，音乐也会有 mp3 格式等等</p><p>​    所以，表现层需要将资源通过各自的形式去表示出来，这样一来对于 URI 就不能做到了，URI 只能标识出一个资源，对于资源的表现需要通过 http 协议在头部信息中加入 accept 和 content-type 字段去指定格式，而这个两个字段就是对资源的表现描述</p><p>​    而互联网中，客户端和服务端进行通信，就必然涉及到对资源状态的变更，这就是 “状态变化”。http 协议中定义了基本的 4 个动词（GET，POST，PUT，DELETE），客户端通过这些动词与服务端互动</p><p>​    因此一个 RESTful 架构，需要有：</p><p>​    1）通过 URL 表示资源</p><p>​    2）客户端和服务端可以在表现层上传递这种资源</p><p>​    3）客户端通过 http 的 4 个基本动词能够对服务端的资源去操作，实现状态变化</p><p>​    简答来说，RESTful 是一种前后端分离下的一种设计架构，RESTful 的关注点在于资源，将服务器上的任何数据都作为资源，利用 http 协议的动词来定义设计接口，将接口作为访问资源的钥匙。通过 RESTful 架构可以很好的将前后端分离，前端无需关注后端的返回的模板，只需要按照设计的接口做资源的处理，而后端就将重点放在资源的获取和业务处理，将资源按照定义的接口进行设计，前后端的交流就可以利用 ajax 通过设计好的 RESTful 接口进行资源获取传递 </p><h4 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h4><p>​    <strong>域名：</strong>应该尽可能部署在专用域名下，但如果 api 很简单，不会涉及后续的扩展，可以放在主域名下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com      # 专用域名会更加规范，但是严格必须遵守</span><br><span class="line"></span><br><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure><p>​    <strong>版本：</strong>一个 api 接口的版本可以在 URL 上，也可以放在 http 头部信息中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure><p>​    <strong>路径：</strong>通过一个 URL 获取一个资源，对于这个 URL 来说不能出现动词，只能使用名词。同时请求的资源通常对于数据库来说，都会是一个集合形式，所以 URL 的名词可以使用复数的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure><p>​    <strong>HTTP 动词：</strong>最基本和常见的 4 个动词与数据库的记录操作是对应的，获取资源时，根据需求做指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br><span class="line"></span><br><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园</span><br><span class="line">GET /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE /zoos/ID：删除某个动物园</span><br><span class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><table><thead><tr><th>API name</th><th>非 RESTful</th><th>RESTful</th></tr></thead><tbody><tr><td>获取dog</td><td><code>/dogs/query/&#123;dogid&#125;</code></td><td>GET： <code>/dogs/&#123;dogid</code>}</td></tr><tr><td>插入dog</td><td><code>/dogs/add</code></td><td>POST： <code>/dogs</code></td></tr><tr><td>更新dog</td><td><code>/dogs/update/&#123;dogid&#125;</code></td><td>PUT：<code>/dogs/&#123;dogid&#125;</code></td></tr><tr><td>删除dog</td><td><code>/dods/delete/&#123;dogid&#125;</code></td><td>DELETE：<code>/dogs/&#123;dogid&#125;</code></td></tr></tbody></table><p>​    restful api 的 url 中希望是不使用动词来表述操作的，但是实际开发的 api 设计并不是要严格遵循这样的要求</p><p>​    使用 RESTful 来设计 api 是很好的规范，但是 REST 是一种设计风格，而是强制性的约束和规则，通常情况下 http 的请求操作可能会比较繁琐，在不使用动词区分的情况下，完全按照 RESTful 风格设计的 api 可能不利于团队的理解和设计，而且复杂的操作也可能无法单纯的使用 http 的动词来描述</p><p>​    <strong>过滤信息：</strong>对于大量的数据库的记录，并不会一次全部返回显示给用户，所以 api 上通过参数过滤结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure><p>​    <strong>状态码：</strong> http 协议对于动词的返回，都设置有对于不同情况下的状态标识。但是 api 设计并不一定是需要依照原来的状态码，自定义的状态码需要规划和设计</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 安全</title>
      <link href="/2491919310/"/>
      <url>/2491919310/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的-web-安全知识点"><a href="#常见的-web-安全知识点" class="headerlink" title="常见的 web 安全知识点"></a>常见的 web 安全知识点</h3><h4 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h4><p>​    在早期的 web 服务中，SQL 注入问题会有两类情况：一是，通过构造特殊的输入参数传入到 web 应用中，从而导致 应用程序执行了恶意的 SQL；二是，开发时数据处理的业务逻辑中，没有对输入进行过滤，直接利用字符串的动态拼接去生成 SQL 语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line">db = MySQLdb.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;123456&#x27;</span>, db=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Enter name:&quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;Enter password:&quot;</span>)</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;select * from userinfo where name=&quot;%s&quot; and password=&quot;%s&quot;&#x27;</span> % (name, password)</span><br><span class="line"></span><br><span class="line">res = cur.excute(sql)</span><br></pre></td></tr></table></figure><p>​    在这样一个简单的例子里，利用输入和字符串的拼接来作为 sql 语句，在正常情况下，确实没有问题，但是一旦出现恶意的输入就会造成 sql 注入的产生。假设，用户在输入名字时，输入 <code>stark &quot; --</code>，就会导致即使在密码不正确的情况下，该条 sql 依旧能正常执行并返回结果。这样的问题一旦投入生产环境，被察觉后，一些人就会利用这个漏洞来绕过认证部分，造成数据泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql = &#x27;select * from userinfo where name=&quot;stark&quot; -- asdasd&quot; and password=&quot;&quot;&#x27;</span><br><span class="line"># 因为 -- 在 sql 语句中被认为是注释，也就是说该 sql 语句真正到数据库中查询的部分只有 &#x27;select * from userinfo where name=&quot;stark&quot;&#x27; 这一部分，因为之后的密码的判断语句在 -- 别误认为了是注释内容</span><br></pre></td></tr></table></figure><p>​    因此，直接利用字符串将用户的输入拼接到 sql 语句中是不安全的，所以可以直接将用户的输入作为一个元组，将这个元组作为参数放入到 execute 的方法中，由此实现 sql 语句 对用户输入的传入，execute 方法会自动将元组的内容输入到 sql</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&#x27;select * from userinfo where name=&quot;%s&quot; and password=&quot;%s&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">res = cur.excute(sql, (name, password))</span><br></pre></td></tr></table></figure><p>​    所以，对于 SQL 注入问题 的防范主要：对输入参数进行类型和范围检查，并注意特殊输入或转义的情况；并且不要直接利用拼接去生成 sql 语句，数据库相关的逻辑在 ORM 中操作可以降低注入风险；同时，在数据库层面做好权限管理配置，不使用明文方式存储关键信息</p><p>​    最后，对于网站中可能存在的 SQL 注入问题可以 sqlmap，SQLninja 去进行检测判断</p><h4 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h4><p>​    即 Cross Site Scripting，不直接叫 CSS 而是 XSS，是因为前端里有 CSS（Cascading Style Sheets）了 &#x1F602;</p><p>​    <strong>XSS 跨站脚本攻击，顾名思义就是利用脚本进行攻击，也就是将恶意的代码放入到 js 的脚本文件</strong>，让恶意代码植入到被提供给其他用户的页面中，当其他用户访问该页面，浏览器在执行脚本文件时，执行被植入的恶意代码</p><p>​    一种简单的例子是，在填写表单时，攻击者在表单输入框中输入了 JavaScript 的代码，这样当后台管理系统中，如果用户在页面中点击了刚才保存的表单数据进行查看时，浏览器会执行文本中的代码，从而被攻击或是被利用向其他路由地址发起请求，将数据发送给攻击者等等</p><p>​    <strong>XSS 攻击分为了两类：反射性（非持久型），存储型（持久型）</strong>。非持久型方式是将恶意的脚本代码放入到 url 中，以其他形式发送给用户，来诱使用户点击触发；持久型是将恶意代码注入到脚本文件中，其他用户使用浏览器访问会触发执行</p><p>​    XSS 跨站脚本攻击最危险的目的就是盗取用户的 cookie，从而对用户造成损失，或是利用用户 cookie 对网站发起 DDOS 攻击等。因此，对于恶意的脚本代码输入，需要进行过滤，比如检查判断 <code>&lt;script&gt;, &lt;a&gt;, &lt;img&gt;</code> 等标签等；然后就是对可能的内容进行转义，不过很多模块框架中都会自动去实现这个功能；最后，可以通过设置 HttpOnly 去禁止浏览器访问和操作 Document.cookie</p><h4 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h4><p>​    <strong>CSRF（跨站请求伪造）的产生需要有两个条件。一是，用户需要登录到目标网站获取到 cookie 且没有退出；二是，用户点击由网页中恶意发布的链接或是表单，从而导致发起了 CSRF 攻击</strong></p><p>​    CSRF 攻击主要使用利用了网站对已认证用户的权限去执行未授权的命令而造成的攻击，因为用户身份得到网站认证后，攻击者可以利用用户的 cookie 信息去进行请求发起，而这些请求并不是由用户批准授权的，而是浏览器中存在的 cookie 冒充用户发起攻击请求</p><p>​    对于 CSRF 攻击而言，<strong>最常见的解决方式就是：令牌同步（Synchronizer token pattern，STP），即在表单中嵌入一个隐藏的 csrf_token，服务端会去对比 cookie 判断是否一致，由于浏览器的同源策略，其他的网站不能获取到 cookie 中的 csrf_token</strong></p><p>​    另外，<strong>使用 js 提交表单，需要将获取的 cookie 中的 csrf_token 作为 X-CSRFtoken 请求头携带然后提交</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">csrfmiddlewaretoken</span>:$(<span class="string">&#x27;[name=&quot;csrfmiddlewaretoken&quot;]&#x27;</span>).<span class="title function_">val</span>()</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="attr">headers</span>:&#123; <span class="string">&quot;X-CSRFtoken&quot;</span>:$.<span class="title function_">cookie</span>(<span class="string">&quot;csrftoken&quot;</span>)&#125;</span><br></pre></td></tr></table></figure><p>​    关于 csrf_token 的实现，为 webpy 中也有相关说明，主要是定义了一个 csrf_token 函数作用是返回一个会话中的 csrf 令牌或是自己生成一个令牌提供给模板中的表单，然后对 post 请求定义了 csrf_protected 的装饰器，用来对模板提交的 csrf 与 会话中的令牌做比较判断一致性，不一致则抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">csrf_token</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> session.has_key(<span class="string">&#x27;csrf_token&#x27;</span>):</span><br><span class="line">        <span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line">        session.csrf_token=uuid4().<span class="built_in">hex</span></span><br><span class="line">    <span class="keyword">return</span> session.csrf_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csrf_protected</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorated</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        inp = web.<span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (inp.has_key(<span class="string">&#x27;csrf_token&#x27;</span>) <span class="keyword">and</span> inp.csrf_token==session.pop(<span class="string">&#x27;csrf_token&#x27;</span>,<span class="literal">None</span>)):</span><br><span class="line">            <span class="keyword">raise</span> web.HTTPError(</span><br><span class="line">                <span class="string">&quot;400 Bad request&quot;</span>,</span><br><span class="line">                &#123;<span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/html&#x27;</span>&#125;,</span><br><span class="line">                <span class="string">&quot;&quot;&quot;Cross-site request forgery (CSRF) attempt (or stale browser form).</span></span><br><span class="line"><span class="string">&lt;a href=&quot;&quot;&gt;Back to the form&lt;/a&gt;.&quot;&quot;&quot;</span><span class="string">&#x27;) # Provide a link back to the form</span></span><br><span class="line"><span class="string">        return f(*args,**kwargs)</span></span><br><span class="line"><span class="string">    return decorated</span></span><br></pre></td></tr></table></figure><p>​    在将 csrf_token 的令牌渲染到模板中时，则是使用 render 方法将参数传给模板，模板中利用模板语法语法进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render = web.template.render(<span class="string">&#x27;templates&#x27;</span>,<span class="built_in">globals</span>=&#123;<span class="string">&#x27;csrf_token&#x27;</span>:csrf_token&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$csrf_token()&quot;</span>/&gt;</span></span><br><span class="line">  # ... form fields ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    最后，对于逻辑部分的代码，在 post 请求上添加装饰器，去对提交的表单的 csrf 令牌做校验即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myformpage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GET</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> render.myform(...)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @csrf_protected </span><span class="comment"># Verify this is not CSRF, or fail</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">POST</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># If we&#x27;re here - this is not a CSRF attack</span></span><br></pre></td></tr></table></figure><h4 id="CORS-跨域"><a href="#CORS-跨域" class="headerlink" title="CORS 跨域"></a>CORS 跨域</h4><p>​    产生跨域问题的实质是，由于客户端浏览器本身的 同源策略 所引起的，它是浏览器最基本的安全功能</p><p>​    同源，指的是请求的 域名，协议，端口号 都要求相同，如果浏览器从 A 域名的页面中点击 B 域名的网站，此时就会发生跨域</p><p>​    通常前后端分离的项目下，前后端都各自使用不同的端口号，当服务器没有设置跨域资源共享情况下，前端请求后会被浏览器拦截，所以后端可以通过 跨域资源共享（<strong>CORS</strong>，Cross-Origin Resource Sharing）设置允许跨源，允许跨域后，请求头部中会加入 <strong>Access-Control-Allow-Origin</strong>，值为 * 表示允许所有访问</p><p>​    CORS 还分为简单请求和复杂请求两种，对于复杂请求通常会在请求前，再发一个 option 请求进行 “预检”，option 请求通过后，在通过发送请求进行数据通信</p>]]></content>
      
      
      <categories>
          
          <category> web 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 整理</title>
      <link href="/441910974/"/>
      <url>/441910974/</url>
      
        <content type="html"><![CDATA[<h3 id="Git-与-Github"><a href="#Git-与-Github" class="headerlink" title="Git 与  Github"></a>Git 与  Github</h3><p>​    <strong>Git：</strong>一个免费且开源的分布式的版本控制软件，提供：记录文件历史所有变化，随时可恢复到任何一个历史状态，多人协作开发和修改，以及 错误恢复 等功能，</p><p>​    <strong>Github：</strong>是项目文件代码的托管平台，借助于 Git 来实现管理项目的代码</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>​    完成 git 的安装后，就可以通过右键点击“Git Bash Here”，这样就能将 git 运行起来。在此之前要注册Github 账户，这样就可以使用 git 来上传项目了</p><p>​    第一次运行 git 时，需要需要进行一些配置，例如用户名和邮箱，这些配置完成以后再运行时就不会再出现了</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>​    完整结构流程图：</p><p><img src="https://wei-foun.github.io/img/git1.png" alt="img/git1.png"> </p><h4 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h4><p>​    登录到 github 后，在点击个人信息的 “your repositories”，然后点击 “new” 去创建一个场库，在 “Repository name” 中填写创建的仓库名；默认情况下，会自动勾选创建 readme 文件，可以取消勾选，自己创建提交这个 readme 文件，然后点击绿色的创建按钮就可以创建一个仓库了，同时会自动跳转到创建的仓库</p><p>​    提示：一般创建的项目会有一些跟随系统运行的文件产生，例如 django 项目会在模块导入后建立 .pyc 的文件等，而这些基本都是不需要在仓库存放管理的，因此可以在完成仓库创建后，<strong>点击 “create new file” 创建新文件</strong>，在右侧的项目地址后输入 <strong>“.gitignore”</strong>，然后在文件中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.pyc</span><br><span class="line">.idea/</span><br></pre></td></tr></table></figure><p>​    之后，可点击 “preview” 查看预览，再点击 “create new file” 完成创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1）克隆远程仓库所有文件到本地</span></span><br><span class="line">git <span class="built_in">clone</span>  远程仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）添加一个远程仓库</span></span><br><span class="line">git remote add  仓库别名  远程仓库地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 查看远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4）删除远程仓库</span></span><br><span class="line">git remote <span class="built_in">rm</span> 仓库别名</span><br></pre></td></tr></table></figure><h4 id="创建-ssh-账号"><a href="#创建-ssh-账号" class="headerlink" title="创建 ssh 账号"></a>创建 ssh 账号</h4><p>​    仓库的建立只是相当于给你批了块工地可以开始干活，但是仓库创建后只能是仓库创建者拥有使用权限，在多人合作开发时，往往需要将每一个开发者加入到对仓库可交互的名单之中</p><p>​    Github 中在个人头像下拉中会有一个 settings 的选项，点击进入后会有一个 “SSH and GPG keys”，在此可以完成 ssh 密钥的添加。但是，在添加之前需要先生成自己的 ssh 的公钥，如果已经有公钥了，它的位置是在 <strong>“~/.ssh”</strong> 下，其中 id_rsa 文件是私钥文件名，id_rsa.pub 则是公钥的文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成 ssh 密钥：</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;Github账号，可以是用户名，也可以是邮箱地址&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看公钥：</span></span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub</span><br></pre></td></tr></table></figure><p>​    完成密钥的创建后，就可以回到 Github 上将公钥添加进去</p><h4 id="配置全局的-git-环境"><a href="#配置全局的-git-环境" class="headerlink" title="配置全局的 git 环境"></a>配置全局的 git 环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxx@gmail.com&quot;</span></span><br><span class="line"><span class="comment"># 如果项目中的某个值和全局设置有区别，则可以不使用 --global 参数，这样会在当前的目录下创建 .git/config，从而使用针对当前项目的配置</span></span><br></pre></td></tr></table></figure><p>​    另外，也可以直接在 “~” 目录下去修改 “.gitconfig” 文件，在 “[user]” 下填写邮箱和用户名</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init        <span class="comment"># 初始化目录，在本地创建一个仓库，并在目录下生成一个 .git 的隐藏文件</span></span><br><span class="line"></span><br><span class="line">git add .        <span class="comment"># 句点符号表示将目录下所有文件添加到暂存区</span></span><br><span class="line"></span><br><span class="line">git add filename1 filename2        <span class="comment"># add 也可以将单个或多个的修改文件加入到暂存区</span></span><br><span class="line"></span><br><span class="line">git add file/        <span class="comment"># add 命令也可以将一个目录进行添加</span></span><br><span class="line"></span><br><span class="line">git status        <span class="comment"># status 命令可以查看暂存区中未提交的记录</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;描述信息&quot;</span>        <span class="comment"># 每一次提交到仓库中时，都需要加上 -m 参数和对应此时提交的简要的说明信息</span></span><br></pre></td></tr></table></figure><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git地址                  <span class="comment"># 从 git 地址中克隆项目到本地，仓库项目文件会在当前目录的仓库文件夹中</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git地址  本地文件夹名<span class="comment"># 从 git 地址中克隆项目到指定的项目文件夹</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b 仓库分支 git地址       <span class="comment"># 从 git 地址中克隆仓库的指定分支，默认 clone 是克隆仓库的主分支 </span></span><br></pre></td></tr></table></figure><p>​    如果出现：sign_and_send_pubkey: signing failed: agent refused operation 异常，表示 ssh 中没有加入新生成的密钥，则可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>​    在开发过程中，为了实现代码互不干扰做到并行开发，每一个人使用一条分支，在整个项目的公共分支中会包含 master 和 dev 两个分支，可以理解为一个是最终线上发布，另一个则就是内部发布提供参考和测试</p><p>​    maser 分支 用于最后的发布，默认会使用 master 这个分支，在每一次发布时会将 dev 的提交的分支进行合并</p><p>​    dev 分支 由于开发阶段性的代码合并，每一个阶段完成后需要进行一次提交，控制项目的进度</p><p>​    成员分支 则是每一个项目成员的代码开发，实现各自代码不会互相影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git branch                     <span class="comment"># 查看所有分支，当前使用的分支前会有 * 表示</span></span><br><span class="line"></span><br><span class="line">git branch -r                  <span class="comment"># 查看远程仓库的分支</span></span><br><span class="line"></span><br><span class="line">git branch 分支名称             <span class="comment"># 创建一个分支</span></span><br><span class="line"></span><br><span class="line">git checkout -b 分支名称        <span class="comment"># 创建并直接切换到该分支</span></span><br><span class="line"></span><br><span class="line">git checkout 分支名称           <span class="comment"># 切换到指定的分支</span></span><br><span class="line"></span><br><span class="line">git branch -m 原分支名 新分支名       <span class="comment"># -m 参数用于重命名分支名</span></span><br><span class="line"></span><br><span class="line">git push origin 分支名称             <span class="comment"># 提交一个分支到服务器，origin 是远程仓库的默认名</span></span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to=origin/分支名称 分支名称            <span class="comment"># 将本地分支跟踪服务器分支</span></span><br><span class="line"></span><br><span class="line">git branch -d 分支名称          <span class="comment"># 删除已合并过的分支，未合并的不能删除，强行删除使用 -D</span></span><br><span class="line"></span><br><span class="line">git merge 分支名称              <span class="comment"># 将指定分支与当前的分支做合并</span></span><br></pre></td></tr></table></figure><h4 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1）建立初始化本地仓库，并与远程仓库进行关联</span></span><br><span class="line">git init</span><br><span class="line">git remote add origin <span class="string">&#x27;远程仓库的地址&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 将要提交的文件加入暂存区</span></span><br><span class="line">git add file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 将暂存区文件提交到本地版本库，并添加此次提交的描述</span></span><br><span class="line">git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) 将本地版本库的目录推送给远程仓库</span></span><br><span class="line">git push origin master             <span class="comment"># 推送给场库的 master 分支上</span></span><br><span class="line">git push origin debug:master       <span class="comment"># 将本地的 debug 分支提交到远程仓库的 master 分支上</span></span><br></pre></td></tr></table></figure><p><img src="https://wei-foun.github.io/img/git2.png" alt="img/git2.png"></p><p>​    如果想要 <strong>修改提交时填写的描述信息，需要使用 <code>--amend</code> 这个参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add .\new.txt </span><br><span class="line">git commit -m <span class="string">&#x27;add new.txt&#x27;</span> </span><br><span class="line"></span><br><span class="line">git commit --amend    <span class="comment"># 输入完成后，会进入 vim 编辑器中，在第一行就可以去修改</span></span><br><span class="line">[master 365ee70] add new.txt on master</span><br><span class="line"> Date: Tue May 25 14:35:18 2021 +0800</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 new.txt</span><br></pre></td></tr></table></figure><h4 id="第一次拉取"><a href="#第一次拉取" class="headerlink" title="第一次拉取"></a>第一次拉取</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pull</span></span><br><span class="line">1）拉取远程仓库的 master 分支，并合并到本地仓库的 master 的分支</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">2）拉取远程的 main 分支，合并到本地的 master 分支</span><br><span class="line">git pull origin main:master</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># fetch</span></span><br><span class="line">1) 获取远程仓库最新的代码</span><br><span class="line">git fetch origin</span><br><span class="line">git fetch origin dev              <span class="comment"># 获取远程仓库 dev 分支的最新的代码</span></span><br><span class="line"></span><br><span class="line">2）查看刚才拉取的内容</span><br><span class="line">git <span class="built_in">log</span> -p FETCH_HEAD</span><br><span class="line"></span><br><span class="line">3）将刚才拉取的内容合并到本地当前的分支</span><br><span class="line">git merge FETCH_HEAD</span><br><span class="line"></span><br><span class="line">git merge origin master           <span class="comment"># 将远程仓库 master 合并到本地当前的分支</span></span><br><span class="line"></span><br><span class="line">git merge origin/master debug     <span class="comment"># 将远程仓库的 master 分支以及本地的 debug 分支合并到本地当前分支</span></span><br></pre></td></tr></table></figure><h4 id="查看本地提交日志"><a href="#查看本地提交日志" class="headerlink" title="查看本地提交日志"></a>查看本地提交日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">1) 查看所有操作过的记录</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">0945949 (HEAD -&gt; debug, origin/master) HEAD@&#123;0&#125;: merge origin/master: Fast-forward</span><br><span class="line">0495169 HEAD@&#123;1&#125;: pull origin master: Fast-forward</span><br><span class="line">982f503 HEAD@&#123;2&#125;: commit: second commit</span><br><span class="line">9416646 (master) HEAD@&#123;3&#125;: checkout: moving from master to debug</span><br><span class="line">9416646 (master) HEAD@&#123;4&#125;: commit (initial): first commit</span><br><span class="line"></span><br><span class="line">2）查看提交的日志，相比 relog 要显得臃肿一些</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit 09459497852cf6052ce32647a62a795ebab3ce6f (HEAD -&gt; debug, origin/master)</span><br><span class="line">Author: A.Ham &lt;34836209+AlaxHAM@users.noreply.github.com&gt;</span><br><span class="line">Date:   Tue May 25 00:49:44 2021 +0800</span><br><span class="line"></span><br><span class="line">    Update &lt;E8&gt;&lt;BF&gt;&lt;9C&gt;&lt;E7&gt;&lt;A8&gt;&lt;8B&gt;&lt;E4&gt;&lt;BB&gt;&lt;93&gt;&lt;E5&gt;&lt;BA&gt;&lt;93&gt;&lt;E7&gt;&lt;9A&gt;&lt;84&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E4&gt;&lt;BB&gt;&lt;B6&gt;</span><br><span class="line"></span><br><span class="line">commit 0495169bc77c2f4b0915acd4c395be3249af5787</span><br><span class="line">Author: A.Ham &lt;34836209+AlaxHAM@users.noreply.github.com&gt;</span><br><span class="line">Date:   Tue May 25 00:34:25 2021 +0800</span><br><span class="line"></span><br><span class="line">    Create &lt;E8&gt;&lt;BF&gt;&lt;9C&gt;&lt;E7&gt;&lt;A8&gt;&lt;8B&gt;&lt;E4&gt;&lt;BB&gt;&lt;93&gt;&lt;E5&gt;&lt;BA&gt;&lt;93&gt;&lt;E7&gt;&lt;9A&gt;&lt;84&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E4&gt;&lt;BB&gt;&lt;B6&gt;</span><br><span class="line"></span><br><span class="line">commit 982f5037da4e1cd600fe1f99169c74596a91c11d</span><br><span class="line">Author: AlaxHAM &lt;1924187152@qq.com&gt;</span><br><span class="line">Date:   Tue May 25 00:18:48 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit 9416646af2743b6b3aeab2681bb5fe7276b2a18e (master)</span><br><span class="line">Author: AlaxHAM &lt;1924187152@qq.com&gt;</span><br><span class="line">Date:   Mon May 24 23:56:43 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">3）查看分支的历史日志，最左侧会有 * 和 | 来表示当前分支的操作</span><br><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line"></span><br><span class="line">* commit 09459497852cf6052ce32647a62a795ebab3ce6f (HEAD -&gt; debug, origin/master)</span><br><span class="line">| Author: A.Ham &lt;34836209+AlaxHAM@users.noreply.github.com&gt;</span><br><span class="line">| Date:   Tue May 25 00:49:44 2021 +0800</span><br><span class="line">|</span><br><span class="line">|     Update &lt;E8&gt;&lt;BF&gt;&lt;9C&gt;&lt;E7&gt;&lt;A8&gt;&lt;8B&gt;&lt;E4&gt;&lt;BB&gt;&lt;93&gt;&lt;E5&gt;&lt;BA&gt;&lt;93&gt;&lt;E7&gt;&lt;9A&gt;&lt;84&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E4&gt;&lt;BB&gt;&lt;B6&gt;</span><br><span class="line">|</span><br><span class="line">* commit 0495169bc77c2f4b0915acd4c395be3249af5787</span><br><span class="line">| Author: A.Ham &lt;34836209+AlaxHAM@users.noreply.github.com&gt;</span><br><span class="line">| Date:   Tue May 25 00:34:25 2021 +0800</span><br><span class="line">|</span><br><span class="line">|     Create &lt;E8&gt;&lt;BF&gt;&lt;9C&gt;&lt;E7&gt;&lt;A8&gt;&lt;8B&gt;&lt;E4&gt;&lt;BB&gt;&lt;93&gt;&lt;E5&gt;&lt;BA&gt;&lt;93&gt;&lt;E7&gt;&lt;9A&gt;&lt;84&gt;&lt;E6&gt;&lt;96&gt;&lt;87&gt;&lt;E4&gt;&lt;BB&gt;&lt;B6&gt;</span><br><span class="line">|</span><br><span class="line">* commit 982f5037da4e1cd600fe1f99169c74596a91c11d</span><br><span class="line">| Author: AlaxHAM &lt;1924187152@qq.com&gt;</span><br><span class="line">| Date:   Tue May 25 00:18:48 2021 +0800</span><br><span class="line">|</span><br><span class="line">|     second commit</span><br><span class="line">|</span><br><span class="line">* commit 9416646af2743b6b3aeab2681bb5fe7276b2a18e (master)</span><br><span class="line">  Author: AlaxHAM &lt;1924187152@qq.com&gt;</span><br><span class="line">  Date:   Mon May 24 23:56:43 2021 +0800</span><br><span class="line"></span><br><span class="line">      first commit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4） 查看具体文件的历史日志</span><br><span class="line">git blame file</span><br></pre></td></tr></table></figure><h4 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1) 回推到上一个操作状态</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD~1</span><br><span class="line"></span><br><span class="line">2) 回推到上上个状态</span><br><span class="line">git reset --hard HEAD~2</span><br><span class="line"></span><br><span class="line">3) 回推到指定的状态，通过提交日志的 <span class="built_in">id</span> 来切换，可以先使用 <span class="built_in">log</span> 或 reflog 看到提交的 <span class="built_in">id</span></span><br><span class="line">git reset --hard 0945949</span><br><span class="line"></span><br><span class="line">4）撤销 add 到暂存区的文件</span><br><span class="line">git reset <span class="built_in">head</span> [之前 add 的文件]</span><br><span class="line"></span><br><span class="line">5）撤销在 add 到暂存区的文件之后的文件修改</span><br><span class="line">git checkout file    <span class="comment"># 文件进入暂存区后，文件数据被更改，要取消更改，用暂存区的状态覆盖当前文件状态</span></span><br><span class="line">git checkout ./      <span class="comment"># 撤销目录所有的更改</span></span><br></pre></td></tr></table></figure><p><img src="https://wei-foun.github.io/img/git3.png" alt="img/git3.png"></p><h4 id="冲突合并"><a href="#冲突合并" class="headerlink" title="冲突合并"></a>冲突合并</h4><p>​    简单来说，A 和 B 对同一个文件进行了修改操作，并且都在各自的分支下完成。并且 A 和 B 都正常执行了常规操作，使用 add 将文件放入暂存区，并且都使用 commit 的命令提交到自己本地的版本上，此时 A 在将版本代码提交到远程仓库前，需要将 B 的本地版本的文件合并到自己本地版本上，相同的文件如果被编辑的话，就会在合并时产生冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A，假设在 master 分支上；B 假设在 debug 分支上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A 和 B 对同一文件都做了修改后并完成了提交，此时 A 要求合并 B 的分支</span></span><br><span class="line">git merge debug</span><br><span class="line"></span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> 第三次提交.txt</span><br><span class="line">Auto-merging 第三次提交.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"><span class="comment"># 提示出现合并错误，要求修改冲突，然后再去进行 commit 提交</span></span><br></pre></td></tr></table></figure><p>​    此时，第三次提交.txt 的文件中会包含 A 和 B 的所有代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">新的 master 的代码</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">新的 debug 的代码</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug</span></span><br></pre></td></tr></table></figure><p>​    1）冲突的解决有两种方法，如果 A 和 B 的提交代码中是重复的，可以选择一个删除；如果 A 和 B 的不重复，那么两者都应该保留，那么就直接删除非代码部分，提示冲突的红色符号部分，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug</p><p>​    2）完成修改后，A 再去执行 add 操作，并再去重新 commit 一次，就能解决冲突问题</p><h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git status         <span class="comment"># 用于检查上次提交之后，是否存在修改</span></span><br><span class="line">nothing to commit, working tree clean         <span class="comment"># 没有修改就返回 nothing to commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个文件后</span></span><br><span class="line">git status</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        <span class="string">&quot;\346\226\260\347\232\204\346\226\207\346\241\243.txt&quot;</span></span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br><span class="line">git status -s    <span class="comment"># 只输出一些简单信息</span></span><br></pre></td></tr></table></figure><h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>​    stash 的作用相当于一个快照容器，当在分支上做开发的时候，突然遇到一个 bug 需要修复，而此时开发的任务还没有完成，自然不能进行提交，而 bug 需要立马修复，此时使用 stash 对当前开发的状态做一个快照保存起来，此时开发中的代码就处于一个不可见状态，相当于是回到了开发任务前的版本状态，当修复好 bug 并提交之后，还可以使用 stash 来恢复快照，获得之前开发中的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1）将当前的代码加入到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 将暂存区的内容进行保存并隐藏</span></span><br><span class="line">git stash                <span class="comment"># 指定 stash 前，一定要执行 add，否则会显示 no local changes to save</span></span><br><span class="line"></span><br><span class="line">git stash save <span class="string">&quot;备注&quot;</span>    <span class="comment"># 保存暂存区内容时，添加备注信息便于查找</span></span><br></pre></td></tr></table></figure><p>​    这样就可以将开发的中间状态存储起来，并且不会干扰其他的提交。然后就可以 checkout -b 创建一个分支来解决 bug 的问题，完成后将修改进行 commit，在回到 master 分支下将处理 bug 的分支合并到 master 下，bug 修复完成就可以将处理 bug 的分支通过 branch -d 删除。最后回到 dev 的分支下，取出 stash 保存的代码，就能继续进行开发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 查看 stash 中保存的状态</span></span><br><span class="line">git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: d1f28d6 new tijiao</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）从 stash 的队列中将需要的中间状态恢复</span></span><br><span class="line">git stash pop              <span class="comment"># 恢复第一个，同时会将这个状态移除 list，也可以 stash@&#123;0&#125; 去指定</span></span><br><span class="line"></span><br><span class="line">git stash apply stash@&#123;0&#125;  <span class="comment"># 恢复指定的第一个中间状态，但是不会从 stash 的 list 中删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3）删除不使用的中间状态</span></span><br><span class="line">git drop stash@&#123;0&#125;         <span class="comment"># 删除指定的 stash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4）删除所有缓存的 stash </span></span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure><p>​    除了用来解决一个 bug 可以使用 stash，如果临时接到一个任务，但是又不想将和这个任务与 dev 分支混在一起，也可以用 stash 将开发的中间状态存储起来</p><p>​    同时，在向远程仓库提交时，如果自己本地的远程仓库版本与实际远程仓库的分支无法匹配，那么 push 就会出现异常。这种情况就是，在自己 push 之前，其他人已经对远程分支做了 push，所以要做的就是先拉取最新的远程分支与本地先合并</p><p>​    这里有两种方式处理：</p><p>​    如果已经在修改的代码从暂存区使用 commit 了，可以使用 reset hard 回退到自己代码修改前的状态，然后使用 pull 拉取最新的分支到本地，然后可以使用 merge 将自己提交过的代码合并到本地最新的分支上，完成后使用 push 到远程仓库</p><p>​    另一种方法可以使用 stash 将当前修改后的代码保存起来，然后使用 pull 拉取合并得到最新的分支，再从 stash 里 pop 出来自己的修改代码，这里会提示有冲突，只需要使用 merge 合并手动去修改冲突即可，完成后再进行 commit 和push </p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>​    通常情况下，会直接使用 <code>git merge 分支名字</code> 来合并某一个分支到当前分支。但是这种方式的合并属于 <strong>fast-forward</strong> 模式，该模式下的合并会将两个分支的提交记录整合在一起，这样的方式会使得提交的历史日志看起来非常来混乱，并且如果删除一个历史的合并记录，会导致合并的信息出现丢失</p><p>​    如果想要合并的同时，将两个分支各自的提交历史记录隔离开，可以使用 <code>git merge --no-ff 分支名字</code> 来做合并操作</p><p>​    除了 merge 可以合并分支，还有一个合并是 rebase，它会将当前的分支和指定分支合并，并作为新的提交在指定的分支下，使得整个合并类似一个线性提交，而没有额外的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 创建并切换到一个分支来处理 bug</span></span><br><span class="line">git checkout -b bugFix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2）将当前分支 bugFix 和 master 合并，作为 master 的一次后续版本</span></span><br><span class="line">git rebase master</span><br><span class="line"></span><br><span class="line">git rebase master bufFix     <span class="comment"># 和上面一致，完成后合并后，切换到 master 分支</span></span><br></pre></td></tr></table></figure><p>​    merge 合并，相当于是将当前版本作为了 merge 的一次后续提交，所以每次使用 merge 都会有 merge commit。使用 rebase 相当于是将自己当前的整个分支作为最新的合并的后续 commit，也就说将自己的提交加在了最后，整个提交是单线的</p><p><img src="https://wei-foun.github.io/img/merge.jpg" alt="img"></p><p><img src="https://wei-foun.github.io/img/rebase.jpg" alt="img"></p><p>​    当本地开发时，没有获取远程的最新版本，就直接要提交的话，是不能提交的。此时要做的就是创建分支拉取远程仓库的最新版本，然后将自己的开发分支与拉取的分支做合并，然后才能提交，这和之前的冲突合并原理是类似的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b o/main</span><br><span class="line">git fetch origin master</span><br><span class="line">git merge dev</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>​    如果不想使用 merge 保留住分支信息，也可以使用 rebase，这样在使用 git push 之后，远程仓库也不会记录你在本地做合并的分支操作，就是一个线性的记录提交</p><p>​    对于 fetch 和 merge 来说，简化的步骤就是 git pull，那对于 fetch 和 rebase 来说，简化的命令就是 git pull –rebase</p><p>​    有些情况下，合并通常不希望是直接把整个分支上的提交全部拉取过来合并在一个提交上，比如指向合并分支某一个提交，这时就可以使用 <code>git cherry-pick  &lt;commit-hash&gt;</code>，比如下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure><p>​    现在使用的分支是 master，然是指向将 feature 的 f 分支拉过来，就可以使用 <code>git cheery-pick f</code>，这样在 master 分支下就会是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure><p>​    也就是说 cherry-pick 主要目的是将一个提交应用到其他的分支上</p><h3 id="git-小游戏"><a href="#git-小游戏" class="headerlink" title="git 小游戏"></a>git 小游戏</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://learngitbranching.js.org/</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Appium 使用</title>
      <link href="/3884749153/"/>
      <url>/3884749153/</url>
      
        <content type="html"><![CDATA[<h2 id="Appium-使用"><a href="#Appium-使用" class="headerlink" title="Appium 使用"></a>Appium 使用</h2><p>​    Appium 是一个跨平台移动端自动化测试工具，可以非常便捷地为 iOS 和 Android 平台创建自动化测试用例。它可以模拟 App 内部的各种操作，如点击、滑动、文本输入等，只要是手工操作的动作 Appium 都可以完成；Appium 实际上继承了 Selenium，Appium 也利用 WebDriver 来实现 App 的自动化测试的</p><p>​    对 iOS 设备来说，Appium 使用 UIAutomation 来实现驱动；对于 Android 来说，它使用 UiAutomator 和 Selendroid 来实现驱动</p><p>​    总体来说，Appium 相当于一个服务器，可以向 Appium 发送一些操作指令，Appium 就会根据不同的指令对移动设备进行驱动，完成不同的动作</p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h4 id="安装-appium"><a href="#安装-appium" class="headerlink" title="安装 appium"></a>安装 appium</h4><ul><li><p>github 地址：<a href="https://github.com/appium/appium">https://github.com/appium/appium</a></p></li><li><p>官方网站：<a href="http://appium.io/">http://appium.io</a> </p></li><li><p>下载链接：<a href="https://github.com/appium/appium-desktop/releases">https://github.com/appium/appium-desktop/releases</a></p></li></ul><p>​        对于 appium 的安装可以通过两种方式，1）直接下载安装包进行软件安装  2）通过 node.js 去安装</p><p>​    下载安装可以通过上面的下载链接，可以根据系统和需要选择版本进行下载，然后就是一步步安装；使用 node 安装，通过命令 <code>npm install -g appium</code></p><h4 id="安装开发环境和配置"><a href="#安装开发环境和配置" class="headerlink" title="安装开发环境和配置"></a>安装开发环境和配置</h4><p>​    安装好 appiumm 后，还需要去下载 Android 并配置，可以直接使用 Android Studio，无论是下载还是配置都非常简便，主要是速度快</p><ul><li>Android Studio下载地址：<a href="https://developer.android.google.cn/studio">https://developer.android.google.cn/studio</a> </li></ul><p>​        安装完成后，点击 Settings，在 Settings 弹出框中直接搜索 “SDK”，选择 Android SDK；然后点击 Android SDK Location 的 Edit 按钮；进入 SDK 的安装页面，修改路径后，勾选 Android SDK，点击 “Next” 按钮后，就会进行下载和安装</p><h4 id="安装-SDK-Platforms"><a href="#安装-SDK-Platforms" class="headerlink" title="安装 SDK Platforms"></a>安装 SDK Platforms</h4><p>​    完成了上面的安装后，就要下载 sdk platform，在 Settings-&gt;Android SDK 页面进行下载，选择对应手机的 Android 系统版本下载 Android 镜像，勾选后点击左侧出现的下载符号即可</p><h4 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h4><p>​    安装都完成后，在一开始选择的路径中，会有一些文件夹：</p><p>​    1）bulid-tools：主要是 Android 开发会使用到的工具</p><p>​    2）emulator：用于管理模拟器</p><p>​    3）platforms：存放所有下载 sdk platforms 包</p><p>​    4）platforms-tools：常用的例如 adb.exe 等可执行文件</p><h4 id="系统变量配置"><a href="#系统变量配置" class="headerlink" title="系统变量配置"></a>系统变量配置</h4><p>​    在 高级系统属性 中，打开 环境变量，新增变量名 ANDROID_HOME，值就是 Android SDK 的安装目录；然后更新 Path 变量，新增 <code>%ANDROID_HOME%\build-tools\30.0.1</code>、 <code>%ANDROID_HOME%\emulator</code> 、<code>%ANDROID_HOME%\platform-tools</code></p><p>​    在命令行，输入命令  <code>adb --version</code>，可查看 adb 版本和 adb 的安装目录 </p><h4 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h4><p>​    Python 可直接使用 pip 去安装 appium 驱动，<code>pip install appium-python-client</code></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    例子来自《52讲轻松搞定网络爬虫》，先在手机安装 app，地址为：<a href="https://app5.scrape.center/">https://app5.scrape.center/</a></p><h4 id="利用-appium-启动-app"><a href="#利用-appium-启动-app" class="headerlink" title="利用 appium 启动 app"></a>利用 appium 启动 app</h4><p>​    首先，开启 appium，打开后初始的界面上会显示 host 和 port，默认 appium 使用的端口是 4723，然后直接点击 “Start Server” 开始服务端开启服务，会看到如下显示：</p><p><img src="https://wei-foun.github.io/img/appium.jpg" alt="img/md5.jpg"> </p><p>​    启动后，从信息上可见 appium 已经在 4723 端口上进行监听了，之后就可以利用这个端口实现向服务接口发送指令，操作返回的日志信息都会在该界面进行显示</p><p>​    然后，将 Android 手机通过数据线和运行 Appium 的 PC 相连，同时打开 USB 调试功能，确保 PC 可以连接到手机，可以在命令行输入 <code>adb devices -l</code> 查看连接情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">P7C0217C13215364       device product:BKL-AL20 model:BKL_AL20 device:HWBKL transport_id:1</span><br></pre></td></tr></table></figure><p>​    返回类似如上的信息则表示连接正常，返回的第一个元素是手机设备的名称，如果使用模拟器，则可能是 emulator-5554，这个元素将作为 deviceName 变量</p><p>​    接着在 appium 的界面右上方会有一个 放大镜 的按钮，表示  Start New Session，会弹出一个新的页面进行配置</p><p>​    需要配置启动 App 时的 <strong>Desired Capabilities 参数</strong>，它们分别是 <strong>platformName、deviceName、appPackage、appActivity</strong></p><p>​    platformName：平台名称，需要区分是 Android 还是 iOS，此处填写 Android<br>    deviceName：设备名称，是手机的具体类型<br>    appPackage：App 程序包名<br>    appActivity：入口 Activity 名，这里通常需要以 . 开头<br>    noReset：在打开 App 时不重置 Session，这里设置为 true</p><p><img src="https://wei-foun.github.io/img/appium-%E9%85%8D%E7%BD%AE.jpg" alt="img/md5.jpg"> </p><p>​    可以直接在点击添加去填写，也可以直接点击右侧 json 的编辑按钮直接输入填写，完成后点击 Start Session 即可启动 Android 手机上的 app</p><p>​    此时，手机可能会需要安装 appium settings 和 io.appium.uiautomator2.server 两个应用，启动 app 的过程中，PC 端的 appium 的窗口会跳转到一个可以进行调试的窗口，该窗口可以预览当前手机的页面，页面的源码等信息</p><p><img src="https://wei-foun.github.io/img/start-app.jpg" alt="img/md5.jpg"> </p><p>​    可以点击左侧手机的界面中任何一个区域，点击后会有高亮显示，同时中间 Source 栏会显示选定元素的对应源码，右侧栏会显示该元素的基本信息，例如 id，class，text 等，同时还提供的操作按钮 Tap、Send Keys、Clear</p><p><img src="https://wei-foun.github.io/img/start-app2.jpg" alt="img/md5.jpg"> </p><p>​    点击中间栏最上方的第三个录制（Start Recording）按钮，Appium 会开始录制操作动作，这时我们在窗口中操作 App 的行为都会被记录下来，Recorder 处可以自动生成对应语言的代码。例如，我们点击录制按钮，然后选中其中一个条目，点击 Tap 操作，即模拟了按钮点击功能，这时手机和窗口的 App 都会跳转到对应的详情页面，同时中间栏会显示此动作对应的代码，<strong>注意：一定要先点击录制的按钮后，再去执行操作，否则直接执行点击操作是不能看到选定和点击操作的代码的</strong></p><p><img src="https://wei-foun.github.io/img/start-app3.jpg" alt="img/md5.jpg"> </p><h4 id="appium-capabilities-参数"><a href="#appium-capabilities-参数" class="headerlink" title="appium capabilities 参数"></a>appium capabilities 参数</h4><p>​    <strong>通用的参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td>automationName</td><td>使用引擎</td><td>默认为 Appium，其中 Appium、UiAutomator2、Selendroid、Espresso 用于Android，XCUITest 用于 iOS</td></tr><tr><td>platformName</td><td>操作系统</td><td>iOS、Android</td></tr><tr><td>platformVersion</td><td>操作系统版本</td><td>4.4、10.0 等等</td></tr><tr><td>deviceName</td><td>操作设备名称</td><td>可以从 adb devices -l 中获取</td></tr><tr><td>newCommandTimeout</td><td>appium 服务端和客户端超时时间</td><td>例如 60 s 等等</td></tr><tr><td>autoWebview</td><td>直接进入 webview 上下文</td><td>True、False，默认是 False</td></tr><tr><td>app</td><td>apk，.ipa 等加载路径，如果应用没有提前安装，可以使用这个参数，在启动时自动安装到手机上</td><td>D:\appium\app\text.apk</td></tr></tbody></table><p>​    <strong>安卓系统的参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td>appActivity</td><td>package 中想要运行的 Activity name，名字前通常需要加.,默认从 package manifest 读取</td><td>如 .MainActivity，MainActivity</td></tr><tr><td>appPackage</td><td>Android app 中想要运行的 Java 的 package 包，默认从package manifest 读取</td><td>如com.example.android.myApp</td></tr><tr><td>appWaitActivity</td><td>设置要等待的 activity，默认与 appActivity 一样，若有 appActivity、appPackage，则必须设置为第一个启动的activity 名称</td><td>如 MainActivity，MainActivity</td></tr><tr><td>appWaitDuration</td><td>用于等待appWaitActivity启动的超时（以毫秒为单位）（默认为 20000）</td><td>如 50000</td></tr><tr><td>adbExecTimeout</td><td>adb 指令超时时间，默认是 20000 毫秒</td><td>50000</td></tr><tr><td>autoGrantPermissions</td><td>让 appium 自动授权 app 权限，如果 noReset 为 True，则该条不生效</td><td>True，False</td></tr><tr><td>ignoreUnimportantViews</td><td>调用 uiautomator 的函数 setCompressedLayoutHierarchy()，此功能能加快测试速度，Accessibility 命令将更快地运行而忽略某些元素</td><td>True，False</td></tr></tbody></table><p>​    更多的参数配置：<a href="https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md">https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md</a> </p><h4 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h4><p>​    直接使用 selenium 提供的查找 api 去查找元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el = driver.find_element_by_id(<span class="string">&#x27;com.package.name:id/path&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    Android 平台，还可以使用 <strong>UIAutomator</strong> 框架去选择元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el = self.driver.find_element_by_android_uiautomator(<span class="string">&#x27;new UiSelector().description(&quot;Animation&quot;)&#x27;</span>)</span><br><span class="line">els = self.driver.find_elements_by_android_uiautomator(<span class="string">&#x27;new UiSelector().clickable(true)&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    iOS 平台，也可以使用 <strong>UIAutomation</strong> 去查找元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el = self.driver.find_element_by_ios_uiautomation(<span class="string">&#x27;.elements()[0]&#x27;</span>)</span><br><span class="line">els = self.driver.find_elements_by_ios_uiautomation(<span class="string">&#x27;.elements()&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h4><p>​    <strong>点击：</strong>可以使用 <strong>tap</strong> 方法， <code>tap(self, positions, duration=None)</code>，该方法可以模拟手指点击（最多五个手指），可设置按时长短（毫秒），positions 参数表示点击位置所组成的列表，duration 参数表示点击持续的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.tap([(<span class="number">100</span>, <span class="number">20</span>), (<span class="number">100</span>, <span class="number">60</span>), (<span class="number">100</span>, <span class="number">100</span>)], <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>​    利用 tap 方法可以实现屏幕上几个点的同时触碰，除此之外，点击操作还有 <strong>click</strong> 方法，例如如果元素是一个按钮，选取到元素后就可以直接使用 click 去进行点击操作</p><p>​    <strong>屏幕拖动：</strong>使用 <strong>scroll</strong> 方法模拟屏幕上的拖动， <code>scroll(self, origin_el, destination_el)</code>，参数 origin_el 表示被操作的元素，destination_el 则是目标元素，scroll 方法实现从元素 origin_el 滚动至元素 destination_el</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.scroll(el1,el2)</span><br></pre></td></tr></table></figure><p>​    除此之外，还有 swipe 方法， <code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>，实现从 start 这一点滑动到 end 这一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.swipe(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">5000</span>)      <span class="comment"># 5 秒内从 (100,100) 坐标滑动到 (400,500) 的坐标位置</span></span><br></pre></td></tr></table></figure><p>​    <strong>拖拽：</strong>使用 <strong>drag_and_drop</strong> 实现某个元素拖动到另一个目标元素上，使用上和 scroll 类似， <code>drag_and_drop(self, origin_el, destination_el)</code></p><p>​    <strong>文本输入：</strong>利用 <strong>set_text</strong> 实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el = find_element_by_id(<span class="string">&#x27;com.tencent.mm:id/cjk&#x27;</span>)</span><br><span class="line">el.set_text(<span class="string">&#x27;Hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    <strong>动作链：</strong>与 Selenium 中的 ActionChains 类似，Appium 中的 <strong>TouchAction</strong> 可支持的方法有 tap、press、long_press、release、move_to、wait、cancel 等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 TouchAction 实现不同位置的连续拖动</span></span><br><span class="line">els = self.driver.find_elements_by_class_name(<span class="string">&#x27;listView&#x27;</span>)</span><br><span class="line">a1 = TouchAction()</span><br><span class="line">a1.press(els[<span class="number">0</span>]).move_to(x=<span class="number">10</span>, y=<span class="number">0</span>).move_to(x=<span class="number">10</span>, y=-<span class="number">75</span>).move_to(x=<span class="number">10</span>, y=-<span class="number">600</span>).release()</span><br><span class="line">a2 = TouchAction()</span><br><span class="line">a2.press(els[<span class="number">1</span>]).move_to(x=<span class="number">10</span>, y=<span class="number">10</span>).move_to(x=<span class="number">10</span>, y=-<span class="number">300</span>).move_to(x=<span class="number">10</span>, y=-<span class="number">600</span>).release()</span><br></pre></td></tr></table></figure><p>​    更多 api：<a href="https://testerhome.com/topics/3711">https://testerhome.com/topics/3711</a></p><h3 id="Python-实现利用-appium-爬取"><a href="#Python-实现利用-appium-爬取" class="headerlink" title="Python 实现利用 appium 爬取"></a>Python 实现利用 appium 爬取</h3><p>​    根据上面的例子，实现电影的名字获取</p><p>​    首先，就是利用 python 来驱动 app，因为 appium 启动后是在 4723 端口运行的，所以先配置服务端的地址，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = <span class="string">&#x27;http://localhost:4723/wd/hub&#x27;</span></span><br></pre></td></tr></table></figure><p>​    接着，就是配置 appium 启动 app 中需要的参数项，利用 python 字典去创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">desired_caps = &#123;</span><br><span class="line">    <span class="string">&#x27;platformName&#x27;</span>: <span class="string">&#x27;Android&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;deviceName&#x27;</span>: <span class="string">&#x27;P7C0217C13115364&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;appPackage&#x27;</span>: <span class="string">&#x27;com.goldze.mvvmhabit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;appActivity&#x27;</span>: <span class="string">&#x27;.ui.MainActivity&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后，就是创建一个 Session 来进行驱动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(server, desired_caps)</span><br></pre></td></tr></table></figure><p>​    以上的配置完成后其实就可以进行 app 的 启动了，但是这还没有结束，还需要使用驱动来执行模拟点击的操作；appium 中的 recorder 可以记录操作并可以生成 python 的代码，只是这个转换的代码会很繁琐，比如前面去点击一个电影后，会生成如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el1 = driver.find_element_by_xpath(<span class="string">&quot;/hierarchy/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.RelativeLayout/android.support.v7.widget.RecyclerView/android.widget.LinearLayout[3]/android.widget.TextView&quot;</span>)</span><br><span class="line">el1.click()</span><br></pre></td></tr></table></figure><p>​    显然，就跟直接在浏览器中复制 xpath 一样，会从根位置一层层找到点击的位置返回，但是利用 xpath 完全可以不用这么麻烦</p><p>​    <strong>完整功能实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">server = <span class="string">&#x27;http://localhost:4723/wd/hub&#x27;</span></span><br><span class="line"></span><br><span class="line">desired_caps = &#123;</span><br><span class="line">    <span class="string">&#x27;platformName&#x27;</span>: <span class="string">&#x27;Android&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;deviceName&#x27;</span>: <span class="string">&#x27;P7C0217C13005364&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;appPackage&#x27;</span>: <span class="string">&#x27;com.goldze.mvvmhabit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;appActivity&#x27;</span>: <span class="string">&#x27;.ui.MainActivity&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;adbExecTimeout&#x27;</span>: <span class="number">20000</span>,      <span class="comment"># 指令超时控制，默认是 20000 毫秒  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(server, desired_caps)</span><br><span class="line"></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">1000</span>)    <span class="comment"># 显示等待</span></span><br><span class="line"></span><br><span class="line">item_element = wait.until(EC.presence_of_element_located(</span><br><span class="line">    (By.XPATH, <span class="string">&#x27;//android.support.v7.widget.RecyclerView/android.widget.LinearLayout[2]&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">item_title_text = item_element.find_element_by_xpath(<span class="string">&#x27;//android.widget.TextView&#x27;</span>).text</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;title_text:&#x27;</span>, item_title_text)      <span class="comment"># 输出电影的名称</span></span><br><span class="line"> </span><br><span class="line">item_element.click()      <span class="comment"># 实现点击电影跳到该电影的单页</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> appium 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法-五</title>
      <link href="/864857163/"/>
      <url>/864857163/</url>
      
        <content type="html"><![CDATA[<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>​    暂时先放上整理的思维导图，<a href="https://www.processon.com/view/link/5f1bda817d9c0835d390df9d，之后会通过思维导图进行一版重新整理">https://www.processon.com/view/link/5f1bda817d9c0835d390df9d，之后会通过思维导图进行一版重新整理</a></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>​    <strong>套接字，是介于应用层与传输层通信的中间软件抽象层</strong>，可以理解为一种接口，让应用程序之间根据各自使用过的协议可接口进行数据通信</p><p><img src="https://wei-foun.github.io/img/socket.jpg" alt="img"></p><p>​    <strong>socket 的常见的类型有：流套接字（sock_stream），数据报套接字（sock_dgram）</strong></p><p>​    <strong>sock_stream 类型就是基于 TCP</strong> 的面向连接，可靠的数据传输；<strong>sock_dgram 则是基于 UDP</strong> 的面向无连接的传输服务；除了常见的两种，还有一种 原始套接字（sock_raw）</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="https://wei-foun.github.io/img/socket%E6%B5%81%E7%A8%8B.jpg" alt="img"></p><p>​    要在互联网中进行通信，至少需要一对的套接字，一个运行在客户端，另一个则是服务端。所以，大致的流程就是：首先，服务端提供对外的地址和端口，使服务器能在该端口进行监听，即等待客户端的连接；然后，由客户端使用套接字去对服务器的地址和端口进行连接；最后，根据套接字使用的协议进行连接确认，然后开始进行数据通信</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server-socket</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)  <span class="comment"># socket.AF_INET 表示 Internet 的ipv4 地址，AF_INET6 则表示 ipv6 地址</span></span><br><span class="line">server_socket.bind((<span class="string">&#x27;ip地址&#x27;</span>, 端口号))   <span class="comment"># 要提供通信，对外提供连接的地址和端口号，使用 bind 去绑定，但是参数必须是一个元组的形式</span></span><br><span class="line">server_socket.lieten()   <span class="comment"># 绑定 ip 和 端口 后，服务端的 socket 使用 listen 去对这个端口进行监听，参数可以是一个数字，表示最大的监听数，一旦超过设置的数，之后的客户端连接就需要等待</span></span><br><span class="line">server_socket.accept()   <span class="comment"># 监听端口后，使用 accept 来允许客户端进行连接</span></span><br><span class="line">server_socket.send()</span><br><span class="line">server_socket.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client-socket</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((<span class="string">&#x27;ip地址&#x27;</span>, 端口号))    <span class="comment"># 客户端的 socket 连接服务端，同样是元组形式的 ip 和 端口号，使用 connect 去主动连接</span></span><br><span class="line">client_socket.send()</span><br><span class="line">client_socket.recv()</span><br></pre></td></tr></table></figure><p>​    创建 socket 的实例时，有两个参数可以填入，第一个参数是 family 表示地址家族，第二参数 type 表示套接字类型</p><p>​    <strong>默认使用 <code>socket.socket()</code> 实例化的套接字对象时，使用的是 AF_INET 和 SOCK_STREAM，即默认使用 TCP 的套接字</strong></p><p>​    <strong>TCP 的 socket 数据的发送与接收，分别是 send 和 recv 两个方法，并且两个方法中数据必须是 字节类型，而在 UDP 中发送与接收，分别是 sendto 和 recvfrom 两个方法</strong></p><p>​    另外，对于服务端 <strong>socket 的 accept 方法，这个方法是会阻塞住 socket</strong> 的，当有客户端进行连接后，才会继续执行后续的代码。并且，<strong>recv 接收数据也会是造成阻塞</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的使用 socket 进行服务端与客户端的聊天，半双工的通信模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># server 端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_socket.bind((<span class="string">&#x27;192.168.1.103&#x27;</span>, <span class="number">8100</span>))</span><br><span class="line">server_socket.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;等待客户端连接&quot;</span>)</span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    conn, addr = server_socket.accept()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;addr&#125;</span>建立连接&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&quot;断开连接&quot;</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;收到<span class="subst">&#123;addr&#125;</span>的消息：<span class="subst">&#123;data.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">                msg = <span class="built_in">input</span>(<span class="string">f&quot;回复<span class="subst">&#123;addr&#125;</span>:&quot;</span>)</span><br><span class="line">                conn.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">server_socket.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;服务端关闭端口服务&quot;</span>)</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># client 端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((<span class="string">&#x27;192.168.1.103&#x27;</span>, <span class="number">8100</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;已与服务端连接&quot;</span>)</span><br><span class="line">client_socket.send(<span class="string">&#x27;你好&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;收到服务端的消息：<span class="subst">&#123;data.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        msg = <span class="built_in">input</span>(<span class="string">f&quot;回复:&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">&quot;断开连接&quot;</span>:</span><br><span class="line">            client_socket.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client_socket.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h4 id="收与发"><a href="#收与发" class="headerlink" title="收与发"></a>收与发</h4><p>​    TCP类型的 socket 发送方法 send 和 接收方法 recv，其中 <strong>当 socket 使用 send 发送数据后，会返回一个发送的字节数，而对应 recv 方法中也会有一个参数，这个参数表示每一次接收的数据的最大字节数</strong></p><p>​    如果 recv 最大接收的字节数，小于了 send 发送的字节数，那么 recv 接收的数据会被截断，可能会看到前一次发送的数据的一部分内容，而剩余的字节会在下一次接收的时候再去返回，这样数据就不会造成丢失</p><p>​    之所以会出现这样的现象，正式因为 TCP 的 socket 在客户端以及服务端，都设置有一个缓冲区，用来对数据做发送和接收的暂时存放。发送时，数据不会立即通过网络进行传输，而是先进入到发送的缓冲区，同理，接收的数据，也先进入到接收的缓存区</p><p><img src="https://wei-foun.github.io/img/socket%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" alt="img"></p><p>​    在 linux 中使用 write 来将数据写入输出缓冲区，read 用来从输入缓冲区读取字节数据，从两个方法的字面意思就能很清晰的说明 socket 套接字的缓冲区的功能就是读和写，但还有一点需要区分，socket 的对象可以理解是应用程序，客户端与服务端分别是在用户态中，而对于缓存区，读写操作是通过系统去调用，是在内核态中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[socket 服务端] -------------- 用户态 -------------- [socket 客户端]</span><br><span class="line"> ||                                                   ||</span><br><span class="line">   [缓存区] ------------------ 内核态 ------------------ [缓存区]</span><br></pre></td></tr></table></figure><p>​    所以，字节数据使用 write/send 发送到输出缓冲区后，任务就算完成了，就会立刻返回，而数据的通信则交给 TCP 协议去完成，也就说套接字并不负责数据传输通信的部分，只是将应用层的数据拷贝到了自己的缓存区中，以及将缓冲区的数据拷贝到应用程序中，交给应用程序读取</p><p>​    <strong>由于缓冲区的存在，数据写入到缓冲区就意味着会有阻塞。如果缓冲区的剩余空间小于数据的长度，那么 write/send 的写入会阻塞，直到输出缓冲区将内部的数据发送出去，得到空余的空间才会继续执行写入</strong></p><p>​    当数据给到 TCP 传输时，整个缓冲区会被锁定，阻塞后面的写入操作，传输完成后会解锁，让写入继续执行</p><p>​    同时如果服务端一直处于 sleep 状态，客户端的数据不断写入到输出缓冲区，而无法被传递到服务端。一旦输出缓冲区满了，也会将客户端后续的写入操作给阻塞</p><p>​    并且，如果数据的长度大于了缓冲区的最大长度设置，数据写入时就会被截断，拆分为多次写入，对于 write/send 方法只有所有分段的数据都写入了才会返回</p><p>​    对于 read/recv 的读取，TCP 的传输的数据进入到输入缓存区后，应用程序会进而从其读取数据。而当缓存区中没有数据，那么 read/recv 就是天然会阻塞住，直到有数据可以读取来返回</p><p>​    另外，当要读取的数据小于输入缓冲区中数据大小，那么数据就无法被一次性完整读取，导致一次传输的完整数据，被分成多次读取，造成缓冲区中数据被不断积压，所以对于读取操作，需要用循环来不断读取</p><p>​    I/O 缓冲区的特性可概括为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）I/O 缓冲区在每个 TCP 套接字中单独存在</span><br><span class="line">（2）I/O 缓冲区在创建套接字时自动生成</span><br><span class="line">（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据</span><br><span class="line">（4）关闭套接字将丢失输入缓冲区中的数据</span><br></pre></td></tr></table></figure><h3 id="TCP-socket-的黏包"><a href="#TCP-socket-的黏包" class="headerlink" title="TCP socket 的黏包"></a>TCP socket 的黏包</h3><p>​    前面提到，当数据的长度大于接收的长度，那读取的数据会根据设置的大小进行截断，然后返回前一部分，那么后一部分的数据只能在下次的 recv 中返回。而后一部分的返回依旧会根据 recv 的大小将后续的数据再截断，将两份数据的后与前，拼在一起返回</p><p>​    这就导致了 黏包 的问题， 也就说两次不相干的数据被整合在了一起返回给了应用程序。产生黏包问题，另一种情况是，发送端对缓存做了设置，要求数据量达到条件才将缓存区的数据区发出，如果缓存区中每一次的数据本身很小，而发送时间有很短，也会将两次的数据黏在一起</p><p>​    <strong>黏包问题是 TCP 的 socket 特有的，使用 UDP 的 socket 不是字节流的形式，所以不会产生黏包问题</strong></p><p>​    所以 TCP 的黏包问题，就是因为对于接收方来说，它不知道每一次的数据的大小所导致的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server_socket</span></span><br><span class="line">conn, addr = server_socket.accept()</span><br><span class="line">conn.send(<span class="string">&#x27;11111111&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">conn.send(<span class="string">&#x27;22222222&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">conn.send(<span class="string">&#x27;33333333&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># client_socket</span></span><br><span class="line"><span class="built_in">print</span>(client_socket.recv(<span class="number">6</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(client_socket.recv(<span class="number">6</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(client_socket.recv(<span class="number">6</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 111111</span></span><br><span class="line"><span class="comment"># 112222</span></span><br><span class="line"><span class="comment"># 222233</span></span><br></pre></td></tr></table></figure><p>​    从代码中，可见如果数据包因为接收大小的限制，除了导致黏包的产生，还会导致三次发送和三次接收后，不能将全部数据完整接收返回</p><p>​    由此，想要解决黏包的问题，就意味着在真正的数据发送之前，需要将这次数据的长度发送给对方，对方根据这个值来设置循环 recv 来接收，直到最后完整接收完成，才能去执行后续的数据接收</p><p>​    那最简单的一种实现方式，前面也提到过就说，就是对 recv 做循环，当接到的数据为空，表示这次的数据接收完成，那可以使用 break 来退出这次接收的循环</p><p>​    另一种方式，构建一个头部信息，这尤其适合文件传输的服务，头部信息可以包含总的数据大小，以及文件名。在发送文件的数据前，使用 struct 模块将 json 后的头部变成定长的数值，然后在将 json 的头部发送，这样对于接收方，首先就是以定值来接收到头部，接着循环内部只需要按照 json 中文件的大小，来依次循环接收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设通过客户端上传 1T:1073741824000 的文件 a.txt</span></span><br><span class="line"><span class="comment"># 为避免粘包, 必须自定制报头</span></span><br><span class="line">header =&#123;<span class="string">&#x27;file_size&#x27;</span>:<span class="number">1073741824000</span>,</span><br><span class="line">         <span class="string">&#x27;file_name&#x27;</span>:<span class="string">&#x27;/a/b/c/d/e/a.txt&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;md5&#x27;</span>:<span class="string">&#x27;8f6fbf8347faa4924a76856701edb0f3&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 1T 数据, 文件路径和 md5 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了该报头能传送, 需要序列化并且转为 bytes</span></span><br><span class="line">head_bytes = json.dumps(header).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了让客户端知道报头的长度, 用 struck 将报头的长度转成固定长度 4 个字节</span></span><br><span class="line">head_len_bytes = struct.pack(<span class="string">&#x27;i&#x27;</span>,<span class="built_in">len</span>(head_bytes))  <span class="comment"># 这 4 个字节里只包含了一个数字, 该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes)   <span class="comment"># 先发报头的长度, 4 个 bytes</span></span><br><span class="line">conn.send(head_bytes)       <span class="comment"># 再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容)       <span class="comment"># 然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端开始接收</span></span><br><span class="line">head_len_bytes = s.recv(<span class="number">4</span>)    <span class="comment"># 先收报头 4 个 bytes, 得到报头长度的字节格式</span></span><br><span class="line">x = struct.unpack(<span class="string">&#x27;i&#x27;</span>,head_len_bytes)[<span class="number">0</span>]          <span class="comment"># 提取报头的长度</span></span><br><span class="line">head_bytes = s.recv(x)        <span class="comment"># 按照报头长度 x, 收取报头的 bytes 格式</span></span><br><span class="line">header = json.loads(json.dumps(head_bytes))       <span class="comment"># 提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后根据报头中定义的长度来做为接收大小</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">&#x27;file_size&#x27;</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure><p>​    对于 TCP 的 socket 的实现的 FTP 的文件传输，其实还有一个问题是，传输过程中可能存在网络断开或是其他的异常问题，导致传输的文件不能传送完成，就需要解决 断点续传 的问题</p><p>​    <strong>断点续传： 简单理解就是客户端上传文件时，由服务端判断文件是否存在</strong>，存在的话说明上传过，这个时候就是续传，服务端将现有文件的大小发送给客户端，客户端根据收到的大小值作为发送文件数据的起始位循环发送后面所有的文件数据。如果文件不存在就是正常的文件上传，起始位就是从 0 开始循环发送</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">CODE = &#123;</span><br><span class="line">    <span class="string">&#x27;1001&#x27;</span>:<span class="string">&#x27;上传文件，从头开始上传&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">cmd_dict,conn,username</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    服务端完成上传文件（含断点续传）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 2. 获取文件信息</span></span><br><span class="line">    file_md5 = cmd_dict[<span class="string">&#x27;md5&#x27;</span>]</span><br><span class="line">    file_name = cmd_dict[<span class="string">&#x27;file_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    file_md5_path = os.path.join(<span class="string">&#x27;home&#x27;</span>, username, file_md5)</span><br><span class="line">    file_name_path = os.path.join(<span class="string">&#x27;home&#x27;</span>, username, file_name)</span><br><span class="line">    upload_file_size = cmd_dict[<span class="string">&#x27;size&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 判断文件是否存在</span></span><br><span class="line">    exist = os.path.exists(file_md5_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exist:  <span class="comment"># 文件不存在，正常接收上传</span></span><br><span class="line">        <span class="comment"># 3.1.1 可以开始上传了，我已经准备好</span></span><br><span class="line">        response = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">1001</span>&#125;</span><br><span class="line">        conn.sendall(json.dumps(response).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1.2 接收上传的文件内容</span></span><br><span class="line">        f = <span class="built_in">open</span>(file_md5_path, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        recv_size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> recv_size &lt; upload_file_size:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            f.write(data)</span><br><span class="line">            f.flush()</span><br><span class="line">            recv_size += <span class="built_in">len</span>(data)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1.3 改名字</span></span><br><span class="line">        shutil.move(file_md5_path, file_name_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 续传</span></span><br><span class="line">        <span class="comment"># 3.2 续传 + 大小</span></span><br><span class="line">        exist_size = os.stat(file_md5_path).st_size</span><br><span class="line">        response = &#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">1002</span>, <span class="string">&#x27;size&#x27;</span>: exist_size&#125;</span><br><span class="line">        conn.sendall(json.dumps(response).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        f = <span class="built_in">open</span>(file_md5_path, <span class="string">&#x27;ab&#x27;</span>)</span><br><span class="line">        recv_size = exist_size</span><br><span class="line">        <span class="keyword">while</span> recv_size &lt; upload_file_size:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            f.write(data)</span><br><span class="line">            f.flush()</span><br><span class="line">            recv_size += <span class="built_in">len</span>(data)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1.3 改名字</span></span><br><span class="line">        shutil.move(file_md5_path, file_name_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NbServer</span>(socketserver.BaseRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        self.request 是客户端的socket对象</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 接收命令</span></span><br><span class="line">        upload_cmd_bytes = self.request.recv(<span class="number">8096</span>)</span><br><span class="line">        cmd_dict = json.loads(upload_cmd_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cmd_dict[<span class="string">&#x27;cmd&#x27;</span>] == <span class="string">&#x27;upload&#x27;</span>:</span><br><span class="line">            upload(cmd_dict,self.request, <span class="string">&#x27;hamilton&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> cmd_dict[<span class="string">&#x27;cmd&#x27;</span>] == <span class="string">&#x27;download&#x27;</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8001</span>),NbServer)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">CODE = &#123;</span><br><span class="line">    <span class="string">&#x27;1001&#x27;</span>:<span class="string">&#x27;上传文件，从头开始上传&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_md5</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    文件进行md5加密</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    obj = <span class="built_in">open</span>(file_path,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> obj:</span><br><span class="line">        m.update(line)</span><br><span class="line">    obj.close()</span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jdt</span>(<span class="params">size,total_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    显示进度条</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    val = <span class="built_in">int</span>(size / total_size * <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\r%s%%|%s&#x27;</span> % (val, <span class="string">&quot;#&quot;</span> * val,), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_file</span>(<span class="params">exist_size,file_total_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    发送文件</span></span><br><span class="line"><span class="string">    :param exist_size:开始读取字节的位置</span></span><br><span class="line"><span class="string">    :param file_total_size: 文件总字节大小</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    f = <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    f.seek(exist_size)</span><br><span class="line">    send_size = exist_size</span><br><span class="line">    <span class="keyword">while</span> send_size &lt; file_total_size:</span><br><span class="line">        data = f.read(<span class="number">1024</span>)</span><br><span class="line">        sk.sendall(data)</span><br><span class="line">        send_size += <span class="built_in">len</span>(data)</span><br><span class="line">        jdt(send_size,file_total_size)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;上传成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    文件上传（含断点）</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    file_md5_val = file_md5(file_path)</span><br><span class="line">    file_name = os.path.basename(file_path)</span><br><span class="line">    file_size = os.stat(file_path).st_size</span><br><span class="line"></span><br><span class="line">    cmd_dict = &#123;<span class="string">&#x27;cmd&#x27;</span>: <span class="string">&#x27;upload&#x27;</span>, <span class="string">&#x27;file_name&#x27;</span>: file_name, <span class="string">&#x27;size&#x27;</span>: file_size, <span class="string">&#x27;md5&#x27;</span>: file_md5_val&#125;</span><br><span class="line">    upload_cmd_bytes = json.dumps(cmd_dict).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    sk.sendall(upload_cmd_bytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 等待服务端的响应</span></span><br><span class="line">    response = json.loads(sk.recv(<span class="number">8096</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> response[<span class="string">&#x27;code&#x27;</span>] == <span class="number">1001</span>:</span><br><span class="line">        send_file(<span class="number">0</span>, file_size)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 短点续传</span></span><br><span class="line">        exist_size = response[<span class="string">&#x27;size&#x27;</span>]</span><br><span class="line">        send_file(exist_size,file_size)</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8001</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># upload|文件路|径</span></span><br><span class="line">    user_input = <span class="built_in">input</span>(<span class="string">&quot;请输入要执行的命令&quot;</span>)</span><br><span class="line">    <span class="comment"># 1. 自定义协议&#123;&#x27;cmd&#x27;:&#x27;upload&#x27;,&#x27;file_path&#x27;:&#x27;.....&#x27;&#125;</span></span><br><span class="line">    cmd,file_path = user_input.split(<span class="string">&#x27;|&#x27;</span>,maxsplit=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">&#x27;upload&#x27;</span>:</span><br><span class="line">        upload(file_path)</span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">&#x27;download&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="利用-socket-发送-http"><a href="#利用-socket-发送-http" class="headerlink" title="利用 socket 发送 http"></a>利用 socket 发送 http</h3><p>​    前面的 socket 基于的都是 CS 模式，即 C(客户端)，S(服务端)。而对于浏览器的网页，属于 BS 模式，即 B(browser 浏览器)，S(服务端)，BS 的结构其实也是一种 CS，只是将客户端的载体换成了 PC 中的浏览器，浏览器成为了客户端</p><h4 id="发起-http-请求"><a href="#发起-http-请求" class="headerlink" title="发起 http 请求"></a>发起 http 请求</h4><p>​    首先，利用 socket 发送请求，就需要知道 http 的请求格式，请求报文分为三部分：请求首行，请求头，请求体</p><p><img src="https://wei-foun.github.io/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="img"></p><p>​    所以要使用 socket 作为浏览器发起请求，要需要按照指定的结构去发送，例如使用 socket 向百度发起请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">sk.send(<span class="string">b&#x27;GET /s?wd=messi HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">res = sk.recv(<span class="number">8096</span>)</span><br><span class="line"><span class="built_in">print</span>(res.decode(<span class="string">&#x27;utf-8&#x27;</span>))    <span class="comment"># 最终会获取的服务器所返回的 response，但是对于这个返回想要完整接收完，需要使用 while 循环和 try 捕获阻塞异常，去做 recv 接收数据</span></span><br></pre></td></tr></table></figure><p>​    上面整个 socket 发起的请求，其实和 requests 模块的 get 是类似的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">&#x27;https://www.baidu.com/s?wd=messi&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure><p>​    不同之处在于，requests 模块的 get 后得到的 response，通过 content 方法可以直接获取到字节类型页面的 html 结构，socket 发送的 http 请求，recv 获取的响应内容非常多，包含了响应报文，页面的 html 以及其他的内容</p><p>​    不过，两种方式都是 阻塞 的，如果发起多个请求，socket 还需要建立多个 socket 对象去连接，阻塞 的模式使得无论是 socket 或是 requests 去请求，都得按照顺序，发送后接收并处理，完成后才继续执行后面的。所以要做到并发，可以使用多线程的方式</p><h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h4><p>​    socket 本身提供了一个方法 <code>setblocking</code> ，但参数是 False 时，原本 socket 操作中会阻塞的地方变为非阻塞的方式，但是在非阻塞状态下，建立 socket 连接时就会抛出 <code>BlockingIOError</code> 的异常</p><p>​    除了利用多线程，python 还有一个模块 select 来利用单线程的 IO 多路复用，支持 linux 底层的三种方式：<strong>select，poll，epoll，后两者在 linux 上可用，windows 中只支持 select</strong></p><h5 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h5><p>​    进程指定内核去监听文件描述符的事件，<strong>select 最多能监听 1024 个，如果文件描述符没有事件发生，就阻塞；反之，就唤起执行</strong></p><p>​    调用 select 时：</p><p>​    1）上下文切换转换为内核态</p><p>​    2）将 fd 从用户空间复制到内核空间</p><p>​    3）内核遍历所有 fd，查看其对应事件是否发生</p><p>​    4）如果没发生，将进程阻塞，当设备驱动产生中断或者 timeout 时间后，将进程唤醒，再次进行遍历</p><p>​    5）返回遍历后的 fd</p><p>​    6）将 fd 从内核空间复制到用户空间</p><p><img src="https://wei-foun.github.io/img/select.jpg" alt="img"></p><p>​    <code>fd_r_list, fd_w_list, fd_e_list = select(rlist, wlist, xlist, timeout=None)</code>，调用 select 时前三个参数是必填参数，并且 select 调用也会返回三个列表，timeout 参数表示 socket 的超时</p><p>​    当 rlist 中的 socket 产生 “变化” 就会将这个对象放入到 fd_r_list，同理 wlist 就对应的是 fd_w_list，xlist 表示的出现异常的对象，则会被加入到 fd_e_list 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">sk1 = socket.socket()</span><br><span class="line">sk1.setblocking(<span class="literal">False</span>)   <span class="comment"># 将 socket 设置为 非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sk1.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))   <span class="comment"># 非阻塞下，需要异常捕获，处理 BlockIOError</span></span><br><span class="line"><span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sk2 = socket.socket()</span><br><span class="line">sk2.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sk2.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line"><span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sk_list = [sk1, sk2]      <span class="comment"># sk_list 作为 select 的第一个参数，如果 socket 有数据返回，就删除当前的 socket 对象</span></span><br><span class="line">conn_list = [sk1, sk2]    <span class="comment"># conn_list 作为 select 的第二个参数，如果 socket 连接成功就删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    fd_r_list, fd_w_list, fd_e_list = select.select(sk_list, conn_list, [], <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sk <span class="keyword">in</span> fd_w_list:</span><br><span class="line">        <span class="comment"># 遍历成功连接的 socket，去发送请求，完成后将当前的 socket 对象从列表删除</span></span><br><span class="line">        <span class="keyword">if</span> sk == sk1:</span><br><span class="line">            sk.sendall(<span class="string">b&#x27;GET /s?wd=messi HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sk.sendall(<span class="string">b&#x27;GET /s?wd=hmilton HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n&#x27;</span>)</span><br><span class="line">        conn_list.remove(sk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sk <span class="keyword">in</span> fd_r_list:</span><br><span class="line">        <span class="comment"># 遍历得到返回的 socket，测试就只收一部分数据，然后退出接收的循环，输入接收的结果，并将当前的 socket 从列表中删除</span></span><br><span class="line">        data_list = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                b = sk.recv(<span class="number">8096</span>)</span><br><span class="line">                data_list.append(b)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        data = <span class="string">b&#x27;&#x27;</span>.join(data_list)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        sk.close()</span><br><span class="line">        sk_list.remove(sk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sk_list:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>​    <strong>select 的 IO 多路复用，简单理解就是通过监听对象的变化实现的一种并发，所有的对象全部在一个列表的容器内，select 通过循环遍历，检测每一个对象的状态变化，当对象收到数据（或响应），就唤起对象加入到另一个容器中，再是轮询将结果返回</strong></p><p>​    select 的多路复用的缺点也很明显，首先，是有最大的监听限制；再者，通过线性扫描做检测判断状态，如果容器内只有少量几个有状态变化，对整个遍历的轮询判断的效率就会非常低；最后，列表容器的创建，以及元素的增加，包括 socket 的对数据在用户空间和内核空间的来回拷贝，非常消耗资源</p><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h5><p>​    与 select 的区别并不是很大，不同点在于，<strong>poll 取消了 select 对监听数量上的限制，并且对容器进行了调整，从原本列表类型的容器，转为了 链表 的结构，正是如此使得 poll 没有监听数量的限制</strong></p><p>​    虽然更改了结构，但在本质上依旧是轮询遍历去检测对象状态</p><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h5><p>​    是在 poll 之上的进一步优化，所以 epoll 同样没有对监听数量做限制，并且更改检测对象的方式，<strong>通过反射回调函数，让状态变化的对象自动去根据回调函数执行处理，而 select 和 poll 采用的都是遍历轮询的方式</strong></p><p><img src="https://wei-foun.github.io/img/epoll.jpg" alt="img"></p><p>​    epoll 通过在 linux 申请一个建议的文件系统，把 select 调用分为了三部分：</p><p>​    1）调用 epoll_create 建立一个 epoll 对象，这个对象包含了一个红黑树和一个双向链表，并与底层建立回调机制</p><p>​    2）调用 epoll_ctl 向 epoll 对象中添加连接的套接字</p><p>​    3）调用 epoll_wait 收集发生事件的连接</p><p>​    这样对比 select 和 poll ，这两者的轮询遍历，需要将所有 socket 对象由用户空间拷贝到内核空间；而 epoll 在调用 epoll_wait 时去触发 select/poll，这一步并不需要再将 socket 拷贝传递，因为内核中的 epoll_ctl 已经得到了监控的 socket 对象</p><p>​    epoll_ctl 负责循环遍历，给每一个对象指明回调函数，将唤醒的对象触发回调函数后，会被加入到就绪的链表队列，有 epoll_wait 去检测是否有就绪的对象</p><p>​    <strong>epoll 还提供了两种模式：水平触发（LT）以及 边缘触发（ET）</strong></p><p>​     <strong>水平触发（LT，也称 条件触发）：如果文件描述符上可以非阻塞地执行 IO 系统调用，就认为文件描述符是已就绪状态满足读取条件，从而发起通知来进行数据读取</strong></p><p>​    水平模式下的 IO 多路复用会监控已连接的描述符，当任意一个描述符上有数据可以读取时，就会触发通知，让对应的回调函数去执行，应用程序收到通知可以选择读取所有数据，或只读取部分数据，或者不读取。如果应用程序只读取部分，或是不读取的话，epoll 在下一次检查判断时，该文件描述符依然会被返回，表示该描述符上依然有数据，会再次去触发通知，让应用程序去读取</p><p>​    <strong>边缘触发（ET，也称 状态触发）：如果文件描述符在上一次检查后产生了新的 IO 活动发生状态变化，就会触发通知，来让应用程序去读取</strong></p><p>​    与水平触发最大的不同点就是，边缘触发只会在描述符的 IO 状态产生了新的状态变化才会触发通知，如果第一次检查后触发了通知，但是应用程序没有读取所有的数据，那么在之后的检查判断中就不会认为描述符发生 IO 变化，从而不会对该描述符向应用程序发起通知</p><p>​    因此，对比水平触发而言，边缘触发省去了同一描述符的多次通知，降低 IO 多路复用中的系统调用的次数，所以在处理上效率要高于水平触发。但也由此导致边缘触发相对而言稳定和可靠性要低于水平触发，使用边缘触发的话，需要尽可能去在第一次得到通知后，将数据尽可能地多读，直到没有数据可以读取为止</p><p>​    <strong>补充：</strong>select 和 poll 支持 水平触发，epoll 既支持 水平触发，也支持 边缘触发</p><h4 id="发送-http-响应"><a href="#发送-http-响应" class="headerlink" title="发送 http 响应"></a>发送 http 响应</h4><p>​    上面的例子都是利用 客户端 去对 服务端 发起请求，如果要用 socket 作为服务器，来发送响应给客户端，那么客户端就是 BS 的 B（browser）浏览器，发送响应需要知道 http 协议的响应报文结构</p><p><img src="https://wei-foun.github.io/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="img"></p><p>​    使用 socket 作为服务端，需要利用浏览器去访问服务端 socket 的 bind 的 ip 和 port</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">port socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">client</span>):</span><br><span class="line">    request_data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;request_data:<span class="subst">&#123;request_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    client.send(<span class="string">&quot;HTTP/1.1 200 OK \r\n Content-Type:Text/html \r\n\r\n&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    client.send(<span class="string">&quot;&lt;h1&gt;hello World&lt;/h1&gt;&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))  <span class="comment"># 根据响应报文的格式，html 的部分是可以直接写在上面一次的 send 之后的</span></span><br><span class="line">    <span class="comment"># client.send(&quot;HTTP/1.1 200 OK \r\n Content-Type:Text/html \r\n\r\n&lt;h1&gt;hello World&lt;/h1&gt;&quot;.encode(&#x27;utf-8&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.bind((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line">        handle_request(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>​    上面的代码执行后，通过浏览器作为客户端去访问，最后的页面上就会显示出   <code>hello World</code>。同时，print 语句会将请求给输出，但是这里没有使用 while 来接收所有的请求数据</p><h3 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver"></a>socketserver</h3><p>​    socketserver 模块是一个基于 socket 实现类似服务器的相关功能，将 socket  和 select 进行了封装，实并发的处理</p><p>​    socketserver 提供了 5 个类：BaseServer，TCPServer，UDPServer，UnixStreamServer  以及 UnixDatagramServer </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure><h4 id="创建一个-socketserve"><a href="#创建一个-socketserve" class="headerlink" title="创建一个 socketserve"></a>创建一个 socketserve</h4><p>​    大致流程：</p><p>​    1）创建一个请求处理类，继承自 BaseRequestHandler 类，并需要重写其中 handle 的方法，该方法用来对传入的请求做处理</p><p>​    2）实例化 socketserver 提供的封装类，比如要使用数据流的 TCPServer，实例化 server 的对象需要给定两个参数，第一个参数是元组，包含 ip 和 port，第二参数是自定义的请求处理类</p><p>​    3）得到的 server 对象通过 server_forever 运行这个服务器对象，并一直允许连接并对请求调用处理的方法，或是使用 handle_request 来只接收处理一个请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyServer</span>(socketserver.BaseRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">server = socketserver.TCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>), MyServer)</span><br><span class="line"></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>​    在 socketserver 中最重要的就是 BaseServer 中初始化的两个属性   <code>self.server_address = server_address</code>，<code>self.RequestHandlerClass = RequestHandlerClass</code></p><p>​    server_address 即服务的 ip 和 port ，RequestHandlerClass 指的就是 socket 对象的处理类，上面的 TCPServer 在 init 初始化函数中，同样是将这两个参数给到 BaseServer 初始化</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 原题</title>
      <link href="/887545606/"/>
      <url>/887545606/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nextnode = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nextnode</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;3-&gt;none</span><br><span class="line">none &lt;- 1</span><br><span class="line">1 &lt;- 2</span><br><span class="line">2 &lt;- 3</span><br><span class="line">none &lt;- 1 &lt;- 2 &lt;- 3</span><br></pre></td></tr></table></figure><p>​    整个反转利用的是遍历链表，一开始定义两个变量，pre 表示前一个节点，cur 表示当前遍历的节点；在遍历之前，pre 赋为 None，cur 赋为所给链表，即方法中的 head</p><p>​    首先，在循环中，从原链表中得到第一个节点 1，从输出可知需要将 1 的 next 指向 None ，也就是将原本的 1.next = node(2) 改为 1.next = node(pre)，完成后会有一个问题，原本的 node(1) 和 node(2) 的连接断了，也就是需要将 2 的 next 重新去指向 1，也就是让 2 去指向前一个节点 1， 后续就重复这些</p><p>​    这样大概的步骤就出来了，首先需要将原链表的节点取出 (<code>cur = head.next</code>) ，并将后一个节点给保存下来，即  <code>nextnode = cur.next</code>；然后将当前得到的节点的 next 去指向上一个节点，即 <code>cur.next = pre</code>，然后就是重新赋值 pre 和 cur，好让循环执行和做出后续正确的操作；让 pre 等于当前的节点，且 cur 等于之前保存的原链表当前节点的下一个节点，即 <code>pre = cur</code>，<code>cur = nextnode</code></p><p>​    pre 等于当前的节点，目的是为了让当前的节点可以指向原链表中 next 指向的下一个节点， <code>cur.next = pre</code>，以此实现，在得到一个节点 1 时，让 1 指向 pre 节点 (none)，让得到节点 2 的时候，让 2 去指向 1，然后 cur 等于 nextnode，是为了作为 while 的判断，以此取出节点到 none 为止，并让 nextnode 的变量可以去到下一个节点，完成向后遍历</p><h3 id="删除链表的指定节点"><a href="#删除链表的指定节点" class="headerlink" title="删除链表的指定节点"></a>删除链表的指定节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">    链表至少包含两个节点。</span><br><span class="line">    链表中所有节点的值都是唯一的。</span><br><span class="line">    给定的节点为非末尾节点并且一定是链表中的一个有效节点。</span><br><span class="line">    不要从你的函数中返回任何结果。</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4    移除节点 2</span><br><span class="line">1 -&gt; 3 -&gt; 3 -&gt; 4</span><br><span class="line">1 -&gt; 3 -&gt; 4 -&gt; null</span><br></pre></td></tr></table></figure><p>​    按照要求给定的是被删除节点，所以不能去对链表遍历从而删除，所以另一种方法就是将被删除的节点进行替换</p><p>​    首先，根据说明知道节点是链表有效且非末尾节点，所以可以获取得到被删除节点的下一个节点，下下个节点；然后，将被删除节点的值替换为下一个节点，就是将 node(2) 的 value 改为 3，这样链表中相当于是 3 -&gt; 3 这个样子了，接下去就可以将下下个节点，也就是 node(4) 这个节点改为被修改后的 node(3) 的所指</p><p>​    所以，这样的做法其实是移除的不是节点 2，而是节点 3，只是因为将节点 3 的值赋值给了原来要删除的节点，并且让被删除的节点的 next 指向了节点 3 的 next，因此最后的返回就是将 2 给移除了 </p><p>​    <strong>变题：</strong>删除链表指定值的节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入: head = [4,5,1,9], val = 5</span></span><br><span class="line"><span class="comment"># 输出: [4,1,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: head = [4,5,1,9], val = 1</span></span><br><span class="line"><span class="comment"># 输出: [4,5,9]</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        pre = head         <span class="comment"># pre 用来表示当前节点的上一个节点</span></span><br><span class="line">        cur = head.<span class="built_in">next</span>    <span class="comment"># cur 表示当前遍历节点</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val != val:   <span class="comment"># 如果链表有节点，且这个节点的值不为删除的值</span></span><br><span class="line">            pre = cur                   <span class="comment"># 将上一个节点改为当前节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>              <span class="comment"># 将当前节点往后去，实现依次遍历</span></span><br><span class="line">        <span class="keyword">if</span> cur: pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span>     <span class="comment"># 如果上面没走，说明找到了要删除的值的节点，将当前节点的上一个节点指向自己的下一个节点，实现删除</span></span><br><span class="line">        <span class="keyword">return</span> head    <span class="comment"># 所有操作都是在原链表上操作的，所以直接返回 head</span></span><br></pre></td></tr></table></figure><h3 id="判断链表是否有环路"><a href="#判断链表是否有环路" class="headerlink" title="判断链表是否有环路"></a>判断链表是否有环路</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">如果链表中有某个节点，可以通过连续跟踪 <span class="built_in">next</span> 指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 <span class="number">0</span> 开始）。如果 pos 是 -<span class="number">1</span>，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span><br><span class="line"></span><br><span class="line">如果链表中存在环，则返回 true 。 否则，返回 false 。进阶：你能用 O(<span class="number">1</span>)（即，常量）内存解决此问题吗？</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s = q = head</span><br><span class="line">        <span class="keyword">while</span> q != <span class="literal">None</span> <span class="keyword">and</span> q.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> s == q: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>最简单的方式就是创建一个集合或者列表这样的容器对象，通过一次遍历，判断节点是否出现在容器中，不在就将节点加入并将遍历节点向后移，在就说明有回环，直接返回。但是这个操作的空间复杂度是 O(n)，每一次遍历都会对容器对象进行一次操作</p><p>​    要实现空间复杂度是 O(1)，就需要利用快慢指针来处理这道题。简而言之，就是让快指针的前进速度是慢指针的速度的两倍，这样一旦出现回环，快指针就会绕到慢指针后面，追上慢指针就说明链表产生了回环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">这个链表中，4 节点的 next 指回了 2，所以这是一个回环链表</span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">首先，建立两个指针，表示 慢 和 快，两个指针初始都是指向链表的头节点</span><br><span class="line">s - 1,  q - 1</span><br><span class="line">要实现 快慢 指针的追及，首先需要去遍历这个链表，要让 q 指针向后移动，所以前提就是 q 本身不为空，且 q.next 不为空，满足条件 q 就向后移动两次，同时让 s 移动一次</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">    s       q</span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">然后，就是重复循环遍历，继续让 q 和 s 进行移动，因为 q 是移动两次，如果 q 和 s 都进入了回环链表中，那么 q 就一定绕到 s 的后方，从而追上 s</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># q 移动第一次，从 4 跳回到了 2，再次之前 s 向后移动一步，走到 3</span><br><span class="line">    q   s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line"></span><br><span class="line"># q 移动第二次，从 2 走到 4，s 只走一步同样到 4 这个节点</span><br><span class="line">           q|s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br></pre></td></tr></table></figure><p>​    所以，最后 s 和 q 出现在了相同的节点上，那么循环遍历就可以结束了，按照题意直接返回 True。由于每一次遍历，没有元素的添加和删除，只是更改两个指针变量的指向，所以空间复杂度还是 O(1)，时间复杂度还是 O(n)</p><h3 id="回环链表的第一个节点"><a href="#回环链表的第一个节点" class="headerlink" title="回环链表的第一个节点"></a>回环链表的第一个节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        s = q = head</span><br><span class="line">        <span class="keyword">while</span> q != <span class="literal">None</span> <span class="keyword">and</span> q.<span class="built_in">next</span> != <span class="literal">None</span>:   <span class="comment"># 双指针遍历，以快指针作为遍历条件</span></span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            q = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> s == q:</span><br><span class="line">                q = head</span><br><span class="line">                <span class="keyword">while</span> s != q:</span><br><span class="line">                    s = s.<span class="built_in">next</span></span><br><span class="line">                    q = q.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>本题和上题是类似的，几乎大部分都是一样，首先还是需要判断出链表是否有回环，还是利用快慢指针向后遍历，当快指针追上慢指针，说明两个指针都在回环链表内</p><p>​    到这里，就是本题需要另外考虑的问题了，当快慢指针走到同一个节点，该如何去判断快慢指针所在的回环中的哪个节点才是回环的入口节点 ？，此时如果还是利用快慢去试图寻找显然是不行的，最好的方式，就是在整个链表的头位置再创建一个指针，让这个指针和原本慢指针一样，每次都只前进一步。这样如果头位置的新指针和原本的慢指针走到一起，那么这个节点就是题目需要的回环的入口节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 按照上题回环判断的例子，最后 q 和 s 会在 4 相遇，此时 q 和 s 都在回环链表内</span><br><span class="line">           q|s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 此时，将 q 移动到原链表的头节点上，改变 q 的前进速度，让 q 和 s 一样每次只移动一步</span><br><span class="line">q           s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 因为 s 和 q 现在不在同一个节点上，所以以此为循环条件去进行遍历，s 走一步回到了 2，而 q 重新从头开始走，走了一步，也来到 2 节点上，所以 2 就是回环链表的第一个节点，q 和 s 返回任意一个即可</span><br><span class="line">   q|s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br></pre></td></tr></table></figure><h3 id="链表倒数第-k-个节点"><a href="#链表倒数第-k-个节点" class="headerlink" title="链表倒数第 k 个节点"></a>链表倒数第 k 个节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;常规版&quot;&quot;&quot;</span></span><br><span class="line">        h, t = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):  </span><br><span class="line">            <span class="comment"># 如果这里是 k+1，那么最后的返回的 t 就是实际倒数第 k 的前一个节点，就需要返回 t.next</span></span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            h, t = h.<span class="built_in">next</span>, t.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindKthToTail</span>(<span class="params">self , pHead , k </span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;严格版，链表长度小于 k 返回空&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span>   <span class="comment"># 如果是 空链表，直接返回 None</span></span><br><span class="line">        h = t = pHead</span><br><span class="line">        <span class="keyword">while</span> k <span class="keyword">and</span> h:         <span class="comment"># 遍历时 k 要大于 0，并且判断 h 的节点不是空</span></span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>: <span class="keyword">return</span>    <span class="comment"># 前面遍历后，如果 h 得到的是 None，说明 k 的值超出链表长度，也直接返回 None</span></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            h,t = h.<span class="built_in">next</span>, t.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><p><img src="https://wei-foun.github.io/img/leetcode1.png" alt="img"> </p><p>​    第一种最简单的方式，先遍历一次链表求出整个链表的长度，然后再遍历一次，用之前得到的长度减去 k ，来得到一个遍历跳过的步数，创建一个指针执行跳过这个步数，就可以得到倒数 k 的节点</p><p>​    第二种，设置两个指针 h 和 t，初始值都是整个链表的头节点，利用 for 循环 range(k)，让 h 指针在每一次循环中，都被重新赋值为它的 next 的节点，即 h 从 1 走到了 3</p><p><img src="https://wei-foun.github.io/img/leetcode2.png" alt="img"> </p><p>​    然后利用 h 的位置继续向后遍历，每一次遍历，都将 h 指针指向 h.next，同时指针 t 也一次指向 t.next</p><p><img src="https://wei-foun.github.io/img/leetcode3.png" alt="img"> </p><p>​    最后，当遍历 h 时，发现上一次 h 指向的位置已经是空的时候，那么循环也就结束了，t 所指向的节点就是倒数 k 的节点，返回 t 即可</p><h3 id="删除倒数第-n-个节点，返回删除节点后的链表"><a href="#删除倒数第-n-个节点，返回删除节点后的链表" class="headerlink" title="删除倒数第  n 个节点，返回删除节点后的链表"></a>删除倒数第  n 个节点，返回删除节点后的链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出：[]</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        p = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        s = q = p</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            q = q.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            s, q = s.<span class="built_in">next</span>, q.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        s.<span class="built_in">next</span> = s.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>这题同样是上一次的变形，上题要求返回的倒数 k 节点后的链表，所以只用返回慢指针所指向的节点。但是这道题要求的是删除这个倒数第 k 的节点，同时，返回的结果要是指定的节点被删除后的原链表。整体上来说，本题和上题的差别不是太大，所以使用双指针依然可以解决本题</p><p>​    但是，但是如果依旧是按照原本的思路，两个指针还是从头节点开始，让快指针先移动 k 步，会产生一个问题，就是慢的指针最后到达的位置是要被删除的节点的位置，那么如果要删除这个节点，需要让这个节点的前面的节点去指向自己后面的节点。也就说每次都需要记录一个 “先” 节点，并且还需要每次更改</p><p>​    所以，比较方便的一种就是给原本的链表的头部加上一个节点，用这个新的头节点来向后遍历。这样就相当于链表的长度 +1 了，所以在让快指针先移动 k 步的时候，这个 k 也需要 +1。也就说快慢指针之间的差距变为了 k，而不是上题 k -1，上题的 k - 1 在最后会走到这个倒数 k 的位置，也就是本题需要被删除的节点位置。而本题因为给链表加了一个头，同时快指针移动的距离也增加一步，那最后慢指针走到的位置，其实就是这个倒数 k 前面的位置。这样一来，就可以直接让慢指针这个位置上的节点的 next 直接去指向下个节点的 next，从而实现将 3 -&gt; 4 -&gt; 5 变为 3 -&gt; 5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1 - 2 - 3 - 4 - 5 ，要删除倒数第 2 个节点</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line">s|q</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 让 q 移动的距离是 2 + 1</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line"> s           q</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 之后让 q 和 s 同时向后遍历移动</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line">     s           q</span><br><span class="line"> </span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line">         s           q</span><br><span class="line"></span><br><span class="line"># 当 q 指针无法向后遍历，s 自然就停住，此时 s 的位置是倒数 k+1 的位置，即 2 + 1，是要被删除节点的前面</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5 - none      </span><br><span class="line">             s            q        </span><br><span class="line">--------------------------------------------------------------------------------------------       </span><br><span class="line"># 最后是需要让 3.next 与 4 这个节点断开连接，直接去指向 4 之后的节点，就实现了删除的效果</span><br><span class="line"> 0 - 1 - 2 - 3 -x- 4   5 - none      </span><br><span class="line">             |---------|</span><br><span class="line">             </span><br><span class="line"># 注意，因为最后要返回的是被删除的原链表，所以返回的链表头结点，要是从 1 开始</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        root = ListNode()</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                n = ListNode(l1.val)</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = ListNode(l2.val)</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = n</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">return</span> root.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line">其实，相当于是通过两个指针遍历两个链表的元素，比较大小后，通过 next 改变其中链表的指针位置</span><br></pre></td></tr></table></figure><p>​    首先，要求返回一个链表，并且目的是为了合并，所以需要定义一个返回链表的头节点 root。后面每一次在 root 的链表上都会链接上新的节点，所以还需要一个变量表示当前节点 cur，这样做的目的是为了后面的节点要加入，都是在当前的节点后 next 加入</p><p>​    然后就是遍历两个有序链表，每一次比较都是比较两个链表头结点的元素大小，得到小的那个节点值，创建一个节点，同时需要将小的链表的头节点要向后移，即当得到小的节点，那么下一次遍历时，该链表的头节点就是上次小的节点后面的第二个节点，以此类推向后推移。也就是说，每一次得到小的节点，小的节点的所在链表的长度就会变短，因为每次都是比较链表的头节点</p><p>​    比较完成后，就需要将 cur 改变，cur 的 next 需要指向得到的创建的小的节点，然后将 cur 也向后推移，这样下次的加入就是在上次之后加入</p><p>​    当两个链表完成遍历，可能存在一些情况，比如因为长度不同，某一个链表还有元素没有遍历，所以在最后 cur 的next 需要在去指向那个节点没有全部遍历的链表，这样 cur 后面就会自动连接上原本没有遍历完的链表</p><h3 id="合并-k-个有序链表"><a href="#合并-k-个有序链表" class="headerlink" title="合并 k 个有序链表"></a>合并 k 个有序链表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br><span class="line">--------------------------------------------------------------------------------------------  </span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;利用合并两个链表的方式，使用分治法实现&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> </span><br><span class="line">    n = <span class="built_in">len</span>(lists)</span><br><span class="line">    <span class="keyword">return</span> self.merge(lists, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge2link</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> a: <span class="keyword">return</span> b</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">if</span> a.val &lt; b.val:</span><br><span class="line">        a.<span class="built_in">next</span> = self.merge2link(a.<span class="built_in">next</span>, b)</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b.<span class="built_in">next</span> = self.merge2link(a, b.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, li, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> li[left]</span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        a = self.merge(li, left, mid)</span><br><span class="line">        b = self.merge(li, mid+<span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> self.merge2link(a, b)</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[ListNode]</span>) -&gt; ListNode:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使用堆结构实现&quot;&quot;&quot;</span></span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                h.append(node.val)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        heapify(h)    <span class="comment"># Python 的 heapq 内置模块中 heapify 方法可以接受一个迭代对象，转为 小根堆 结构</span></span><br><span class="line">        root = ListNode(heappop(h))</span><br><span class="line">        curnode = root</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            nextnode = ListNode(heappop(h))</span><br><span class="line">            curnode.<span class="built_in">next</span> = nextnode</span><br><span class="line">            curnode = nextnode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）合并 k 个 有序链表，可以简单从原本 合并两个链表 来开始，利用循环将合并好的链表再去和后面的链表合并</span><br><span class="line">2）另一种方法，就是可以利用 堆 的形式实现，将多个链表转换成一个有序堆，再挨个出数将返回一个有序的链表</span><br></pre></td></tr></table></figure><p>​    mergeKLists 方法接收的是一个数组套数组的结构，也就是大的列表里面，嵌套一个个链表，所以需要将每一个链表拿出，并将其先变为一个列表，用来为转换成堆结构，while 循环负责拿出每一个链表，for 循环则是利用 pop 方法将每一个元素取出，同时将元素 append 到 h</p><p>​    接下来，就是去利用这个数组去实现堆，<strong>在 heap 模块中有一个 heapify 方法可以实现原地将数组变成堆的结构，同时 heappop 方法可以将堆中最小值节点弹出来实现出数</strong></p><p>​    所以，直接利用 heapify(h) 完成构造堆，然后 heappop(h) 将堆中最小节点弹出并赋予 root ，这个 root 将作为最终返回的链表头结点，同时为了实现遍历节点后移，将 root 赋给 curnode，在 while h 循环中，利用 heappop 方法将 h堆 最小的节点弹出，并将节点接在 curnode 后，同时将 curnode 变为当前弹出的最小节点。以此，实现弹出 1 之后，0.next 指向 1 并将 1作为当前节点，同时下次循环开始时，0 和 1被弹出后，最小节点是 2，就将当前节点的 1 节点的 next 从而指向弹出的 2 节点</p><p>​    题目的测试用例，含有特殊情况，即 lists 可能是 空 [] 或是 嵌套的空形式 [[]]，这样上面在利用 heappop 弹出来构成数组时，会遇到 out of index 的情况，因为没有元素的话弹出无法取出 index，所以在构造堆之前，可以加上一个判断，判断 h 是否为空，为空就直接返回 None 即可。因为在构造 h 的数组的时候，里面使用 while 来做遍历的每一个链表节点的，所以 [[]] 在 while 判断时，就是判断 [] 是否为 True，需要注意的是如果直接判断 [[]] 的话，返回的会是 True，虽然一个元素也没有，但是外层的 [] 嵌套了一个元素 []，所以判断会为 True</p><h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共节点</span><br><span class="line"></span><br><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node <span class="keyword">with</span> value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br><span class="line"></span><br><span class="line">输入：intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        h1, h2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> h1 != h2:</span><br><span class="line">            h1 = h1.<span class="built_in">next</span> <span class="keyword">if</span> h1 <span class="keyword">else</span> headB</span><br><span class="line">            h2 = h2.<span class="built_in">next</span> <span class="keyword">if</span> h2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> h1</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>本题通过双指针实现，是最方便的一种。根据题意，需要在两个链表上找到相同的 next 的指向的节点。这里需要注意一点就是第一个例子中，A 和 B 链表链表中在正确的 8 这个相同节点前，两个链表上也还有一个值相同的节点 1，但是这个节点并不符合题目的要求，因为 A 的 skip 是 2，B 的 skip 是 3，可以理解为是一个长度为 2 和 3 的两个完全不相干的数组，虽然有相同的元素 1，但是这个 1 不是两个链表共同指向的</p><p>​    所以，使用双指针给到 A 和 B 两个链表上，然后进行遍历，依次将指针在两个链表上向后移动，如果一个指针走完了所在链表，就将这个指针重新转移到另一个链表的头部；同理，另一个指针也是如此操作。最后，如果两个指针所在节点一样，就表示两个指针所在的节点，就是两个链表所指向的共同节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">listA = [4,1,8,4,5], listB = [5,0,1,8,4,5]</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">    4 - 1</span><br><span class="line">        |- 8 - 4 - 5</span><br><span class="line">5 - 0 - 1 </span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">    h1</span><br><span class="line">    4 - 1</span><br><span class="line">        |- 8 - 4 - 5</span><br><span class="line">5 - 0 - 1</span><br><span class="line">h2</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">    4 - 1</span><br><span class="line">        |- 8 - 4 - 5</span><br><span class="line">5 - 0 - 1      h2  h1</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">    4 - 8</span><br><span class="line">        |- 8 - 4 - 5</span><br><span class="line">5 - 0 - 1          h2  </span><br><span class="line">h1</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">    h2</span><br><span class="line">    4 - 1</span><br><span class="line">        |- 8 - 4 - 5</span><br><span class="line">5 - 0 - 1           </span><br><span class="line">    h1</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">        h2</span><br><span class="line">    4 - 1</span><br><span class="line">        |- 8 - 4 - 5      </span><br><span class="line">5 - 0 - 1           </span><br><span class="line">        h1</span><br><span class="line"># 再次注意，这里 h1 和 h2 所在节点都是 1，但不是共同节点，他们分别在各自原本的链表上。下一个循环判断时，会判断出 h1 = h2，因为两个指针的 next 都是一个节点，所以返回任意一个指针即可</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   4                                 4</span><br><span class="line"> /   \        ---------------&gt;     /   \</span><br><span class="line">2     7                           7     2</span><br><span class="line"></span><br><span class="line">   2                                 2</span><br><span class="line"> /   \        ---------------&gt;     /   \</span><br><span class="line">1     3                           3     1</span><br><span class="line"></span><br><span class="line">   7                                 7</span><br><span class="line"> /   \        ---------------&gt;     /   \</span><br><span class="line">6     9                           9     6</span><br></pre></td></tr></table></figure><p>​    从要求的输入可输出可知，翻转的目的是为了实现一个节点左右子节点进行位置互换，按照给定的 invertTree 方法中给定一个参数 root，即表示一个二叉树的根节点，那么就可以将整个二叉树进行拆分，全部拆分为最小的二叉树，即只有三个节点，主和两个子节点，这样只需要对当前的主节点交换左右子节点即可，即 <code>root.left, root.right = root.right, root.left</code>，这样就是实现要求的翻转，剩余的步骤就是递归去对下一层中的主节点调用 invertTree 这个方法去分别对 root.left 和 roo.right 去进行子节点的交换</p><h3 id="二叉树层序遍历（BFS-广度优先）"><a href="#二叉树层序遍历（BFS-广度优先）" class="headerlink" title="二叉树层序遍历（BFS 广度优先）"></a>二叉树层序遍历（BFS 广度优先）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层从左到右访问所有节点）</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        cur_node = [root]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">while</span> cur_node:</span><br><span class="line">            nex_node = []</span><br><span class="line">            res.append([n.val <span class="keyword">for</span> n <span class="keyword">in</span> cur_node])</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> cur_node:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nex_node.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nex_node.append(n.right)</span><br><span class="line">            cur_node = nex_node</span><br><span class="line">       <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  3                [3]        c</span><br><span class="line"> / \</span><br><span class="line">9  20              [9, 20]    n</span><br><span class="line"></span><br><span class="line">9  20              [9, 20]    c</span><br><span class="line">  /  \</span><br><span class="line"> 15   7            [none, none, 15, 7] --&gt; [15, 7]      n</span><br><span class="line">  </span><br><span class="line"> 15   7            [15, 7]    c</span><br><span class="line"> </span><br><span class="line">                   [none, none, none, none] --&gt; none    n</span><br></pre></td></tr></table></figure><p>​    要实现层级遍历，其中有一个关键点就是一个主节点的左右两个子节点，因为这两个节点会作为下一层两个树中的主节点；首先，方法要求是返回一个列表套列表的结构，所以创建一个 res 作为外层列表，并且在最开始去对 root 进行判断，如果给定的树是一个空的，那就直接可以返回一个空列表即可，否则再去做后续真正的逻辑算法，这个判断是算法中常常要考虑的一点，因为 LeetCode 的测试用例中会有这样的试例去检测代码的健壮程度</p><p>​    开始循环之前，在 if 判断不是空树的情况下，可以简单一点，直接将根节点的值放入列表加到 res 中，因为不是空树，第一个节点自然就是要求返回的嵌套列表中的第一个列表；接下来，就是创建遍历节点了，将主节点用列表将 cur_nodes 保存起来，nex_nodes 用来存储 cur_nodes 的子节点，但是在循环之外 nex_nodes 可以直接赋为空列表</p><p>​    然后，就是循环遍历的逻辑，要一层层遍历，那么循环就可以用 while 实现，利用 cur_nodes 遍历，并且可以同时判断 nex_nodes 是否有值。首先就是从 3 的两个子节点 9 和 20 开始，之后要进入下一层就是从 9 和 20 开始遍历，所以循环内部先要将 cur_nodes 的子节点取出加到 nex_nodes 中，也就是在第一次遍历中，nex_nodes  =  [9，20]，但是这还没有结束，返回结果要求的是节点的值，nex_nodes  中现在只是取出了 3 后一层的两个节点，所以还需要遍历一次取出值将入到列表，再将这个列表放入 res 中，这样就可以得到 res 为 [[3]，[9，20]]</p><p>​    这样基本就完成了大部分工作，但是循环还要继续，所以最后在循环中还需要去更改 cur_nodes 和 nex_nodes 好让 while 可以继续循环下一层，将 cur_nodes 赋为前面取出的 nex_nodes ，即 cur_nodes = [9，20]，同时将 nex_nodes 再次置为空列表，用来存储这一层的下的子节点</p><p>​    层序遍历的基本思路，简单来说就是 广度优先 搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_queue</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用队列，实现树的广度优先遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    my_queue = []</span><br><span class="line">    node = root</span><br><span class="line">    my_queue.append(node)</span><br><span class="line">    <span class="keyword">while</span> my_queue:</span><br><span class="line">        node = my_queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            my_queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            my_queue.append(node.right)</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树判断"><a href="#平衡二叉树判断" class="headerlink" title="平衡二叉树判断"></a>平衡二叉树判断</h3><p>​    首先，平衡二叉树的性质是，任意节点的左右子树的深度相差不等超过 1。那对于根节点来说，就是判断两个子树的深度差，那就可以先序遍历，挨个遍历出子树深度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">depth_tree</span>(<span class="params">tree_node</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;深度优先遍历&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> tree_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(tree_node.val)</span><br><span class="line">        <span class="keyword">if</span> tree_node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> depth_tree(tree_node.left)</span><br><span class="line">        <span class="keyword">if</span> tree_node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> depth_tree(tree_node.right)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        首先，按照要求没有树的情况，返回 True</span></span><br><span class="line"><span class="string">        否则，需要判断左右两边的差的绝对值是否小于等于 1，左边是否是平衡，以及右边是否也平衡</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.high(root.left) - self.high(root.right)) &lt;=<span class="number">1</span> \</span><br><span class="line">            <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">high</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        high 函数用来递归遍历两个子树的深度</span></span><br><span class="line"><span class="string">        当子树向下遍历，没有子节点了，就说明到了循环出口，返回 0</span></span><br><span class="line"><span class="string">        high 返回函数最后的最大的深度，所以取出左右两个最大值 +1，因为根节点深度是 0，所以要 +1</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.high(root.left), self.high(root.right)) +<span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    但是，自顶向下的遍历，存在很多相同节点的多次遍历，时间复杂度非常高是 O(nlogn)。所以，还有另一种方式，从底向上去遍历，这样一旦判断出左右的深度大于 1 就说明不是平衡二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">return</span> self.end2top(root) != -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end2top</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.end2top(root.left)</span><br><span class="line">        right = self.end2top(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># max(left, right) + 1 表示树的深度，如果左边和右边的深度差小于 2 表示是平衡的，反之就是不平衡的，那就返回一个 -1</span></span><br></pre></td></tr></table></figure><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(preorder) != <span class="built_in">len</span>(inorder): <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root_index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        inorder_left = [<span class="number">0</span>:root_index]</span><br><span class="line">        inorder_right = [root_index + <span class="number">1</span>:]</span><br><span class="line">        preorder_left = [<span class="number">1</span>:root_index + <span class="number">1</span>]</span><br><span class="line">        preorder_right = [root_index + <span class="number">1</span>:]</span><br><span class="line">        </span><br><span class="line">        root.left = self.buildTree(preorder_left, inorder_left)</span><br><span class="line">        root.right = self.buildTree(preorder_right, inorder_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>本地的条件要求在前序和中序返回的两个列表的顺序来构建二叉树。那根据前序遍历的特点，三个节点中，父节点是第一个元素，其余两个节点按照左右顺序排列；而中序排列的特点是，三个节点可以看作落在同一直线上，顺序就是左子，父，右子。而根据前序列表，最容易确定就是整个树的根节点，那剩余的工作就是如何从前序列表第一个元素之后的左和右两个子树。同时，在得到树的根节点后，在中序列表中就能得到根节点位置，同时能进一步确认出中序排列上的左右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line"><span class="comment"># 可以得到 根节点 root = preorder[0] = 3</span></span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"><span class="comment"># 可以得到 root 的位置在 index 为 1 上，那么可以确定这个二叉树的</span></span><br><span class="line"><span class="comment"># 左子树就是 inorder[:1] = [9]</span></span><br><span class="line"><span class="comment"># 右子树就是 inorder[1:] = [15, 20, 7]</span></span><br></pre></td></tr></table></figure><p>​    但是，这样还远没结束，对于 inorder 的右子树而言，这里是恰好只有三个元素，肉眼可见就是 20 是这个子树的根节点，但是如果不止三个元素的话，就不能判断这个子树的根节点了。所以，要想就像判断子树的根，还需要依赖前序列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line"><span class="comment"># 通过上面 inorder 确定的左右子树，对于 preorder 来说，就也能得到</span></span><br><span class="line"><span class="comment"># 左子树是 preorder[1:1+1] = [9]</span></span><br><span class="line"><span class="comment"># 右子树是 preorder[1+1:] = [20, 15, 7]</span></span><br><span class="line"><span class="comment"># 注意，这里的子树都是意义上做的划分，因为后续需要再去递归判断，从而确定二叉树的节点顺序</span></span><br></pre></td></tr></table></figure><p>​    知道了前序和中序的左右两个子树，那接下去就是类似的操作，先在前序列表上将第一个元素作为根，再到中序上确定这个节点，划分出左右子树，然后再将前序做一左右的划分。也就是说，需要将前序得到左子树列表和中序得到的左子树列表做递归，前序的右子树列表和中序的右子数列表做递归，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">preorder[:<span class="number">1</span>] = [<span class="number">9</span>], inorder[:<span class="number">1</span>] = [<span class="number">9</span>]</span><br><span class="line"><span class="comment"># 因为本题左子树，只有一个节点，所以可以确定在二叉树的根节点 3 的左子节点就是 9</span></span><br><span class="line"></span><br><span class="line">preorder[<span class="number">2</span>:] = [<span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>], inorder[<span class="number">1</span>:] = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 对于两个右子树，都是三个元素，那么就和前面是类似的操作了，将前序的第一个元素 20 作为根节点</span></span><br><span class="line"><span class="comment"># 回到中序列表，得到左子树 inrorder[:1] = [15]，右子树 inorder[1:] = [7]</span></span><br><span class="line"><span class="comment"># 那回到前序，同样划分出左右，做就是 preorder[1:1+1] = [15]，右子树就是 preorder[1+1:] = [7]</span></span><br><span class="line"><span class="comment"># 最后还是用过递归，两个列表的左，以及两个列表的右</span></span><br></pre></td></tr></table></figure><p>​    那对于递归操作来说，每次都是深度遍历左，得到根节点的 left 左节点，同理，对于右边也是一样的，从而得到根节点的 right 右节点，直到没有左右子节点就回溯向上返回递归的子树</p><p>​    <strong>优化：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">root, left, right</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">return</span>                               <span class="comment"># 递归终止</span></span><br><span class="line">            node = TreeNode(preorder[root])                       <span class="comment"># 建立根节点</span></span><br><span class="line">            i = dic[preorder[root]]                               <span class="comment"># 划分根节点、左子树、右子树</span></span><br><span class="line">            node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>)              <span class="comment"># 开启左子树递归</span></span><br><span class="line">            node.right = recur(i - left + root + <span class="number">1</span>, i + <span class="number">1</span>, right) <span class="comment"># 开启右子树递归</span></span><br><span class="line">            <span class="keyword">return</span> node                                           <span class="comment"># 回溯返回根节点</span></span><br><span class="line"></span><br><span class="line">        dic, preorder = &#123;&#125;, preorder</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​    首先，是一个 for 循环将中序遍历的元素和索引位置存在了字典里，这样就不用 index 方法通过 O(n) 找索引，而是 O(1) 来得到前序的每一个节点在中序的位置。而 recur 的方法中，接受了三个参数，root 表示当前子树的根节点位置，left 是中序列表中左边界位置，right 就是中序列表中右边界的位置</p><p>​    所以，在第一次递归时，是整个列表做划分，那么就是 recur(0, 0, len(inorder) - 1)，即 recur(0,0,4)。在后面的递归中，root 就每次就需要往后移动，将前序的节点依次做为根节点。对于根节点的 left 左子节点来说，recur 的 left 首先就是 0，而 right 参数就是根节点的 index  - 1，这样 left  和 right 就构建出左子树的左右两个边界。对于与根节点的 right 的右子节点，recur 的 root 参数需要是中序列表上的根节点位置，这个位置的计算式是 i - left + root + 1，即 根节点索引 + 左子树长度 + 1，left 就是 i + 1，即中序节点上根节点的后一位，right 参数则不变</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        index = -<span class="number">1</span>    <span class="comment"># 从 nums1 中获取最后一个元素，目的是将每次比较的两个列表中最大值放到这个位置</span></span><br><span class="line">        m -= <span class="number">1</span>        <span class="comment"># 反向遍历的指针，从 nums1 中最后不是 0 的位置向前遍历</span></span><br><span class="line">        n -= <span class="number">1</span>        <span class="comment"># 同上，用作 nums2 反向遍历指针</span></span><br><span class="line">        <span class="keyword">while</span> m &gt;= <span class="number">0</span> <span class="keyword">and</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m] &gt; nums2[n]:</span><br><span class="line">                nums1[index] = nums1[m]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[index] = nums2[n]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        nums1[:n+<span class="number">1</span>] = nums2[:n+<span class="number">1</span>]     <span class="comment"># 如果 nums1 是一个空，上面循环不能走，就直接将 num2 的元素放到 nums1 中，因为 n 在最开始被 -1，所以这里要 +1</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最简单的一种方式是，将 nums1 有元素部分和 nums2 做拼接，然后用 sort 方法原地排序 nums1</span><br><span class="line">其他的方法，就是利用双指针进行遍历，可以从前往后，也可以从后往前，上面的代码就是由 nums1 的最后开始遍历，每次比较两个列表中的最大放到最后，再从倒数第二位继续遍历</span><br></pre></td></tr></table></figure><h3 id="删除数组中重复项"><a href="#删除数组中重复项" class="headerlink" title="删除数组中重复项"></a>删除数组中重复项</h3><p>​    要求：删除的操作要是原地的，也就是在 O(1) 的空间下完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [0,0,1,1,1,2,2,3,3,4]</span></span><br><span class="line"><span class="comment"># 输出：5, nums = [0,1,2,3,4]</span></span><br><span class="line"><span class="comment"># 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        p,q,n = <span class="number">0</span>,<span class="number">1</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> q &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[p] != nums[q]:</span><br><span class="line">                nums[p+<span class="number">1</span>] = nums[q]</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            q+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums[:p+<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>利用一快一慢的双指针向后遍历，循环的结束条件就是快的指针遍历到最后一个元素就应该退出循环。循环内的操作是，当快指针的元素和慢指针的元素值是一样的话，那么快指针向后 +1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s 表示慢指针，q 表示快指针，循环开始前，s 为数组的第一个元素，q 则就是第二个元素</span><br><span class="line">1  1  2  2  3</span><br><span class="line">|  |</span><br><span class="line">s  q</span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">第一次循环，s 和 q 的元素值是一样的，意味着其中一个元素需要被删除，但是原地操作的话，会导致最后的遍历操作出现 index out of range</span><br><span class="line">1  1  2  2  3</span><br><span class="line">|     |</span><br><span class="line">s     q</span><br></pre></td></tr></table></figure><p>​    s 和 q 的元素相同，让 q 向后 +1 的目的是为了将 +1 后的 q 的元素在后面的循环中，将值赋给 s + 1，前提是下一次的 s 和 q 的元素不是相同的，因为题目给出的是一个有序数组，所以重复的元素后面相邻的如果不是一样的元素，就让后面的元素覆盖到 q 这个快指针上一次循环的位置，实现元素前移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第二循环，s 和 q 的元素不一样，所以将 s + 1 的位置重新赋值，这个值就是当前 q 所指向的元素</span><br><span class="line">1  2  2  2  3</span><br><span class="line">|     |</span><br><span class="line">s     q</span><br><span class="line"></span><br><span class="line">1  2  2  2  3</span><br><span class="line">   |  |</span><br><span class="line">   s  q</span><br></pre></td></tr></table></figure><p>​    如此往复，当最后 q 遍历到最后的元素，也就完成了数组的排序，不同的元素还是按照原本的升序排列，并在数组的最前面，一直到 s 所在的位置。所以，最后返回的数组应该是下标索引一直到 s + 1 的位置</p><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，你可以假设数组是非空的，并且给定的数组总是存在多数元素，如果不存在则输出 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span><br><span class="line">        votes, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>: x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num == x: count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; <span class="built_in">len</span>(numbers) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):  </span><br><span class="line">            <span class="comment"># enumerate 在循环中会返回一个元组，第一个元素是 index，第二个元素是 value</span></span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[target - num], i]</span><br><span class="line">            dic[nums[i]] = i</span><br><span class="line">            <span class="comment"># 默认都是将数组的元素和对应索引放入字典，以数组中的元素作为 key，以该元素的 index 作为 value</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>本题最简单的思路，其实就是通过两次循环，对整个列表做遍历，通过两个循环的指针 i 和 j(j = i+1)，依次去判断两个指针作为索引的元素之和是否是目的值 target。但是暴力枚举的方法，在时间复杂度上非常高，因为是 O(n²)</p><p>​    另一个思路，就是通过 hash 表的结构将元素的值与其索引值做存储，以元素的值为 key，元素在列表中的索引值作为 value。然后去遍历整个列表，通过计算 target 和 当前的元素值的差，判断这个差值是否在 hash 表存在，存在即说明 hash 表中的值与当前的元素值满足题目的要求，即这两个元素的索引位置就是要返回的结果。如果计算的差值不在 hash 表中，就需要将当前用来计算差值的元素值和其对应的索引值，需要组成 key-value 放入到 hash 表中，用作后续遍历的时候，target 做差值需要判断的条件。最后，如果循环遍历结束，依然没有找到匹配的两个元素的索引位置，就直接返回一个空列表</p><p>​    hash 表的结构在 python 中可以用字典去实现，而对于遍历，即需要得到元素，又需要改元素的索引值，就可以通过 enumerate 去遍历这个列表</p><h3 id="最小的-k-个数"><a href="#最小的-k-个数" class="headerlink" title="最小的 k 个数"></a>最小的 k 个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入整数数组 arr ，找出其中最小的 k 个数。例如，输入<span class="number">4</span>、<span class="number">5</span>、<span class="number">1</span>、<span class="number">6</span>、<span class="number">2</span>、<span class="number">7</span>、<span class="number">3</span>、<span class="number">8</span>这<span class="number">8</span>个数字，则最小的<span class="number">4</span>个数字是<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span></span><br><span class="line"></span><br><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLeastNumbers</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(arr): <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">l,r</span>):</span><br><span class="line">            i, j = l, r </span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= arr[l]: j -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= arr[l]: i += <span class="number">1</span></span><br><span class="line">                arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            arr[l], arr[i] = arr[i], arr[l]</span><br><span class="line">            <span class="keyword">if</span> n-i &lt; k: <span class="keyword">return</span> quick_sort(l, i-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> n-i &gt; k: <span class="keyword">return</span> quick_sort(i+<span class="number">1</span>, r)</span><br><span class="line">            <span class="keyword">return</span> arr[:k]    <span class="comment"># 最大的 k 个数，就是 arr[-k:]</span></span><br><span class="line">        <span class="keyword">return</span> quick_sort(<span class="number">0</span>, <span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>按照题目要求，本题的思路就是要对给定数组排序，然后取出排序后的数组中前 k 个元素。那么按照排序算法这题就能实现，但是本题的关键点在于只需要返回前 k 个数，所以这是本题需要优化的点</p><p>​    这里使用快排不同于平常的递归快排算法，上面的代码中快排并不一定会按照值的大小顺序将整个数组排序，而是同过分治法，将数组分为两部分，这和通常编写的快排类似，但是最大的不同是，这里的空间复杂度更低，整个快排的操作是在原地进行的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">l,r</span>):</span><br><span class="line">i, j = l, r </span><br><span class="line"><span class="keyword">while</span> i &lt; j:</span><br><span class="line"><span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= arr[l]: j -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt;= arr[l]: i += <span class="number">1</span></span><br><span class="line">arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">arr[l], arr[i] = arr[i], arr[l]</span><br></pre></td></tr></table></figure><p>​    这里的 while 循环的真正目的，为了将数组变为有序，<strong>注意！！并不是说将数组变为绝对意义上的按照值的顺序有序</strong>，快排的参数 l 和 r，指的是数组的左右边界</p><p>​    而 i 和 j 则是作为左右边界的指针，循环的遍历条件自然是 i 和 j 不能相遇，而在循环中所比较的就是 i 和 j 位的元素和 l 的元素的大小比较，也就说 i 所代表的都是值要小于 l 位的元素，而 j 则就是值要大于 l 的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">l              r </span><br><span class="line">2, 4, 1, 0, 3, 5</span><br><span class="line">i              j</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"># while 中的第一个 while 循环比较的是 j 所指向的元素，目的是要从右至左，过滤得到小于 l 指向的第一个元素，所以最后 j 的位置会在 0 停住</span><br><span class="line">l              r </span><br><span class="line">2, 4, 1, 0, 3, 5</span><br><span class="line">i        j</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"># 当退出 j 的循环后，对 i 指向的位置进行一样的遍历操作，也就说从左至右，找到值大于第一个元素 l 的元素，即 i 会在 4 停住</span><br><span class="line">l              r </span><br><span class="line">2, 4, 1, 0, 3, 5</span><br><span class="line">   i     j</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"># 此时，关于 i 和 j 的两个 while 都不能执行了，也就是说 i 和 j 所指位置的元素需要进行交换，从而使得 i 和 j 的元素能回到满足 while 循环的条件</span><br><span class="line">l              r </span><br><span class="line">2, 0, 1, 4, 3, 5</span><br><span class="line">   i     j</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"># 完成 i 和 j 的交换，会继续执行 while 循环，而在下一次循环中，j 会指向 1，然后退出 j 自己的循环，而 i 同样会指向 1，并且也会退出，此时 i 和 j 相遇，同时指向了 1</span><br><span class="line"># 按照之前的规则，i 和 j 的循环都不满足，因此需要交换 i 和 j，此时不会发生改变，完成后因为 i 和 j 相遇，就会触发退出外层循环的退出，此时，最关键的就是需要让 l 的元素归为，让 l 和 i 的元素交换，使得原本索引是 0 的 l 的元素与 i 位置的元素交换，这样一来 l 的左边都是小于 l 的元素，l 的右边自然就是大于 l 的元素</span><br><span class="line"></span><br><span class="line">l              r </span><br><span class="line">2, 0, 1, 4, 3, 5</span><br><span class="line">     i|j</span><br><span class="line"></span><br><span class="line">l              r </span><br><span class="line">1, 0, 2, 4, 3, 5</span><br><span class="line">     i|j</span><br></pre></td></tr></table></figure><p>​    完成 “排序” 后，可见现在的列表并不是绝对按照值的小到大的顺序返回的，那根据题目的要求是返回前 k 个数，如果现在就取数组前 k 的数字返回，很显然会出错。因为此时 i 左边和右边并不一定就会是有序的，因此需要使用递归对左右两边再去进行快排</p><p>​    此时，在第一次排序后，左边的数组就是 [l:i-1]，右边的数组就是 [i+1:r]，即左边是 [1,0]，右边是 [4,3,5]，所以当 k 小于 i 的时候，需要对左边进行递归，当 k 大于 i 则是对右边递归。之所以左边要递归，是为了防止当数组中如果有相同元素，那么在第一次排序后，直接取出前 k 个值会导致错误，因为左边的数组不是绝对按照值的大小升序的，所以需要递归再去排序</p><p>​    <strong>注意！！！</strong>，上面的实现递归左和右的时候，是直接比较 k 和 i 的大小，但是这样的做法在题目变为最大的 k 个数的时候就会出错。因为获取最大的 k 个数，也就是获取有序后的列表的 -k 个元素的时候，k 通过都会大于 i，也就是说只会对列表的右边做递归。因此，最好的比较方法是判断 n-i 和 k 的大小，n 是整个数组的长度，n 减去 i 的值如果大于 k，就对右边做递归，反之就先对左做递归，这样做的目的就防止在获取最大的 k 个数的时候，左右的递归遍历出现顺序问题</p><h3 id="平衡点"><a href="#平衡点" class="headerlink" title="平衡点"></a>平衡点</h3><p>​    比如 int[] numbers = {1,3,5,7,8,25,4,20}， 25 前面的总和为 24，25 后面的总和也是 24，25 这个点就是平衡点；假如一个数组中的元素，其前面的部分等于后面的部分，那么这个点的位序就是平衡点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Find_Blance</span>(<span class="params">alist</span>):</span><br><span class="line">    sumlist = <span class="built_in">sum</span>(alist)</span><br><span class="line">    balance = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="keyword">if</span> balance &lt; (sumlist - num) / <span class="number">2</span>:</span><br><span class="line">            balance += num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> balance == (sumlist - num) / <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平衡点是:&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(num))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平衡点不存在!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">20</span>]</span><br><span class="line">    Find_Blance(numbers)   <span class="comment"># 平衡点是:10</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>从题目了解平衡点的定义后，想要得到一个数组中的平衡点。需要前知道数组的元素值的总和，然后使用一个变量用作对平衡点判断的前序数组元素累加，如果 累加的和 &lt; （数组总和 - 当前遍历元素值）/ 2，就表示当前遍历的元素并不是平衡点，需要将前序累计和继续加上当前元素值</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">使用栈实现队列的下列操作：</span><br><span class="line">push(x)   --  将一个元素放入队列的尾部。</span><br><span class="line">pop()     --  从队列首部移除元素。</span><br><span class="line">peek()    --  返回队列首部的元素。</span><br><span class="line">empty()   --  返回队列是否为空。</span><br><span class="line"> </span><br><span class="line">示例:</span><br><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  // 返回 <span class="number">1</span></span><br><span class="line">queue.pop();   // 返回 <span class="number">1</span></span><br><span class="line">queue.empty(); // 返回 false</span><br><span class="line"> </span><br><span class="line">说明:</span><br><span class="line">你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop <span class="keyword">from</span> top, size, 和 <span class="keyword">is</span> empty 操作是合法的。</span><br><span class="line">你所使用的语言也许不支持栈。你可以使用 <span class="built_in">list</span> 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</span><br><span class="line">假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.s = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.s.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.s.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.s) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.s[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.s1 = Stack()</span><br><span class="line">        self.s2 = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.s1.push(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.s2.empty():</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():</span><br><span class="line">                self.s2.push(self.s1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.s2.empty():</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():</span><br><span class="line">                self.s2.push(self.s1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.s2.top()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.s2.empty() <span class="keyword">and</span> self.s1.empty()</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈：后进先出      队列：先进先出</span><br><span class="line">用栈实现队列，即当队列执行元素弹出的时候，弹出的这个值在栈中的位置是最前面的，所以就需要利用两个栈做存储，第一个栈正常的将元素加入，第二个栈用来将第一个栈的元素进行加入，实现第一个栈的最后面的元素加入到第二个栈时，就成了最前的元素，而实现的队列依然使用弹出方法正常的将第二个栈的元素弹出即可</span><br></pre></td></tr></table></figure><p>​    根据需求，可以使用 list 和 deque 去模拟出栈，即 Stack 类，初始化一个列表作为栈，并实现基本的 push，pop ，empty，top 的方法，push 即对 list 使用 append 将元素加入，pop 即 list 正常的 pop 默认将最后一个元素返回，empty 则使用 len 方法判断 list 是否为空，top 即对应实现队列的 peek 的方法返回队列中的第一个元素，即获取到 list 的最后一个元素返回</p><p>​    根据思路，在 MyQueue 中需要去实现两个栈，即实现两个 Stack 实例对象，MyQueue  的 push 方法正常往队列加入元素，即往 s1 的栈中加入，由于后进先出的规则，那么新的元素总是在 s1 栈的最后的</p><p>​    MyQueue  的 pop 的方法要做的就是实现队列的先进先出的效果，也就是说这个 pop 方法协调 s1，s2  两个栈，将 s1 的元素逐个加入到 s2 中，实现最新的元素在 s2 栈中在最底部，那么最后只需要调用 s2 的pop 方法去将元素弹出即可实现 MyQueue 的先进先出；首先，判断 s2 是否为空，为空就循环遍历 s1 将每一个元素逐一加入到 s2，然后只需要返回 s2.pop 方法的结果</p><p>​    MyQueue 的 peek 方法类似上面的 pop，只是 peek 方法并不是将元素弹出而是返回队列中的第一个元素，所以同理上面的方法，需要判断 s2 是否为空，并遍历 s1 将元素加入到 s2，然后返回 s2.top 去返回这个栈中的最后一个元素，即 MyQueue 队列中的第一个元素</p><p>​    最后在 MyQueue 的 empty 方法需要同时判断 s1 和 s2 是否都为空，如果只判断其中任何一个 s1 或 s2 的话都不能证明队列是完全空的，因为判断 s1 空，可能会有元素已经在 s2 中了，如果 pop 就是从 s2 返回，显然是错误的；如果只判断 s2 为空，会因为 push 方法只将元素加到 s1，即使 s2 为空也依然不能证明队列是空的，因为元素已经执行了 push</p><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 <span class="string">&#x27;(&#x27;</span>，<span class="string">&#x27;)&#x27;</span>，<span class="string">&#x27;&#123;&#x27;</span>，<span class="string">&#x27;&#125;&#x27;</span>，<span class="string">&#x27;[&#x27;</span>，<span class="string">&#x27;]&#x27;</span> 的字符串 s ，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：</span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;()[]&#123;&#125;&quot;</span></span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">&quot;(]&quot;</span></span><br><span class="line">输出：false</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:        </span><br><span class="line">        pairs = &#123;<span class="string">&quot;)&quot;</span>:<span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>:<span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>:<span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != pairs[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>这题的本质其实就是使用 栈 这个结构，栈的插入和删除特点是 FIFO 先进先出，所以按照循环，每次遍历的字符要去判断是否与栈的字符匹配，匹配删除</p><p>​    所以，在循环开始前，需要两个结构，一个是 hash 表，里面存储每个符号对应的反向符号，另一个就是 栈，可以直接使用 list 去实现。注意，在字典中，key 应该是反向的符号，因为题目的符号开始都是向右的，key 的符号是向左的符号，来取匹配向右的符号</p><p>​    最后，如果 栈 是空的，说明给定的字符满足符号规则要求，返回 True，如果有符号在 栈 中，说明不满足规则，返回 False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">pairs = &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1）（</span><br><span class="line">li = [(]</span><br><span class="line"></span><br><span class="line">2） ）；） in paris；&quot;)&quot;:&quot;(&quot;</span><br><span class="line">li = []</span><br><span class="line"></span><br><span class="line">后面的步骤同理如上步骤</span><br></pre></td></tr></table></figure><p>​    但是，在让元素出栈的这一步，如果只是判断符号在字典中存在，会出现问题，因为如果给定的字符全都是朝向右边的符号，那么只是判断符号不在字典的话，这个判断条件就失效了，也就说整个遍历最终会将所有的符号都入栈</p><p>​    所以，判断符号在字典中，将符号从出栈之前还需要一个判断。因为，如果给定的字符只有一个，而且是一个反向的括号，那么就会通过第一个判断，因为反向括号是字典中的 key，而给定的只有一个符号，那么对于 栈 来说就是空的，那么就直接返回 False。同时如果这个 栈 不是空的，存在了向右的括号，并且当前遍历的括号，是反向括号的话，同样会通过一个判断，但是如果当前的反向括号在字典中的 value 并不是 栈 中最后一个括号对应的反向括号，就说明给定的括号字符已经不满足要求，直接就能返回 False</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;(]&quot;</span><br><span class="line">pairs = &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1）（</span><br><span class="line">li = [(]</span><br><span class="line"></span><br><span class="line">2） ] ；] in pairs；&quot;]&quot;:&quot;[&quot;</span><br><span class="line">li[-1] != pairs[&quot;]&quot;]</span><br><span class="line">直接 return False</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">s = &quot;]&quot;</span><br><span class="line">pairs = &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125;</span><br><span class="line"></span><br><span class="line">1）] ；] in pairs；&quot;]&quot;:&quot;[&quot;</span><br><span class="line">li = []，li 中没有括号，直接返回 False</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶</span><br><span class="line">每次你可以爬 <span class="number">1</span> 或 <span class="number">2</span> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line">注意：给定 n 是一个正整数</span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a,b,c = <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            c = a + b</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">爬 2 阶，总共 2 种方式：1）1+1 ，2）2+0</span><br><span class="line">爬 3 阶，总共 3 种方式：1）1+1+1 ，2）1+2 ，3）2+1</span><br><span class="line">爬 4 阶，总共 5 种方式：1）1+1+1+1 ，2）1+1+2 ，3）1+2+1 ，4）2+1+1 ，5）2+2</span><br><span class="line">爬 5 阶，总共 8 种方式：1）1+1+1+1+1 ，2）1+1+1+2 ，3）1+1+2+1 ，4）1+2+1+1 ，5）2+1+1+1 ，6）2+2+1 ，7）2+1+2 ，8）1+2+2</span><br><span class="line">....     ......</span><br></pre></td></tr></table></figure><p>​    由上面的推理，可知其实这个问题是一个斐波那契数列的问题，即   <code>[1,1,2,3,5,8,13]</code></p><p>​    回到原题，要求出爬 n 阶的楼梯的有多少种方法，那么就是说再爬到第 n 阶的楼梯前，所在的位置会有两种情况，要么是前 1 阶的楼梯（即 <code>n-1</code>），要么是前 2 阶的楼梯（即 <code>n-2</code>）。同理，也就是这个前 1 阶和前 2 阶也都会遇到一样的情况，除非这个 n 的位置到了整个楼梯的第 1 阶，那么就只有一种方式，所以问题就和斐波那契数列是一样的了</p><p>​    对于斐波那契的实现，最简单的方式就是递归调用，因为到第 n 阶，就是（n-1）与（n-2）的和，使用递归就可以让每一阶都计算去计算当前楼梯阶数的前 1 阶和前 2 阶各自有几种方法，但是利用递归，必须要设置递归出口，也就是 n 如果是第 1 阶，即小于 2，那就只有 1 中方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slef.climbStaris(n - <span class="number">1</span>) + slef.climbStaris(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>​    通过递归方式可以计算出结果，但是这在时间复杂度上是 O(n²)，因为 n 阶楼梯，内部的递归运算需要对 n 遍历一次，一直到最后找到出口返回那个 return 1，即 n 个阶梯要遍历 n 次，所以这个算法在 LeetCode 上会遇到超时问题</p><p>​    而且，使用递归方式计算，其实内部存在了很多计算过的值，但是每一个阶梯自己的递归都需要最终找到出口返回 1，即 4 的阶梯，递归的计算要算出 3 和 2，而 3 的阶梯，递归还需要计算 2 和 1，这就存在了重复计算问题</p><p>​    所以，如果使用递归方式去解决这个问题，要避免重复计算，就需要一个容器来存储计算过的值，比如使用哈希表来存储，这样每次计算的数作为键，递归后的结果作为该键的值，就能 O(1) 去查找到计算过的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numWays</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> self.d: <span class="keyword">return</span> self.d[n]  <span class="comment"># 先用 if 判断值是否在字典里，存在就直接返回该数字计算过的结果</span></span><br><span class="line">        v = self.numWays(n-<span class="number">1</span>) + self.numWays(n-<span class="number">2</span>)</span><br><span class="line">        self.d[n] = v  <span class="comment"># 默认将递归计算的值都将入到字典中，用计算的数值作为键</span></span><br><span class="line">        <span class="keyword">return</span> v % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：</strong>变态的爬台阶的问题，就是在原基础上增加了一个条件，除了一次可以跳 1 阶或是 2阶，也可以一次跳 n 阶，来求出一个 n 级的台阶可以有多少种方式来跳完</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">    res = <span class="number">2</span> * fib(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> dic:</span><br><span class="line">                i = <span class="built_in">max</span>(i, dic[s[j]])</span><br><span class="line">            dic[s[j]] = j + <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>本题的最佳实现，是通过 滑动窗口 来维持一个连续不重复的子串列表范围，每次遍历时，滑动窗口的右边都会将字符从右边加入，并且判断新加入的字符是否出现在滑动窗口的范围内，有重复就说明滑动串口的大小需要调整</p><p>​    调整的方式，并不是将窗口最左边的字符移除窗口，而是需要将滑动窗口的左边界移动到当前加入的这个有重复的字符的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;pwwkew&quot;</span><br><span class="line">ans = []</span><br><span class="line"></span><br><span class="line">第一次遍历：ans = [p]</span><br><span class="line">第二次遍历：ans = [pw]</span><br><span class="line">第三次遍历：ans = [pw]，新的加入元素 w 在 ans 中有出现，所以 ans 要置空，并将当前元素放入，ans = [w]</span><br><span class="line">第四次遍历：ans = [wk]</span><br><span class="line">第五次遍历：ans = [wke]</span><br><span class="line">第六次遍历：ans = [w]，同理第三次遍历</span><br></pre></td></tr></table></figure><p>​    但是，题目要求的是返回给定的字符串中最长的没有重复的子字符串的长度，所以也就是要返回 ans 的最大值。那么在每一次遍历后，都需要计算出当前 ans 的值与之前存储的值作比较，取出最大的值作为 ans 的新值</p><p>​    所以，难点就是每一次遍历后 ans 的窗口大小计算。也就说对于给定的字符串需要遍历，就需要两个指针，i 用于表示新的窗口左边界位置，j 表示循环遍历的每一个元素的索引位置。i 的初始值是 0，表示初始的窗口是一个空窗口，j 按给定 s 的长度去遍历，所以初始也是 0 开始</p><p>​    由于 i 表示的是窗口的左边界，那么一旦有重复元素出现后，i 的位置需要变更，那就需要有一个容器记录每一个元素的位置，并且出现重复后需要更新这个字符的值。所以，最适合的就是 hash 表结构，因为需要构建一个字典，key 是每一个遍历的元素，value 是这个字符在规定的 s 中的 index 位置 + 1（！！注意这个 +1，之所以 +1，是为了表示当前位置的后一个位置才是不重复的），一旦出现重复后，需要更新这个 value，同时还需要更新窗口的左边界 i 的值，因为 i 表示的不重复窗口的最左边界，一旦重复窗口的左边界需要移动到当前遍历的位置，而这个位置就是字典中的那个重复元素的 value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;pwwkew&quot;</span><br><span class="line">i, ans = 0, 0</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">j = 0   # j 随着 for 循环每次递增</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第一次遍历：p</span><br><span class="line">j = 0</span><br><span class="line">i = 0</span><br><span class="line">ans = 0</span><br><span class="line"></span><br><span class="line">dic = &#123;p:j+1&#125; = &#123;p:1&#125;</span><br><span class="line">ans = max(ans, j-i+1) = 1</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第二次遍历：w</span><br><span class="line">j = 1</span><br><span class="line">i = 0</span><br><span class="line">ans = 1</span><br><span class="line"></span><br><span class="line">dic = &#123;p:1, w:j+1&#125; = &#123;p:1, w:2&#125;</span><br><span class="line">ans = (ans, j-i+1) = 2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第三次遍历：w，w 在 dic 中已存在</span><br><span class="line">j = 2</span><br><span class="line">i = 0</span><br><span class="line">ans = 2</span><br><span class="line"></span><br><span class="line">i = max(原本字典中 w 的值，当前 i) = max(2, 0) = 2</span><br><span class="line"></span><br><span class="line">dic = &#123;p:1, w:j+1&#125; = &#123;p:1, w:3&#125;</span><br><span class="line">ans = max(ans, j-i+1) = max(2, 2-2+1) = max(2, 1) = 2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第四次遍历：k</span><br><span class="line">j = 3</span><br><span class="line">i = 2</span><br><span class="line">ans = 2</span><br><span class="line"></span><br><span class="line">dic = &#123;p:1, w:3, k:j+1&#125; = &#123;p:1, w:3, k:4&#125;</span><br><span class="line">ans = max(ans, j-i+1) = max(2, 3-2+1) = 2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第五次遍历：e</span><br><span class="line">j = 4</span><br><span class="line">i = 2</span><br><span class="line">ans = 2</span><br><span class="line"></span><br><span class="line">dic = &#123;p:1, w:3, k:4, e:j+1&#125; = &#123;p:1, w:3, k:4, e:5&#125;</span><br><span class="line">ans = max(ans, j-i+1) = max(2, 4-2+1) = 3</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第六次遍历：w，w 在 dic 中已存在</span><br><span class="line">j = 5</span><br><span class="line">i = 2</span><br><span class="line">ans = 3</span><br><span class="line"></span><br><span class="line">i = max(原本字典中 w 的值，当前 i) = max(3, 2) = 3</span><br><span class="line"></span><br><span class="line">dic = &#123;p:1, w:j+1, k:4, e:5&#125; = &#123;p:1, w:6, k:4, e:5&#125;</span><br><span class="line">ans = max(ans, j-i+1) = max(3, 5-3+1) = 3</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">最后，遍历结束，因为 ans 的每次都是和原来的值比较取出最大的值，所以最后返回 ans 就是结果</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;abaccdeff&quot;</span></span><br><span class="line">返回 <span class="string">&quot;b&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;</span> </span><br><span class="line">返回 <span class="string">&quot; &quot;</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            dic[c] = <span class="keyword">not</span> c <span class="keyword">in</span> dic</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> dic[c]: <span class="keyword">return</span> c</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>使用字典判断，遍历整个字符串，判断每一个字符是否已在字典中存在，不存在的话在字典中以该字符为 key，值设置为 True，当字符被第二次遍历到时，那就说明这个字符已在字典出现，那么将字典中该字符的值修改为 False。最后在进行一次遍历，取出值为 True 的那个字符即可</p><p>​    注意：代码中 <code>not c in dic</code>，这里实则可以是拆分两块理解，一个是 not，另一部分是 c in dic，后者用来判断是否字符存在于字典中，前者的 not 为了用例取反。这里也可以不写 not，那和上面逻辑正好相反，上面的逻辑中只出现一次的字符在字典的值是 True。如果不使用 not，就表示只出现一次的字符是 False，那最后遍历，就需要使用 not dic[c] 去判断，然后返回这个字符</p><h2 id="特殊题"><a href="#特殊题" class="headerlink" title="特殊题"></a>特殊题</h2><h3 id="求-1-2-…-n"><a href="#求-1-2-…-n" class="headerlink" title="求 1+ 2 + … + n"></a>求 1+ 2 + … + n</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">求 <span class="number">1</span>+<span class="number">2</span>+...+n ，要求不能使用乘除法、<span class="keyword">for</span>、<span class="keyword">while</span>、<span class="keyword">if</span>、<span class="keyword">else</span>、switch、<span class="keyword">case</span>等关键字及条件判断语句（A?B:C）</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.s = s</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNums</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n &gt; <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">        s += n</span><br><span class="line">        <span class="keyword">return</span> self.s</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>这道题最难的就是题目的语法限制，不能使用循环和逻辑符的情况下，只能去使用递归的方式来实现累加计算。代码中 <code>n &gt; 1 and self.sumNums(n - 1)</code> 实际上也是利用判断逻辑，只有 n &gt; 1 的情况下，才能去递归调用自己来计算 n - 1 的值，要替换成 if 语句就更加容易理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">self.sumNumbers(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​    所以 sumNums 方法的第一行代码，即使作为递归的出口，也是为了做后续递归的 n - 1 的计算。当递归到达出口后，n 的是 1，然后再去和 init 的初始值 s 做累加</p><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">我们把只包含质因子 <span class="number">2</span>、<span class="number">3</span> 和 <span class="number">5</span> 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">10</span></span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span> 是前 <span class="number">10</span> 个丑数</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        a = b = c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            n2 = dp[a] * <span class="number">2</span></span><br><span class="line">            n3 = dp[b] * <span class="number">3</span></span><br><span class="line">            n5 = dp[c] * <span class="number">5</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(n2, n3, n5)</span><br><span class="line">            <span class="keyword">if</span> dp[i] == n2: a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n3: b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == n5: c += <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>​    <strong>思路：</strong>首先最小的丑数是 1，所以开始创建列表的时候，可以创建长度是 n ，元素都是 1 的列表。这样后续在循环遍历完成计算的时候，只需要修改对应位置的值，就能得出对应位置的丑数值</p><p>​    本题复杂的部分就在于丑数的逻辑计算和遍历，由于最小丑数是 1，所以遍历就直接从 1 开始，这个 1 的位置也就是定义的丑数列表的第二个元素，即顺序排列的第二个丑数。2，3，5 作为丑数的质因子，那就需要去计算三个数，即定义的 a，b，c 这三个变量</p><p>​    a*2，b*3，c*5，在第一次遍历下，得到就是 2，3，5 三个值，按照题目要求的小到大的顺序排列，就需要每一次计算取出最小值，即 2 就是第二最小丑数，注意！！！当完成每一位的丑数计算后，需要对用来用计算的 a，b，c 三个变量做累加，这三个变量实际的作用就是代表了对应的丑数所在的位置</p>]]></content>
      
      
      <categories>
          
          <category> leetcode 原题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 整理</title>
      <link href="/2197405715/"/>
      <url>/2197405715/</url>
      
        <content type="html"><![CDATA[<h3 id="MVC-和-MTV-架构"><a href="#MVC-和-MTV-架构" class="headerlink" title="MVC 和 MTV 架构"></a>MVC 和 MTV 架构</h3><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>​    MVC 模型是 web 服务器开发领域里著名的一个模型，所谓的 MVC 就是把 web 应用分为，<strong>模型（Model），控制器（Controller），视图（View）</strong>，三者之间以一种 <strong>插件式</strong> 的，<strong>松耦合</strong> 的方式连接在一起</p><p>​    <strong>模型 M：</strong>负责业务对象与数据库的映射关系（ORM）</p><p>​    <strong>视图 V：</strong>提供与用户进行交互的页面</p><p>​    <strong>控制器 C：</strong>接收用户的输入调用模型和视图完成用户请求</p><p><img src="https://wei-foun.github.io/img/MVC.jpg" alt="img/md5.jpg"></p><h4 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h4><p>​    Django 用的是 MTV 模型，但是本质上是和 MVC 一样的，也是为了将各组件之间保持松耦合关系，但是定义上有些不同；依然是分为三块：<strong>模型（model），模板（template），视图（view）</strong> </p><p>​    <strong>模型 M：</strong>与 MVC 一样是负责业务对象和数据的关系映射，对数据库进行调取和处理，即数据存取层</p><p>​    <strong>模板 T：</strong>利用模板语法进行html和数据的渲染展示，即表现层</p><p>​    <strong>视图 V：</strong>负责业务的逻辑，并在适当时调用 model 和 template，即业务逻辑层</p><p>​    除了这三层之外，还有一个 <strong>Controller</strong> 即 <strong>URL分发器</strong>，作用是将一个个 url 的页面请求分发给匹配路由的视图来处理</p><p><img src="https://wei-foun.github.io/img/MTV.jpg" alt="img/md5.jpg"></p><h3 id="WSGI-和-uWSGI"><a href="#WSGI-和-uWSGI" class="headerlink" title="WSGI 和 uWSGI"></a>WSGI 和 uWSGI</h3><p>​    <strong>WSGI：</strong>web service getaway interface，<strong>web服务器网关接口</strong>，是一个 web服务器 与 应用服务器 通信的 <strong>一种规范协议</strong>，<strong>WSGI 是 web服务器 与 web应用程序 或 应用框架 之间的一种的接口</strong></p><p>​    <strong>uWSGI：</strong>是一个 <strong>web服务器</strong>，实现了 <strong>WSGI，uwsgi，http 协议</strong></p><p>​    <strong>uwsgi：</strong>它与 WSGI 一样，是 uWSGI服务器 的 <strong>通信协议</strong></p><p><img src="https://wei-foun.github.io/img/WSGI.jpg" alt="img/md5.jpg"> </p><p>​    对于 Python 的 Django 和 Flask 框架，他们本身就是基于 WSGI 实现的，但实际项目部署时，如果使用框架自身的 WSGI 来运行，性能上是非常有影响的，所以通常在生产环境下，会利用 uwsgi 或是 gunicorn 这类实现了 WSGI 的库来运行项目，后者性能更好，更轻量化</p><h3 id="Django-请求生命周期"><a href="#Django-请求生命周期" class="headerlink" title="Django 请求生命周期"></a>Django 请求生命周期</h3><p>​    1）按照 wsgi 协议，封装请求后交给 Django 框架</p><p>​    2）请求到达中间件，并对请求进行校验或是在请求对象中添加其他的相关数据，例如：csrf，request.session</p><p>​    3）通过中间件后，由路由控制器对请求 url 进行匹配，然后分发给对应的视图函数</p><p>​    4）视图函数进行业务逻辑的处理并返回</p><p>​    5）返回的需要再次经过中间件，对要响应的数据进行处理</p><p>​    6）通过 wsgi 再将响应结果和内容发送给浏览器</p><h3 id="Django-基本命令"><a href="#Django-基本命令" class="headerlink" title="Django 基本命令"></a>Django 基本命令</h3><p>​    <strong>安装：</strong><code>pip3 install django</code>， 直接安装会从原地址去下载，会非常非常慢甚至会中断失败，所以可以通过国内的一些镜像源去安装，比如豆瓣源：<code>pip3 install -i https://pypi.douban.com/simple/ django</code></p><p>​    <strong>创建 django 项目：<code>django-admin.py startproject 项目名称</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">项目名称文件夹</span><br><span class="line">|---- manage.py             # 启动文件 </span><br><span class="line">|---- 项目文件夹</span><br><span class="line">    |---- __init__.py</span><br><span class="line">    |---- settings.py       # 包含一些数据库等配置信息</span><br><span class="line">    |---- urls.py           # 全局路由与视图函数映射文件，但并不需要将所有 url 全写在这个文件中 </span><br><span class="line">    |---- wsgi.py           # 关于 wsgi 协议的配置设置</span><br></pre></td></tr></table></figure><p>​    <strong>创建应用：<code>python3 manage.py startapp 应用名称</code></strong>，该命令会在项目文件夹下创建一个应用的文件夹</p><p>​    <strong>注意，创建一个应用后，需要在 settings 文件中 INSTALLED_APPS 中，将引用添加进去，否则后面应用建好 ORM 模型类后，要进行数据迁移操作，就不会生成迁移文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用文件夹</span><br><span class="line">|---- __init__.py</span><br><span class="line">|---- admin.py</span><br><span class="line">|---- apps.py</span><br><span class="line">|---- migrations              # 进行迁移时，会产生文件在该文件夹下</span><br><span class="line">    |---- __init__.py</span><br><span class="line">|---- models.py</span><br><span class="line">|---- test.py</span><br><span class="line">|---- views.py</span><br></pre></td></tr></table></figure><p>​    <strong>启动项目：<code>python3 manage.py runserver (ip:port)</code></strong>，括号中的 ip 和端口可以不用显式输入，默认会在本地的 8000 端口启动这个项目，然后在浏览器输入 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 就可以访问了，会跳转到 django 自带一个首页界面，会显示成功启动项目以及 django 的版本信息</p><p>​    <strong>模型创建和数据库同步：<code>python3 manage.py makemigrations</code></strong>，创建迁移记录文件，即将模型（models）文件中对数据库的操作，以文件形式进行记录，该命令执行后，会在 migrations 文件夹下生成一个 <code>0001_initial.py</code> 的文件，可以查看这个文件会发现其实和在 models.py 中的代码是相似的，只是做了一些处理且每一次创建迁移都会生成一个类似 <code>0001_initial.py</code>  的文件，需要知道的是 ‘makemigrations’ 的命令完成后，并不会影响到数据库</p><p>​    <strong><code>python3 manage.py migrate</code></strong>，即使数据库与 models.py 中的 <strong>模型集 和 迁移文件 进行同步，这个命令会直接对数据库进行操作</strong>，所以 ‘migrate’ 命令必然是在 ‘makemigrations’ 之后进行操作的</p><p>​    如果需要使用 django 自带的 admin 系统，需要通过命令注册账户，再次之前需要先进行一次迁移同步操作 migrate。然后在终端上输入 <code>python3 manage.py creatersuperuser</code>，按照要求顺序输入用户名，邮箱地址（可为空），密码有长度限制，但是回车后输入 y 依然可以创建。完成创建后，在 <a href="http://127.0.0.1:8000/admin/">http://127.0.0.1:8000/admin/</a> 的地址就可以进行登录了</p><p>​    补充一点，如果想在 admin 系统里看见其他的 model，默认情况下只会有 Groups 和 Users 两个模型，自定义的模型要在 admin 页面中显示，需要在项目应用的目录中 admin.py 文件里将 models.py 的自定义的模型进行注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Jobs</span><br><span class="line"></span><br><span class="line">admin.site.register(</span><br><span class="line">    Jobs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Django-配置文件"><a href="#Django-配置文件" class="headerlink" title="Django 配置文件"></a>Django 配置文件</h3><p>​    创建完一个 django 的应用后，在项目同名的子文件夹中，会自动生成一个 settings.py 的文件，其中包含了默认生成的一些配置项，注意！django 的 settings 的文件并不只是这一个，<strong>django 内部还有一个 settings 文件叫 global_settings 在 django 的 conf 下</strong>，global_settings.py 是整个 django 框架全局的配置文件，包含了所有的配置项和默认值，项目文件夹下的 settings.py 文件的作用是更改默认配置项的值，因为 django 的配置加载是优先加载 global_settings.py 中的配置，然后加载指定的 settings 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build paths inside the project like this: os.path.join(BASE_DIR, ...)</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"><span class="comment"># __file__ 表示为当前 settings.py 文件，BASE_DIR 指的就是当前整个项目的根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY WARNING: keep the secret key used in production secret!</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;n%qi)e!np)*iu=hvt22w15pk0w115aw)%$*a=al@*87x16s8nq&#x27;</span></span><br><span class="line"><span class="comment"># secret_key 的值用作 session 的信息做加盐编码，注意提示说明了这个配置项在生产环境中要保留，对于 secret_key 的配置可以额外使用一个 env 文件保存 key，让关键信息和配置项隔离</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY WARNING: don&#x27;t run with debug turned on in production!</span></span><br><span class="line">DEBUG = <span class="literal">True</span></span><br><span class="line"><span class="comment"># debug 配置项的作用是为了方便开发环境中对项目做调试，可以在页面上显示错误信息，默认是 True 开启调试的，在实际的生产环境中，需要将这个值改为 False</span></span><br><span class="line"></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">&quot;*&quot;</span>]</span><br><span class="line"><span class="comment"># allowed_host 用来配置可以访问网站的源，默认是元素是 * 表示允许任何源来访问，如果项目是允许固定的 ip 来访问，可以将指定的 ip 加入到列表里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application definition</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework.authtoken&#x27;</span>,  <span class="comment"># drf 的 token 认证</span></span><br><span class="line">    <span class="string">&#x27;course&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># installed_apps 中包含了 django 自带的应用组件，开发中创建了应用后，需在将创建的应用添加到这个列表中，比如上面使用的第三方库 rest_framework，以及自己创建的 course 的应用</span></span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,   <span class="comment"># 对 request 的 user 赋值</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># middleware 同样包含 django 自带的处理中间件，包括 csrf 校验的 csrfmiddleware，自带的用户认证的 authenticationmiddleware，对 session 做处理的 sessionmiddleware</span></span><br><span class="line"><span class="comment"># ！！注意，任何自己创建的自定义的中间件，都只能加在 middleware 列表的最后，让 django 自带的中间件优先执行</span></span><br><span class="line"></span><br><span class="line">ROOT_URLCONF = <span class="string">&#x27;drf.urls&#x27;</span></span><br><span class="line"><span class="comment"># root_urlconf 配置指的值项目的总路由文件，即项目同名文件夹中的 urls.py，这个路由文件是所有应有路由的起始点</span></span><br><span class="line"></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&#x27;templates&#x27;</span>)]</span><br><span class="line">        ,</span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># templates 的配置中，backend 包含了 django 使用模板引擎，dirs 指的是 django 的模板文件夹的路径，默认是在项目中的 templates 的文件夹</span></span><br><span class="line"></span><br><span class="line">WSGI_APPLICATION = <span class="string">&#x27;drf.wsgi.application&#x27;</span></span><br><span class="line"><span class="comment"># wsgi_application 配置的就是 django 的 wsgi 的应用，默认就是项目同名的文件夹中 wsgi.py 中的 application</span></span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># databases 配置的就是项目使用的存储数据库，默认使用自带的 sqlite3 的数据库</span></span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-hans&#x27;</span></span><br><span class="line"><span class="comment"># language_code 配置项表示使用的语言，改为 zh_hans 表示用中文，这样 django 自带的 admin 中可以用中文显示</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="comment"># time_zone 是时区的配置，改为使用 Asia/Shanghai，否则时区默认是 UTC </span></span><br><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">&#x27;/static/&#x27;</span></span><br><span class="line"><span class="comment"># static_url 配置的是请求静态文件的资源，需要访问的路径</span></span><br><span class="line"></span><br><span class="line">STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line"><span class="comment"># static_root 配置的是项目所有静态资源所要存放的目录，注意需要是一个绝对路径，当项目部署时，使用 python manage.py collectstatic 会将项目中所有的 static 的文件全部拷贝到当前的 static_root 的目录中</span></span><br><span class="line"></span><br><span class="line">STATICFILES_DIRS = (</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">&quot;staticfiles&quot;</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># staticfiles_dirs 配置并不完全是一个必须配置项，staticfiles_dirs 的作用是告诉 django 在查找静态资源的时候优先会在 staticfiles_dirs 中查找，如果资源存在就返回，没有就继续往后查找，到 static_root 去寻找</span></span><br></pre></td></tr></table></figure><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><p>​    默认 django 的数据配置使用的 sqlite3，如果要是用 mysql，需要更改 engine 的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库配置</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;  </span><br><span class="line">     <span class="comment"># default 表示默认使用的数据库</span></span><br><span class="line"> <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;course&#x27;</span>,  <span class="comment"># 数据库名称 数据库需要自己提前建好</span></span><br><span class="line"> <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,    <span class="comment"># 数据库用户名</span></span><br><span class="line"><span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;&#x27;</span>,    <span class="comment"># 数据库密码</span></span><br><span class="line"> <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;&#x27;</span>,        <span class="comment"># 数据库主机，留空默认为 localhost</span></span><br><span class="line"> <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,    <span class="comment"># 数据库端口</span></span><br><span class="line"> &#125;,</span><br><span class="line">    <span class="string">&#x27;db2&#x27;</span>: &#123;</span><br><span class="line">     <span class="comment"># 这里的 db2 表示的多数据库项目下的配置</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;db_data&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;mysql_db&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;priv4te&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当项目如果是使用多数据库，比如要求 <strong>读写分离，那么就需要去配置 DATABASE_ROUTERS，来对指定数据库的读写分离的路由选择，django 中提供了两个方法来指定，分别是 db_for_read 和 db_for_write</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myrouter.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">db_for_read</span>(<span class="params">self, model, **hints</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;指定项目读取对象的数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;db2&#x27;</span>     <span class="comment"># 分别是 DATABASES 数据库配置的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">db_for_write</span>(<span class="params">self, model, **hints</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;指定项目写入模型类对象到的数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span></span><br></pre></td></tr></table></figure><p>​    <strong>完成数据库的路由创建后，在 settings 中就可去指定 django 的数据路由配置 DATABASE_ROUTERS</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATABASE_ROUTERS = [<span class="string">&#x27;myrouter.Router&#x27;</span>,]  <span class="comment"># 使用自己定义的数据库路由</span></span><br></pre></td></tr></table></figure><h4 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h4><p>​    django 默认生成的 settings 中是不配置缓存的配置，所以如果项目中使用到 redis 或其他缓存数据库，需要去配置 caches</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># django 缓存配置</span></span><br><span class="line"> CACHES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django_redis.cache.RedisCache&#x27;</span>,</span><br><span class="line">     <span class="comment"># backend 配置使用 django-redis 的 RedisCache，必设置项，这里使用 redis 来作为缓存中间件</span></span><br><span class="line">  <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;redis://127.0.0.1:6379&#x27;</span>,</span><br><span class="line">     <span class="comment"># location 是连接 redis 的地址和端口，必配置项</span></span><br><span class="line">  <span class="string">&#x27;KEY_PREFIX&#x27;</span>: <span class="string">&#x27;alexham&#x27;</span>,</span><br><span class="line">     <span class="comment"># key-prefix 表示缓存时，key 的前缀，非必配置项</span></span><br><span class="line">  <span class="string">&#x27;TIMEOUT&#x27;</span>: <span class="number">300</span></span><br><span class="line">     <span class="comment"># time-out 即 redis key 的超时时间，单位是秒，如果值为 None 表示不设置超时</span></span><br><span class="line">     <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">         <span class="comment"># options 的中用来配置三方可能需要的参数</span></span><br><span class="line">            <span class="string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="number">1000</span></span><br><span class="line">         <span class="comment"># max_entires 表示的缓存数，默认是 300，在 redis 的缓存配置中也为 非必配置项</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="session-配置"><a href="#session-配置" class="headerlink" title="session 配置"></a>session 配置</h4><p>​    django 中 session 默认是存储在数据库中，数据迁移后生成一张 django_session 的表来存储，也支持其他的方式例如缓存方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># session 相关配置</span></span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.db&#x27;</span> </span><br><span class="line"><span class="comment"># .db 表示存储在数据库上（默认）</span></span><br><span class="line"><span class="comment"># .cache_db 表示存储在缓存数据库上</span></span><br><span class="line"><span class="comment"># .cache 表示直接放在缓存中</span></span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_NAME ＝ <span class="string">&quot;sessionid&quot;</span></span><br><span class="line"><span class="comment"># session-cookie-name 表示在浏览器上 cookie 信息中的 key 的字段名字默认是 sessionid，也就是 sessionid=xxxxxxxxx</span></span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_SECURE = <span class="literal">False</span></span><br><span class="line"><span class="comment"># session-cookie-secure 表示是否使用 https 传出 cookie，默认是 False</span></span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_HTTPONLY = <span class="literal">True</span></span><br><span class="line"><span class="comment"># session-cookie-httponly 表示 session 的 cookie 只支持 http 协议传输</span></span><br><span class="line"></span><br><span class="line">SESSION_COOKIE_AGE = <span class="number">1209600</span></span><br><span class="line"><span class="comment"># session-cookie-age 表示 session 的 cookie 最大失效日期，默认是两周，即 60*60*24*7*2</span></span><br></pre></td></tr></table></figure><h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>​    日志的配置也是项目开发和测试时，必备的配置，补充一点 <strong>logging 日志的五个等级</strong>，按照从高到低顺序是：<strong>critical，error，warning，info，debug</strong>，还有一个最低级级别的 notest</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LOG_DIR = os.path.join(BASE_DIR, <span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment"># 默认配置项</span></span><br><span class="line">    <span class="string">&quot;disable_existing_loggers&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="comment"># 默认配置项</span></span><br><span class="line">    <span class="string">&quot;formatters&quot;</span>: &#123;</span><br><span class="line">        <span class="comment"># formatters 表示自定义日志格式</span></span><br><span class="line">        <span class="string">&quot;verbose&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;format&quot;</span>: <span class="string">&quot;%(levelname)s %(asctime)s %(module)s &quot;</span></span><br><span class="line">            <span class="string">&quot;%(process)d %(thread)d %(message)s&quot;</span></span><br><span class="line">            <span class="comment"># format 的值表示输出日志级别名称、日志信息，以及生成日志信息的时间、进程、线程和模块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;handlers&quot;</span>: &#123;</span><br><span class="line">        <span class="comment"># handlers 中定义各类日志处理器</span></span><br><span class="line">        <span class="string">&quot;console&quot;</span>: &#123;</span><br><span class="line">            <span class="comment"># console 表示输出到终端</span></span><br><span class="line">            <span class="string">&quot;level&quot;</span>: <span class="string">&quot;DEBUG&quot;</span>,</span><br><span class="line">            <span class="comment"># level 表示的日志记录的等级，这里表示 DEBUG 以以上等级的日志信息全都写入日志</span></span><br><span class="line">            <span class="string">&quot;class&quot;</span>: <span class="string">&quot;logging.StreamHandler&quot;</span>,</span><br><span class="line">            <span class="string">&quot;formatter&quot;</span>: <span class="string">&quot;verbose&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;root&quot;</span>: &#123;<span class="string">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>, <span class="string">&quot;handlers&quot;</span>: [<span class="string">&quot;console&quot;</span>]&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Django-中间件"><a href="#Django-中间件" class="headerlink" title="Django 中间件"></a>Django 中间件</h3><p>​    Django 中间件的使用是要在 settings 配置文件中的 Middleware 的配置项列表中去进行配置的，默认创建 Django 项目的时候，会加入一系列 Django 所要使用的中间件，包括 Sessionmiddleware，CsrfViewmiddleware，Authenticationmiddleware 等等</p><p>​    SessionMiddleware 的作用是开启对 session 会话支持，将信息存在 django_session 表里，以及对 request 的 session 做键值的设置和获取</p><p>​    CsrfViewMiddleware 的作用是为了防止跨站请求伪造，主要是对比提交的表单的 csrf_token 与 cookie 的 csrf_token 是否一致来判断请求是否可以执行</p><p>​    AuthenticationMiddleware 的作用是为了给 request 设置 user 属性，来判断请求是否是登录用户，以及匿名用户</p><p>​    httprequest 进入到 Django 中间件后，按照 settings 中 middleware 配置注册的顺序依次从上往下执行，当完成处理得到响应后，会从下而上再去执行一遍中间件，然后才能将 httpresponse 返回</p><p>​    <strong>Django 的中间件中提供了 5 个方法，包括：process_request，process_view，process_template_response，process_exception，process_response</strong>，其中常用的就是 process_request 和 process_response</p><p>​    首先，request 会进入到中间件的 process_request 方法，在这里可以对 request 做属性添加，或者属性值的判断。这方法 <strong>如果返回 None，就会将请求交给下一个中间件的 process_request 执行并以此类推，如果这里直接返回 response 对象，那么这个请求将不会走到路由匹配包括后面的视图中，而是直接给到最后一个中间的 process_response 去执行</strong></p><p>​    经过所有中间件的 process_request 之后，就会进入 url 文件进行路由匹配，完成后请求会回到第一个中间件，开始执行 <strong>process_view 方法，同理如果返回 None 就依次往后执行，返回 response 就会走到 process_response</strong></p><p>​    经过所有中间件的 process_view 之后，就会根据 url 对应的视图，把 request 交给视图开始做业务逻辑处理</p><p>​    如果在视图中，出现异常没有被捕获，那这个异常就会被 Django 去自行捕获，Django 会将捕获的异常再次执行中间件 process_exception，依然是从上往下执行，来得到异常的响应对象，然后再去执行 process_response</p><p>​    如果视图业务处理没有问题，最后使用 render 去通过模板渲染返回 response 的话，在 render 的选择模板的时候，会触发中间件的 process_template_response 方法 </p><p>​    最后，<strong>响应要返回都会经过中间件的 process_response 方法，而且执行的顺序是从下而上的</strong>，并且对于 process_response，必须要将返回一个 response</p><h3 id="URL-配置"><a href="#URL-配置" class="headerlink" title="URL 配置"></a>URL 配置</h3><p>​    在应用创建完成前，项目的目的下有一个全局的 urls.py ，即该文件所存储的就是网站中所有的 url 配置，不过通常来说，将应用的 url 放在全局的 urls 中显然有些不妥，不仅不方便对应查看，也不能体现根据应用实现 url 的解耦，所以都会在创建的应用文件夹中另外创建一个 urls.py 的文件，将该应用的 url 记录在该应用的 urls 中，且在全局 urls 文件中去引用它，这样全局的 urls 中只需要给一个对应创建应用的 url 就能指向到应用内部的创建的 urls 去匹配和分发，以此实现解耦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py 配置</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(正则表达式, views视图函数，参数，别名),   <span class="comment"># 在 django 1.1.x 的版本使用的 url 方法去配置理由，而在 2.2.x 的版本开始使用的是 path 和 re_path</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式，即用来对 url 去进行匹配</span></span><br><span class="line"><span class="comment"># views 视图函数，即匹配成功后回调的 target，通常是一个视图函数名或是视图函数的路径</span></span><br><span class="line"><span class="comment"># 参数，可选的配置项，用来将这个默认参数传递给视图函数，是字典格式的</span></span><br><span class="line"><span class="comment"># 别名，可选的配置项，别名主要用来简化 url，方便在其他地方可以直接利用别名去找指定 url</span></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># django 1.1.x，urls 配置</span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url   <span class="comment"># 用 url 需要引入</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^admin/$&#x27;</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r&#x27;^index/$&#x27;</span>, views.index), <span class="comment"># 普通路径</span></span><br><span class="line">    url(<span class="string">r&#x27;^articles/([0-9]&#123;4&#125;)/$&#x27;</span>, views.articles), <span class="comment"># 正则路径</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># django 2.2.x，urls 配置</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path    <span class="comment"># 用 re_path 需要引入</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),    <span class="comment"># admin 的路由是 django 自带的后台管理应用</span></span><br><span class="line">    path(<span class="string">&#x27;index/&#x27;</span>, views.index),   <span class="comment"># 普通路径</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^articles/([0-9]&#123;4&#125;)/$&#x27;</span>, views.articles), <span class="comment"># 正则路径</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># path，用作普通路径，不需要手动添加正则的开始和结尾的限制符号</span></span><br><span class="line"><span class="comment"># re_path，和 1.1.x 中的 url 方法一致，需要手动去添加限制符（^ ，$）</span></span><br></pre></td></tr></table></figure><h4 id="url-的注意点"><a href="#url-的注意点" class="headerlink" title="url 的注意点"></a>url 的注意点</h4><p>​    1）url 的正则匹配由上至下逐一匹配，一旦有正则表达式满足 url 的匹配，就不会继续往后进行，所以在 url 的配置顺序上，如果有相似度极高的 url ，就需要做些配置顺序上的调整或是直接修改 url ，让每一个 url 可以被单独匹配，而不会在因为相似情况下，被前面的 url 匹配导致真正匹配的 url 不能匹配到，从而可能导致出错</p><p>​    2）url 的正则表达式前面不需要加上反斜杠 ‘/‘，因为浏览器会默认在 8080 后面加上 ‘/‘，发送请求后 url 是携带着这个反斜杠的</p><p>​    3）在使用 url 和 re_path 方法中设置正则表达式，建议在表达式字符串前加上 ‘r’，来表示一个原始字符串和防止转义</p><p>​    4）在 url 的正则匹配中，如果有参数，需要使用 ‘()’，例如   <code>re_path(r&#39;^articles/([0-9]&#123;4&#125;)/$&#39;, views.articles)</code>，匹配这个 url 的地址会携带后面 4 个数字，一旦 url 匹配上，这个 4 位数的参数会被一起传递给视图函数 articles，那么在这个函数中，就需要定义一个形参去接受这个参数</p><p>​    5）即明确名字的参数，例如   <code>path(&#39;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#39;, views.month_archive),</code>，这个 url 中使用 ‘&lt;&gt;’ 明确定义了参数，那么在视图函数中 views.month_archive 的形参就需要明确定义 year 和 mouth</p><h4 id="无名分组和有名分组"><a href="#无名分组和有名分组" class="headerlink" title="无名分组和有名分组"></a>无名分组和有名分组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无名分组</span></span><br><span class="line"><span class="comment"># urls 中的配置</span></span><br><span class="line">url(<span class="string">r&#x27;^articles/(\d&#123;4&#125;)/(\d&#123;2&#125;)/$&#x27;</span>, views.year_month), </span><br><span class="line"></span><br><span class="line"><span class="comment"># views 的配置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">year_month</span>(<span class="params">request, y, m</span>)</span><br><span class="line"></span><br><span class="line">此时，请求 url = <span class="string">&#x27;http://127.0.0.1:8000/articles/2020/05/&#x27;</span></span><br><span class="line">进入到视图处理时， 就是 year_month(requset,<span class="number">2020</span>,05)   <span class="comment"># 匹配的 url 会按位置传递参数</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有名分组</span></span><br><span class="line"><span class="comment"># 应用的 urls.py </span></span><br><span class="line">url(<span class="string">r&#x27;^articles/(?P&lt;year&gt;\d&#123;4&#125;)/(?P&lt;month&gt;\d&#123;2&#125;)/$&#x27;</span>, views.year_month) </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">year_month</span>(<span class="params">request, year, month</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">f&#x27;year:<span class="subst">&#123;year&#125;</span>, month:<span class="subst">&#123;month&#125;</span>&#x27;</span>)   <span class="comment"># HttpResponse 可以时间将指定的字符渲染到页面上</span></span><br></pre></td></tr></table></figure><p>​    此时，请求   <code>url = http://127.0.0.1:8000/articles/2020/05/</code>，进入到视图处理时， 就是 year_month(requset, year=2020, month=05)</p><p><img src="https://wei-foun.github.io/img/views1.jpg" alt="img/md5.jpg"> </p><h4 id="url-分发"><a href="#url-分发" class="headerlink" title="url 分发"></a>url 分发</h4><p>​    前面说到了，对于 urls 配置可以根据应用内部创建 urls.py 的文件去实现解耦，这就是 url 的分发，但是前提是需要在全局的 urls 中去配置要分发的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Including another URLconf</span><br><span class="line">    1. Import the include() function: from django.urls import include, path</span><br><span class="line">    2. Add a URL to urlpatterns:  path(&#x27;blog/&#x27;, include(&#x27;blog.urls&#x27;))</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>​    全局的 urls 文件中给出了这样的提示，所以只需要模仿它的样子，在全局中去导入 app 和 <code>from django.urls import include</code> 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局的 urls 文件</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include</span><br><span class="line"><span class="keyword">import</span> app01</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;app01.urls&#x27;</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 app01 的 urls 文件</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r&#x27;^articles/([0-9]&#123;4&#125;)/$&#x27;</span>, views.year_article),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​    全局的 url 分发的正则部分给了空，也就是说当使用 python  manage.py 启动项目后，直接访问启动的路由，这个请求就会被分发到 app01 中的 urls 中，再去进行匹配得到对应处理的视图</p><h4 id="url-反向解析"><a href="#url-反向解析" class="headerlink" title="url 反向解析"></a>url 反向解析</h4><p>​    所谓反向解析，是为了在模板中为了渲染 url，但是直接将 urls 中路由填写在模板中显然是不合理的，所以在配置 url 时就有了参数 name，用别名来代替 url，可以更简便的管理 url</p><p>​    反向解析的目的就是防止对 url 进行硬编码，以至于在修改了 urls 中的路由后，不用 name 的情况下，就需要一个个去修改模板中的路由，否则就无法进行跳转，并且会在渲染时就会抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反向解析 url ，可以是在视图函数中或是在模板文件中</span></span><br><span class="line"><span class="comment"># 假设 urls 中有一个路由</span></span><br><span class="line">path(<span class="string">&#x27;news/index&#x27;</span>, views.index, name=<span class="string">&#x27;news_index&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 视图函数中的应用：</span></span><br><span class="line">reverse(<span class="string">&quot;news_index&quot;</span>)     <span class="comment"># 返回 http://127.0.0.1:8000/news/index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果路由是一个需要动态参数的话，通过 args 添加</span></span><br><span class="line">reverse(<span class="string">&quot;news_index&quot;</span>, args=(<span class="number">1</span>,))     <span class="comment"># 返回 http://127.0.0.1:8000/news/index/1/</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模板中的应用：</span></span><br><span class="line">&#123;% url <span class="string">&#x27;news_index&#x27;</span> %&#125;     <span class="comment"># 即 http://127.0.0.1:8000/news/index</span></span><br><span class="line"></span><br><span class="line">&#123;% url <span class="string">&#x27;news_index&#x27;</span> <span class="number">1</span> %&#125;   <span class="comment"># 即 http://127.0.0.1:8000/news/index/1/</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充 reverse  和 reverse_lazy：</strong></p><p>​    在视图函数中，要想直接利用 url.py 中路由设置的 name 来做反向解析，除了 reverse 方法，还有一个 reverse_lazy 的方法。两者简单的区别是，<strong>reverse 方法适用于在 FBV 中做反向 url 解析，而 reverse_lazy 方法则是适用于 CBV 中来处理</strong></p><p>​    为什么 reverse 不能在 CBV 中使用，而 reverse_lazy 可以呢？官方文档的解释是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">It <span class="keyword">is</span> useful <span class="keyword">for</span> when you need to use a URL reversal before your project’s URLConf <span class="keyword">is</span> loaded.</span><br><span class="line"><span class="comment"># 就是说，如果在 django 的 urlconf 文件加载前就要使用 url 的方向解析，最好就是使用 reverse_lazy</span></span><br></pre></td></tr></table></figure><p>​    同时也给出适合使用的场景，其中第一个就是 CBV 的视图，然后使用装饰器的时候如果使用 url 反向解析，比如 login_url 的参数是反向 url，这些就需要使用 reverse_lazy 方法</p><p>​    详细来说，python 在导入一个模块时，会默认 “执行” 一次这个模块，这其中包括全局变量的定义和赋值，函数和类的声明，以及检查 <code>__name__</code> 的主线程代码的操作。对于类而言，类的全局属性也会被加载赋值，但是如果类的全局属性是一个函数的结果，那么这个函数也就需要被立即执行。所以对于 django 的 CBV 来说，全局属性使用 reverse 来方向解析 url 时，如果这个 url 不是全局 url.py 下的，而是跟随具体应用的话，即全局 url 是通过 include 导入的，那么 CBV 的方向解析 url 如果是其他的应用，这会因为加载顺序问题导致无法解析而抛出异常</p><p>​    而 reverse_lazy 就是 reverse 的惰性版本的方法，这个方法会等待 urlconf 全部加载完成后，再去方向解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体例子</span></span><br><span class="line"><span class="comment"># importme.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;FUNCTION HELLO&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;CLASS HELLO&quot;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> importme</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>CLASS HELLO</span><br></pre></td></tr></table></figure><p>​    可见模块导入后，CBV 的 print 方法会被立刻执行，这样一来在 django 的 CBV 中，如果 success_url 的属性值是通过 reverse 方法的时候，这个方法就会立刻执行，导致出现上诉说明的情况，所以可以使用 reverse_lazy 方法或是在 get_success_url 中调用 reverse</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewJobCBV</span>(LoginRequiredMixin, CreateView):</span><br><span class="line">    template_name = <span class="string">&#x27;company/job.html&#x27;</span></span><br><span class="line">    form_class = newJobForm</span><br><span class="line">    <span class="comment"># success_url = reverse_lazy(&#x27;newJob&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_success_url</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="string">&quot;newJob&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="url-名称空间"><a href="#url-名称空间" class="headerlink" title="url 名称空间"></a>url 名称空间</h4><p>​    即给应用的 url 划定唯一的空间，所以即使出现相同的 url 只要是在不同的应用名称空间中都是允许的，名称空间的定义是在配置 url 分发时，通过参数 namespace 来指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;xxxx/xxx&#x27;</span>,  include((<span class="string">&#x27;app.urls&#x27;</span>, <span class="string">&#x27;app&#x27;</span>), namespace=<span class="string">&#x27;app&#x27;</span>))</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 第一个 app 是应用名称，第二个 app 是 namespace 也就是名称空间</span></span><br></pre></td></tr></table></figure><h3 id="HttpRequests-和-HttpResponse-对象"><a href="#HttpRequests-和-HttpResponse-对象" class="headerlink" title="HttpRequests 和 HttpResponse 对象"></a>HttpRequests 和 HttpResponse 对象</h3><p>​    HttpRequests 即 访问的 http 请求，客户端向应用服务器发起请求来获取资源，HTTPResponse 即 http 响应，服务器接收到客户端的请求后将处理后的结果发回给客户端</p><h4 id="HttpRequests-对象"><a href="#HttpRequests-对象" class="headerlink" title="HttpRequests 对象"></a>HttpRequests 对象</h4><p>​    当服务器接收到请求后，django 会根据报文创建 HttpRequests 对象，并且会在内部封装一个 request 作为 HttpRequests 对象，而这个 request 就是视图函数中第一个必须的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性</span></span><br><span class="line">path          <span class="comment"># 请求的路径，但是不包括域名和端口</span></span><br><span class="line">method        <span class="comment"># 请求的类型，以全大写返回，如 GET，POST</span></span><br><span class="line">GET           <span class="comment"># GET 请求中所有的参数，返回的是一个 QueryDict 对象</span></span><br><span class="line">POST          <span class="comment"># 同上，返回的是 POST 请求中的参数</span></span><br><span class="line">body          <span class="comment"># json 数据需要通过 body 获取，但返回结果不是字典，而是字节类型的字符串，所以需要先 decode</span></span><br><span class="line">COOKIES       <span class="comment"># 返回请求头中 Cookie 信息，字典形式返回</span></span><br><span class="line">FILES         <span class="comment"># 文件上传的 QueryDict 对象，key 是 input 标签中的 name，而 value 包含 filename(文件名)，content_type(文件 content_type 类型)，content(文件原始内容)</span></span><br><span class="line">session       <span class="comment"># 返回一个 session 对象，可以在 django 的中间件启用</span></span><br><span class="line">user          <span class="comment"># 即当前访问登录的用户对象，是一个 django.contrib.auth.models.User 对象，同样可以在中间件去启用</span></span><br><span class="line">META          <span class="comment"># 包含请求和响应的 headers 中所有的信息，是一个字典格式，且 key 全部都是大写，另外对比浏览器的头部信息，可以看到在请求的头部中，django 给键都加上了 HTTP_ 前缀，所以如果要去添加一个自定义的信息到 META 中，就需要加上必要的前缀</span></span><br><span class="line"> CONTENT_LENGTH    <span class="comment"># 正文长度</span></span><br><span class="line"> CONTENT_TYPE      <span class="comment"># 正文的 MIME 类型</span></span><br><span class="line"> HTTP_ACCEPT       <span class="comment"># 可接受的 Content-Type</span></span><br><span class="line"> HTTP_ACCEPT_ENCODING     <span class="comment"># 可接受的响应编码类型</span></span><br><span class="line"> HTTP_HOST         <span class="comment"># 客户端发送的 host 头部</span></span><br><span class="line"> HTTP_USER_AGENT   <span class="comment"># 客户端的 User-Agent 的字符串</span></span><br><span class="line"> REMOTE_ADDR       <span class="comment"># 客户端的 ip 地址</span></span><br><span class="line"> REMOTE_HOST       <span class="comment"># 客户端的主机名</span></span><br><span class="line"> REQUEST_METHOD    <span class="comment"># 请求方法的字符串，&quot;GET&quot; 等等</span></span><br><span class="line"> SERVER_NAME       <span class="comment"># 服务器的主机名</span></span><br><span class="line"> SERVER_PORT       <span class="comment"># 服务器的端口字符串</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">get_full_path()    <span class="comment"># 返回请求的 url，同样没有域名和端口，但是与 path 属性不同，该方法在请求有参数的情况下会返回带有参数的 url</span></span><br><span class="line">is_ajax()          <span class="comment"># 判断请求是否是 AJAX 发起的</span></span><br></pre></td></tr></table></figure><h4 id="HttpResponse-对象"><a href="#HttpResponse-对象" class="headerlink" title="HttpResponse 对象"></a>HttpResponse 对象</h4><p>​    请求的 httprequests 是由 django 来自动创建的，进入到视图函数处理完成后，就需要去返回，也就是需要去创建一个相应的 httpresponse 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用的方法</span></span><br><span class="line"></span><br><span class="line">render(request, template_name[, context]）</span><br><span class="line"><span class="comment"># 用于直接渲染模板文件或是给定的上下文字典加入到文件一同渲染，最后会返回一个 HttpResponse 对象，视图函数最后只需要 return 这个对象即可</span></span><br><span class="line"><span class="comment"># request，参数是必须的参数，用作响应的请求对象</span></span><br><span class="line"><span class="comment"># template_name，即要渲染的模板文件</span></span><br><span class="line"><span class="comment"># context，可选参数，且是字典结构，渲染文件时会将字典作为上下文传递给模板文件，让其进行渲染</span></span><br><span class="line"><span class="comment"># content_type，可选参数，指定生成的文档使用的 MIME 类型</span></span><br><span class="line"><span class="comment"># status，来指定响应的状态码</span></span><br><span class="line"></span><br><span class="line">redirect()</span><br><span class="line"><span class="comment"># 用于进行页面跳转</span></span><br><span class="line"></span><br><span class="line">HttpResponse()</span><br><span class="line"><span class="comment"># 可以直接将字符串传入，来作为页面内容构造响应对象，请求页面会将字符串显示；也可直接实例化这个响应对象，使用该对象的 write 方法将字符串写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HttpResponse 对象举例：</span><br><span class="line">ret = HttpResponse(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">ret = render(request, <span class="string">&quot;index.html&quot;</span>)</span><br><span class="line">ret = redircet(<span class="string">&quot;/index/&quot;</span>)    <span class="comment"># 这是写死的 url，跳转默认会将当前的域名和端口</span></span><br></pre></td></tr></table></figure><h3 id="FBV-和-CBV"><a href="#FBV-和-CBV" class="headerlink" title="FBV 和 CBV"></a>FBV 和 CBV</h3><p>​    FBV：function base views，基于函数的视图，即使用 def 去定义函数作为请求的处理入口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt   <span class="comment"># csrf_exempt装饰器，用来取消自带的 csrf 认证</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;login.html&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    CBV：class base views，基于类的视图，即使用面向对象的方式去定义视图，让类作为处理的入口，这样就可以利用类的三大特性，来实现高可用的代码，比如 Mixin 的多继承，并且不用像 FBV 中对于同一 url 的不同请求类型需要利用 if 去判断，使用 CBV 将每一个类型请求单独隔离开，这样维护成本就会降低</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator   <span class="comment"># method_decorator 用来给视图类做装饰</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@method_decorators(<span class="params">csrf_exempt, name=<span class="string">&quot;dispatch&quot;</span></span>)  </span><span class="comment"># CVB 中取消 csrf，使用 method_decorator 的话，name 的参数必须是 dispatch，而不是 POST，因为 CBV 的请求处理，是先进入的 View 的 dispatch</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># @csrf_exempt       # CVB 取消 csrf，也可以像 FBV 一样使用 csrf_exempt 来专门对 post 做装饰</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;POST&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    使用 CBV 时，创建的类需要去继承 django.views 的 View，另外要注意，使用 CBV 去编写处理逻辑前，urls 的配置也需要改变，需要在类名后加上 <code>.as_view()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;index/&#x27;</span>, views.MyView.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 渲染变量语法：</span><br><span class="line"></span><br><span class="line">&#123;&#123; 变量名 &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 变量的渲染必须是在 &#123;&#123; &#125;&#125; 之内，且如果变量是一个 list 或 dict 的话，想要渲染其中的某一个值，可以使用 .索引 或 .key 来遍历取出想要的值</span><br><span class="line"># 如果要渲染的这个变量是一个 object 的话，依然可以使用 .属性 或 .方法 获取值，但是 . 后面只能是无参的方法，如果要直接渲染对象，需要在对象内部实现 __str__ 方法</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 渲染标签语法：</span><br><span class="line"></span><br><span class="line">&#123;% 标签名 %&#125;</span><br><span class="line"></span><br><span class="line"># 通常不会直接使用这样的方式去渲染出一个简单 html，一般对于标签渲染都会用于需要循环创建的逻辑，比如需要渲染一堆 li 标签等等</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 用 for 循环创建标签</span><br><span class="line"></span><br><span class="line">&#123;% for i in [111,222,333] %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125; </span><br><span class="line"></span><br><span class="line"># for 循环创建标签并渲染，在最后需要使用 &#123;% endfor %&#125;，如果需要将遍历的序号一起渲染，需要使用 &#123;&#123; forloop.counter &#125;&#125;，这个语法会依次将遍历序号渲染，且是从 1 开始，如果要改为从 0 开始，使用 &#123;&#123; forloop.counter0 &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% for name in name_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">&lt;p&gt; no, name! &lt;/p&gt;</span><br><span class="line">&#123;% endfor %&#125; </span><br><span class="line"></span><br><span class="line"># &#123;% empty %&#125; 的标签语法并会渲染任何标签，它会在 for 循环是空的，或是变量找不到的情况下触发，来保证如果使用 for 得不到任何东西时，可以渲染一些提示等等，让操作能完成</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 条件判断语法:</span><br><span class="line"></span><br><span class="line">&#123;% if num &lt; 17 %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% elif num &gt; 5 %&#125;</span><br><span class="line">&lt;p&gt;&#123;&#123; num + 1 &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&lt;p&gt;&#123;&#123; num - 10 &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"># 和 for 循环标签语法一样，使用 if 的条件判断最后一个需要使用 endif</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">表单提交的标签：</span><br><span class="line"></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line"></span><br><span class="line"># 这是一个安全机制的标签，csrf 是指跨站请求伪造，跨站即跨域，csrf_token 的标签其实最后渲染后就是一个隐藏的 input 标签，csrf_token 标签不限位置，提交时会自动找到加上</span><br><span class="line"># 例如：&lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=&quot;uNHz6h6kVLlSXrMsyA7grL4Ly08D1ewY4kBtm9DnK3b6mC6cWUz8z5tIYCLvqQlw&quot;&gt;</span><br><span class="line"># django 的中间件 django.middleware.csrf.CsrfViewMiddleware 默认是开启，所以在提交发起请求后如果没有添加 csrf_token 的标签，会遇到 403 forbidden 的错误，在测试阶段也可以在 settings 文件的 MIDDLEWARE 中找到 &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27; 将其注释，表示不启用保护</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">with 标签：</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&#123;&#123; person_list.2.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% with name=person_list.2.name %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;% endwith %&#125;</span><br><span class="line"></span><br><span class="line"># with 标签相当于是给原本变量起了别名，因为变量可以利用 . 来实现一个链式的获取，就会导致可能需要写很长的一段代码，如果这个值恰好是常用的，就会相对繁琐一些，利用 with 别名去接收原来的值并使用要更加简便</span><br></pre></td></tr></table></figure><h4 id="模板语法自带的过滤器方法"><a href="#模板语法自带的过滤器方法" class="headerlink" title="模板语法自带的过滤器方法"></a>模板语法自带的过滤器方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 没有值或为空的替补值：default</span><br><span class="line">&#123;&#123;  res | default:val &#125;&#125;      # 如果 res 为 false 或 空，使用默认值 val</span><br><span class="line"></span><br><span class="line"># 返回变量的长度：length</span><br><span class="line">&#123;&#123; res | length &#125;&#125;             # 如果变量是一个列表，就返回列表的长度</span><br><span class="line"></span><br><span class="line"># 文件大小格式化：filesizeformat</span><br><span class="line">&#123;&#123; res | filesizeformat &#125;&#125;     # 将 res 转化为合适的存储大小单位，如：KB，MB，bytes...</span><br><span class="line"></span><br><span class="line"># 日期过滤：date</span><br><span class="line">&#123;&#123; res | date:&#x27;Y-m-d&#x27; &#125;&#125;     # res 是类似 datetime.datetime.now()，则会根据规定给定的 date 的字符串去格式化</span><br><span class="line"></span><br><span class="line"># 字符串切片过滤器：slice</span><br><span class="line">&#123;&#123; res | slice:&#x27;5:7&#x27;&#125;&#125;        # 将 res 根据给定范围去截取</span><br><span class="line"></span><br><span class="line"># 字符串截断：truncatechars</span><br><span class="line">&#123;&#123; res | truncatechars:num &#125;&#125;     # 会将 res 整体截取到给定的 nums 的位置，并将最后一个字符替换为 &#x27;...&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 单词截断：truncatewords</span><br><span class="line">&#123;&#123; res | truncatewords:num &#125;&#125;     # 同上，按照英文单词截断，每一位表示一个英文单词</span><br><span class="line"></span><br><span class="line"># 例如：s = &#x27;l am not throwing away my shot, hey yo, l just like my contry, young, scrape and hungry&#x27;</span><br><span class="line">使用 &#123;&#123;  res | truncatewords:5 &#125;&#125;，页面显示 &#x27;l am not throwing away …&#x27;</span><br><span class="line">使用 &#123;&#123;  res | truncatechars:15 &#125;&#125;，页面显示 &#x27;l am not throw…&#x27;</span><br><span class="line"></span><br><span class="line"># 防止转义</span><br><span class="line">&#123;&#123; res | safe &#125;&#125;             # 如果 res 是包含了 html 标签 或 是 js 代码 的内容需要使用 safe 过滤器防止显示异常，来告知 django 代码是安全的</span><br><span class="line"></span><br><span class="line"># 例如：res = &#x27;&lt;a href=&quot;&quot;&gt;点击&lt;/a&gt;&#x27;，直接交给模板渲染会将标签也一起作为字符串渲染，页面会显示 &lt;a href=&quot;&quot;&gt;点击&lt;/a&gt;，使用 &#123;&#123; res | safe &#125;&#125;，则会渲染 a 标签，页面会显示一个可以点击的 &#x27;点击&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自定义标签与过滤器"><a href="#自定义标签与过滤器" class="headerlink" title="自定义标签与过滤器"></a>自定义标签与过滤器</h4><p>​    在去创建自定义的标签与过滤器之前，需要完成三个前置步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）在 settings 配置文件中找到 INSTALLED_APPS，并在这个列表中配置上创建的应用名</span><br><span class="line"></span><br><span class="line">2）在创建的应用中，新建一个文件夹作为包，且文件名必须为 &#x27;templatetags&#x27;</span><br><span class="line"></span><br><span class="line">3）在 &#x27;templatetags&#x27; 中创建任意名字的 py 文件，作为自定义标签和过滤器的模块</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># templates 中新建 my_tags.py </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line"><span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> make_safe     <span class="comment"># make_safe 类似 safe 过滤器</span></span><br><span class="line"></span><br><span class="line">register = template.Library()      <span class="comment"># register 对象只能是这个名字</span></span><br></pre></td></tr></table></figure><p>​    <strong>自定义过滤器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@register.filter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x**y</span><br></pre></td></tr></table></figure><p>​    <strong>自定义标签</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@register.simple_tag</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_input</span>(<span class="params"><span class="built_in">id</span>, arg</span>):</span><br><span class="line">    content = <span class="string">f&quot;&lt;input type=&#x27;text&#x27; id=<span class="subst">&#123;<span class="built_in">id</span>&#125;</span> class=<span class="subst">&#123;arg&#125;</span> /&gt;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> mark_safe(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment">#使用前，也有一个前置步骤：在要是用自定义过滤器或标签的 html 模板中，使用  &#123;% load my_tags %&#125; 将创建的 my_tags 模块导入</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% load my_tags %&#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h3&gt;&#123;&#123; num | power:6 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &#123;% new_input &#x27;user&#x27; &#x27;red&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>​    最后，配合上视图的处理，返回的 html 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>64<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>     <span class="comment">&lt;!-- 这里视图函数中传递的 num 的值是 2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    <strong>区别：</strong></p><p>​    <strong>自定义过滤器</strong> 只能接受 <strong>两个参数</strong>，即定义函数时只能有两个形参，第一个参数为模板语法中 ‘|’ 管道符前的变量，第二个参数为自定义过滤器参数，就是管道符后过滤器名后的参数；且自定义过滤器是 <strong>可以配合 if 和 for</strong> 两个逻辑操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if num|power:6 &gt;= 60 %&#125;      &lt;!-- 这里的管道符左右是不能有空格的 --&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123; num|power:6 &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;h3&gt;大于 60&lt;/h3&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>自定义标签</strong> 与自定义过滤器相反，<strong>不对参数的个数做限制</strong>，但同样也就 <strong>无法配合 if 和 for</strong> 来使用自定义标签</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​    即对于使用相同部分的 html 的文件，可以利用继承来减少模板之前大量的相同地方，通过将需要的结构代码放在 base 之中，利用模板语法继承这个 base 就能实现一样的内容（包括 html 结构 或 css 的样式 或是 js 的代码）</p><p>​    <strong>创建继承：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）可以选择创建一个 base.html，将可能多个模板都会用到的代码放在该文件中</span><br><span class="line"></span><br><span class="line">2）在需要使用到相同部分的 html 模板文件中，直接利用  &#123;% extends &#x27;base.html&#x27; %&#125;，就可以实现继承</span><br><span class="line"></span><br><span class="line">3) 这时，再去访问 index，会将 base 中的部分原封不动的搬过来，简单高效；但是，只有继承的话对于那些可能有用相同的部分，但是内容上却不同的不就又无法使用 extends 去继承了，例如相同样式的导航栏，会员与普通用户所看到的导航菜单是不一样的，这就需要使用 钩子 去实现一个可自定制的继承</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​     <strong>钩子</strong> 的创建也很简单：</p><p>​    在 base 的模板文件中，使用 block 标签留出其他模板会添加的部分，或是将一块部分用 block 标签框起来，这样继承 base 的模板就可以实现在这一块的自定制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># base.html</span><br><span class="line">&#123;% block 钩子名 %&#125;</span><br><span class="line">....</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wei-foun.github.io/img/%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF.jpg" alt="img/md5.jpg"></p><p>​    上图中就是直接在 index 的 html 文件中继承使用 base 的 html 文档，当访问上 index 后就会看到 base 页面上原本就存在 dom</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>​    前端向后端上传文件，有两种方式：form 表单，或是 ajax 的 post 封装好文件数据上传</p><p>​    1）form 表单上传</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-md-12&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  前端使用 form 表单去上传文件，需要使用 enctype 属性，值为 multipart/form-data --&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lable</span>&gt;</span>请输入姓名<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lable</span>&gt;</span>请选择上传文件<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;upload_file.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        file_obj = request.FILES.get(<span class="string">&quot;files&quot;</span>)      <span class="comment"># 上传的文件对象 request.FILES</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> file_obj:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&quot;no files for upload&quot;</span>)</span><br><span class="line">        file_dir = os.path.join(settings.BASE_DIR, <span class="string">f&#x27;static/uploads/<span class="subst">&#123;file_obj.name&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_dir, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> chunk <span class="keyword">in</span> file_obj.chunks():</span><br><span class="line">                f.write(chunk)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    2）ajax 上传，<strong>注意！！使用 ajax 的方式，必须要自己建立一个 formData 的对象，用来存储提交的数据键值，同时还需要将 contentType 和 processData 都设为 false</strong>，完成后在使用 ajax 上传时，在请求头中会自动将 Content-Type 设置为 multipart/form-data</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lable</span>&gt;</span>请输入姓名<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lable</span>&gt;</span>请选择上传文件<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         $(<span class="string">&quot;#button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">             formData.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, $(<span class="string">&quot;#name&quot;</span>).<span class="title function_">val</span>());</span></span><br><span class="line"><span class="language-javascript">             formData.<span class="title function_">append</span>(<span class="string">&quot;files&quot;</span>, $(<span class="string">&quot;#files&quot;</span>)[<span class="number">0</span>].<span class="property">files</span>[<span class="number">0</span>]);   </span></span><br><span class="line"><span class="language-javascript">             <span class="comment">// $(&quot;#files&quot;)[0].files[0] 获取文件对象</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">             $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">url</span>:<span class="string">&quot;/upload/&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">type</span>:<span class="string">&#x27;post&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">headers</span>: &#123;<span class="string">&quot;X-CSRFToken&quot;</span>: $.<span class="title function_">cookie</span>(<span class="string">&#x27;csrftoken&#x27;</span>)&#125;,  <span class="comment">// 从 cookie 中拿取 csrftoken</span></span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">data</span>: formData,        </span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">contentType</span>: <span class="literal">false</span>,    <span class="comment">// contentType 要设为 false</span></span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">processData</span>: <span class="literal">false</span>,    <span class="comment">// processDate 要是 false，不对数据做预处理</span></span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;上传成功&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">                 &#125;</span></span><br><span class="line"><span class="language-javascript">             &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    上面在 ajax 的请求中，是将 csrftoken 直接放在请求头中，使用到了 jquery-cookie，所以需要先引入 jquery 和 jquery-cookie</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery/3.4.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/jquery-cookie/1.4.1/jquery.cookie.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    除了使用 <code>$.cookie</code>，也可以将 csrftoken 放在提交给后端的数据中，通过获取到 csrftoken 的 input 标签，从而得到 token 的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">csrfmiddlewaretoken</span>:$(<span class="string">&#x27;[name=&quot;csrfmiddlewaretoken&quot;]&#x27;</span>).<span class="title function_">val</span>()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python web框架 </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 逆向爬取实例(下)</title>
      <link href="/3660878595/"/>
      <url>/3660878595/</url>
      
        <content type="html"><![CDATA[<p>###详情页 id 入口寻找</p><p>​    上一篇中，已经完成了对列表页的接口的分析，知道了列表页请求接口的逻辑，但列表页的数据毕竟只是一部分，更多的详细数据是需要进入每一个详情页中去抓取的，所以列表页的接口数据是一个进入详情页的入口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;count&#x27;: 100, &#x27;results&#x27;: [&#123;&#x27;id&#x27;: 1, &#x27;name&#x27;: &#x27;霸王别姬&#x27;, &#x27;alias&#x27;: &#x27;Farewell My Concubine&#x27;, &#x27;cover&#x27;: &#x27;https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c&#x27;, &#x27;categories&#x27;: [&#x27;剧情&#x27;, &#x27;爱情&#x27;], &#x27;published_at&#x27;: &#x27;1993-07-26&#x27;, &#x27;minute&#x27;: 171, &#x27;score&#x27;: 9.5, &#x27;regions&#x27;: [&#x27;中国大陆&#x27;, &#x27;中国香港&#x27;]&#125;, ....]&#125;</span><br></pre></td></tr></table></figure><p>​    从列表页的接口返回的数据中，可以看到 id 这个字段，第一个电影的 id 是 1，但是当点击第一个电影进入详情页后，在 url 上是经过加密的 <a href="https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx，从中可知">https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx，从中可知</a> url 中的 id 字段的值是 ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx，因此需要对这个 id 字段的加密去进行分析</p><p>​    <img src="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlJCAdQd6AAk_ZX1vrAI092.png" alt="image (25).png"> </p><p>​    回到一开始，从图中可知，当列表页的 ajax 请求后，每一个电影的详情 url 后的 id 字段就已经是加密过了，且每一个电影页详情 url 后的加密 id 都是不同的，也就说明这个加密 id 的构造需要依赖列表页的 ajax 请求返回的结果，就可以确定 id 的加密是发生在 ajax 请求后完成的</p><h4 id="请求监听"><a href="#请求监听" class="headerlink" title="请求监听"></a>请求监听</h4><p>​    在 Sources 面板的右侧，有一个 Event Listener Breakpoints，这里有一个 XHR 的监听，包括发起时、成功后、发生错误时的一些监听，勾选上 readystatechange 事件，代表 Ajax 得到响应时的事件，其他的断点可以都删除了，然后刷新页面</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlKSAQ_UFAAh49gbNW9s441.png" alt="image (26).png"> </p><p>​    之后 JavaScript 的代码会在执行到 ajax 得到响应后的位置停住，进入调试模式；至此，只是得到了响应后的入口，如果要去查找 id 的构造逻辑，只能一步步往下调试，但是可能会在断点调试过程中出现崩溃，因为可能会逐渐调用到页面的 UI 渲染的一些底层实现，甚至可能即使找到了也不知道最后具体找到哪里去了，因此这样的方式显得比较繁琐</p><h4 id="Hook-钩子"><a href="#Hook-钩子" class="headerlink" title="Hook 钩子"></a>Hook 钩子</h4><p>​    钩子指的是在程序执行过程中，对其中某个方法进行重写，在原来的方法前后加入自定义的代码，也就是说程序执行到真正的处理逻辑的函数之前，会先被钩子程序捕获到，这样就可以获取到程序控制权，这样钩子函数就可以加工处理或是改变函数的一个执行行为（钩子和装饰器的概念很像，但个人感觉钩子最主要的目的还是为了去捕获程序执行前的一个位置）</p><p>​    通俗来说，比如要 Hook 一个方法 a，可以先临时用一个变量存一下，把它存成 _a，然后呢，我再重新声明一个方法 a，里面添加自己的逻辑，比如加点调试语句、输出语句等等，然后再调用 _a，这里调用的 _a 就是之前的 a</p><p>​    这样就相当于新的方法 a 里面混入了我们自己定义的逻辑，同时又把原来的方法 a 也执行了一遍。所以这不会影响原有的执行逻辑和运行效果，但是通过这种改写便可以顺利在原来的 a 方法前后加上了我们自己的逻辑，这就是 Hook</p><p>​    知道 hook 的概念，就是去分析如何来利用 hook 去得到 id 加密得到入口点，从 url 上可以看到这基本是一个 base64 的编码字符串，而在 <strong>JavaScript 中使用 base64 编码的方法叫 btoa</strong>；当然除了这个方法外，也有其他的方法比如 crypto-js 库去实现，这个库的底层可以调用的就不会是 btoa 了</p><p>​    因为无法确定使用的编码方法，就只能去尝试看结果，那么对于 hook 的实现，关键就是要对原方法去重写，以 btoa 为例，这个编码方法是属于 window 对象的，所以需要去重写 window 对象的 btoa 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="string">&#x27;use strict&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params">object, attr</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> func = object[attr]</span><br><span class="line">        object[attr] = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hook&#x27;</span>, object, attr, <span class="variable language_">arguments</span>)</span><br><span class="line">            <span class="keyword">var</span> ret = func.<span class="title function_">apply</span>(object, <span class="variable language_">arguments</span>)</span><br><span class="line">            <span class="keyword">debugger</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result&#x27;</span>, ret)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hook</span>(<span class="variable language_">window</span>, <span class="string">&#x27;btoa&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>​    这里定义的 hook 方法中，需要两个参数 object 和 attr，比如要 hook 一个 alter 弹框，那么 object 就是 window 对象，而 attr 就是方法 alter 的字符串（很像是 Python 对象的映射方法），所以可以看到最后调用时是 hook(window, ‘btoa’)</p><p>​    在 hook 函数中，定义了变量 func 赋值为函数的调用，即表示用 func 最为方法去实现原函数的功能，之后就是对 object[attr] 方法调用进行定义，来加上自己的处理逻辑，在这个函数中，最重要的就是通过定义的 func 去调用 apply 方法来调用程序原来函数的方法，通过变量 ret 接收后，就会执行定义的 debugger ，即在位置加上断点让执行停住</p><p>​    简单来说，这个 hook 函数就是：</p><p>​    1）func = object[attr] 这个变量作为了程序原函数的一个别名的存在，将通过它来实现对原函数的调用</p><p>​    2）object[attr] 通过接受的参数表示要加入钩子的函数，并且定义了一个函数去触发它的执行，当 func = object[attr] 进行调用时，就会触发定义的函数</p><p>​    3）在定义得到函数内部，通过 apply 来实现 func 的重新调用，即让程序正常去执行原本的逻辑，两个 console.log 分别输入原函数处理前的一些状态信息和完成后的结果，同时利用 debugger 关键字去让程序停住</p><p>​    4）最后，通过钩子调用 window 的 btoa 方法就会触发到内部的原函数的调用</p><h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p>​    知道了逻辑后，就是将代码进行注入了，可以使用：</p><p>​    1）直接控制台注入</p><p>​    2）复写 JavaScript 的代码</p><p>​    3）利用插件 Tampermonkey 去注入</p><p>​    <strong>控制台注入</strong></p><p>​    控制台注入是一种非常简便的方式，即直接在浏览器的控制台中，将刚才的代码复制进入即可。但是这种方式是有局限性的，因为一旦对网页进行刷新，注入的代码就会被删除，自然也就不会生效了，不过在对于像这个案例，是一个 SPA 的单页面应用，它在点击后从列表页进入详情页是不会发生整体刷新的，所以利用控制台去注入代码是一个方便的方案</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlPqALm_6AAY-ro6hjwQ572.png" alt="image (27).png"> </p><p>​    完成后，只需要在控制台调用 btoa 这个方法即可，控制台会将 hook 函数中两个 console 的语句进行输出，从这里面可以看到一些属性，参数和返回的结果信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;123123&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlRSAdfGaAAacrG5N8q4214.png" alt="image (29).png"> </p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlQiALo85AAgcGmKilPk416.png" alt="image (28).png"> </p><p>​    通过点击旁边的如 VM71870:6 会进入到我们定义的函数的断点位置，通过把断点向下执行，点击 Resume 按钮，然后看看控制台的输出，可以看到也输出了一些对应的结果</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlTOAXTlNAAbm2aEXYuA791.png" alt="image (30).png"> </p><p>​    从调试中，可以看到 id 在编码前的样子，以及编码后的样子，即 id 编码前的结果 ef34#teuq0btua#(-57w1q5o5–j@98xygimlyfxs*-!i-0-mb1，接下来就是去分析编码前的逻辑是怎么样的</p><p>​    这里只需要和列表页一样通过栈的调用信息一层层往上去看即可，在第 5 层中可以很明显看到一个拼接，_0x135c4d 是一个写死的字符串 ef34#teuq0btua#(-57w1q5o5–j@98xygimlyfxs*-!i-0-mb，然后和传入的这个 _0x565f18 拼接起来就形成了最后的字符串，而后面的  _0x565f18 就是电影的 id</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlVGAO62xAAmWfTuXTnI776.png" alt="image (31).png"> </p><p>​    所以，整个详情页 url 的 id 构造是：</p><p>​    1）通过列表页的 ajax 获得每一个电影的 id 字段的值</p><p>​    2）通过拼接，将一个写死的字符串变量和 id 的值进行拼接得到一个编码前的字符串</p><p>​    3）通过 base64 对包含 id 的字符串进行编码</p><p>​    至此，详情页的 id 的构造逻辑就很清楚了；但是，对于注入的方式来说， hook 的钩子函数是在浏览器的控制台进行输入的，如果页面出现整体的刷新就会失效，某种程度上来说，这样的方式可用性不太高，有局限性</p><p>​    <strong>重写 JavaScript 注入</strong></p><p>​    借助于 Chrome 浏览器的 Overrides 功能实现某些 JavaScript 文件的重写和保存，它会在本地生成一个 JavaScript 文件副本，以后每次刷新的时候会使用副本的内容，需要切换到 Sources 选项卡的 Overrides 选项卡，然后选择一个文件夹，比如自定一个文件夹名字叫作 modify</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlX6ADDfeAAZ2FWeRVsQ406.png" alt="image (32).png"> </p><p>​    然后我们随便选一个 JavaScript 脚本，后面贴上这段注入脚本</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlYmAK5yrAAh8B0rKWe4441.png" alt="image (33).png"> </p><p>​    创建文件后，会自动下载这个文件，此时可能提示页面崩溃，但是不用担心，重新刷新页面就好了，这时候我们就发现现在浏览器加载的 JavaScript 文件就是我们修改过后的了，文件的下方会有一个标识符，刷新后同时会直接进入到 hook 的断点位置，也就成功了</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlZSADgU4AAZ9p5grU3A458.png" alt="image (34).png"> </p><p>​    Overrides 的这个功能非常有用，有了它可以持久化保存任意修改的 JavaScript 代码，所以想在哪里改都可以了，甚至可以直接修改 JavaScript 的原始执行逻辑也都是可以的</p><p>​    <strong>Tampermonkey 注入</strong></p><p>​    这个浏览器插件叫作 Tampermonkey，中文叫作 ‘’油猴’’，支持 Chrome。利用它可以在浏览器加载页面时自动执行某些 JavaScript 脚本。由于执行的是 JavaScript，所以可以在网页中完成任何想实现的效果，如自动爬虫、自动修改页面、自动响应事件等等</p><h4 id="详情页的-token"><a href="#详情页的-token" class="headerlink" title="详情页的 token"></a>详情页的 token</h4><p>​    这个 token 的逻辑是和列表页中的 token 一样的，详情页中的 token 没有在列表页中的 href 中存在，所以这个 token 是在点击了详情页的 url 的时候触发的，并作为参数附带在后面，不过跳转之后详情页的网址上并不存在这个 token，只能是在 Network 的面板中看到发送的请求携带了这个 token，而且这个 token 会随着刷新产生变化，所以个人猜测应该是用作失效的判断</p><p>​    依旧可以在 XHR/fetch Breakpoints 中添加 /api/movie 的断点，然后刷新页面就会在请求发送前停住，然后和之前一样可以在栈的调用顺序中一层层去寻找，和列表页一样都是在 onFetchData 这个方法里面实现了这个 token 的构造逻辑，在构造的入口上一行打上断点，并除去之前的 /api/movie，然后在方法的内部会有一个 a 属性，点击进入就看到 token 的构造，可见与列表页的是一样的逻辑</p><p>​    <img src="https://wei-foun.github.io/img/token%E5%88%86%E6%9E%90.jpg" alt="img/md5.jpg"> </p><h3 id="Python-实现详情页的数据爬取"><a href="#Python-实现详情页的数据爬取" class="headerlink" title="Python 实现详情页的数据爬取"></a>Python 实现详情页的数据爬取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://dynamic6.scrape.cuiqingcai.com/api/movie?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&amp;token=&#123;token&#125;&#x27;</span></span><br><span class="line">DETAIL_URL = <span class="string">&#x27;https://dynamic6.scrape.cuiqingcai.com/api/movie/&#123;id&#125;?token=&#123;token&#125;&#x27;</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">OFFSET = <span class="number">0</span></span><br><span class="line">SECRET = <span class="string">&#x27;ef34#teuq0btua#(-57w1q5o5--j@98xygimlyfxs*-!i-0-mb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">args: <span class="type">List</span>[<span class="built_in">any</span>]</span>):</span><br><span class="line">    timestamp = <span class="built_in">str</span>(<span class="built_in">int</span>(time.time()))</span><br><span class="line">    args.append(timestamp)</span><br><span class="line">    sign = hashlib.sha1(<span class="string">&#x27;,&#x27;</span>.join(args).encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="string">&#x27;,&#x27;</span>.join([sign, timestamp]).encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = [<span class="string">&#x27;/api/movie&#x27;</span>]</span><br><span class="line">token = get_token(args=args)</span><br><span class="line">index_url = INDEX_URL.<span class="built_in">format</span>(limit=LIMIT, offset=OFFSET, token=token)</span><br><span class="line"></span><br><span class="line">response = requests.get(url=index_url)</span><br><span class="line"><span class="comment"># print(response.json())</span></span><br><span class="line">result = response.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result[<span class="string">&#x27;results&#x27;</span>]:</span><br><span class="line">    ID = item[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    encrypt_id = base64.b16encode((SECRET + <span class="built_in">str</span>(ID)).encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    args = [<span class="string">f&#x27;/api/movie/<span class="subst">&#123;encrypt_id&#125;</span>&#x27;</span>]</span><br><span class="line">    token = get_token(args=args)</span><br><span class="line">    detail_url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=encrypt_id, token=token)</span><br><span class="line">    response = requests.get(url=index_url)</span><br><span class="line">    <span class="built_in">print</span>(response.json())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> js 逆向爬取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 逆向爬取实例(上)</title>
      <link href="/3274678850/"/>
      <url>/3274678850/</url>
      
        <content type="html"><![CDATA[<p>案例源自崔庆才的《52讲轻松搞定网络爬虫》</p><h3 id="JavaScript-逆向分析"><a href="#JavaScript-逆向分析" class="headerlink" title="JavaScript 逆向分析"></a>JavaScript 逆向分析</h3><p>​    由于，现在的网站几乎都是动态数据传输，为了对应爬虫和自身的数据保护，深度的措施就是直接对 JavaScript 的代码进行混淆，所以在利用像 selenium 的自动工具去进行爬取操作，要从接口层面上获取数据，就需要一点点调试分析 JavaScript 的调用逻辑，堆栈调用关系来弄清楚网站的加密实现方法，这个过程就称为 <strong>JavaScript 逆向</strong>；通常，对于接口的加密参数往往都是一些加密算法和编码的组合</p><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>​    案例的地址为：<a href="https://dynamic6.scrape.cuiqingcai.com/">https://dynamic6.scrape.cuiqingcai.com/</a></p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DC/CgqCHl6qkaOAH4oXABChHxWKtLo031.png" alt="image (1).png"> </p><p>​    可以从这个网站的任何一个详情的电影页上，看到这个 url 的最后会有一段非常长的字符串，着很明显使用了编码之后的结构</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkbiASEZbAAoPAmLuiLs518.png" alt="image (2).png"> </p><p>​    通过首页的 ajax 请求中，可以看到这个数据请求的接口里，包含了一个 token，而且不同的页码请求中里这个 token 的值还不一样，从长度上可以看出这个 token 也可能是一个编码后的结果</p><p>​    另外，这个网站的数据请求的接口是有时效性的，也就是说即使通过复制请求接口的 url，短时间是可以访问的，但是一段时间过后就会无法访问，而直接返回 401 的状态码</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkcOAQupqAAMYHAP-Uvk656.png" alt="image (3).png"> </p><p>​    从首页的 ajax 的接口数据，以第一个电影数据为例，其中没有包含什么可能的参数信息，所以直接从这个 url 上看，’<a href="https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx&#39;，看起来像是使用">https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx&#39;，看起来像是使用</a> base64 进行编码的，但是直接对这个长字符使用 base64 去解码得到的却是 ‘ef34#teuq0btua#(-57w1q5o5–j@98xygimlyfxs*-!i-0-mb1’，这说明最终首页的数据请求的接口里，肯定是包含了其他的参数的</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkeKAfDyaAAk629L2zsE019.png" alt="image (4).png"> </p><p>​    回到第一个电影的详情页上，在这个电影的数据请求的接口中，可以看到 url 最后拼上了一个 token，而且也类似是一个 base64 编码后的样子</p><p>​    所以，对于这个网站来说，请求接口的特点有：</p><p>​    1）列表页的 ajax 接口参数带有加密的 token</p><p>​    2）详情页的 url 带有加密后的 id</p><p>​    3）详情页的 ajax 接口的参数带有加密的 id 与 加密的 token</p><p>​    因此，要去爬取网站的接口数据，就需要想法把 id 和 token 构造出来，所以需要先获取首页列表页中的 ajax 的 token，然后才能获取每一部电影的数据信息，再去根据 id 和 token 去构造加密后的 url</p><h4 id="JavaScript-分析"><a href="#JavaScript-分析" class="headerlink" title="JavaScript 分析"></a>JavaScript 分析</h4><p>​    对于具体的加密步骤来说，这个逻辑一定是藏在了 js 的代码里的，但是网站对接口进行了加密操作，就会采取压缩，混淆的方式来增大分析难度</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkgGANjrqAASTjV0jn7Q608.png" alt="image (5).png"> </p><p>​    通过直接查看网站的源代码，可以发现这是一个典型的 SPA（单页面的 web 应用）的页面，因为其 JavaScript 的代码中有明显的编码字符、chunk、vendors 等关键字，整体就是经过 Webpack 打包压缩后的源代码，目前主流的前端开发，如 Vue.js、React.js 的输出结果都是类似这样的结果</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkjGAGyKRAAYIIGMFEZw194.png" alt="image (6).png"> </p><p>​    切到 sources 的选项卡去看文件，打开 js 的文件夹下的代码，可以看到是被压缩为一行的，并且稍微看一下，变量基本都是一些十六进制的字符串</p><p>​    接下来要做的，就是在这些 js 代码中去找到 id 和 token 的构造逻辑，这个例子没有使用特别高难度的，例如：字符串编码、控制流扁平化等方式，所以最后可以从分析接口中去大致判断逻辑</p><h4 id="列表页-Ajax-的入口寻找"><a href="#列表页-Ajax-的入口寻找" class="headerlink" title="列表页 Ajax 的入口寻找"></a>列表页 Ajax 的入口寻找</h4><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qknSAaJi9AAZGLdfg3f4342.png" alt="image (7).png"> </p><p>​    就以第一页的列表页为例，从 ajax 的接口中可以看到有三个参数：limit，offset，token；那么对于构造的入口来说，可以利用搜索 token 去寻找</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkoqANZ5EAAXALwrapv4539.png" alt="image (8).png"> </p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkpWAbJRjAAdFuzcwiio327.png" alt="image (9).png">     </p><p>​    从全局搜索的返回中，可以看到有两个可能的结果，点击第一个 chunk 的 js 文件进入查看，会看到压缩后的代码，可以通过左下角的 {} 的按钮进行格式化（美化）</p><p>!image (10).png](<a href="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkpyAJI-uAAWL2y8otZc090.png">https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkpyAJI-uAAWL2y8otZc090.png</a>) </p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkqSAUtJ4AAWPHUlveFY575.png" alt="image (11).png"> </p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkq2AEhDXAAgZeF5_6Xk163.png" alt="image (12).png"> </p><p>​    格式化，会弹出一个新的选项卡，并且名称是 文件名:formatted，表示格式化后的代码结果，通过搜索 token，可以快速找到匹配的行；从图中，可以看到所需的三个参数都在高亮的行之上，在观察一下其他的逻辑，基本就可以确定这就是 ajax 请求的地方，那么混淆的入口就被找到了，但是如果不是的话可以继续搜索其他匹配的行</p><p>​    通常来说，通过全局的搜索是最简单直接的方式，但是这针对于 JavaScript 没有做字符串或变量混淆的情况下，如果字符串被混淆，那么这样就无法轻松去进行全局搜索了，通常字符串会以 unicode，base64，rc4 进行编码，一旦字符串被混淆，也就需要再去对编码后的内容进行判断测试，得到编码的方式后再去进行后续的操作</p><h4 id="XHR-断点"><a href="#XHR-断点" class="headerlink" title="XHR 断点"></a>XHR 断点</h4><p>​    使用断点来调试，目的就是对于刚才提到的，如果字符串被编码无法全局搜索的情况，XHR 断点就是指当发起 XHR 的时候进入断点调试模式，即当 JavaScript 要发起 ajax 请求的时候会停住，阻塞住请求发送，进入调试模式下，就可以通过当前栈的逻辑一步步去找到构造的入口</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qkxqAK4pMAAhc_XTSt_Y367.png" alt="image (13).png"> </p><p>​    浏览器的 XHR 调试在 Sources 选项卡的右侧，XHR/fetch Breakpoints 处添加一个断点选项， 点击 + 号，然后输入匹配的 URL 内容，由于 Ajax 接口的形式是 /api/movie/?limit=10… 这样的格式，所这里我们就截取一段填进去就好了，这里填的就是 /api/movie</p><p>​    加入请求断点后，重新刷新页面，会在发送请求时，会自动进入到断点模式中，之后只需要将代码格式化一下，就可以方便进行查看和调试了</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qkyKAVRkUAAUv1oHhpbk473.png" alt="image (14).png"> </p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qkzyAQZcQAAguLqHyraA259.png" alt="image (15).png"> </p><p>​    格式化代码后，可以看到指定的请求的断点在 send 关键字这停住了，也就是说到这里的代码都是数据已经处理好后的，等待着向服务端发送的最后一步。所以，在 send 的地方停住，依然不能找到构造的过程，因此可以通过点击右侧的 Call Stack，这个区域会记录 JavaScript 的方法逐层调用的过程</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qk0qAJ04jAAiOvyuo0wU233.png" alt="image (16).png"> </p><p>​    通过一层层往下查找，观察是否有 token 的信息，最后就可以确定构造的入口。最后在onFetchData 这个方法里面实现了这个 token 的构造逻辑，这样我们也成功找到 token 的参数构造的位置了</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk1qASl3iAAfB8DQP-C0830.png" alt="image (17).png"> </p><p>​    注意：这里的请求调试是在第一页的主页下的，如果你在详情页中去调试，也能找到 token，但是不会有其他的信息，毕竟一个电影的详情页根本用不到 limit 和 offset 这两个分页的参数，我之前就很迷糊，后来才发现自己调试错了页面</p><h4 id="加密逻辑寻找"><a href="#加密逻辑寻找" class="headerlink" title="加密逻辑寻找"></a>加密逻辑寻找</h4><p>​    找到了构造的入口，只是完成了一半的任务，因为还不知道背后对参数具体是如何操作的，因此就需要手动加上一个断点，去调试请求中参数具体的加密混淆的逻辑；也就是对应在找到的入口的上一行代码加上断点，同时可以将原来添加的 XHR 请求断点去除</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk2iAXuw4AAfT4EPsbZI161.png" alt="image (18).png"> </p><p>​    重新刷新页面后，执行到断点就会停住，这里鼠标移动到变量上，会有弹框显示一些值和类型</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qk5-AfIb1AAdTDoapgWc715.png" alt="image (20).png"> </p><p>​    除此之外，右侧的 Watch 面板中可以去添加需要查看的变量值，比如图中的代码 _0x18b11a 的变量中 this 这个属性的值是需要关注的，在右侧 Watch 中的右边会有一个 + 号按钮，点击后输入这个 this 即可</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk9eAGFwlAAedDDa3zXI764.png" alt="image (21).png"> </p><p>​    观察下可以发现 _0x18b11a 是一个 Object，它有个 a 属性，其值是一个 function，然后 this[‘$store’][‘state’][‘url’][‘index’] 的值其实就是 /api/movie，就是 Ajax 请求 URL 的 Path，_0xa70fc9 就是调用了前者这个 function 然后传入了 /api/movie 得到的</p><p>​    下一步就是去寻找这个 function，将  _0x18b11a 的属性 a 展开，会显示一个 FunctionLocation，就是这个 function 的代码位置</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk-eAetpKAAfZ8WF5vF8742.png" alt="image (22).png"> </p><p>​    同样，点击后就进入了一个新的名字为 _0xc9e475 的方法里面，所看到是压缩后的，通过将其格式化可以方便查看，这个方法里面应该就是 token 的生成逻辑了，我们再打上断点，然后执行面板右上角蓝色箭头状的 Resume 按钮</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk_KAUBCyAAhWMyGe2CQ797.png" alt="image (23).png"> </p><p>​    之后就会单步执行到指定的位置，接下来就需要不断去记性单步测试，观察这里面执行逻辑和每一步调试过程中结果都有什么变化</p><p><img src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk_2AIAG8AActuiud1jI582.png" alt="image (24).png"> </p><p>​    在每步的执行过程中，可以发现一些运行值会被打到代码的右侧并带有高亮表示，同时在 Watch 面板还能看到每步的变量的具体结果</p><p>​    最后总结出这个 token 的构造逻辑如下：</p><p>​    1）传入的 /api/movie 会构造一个初始化列表，变量命名为 _0x3dde76<br>    2）获取当前的时间戳，命名为 _0x4c50b4，push 到 _0x3dde76 这个变量里面<br>    3）将 _0x3dde76 变量用“,”拼接，然后进行 SHA1 编码，命名为 _0x46ba68<br>    4）将 _0x46ba68 （SHA1 编码的结果）和 _0x4c50b4 （时间戳）用逗号拼接，命名为 _0x495a44<br>    5）将 _0x495a44 进行 Base64 编码，命名为 _0x2a93f2，得到最后的 token</p><p>​    所以，根据推断出来的构造逻辑，就可以知道分析出加密的逻辑：</p><p>​    1）先将 /api/movie 放到一个列表里面<br>    2）列表中加入当前时间戳<br>    3）将列表内容用逗号拼接<br>    4）将拼接的结果进行 SHA1 编码<br>    5）将编码的结果和时间戳再次拼接<br>    6）将拼接后的结果进行 Base64 编码</p><h4 id="Python-实现列表页的爬取"><a href="#Python-实现列表页的爬取" class="headerlink" title="Python 实现列表页的爬取"></a>Python 实现列表页的爬取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://dynamic6.scrape.cuiqingcai.com/api/movie?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&amp;token=&#123;token&#125;&#x27;</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">OFFSET = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">args: <span class="type">List</span>[<span class="built_in">any</span>]</span>):</span><br><span class="line">    timestamp = <span class="built_in">str</span>(<span class="built_in">int</span>(time.time()))</span><br><span class="line">    args.append(timestamp)</span><br><span class="line">    sign = hashlib.sha1(<span class="string">&#x27;,&#x27;</span>.join(args).encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="string">&#x27;,&#x27;</span>.join([sign, timestamp]).encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = [<span class="string">&#x27;/api/movie&#x27;</span>]</span><br><span class="line">token = get_token(args=args)</span><br><span class="line">index_url = INDEX_URL.<span class="built_in">format</span>(limit=LIMIT, offset=OFFSET, token=token)</span><br><span class="line"></span><br><span class="line">response = requests.get(url=index_url)</span><br><span class="line"><span class="built_in">print</span>(response.json())</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;count&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;results&#x27;</span>: [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;霸王别姬&#x27;</span>, <span class="string">&#x27;alias&#x27;</span>: <span class="string">&#x27;Farewell My Concubine&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>: <span class="string">&#x27;https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>], <span class="string">&#x27;published_at&#x27;</span>: <span class="string">&#x27;1993-07-26&#x27;</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">171</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.5</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;中国大陆&#x27;</span>, <span class="string">&#x27;中国香港&#x27;</span>]&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;这个杀手不太冷&#x27;</span>, <span class="string">&#x27;alias&#x27;</span>: <span class="string">&#x27;Léon&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>: <span class="string">&#x27;https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;动作&#x27;</span>, <span class="string">&#x27;犯罪&#x27;</span>], <span class="string">&#x27;published_at&#x27;</span>: <span class="string">&#x27;1994-09-14&#x27;</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">110</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.5</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;法国&#x27;</span>]&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;肖申克的救赎&#x27;</span>, <span class="string">&#x27;alias&#x27;</span>: <span class="string">&#x27;The Shawshank Redemption&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>: <span class="string">&#x27;https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@464w_644h_1e_1c&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;犯罪&#x27;</span>], <span class="string">&#x27;published_at&#x27;</span>: <span class="string">&#x27;1994-09-10&#x27;</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">142</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.5</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;美国&#x27;</span>]&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;泰坦尼克号&#x27;</span>, <span class="string">&#x27;alias&#x27;</span>: <span class="string">&#x27;Titanic&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>: <span class="string">&#x27;https://p1.meituan.net/movie/b607fba7513e7f15eab170aac1e1400d878112.jpg@464w_644h_1e_1c&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;灾难&#x27;</span>], <span class="string">&#x27;published_at&#x27;</span>: <span class="string">&#x27;1998-04-03&#x27;</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">194</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.5</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;美国&#x27;</span>]&#125;, ..........]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> js 逆向爬取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 混淆技术</title>
      <link href="/2586209473/"/>
      <url>/2586209473/</url>
      
        <content type="html"><![CDATA[<p>内容源自崔庆才的《52讲轻松搞定网络爬虫》的个人整理</p><h3 id="什么是-JavaScript-的混淆技术？"><a href="#什么是-JavaScript-的混淆技术？" class="headerlink" title="什么是 JavaScript 的混淆技术？"></a>什么是 JavaScript 的混淆技术？</h3><p>​    简单来说，在去爬取网站时，人家对内容做的一些保护措施，毕竟如果只是利用检测设备等或是 ip 去拦截，某种程度上可能会有误伤的操作，而且对于这些反爬手段，通常爬虫都以可以使用代理来绕开或避免被拦截。所以，就会有更深层的技术来保护一些重要的数据和参数可以不被显式的给抓取，理解和使用，对于现在几乎都是动态数据的网站来说，最重要的就是其中 js 的代码了</p><p>​    因此，就会见到，例如：js 对请求的 URL 进行了加密，包含一些看不懂的长字符加密参数；或是在利用 Ajax 请求的时候，在 request headers 中加入加密参数；更直接点就是把 js 的代码记性压缩，或是将文件名编码，或是把变量修改为为单字符以及十六进制的字符等等</p><p>​    对于上诉的情况，都是网站常用的一些对内容和数据进行保护的手段措施，大体上可以分为两类：<strong>1）接口加密技术    2）JavaScript 压缩、混淆、加密技术</strong></p><h3 id="接口加密技术"><a href="#接口加密技术" class="headerlink" title="接口加密技术"></a>接口加密技术</h3><p>​    举一个很形象的例子，以前的情报员们交流的时候的都是知道有对方这个人的，提供东西的人就是服务端的一个接口，他给你需要从服务端获取的数据，要找指定的情报人才能获得需要的内容，但是这就完了？当然不！你知道对方是谁后，其他人也会到他那获取东西，那这就不是情报交流了，这就是一个送快递的了，所以接口是最容易最容易想到的保护对象；既然是情报交流，那就需要弄一些只能是双发知道的东西做一个中间验证才行，只有你的谜语被服务端所知道，才能将东西交给你</p><p>​    通常来说对于接口加密，会对 URL 的一些参数加上校验码或是把指定的参数（比如 ID 等）进行一个编码；或者是在请求的接口上添加一些 token，sign 签名等等</p><p>​    比如说客户端和服务端约定一种接口校验逻辑，客户端在每次请求服务端接口的时候都会附带一个 sign 参数，这个 sign 参数可能是由当前时间信息、请求的 URL、请求的数据、设备的 ID、双方约定好的秘钥经过一些加密算法构造而成的，客户端会实现这个加密算法构造 sign，然后每次请求服务器的时候附带上这个参数。服务端会根据约定好的算法和请求的数据对 sign 进行校验，如果校验通过，才返回对应的数据，否则拒绝响应</p><p>​    通过使用接口加密技术的确是一个保护措施，但是客户端可服务端需要约定好的逻辑在 JavaScript 中确实不安全的，因为：    </p><p>​    1）JavaScript 的代码是在客户端运行的，用户的浏览器就是服务端 js 文件运行的载体</p><p>​    2）JavaScript 的代码在浏览器中是公开透明的，也就是说用户可以在浏览器中获取到正在运行的 js 的源码</p><p>​    基于这两点，利用接口加密也就不是所谓的绝对安全的了，当然这世界上没有什么是绝对安全的。就相当于你要去情报交流，结果被人恶意获取你的暗号等，这样你的东西就会被坏人给获取了</p><h3 id="JavaScript-压缩、混淆、加密技术"><a href="#JavaScript-压缩、混淆、加密技术" class="headerlink" title="JavaScript 压缩、混淆、加密技术"></a>JavaScript 压缩、混淆、加密技术</h3><p>​    既然在接口加密方法中，JavaScript 的代码会被获取，分析，复制，盗用和篡改，那就直接对 js 代码进行保护，相比之下会更安全</p><p>​    <strong>压缩：</strong>指的是将 JavaScript 代码中的换行和空格等内容删除，会将原本很长的代码压缩成只有几行的内容，这样的代码降低了可读性，并且压缩后的 js 在网站加载的速度上也更好</p><p>​    但是仅仅使用压缩，其实并没有多大的保护效果，因为压缩后的内容只是降低了直接的可读性，而这样的代码通过编辑器或浏览器的插件等，在格式化后会重新转换为原来的状态</p><p>​    <strong>混淆：</strong>采用变量替换，字符串阵列化，控制流平坦化，多态变异，僵尸函数，调试保护等手段，提高代码的阅读成本和分析，混淆后的代码不会影响原来的功能，因此是一种理想且实用的 js 代码保护的方案</p><p>​    变量替换：将有字面含义的变量名，函数名或是常量名随机变为没有意义的乱码字符串，比如单个或十六进制的字符串</p><p>​    字符串阵列化：将字符串阵列化集中放置、并可进行 MD5 或 Base64 加密存储，使代码中不出现明文字符串，这样可以避免使用全局搜索字符串的方式定位到入口点</p><p>​    属性加密：针对对象的属性加密化，隐藏代码之间的调用关系</p><p>​    控制流平坦化：<strong>打乱</strong> 函数原本的 <strong>执行流程和调用关系</strong>，会使代码逻辑变得混乱无序</p><p>​    僵尸代码：随机在代码中插入无用的代码，函数等，扰乱可读性</p><p>​    调试保护：基于调试器特性，对运行环境进行检验，加入一些强制调试 debugger 语句，让代码在调试中难以顺利的执行</p><p>​    多态变异：让代码在每次被调用后，立即发生变异，变为和之前完全不同的代码，即功能安全不变的状态下，将代码的表现形式发生变异，来达到完全拒绝动态分析调试的效果</p><p>​    锁定域名：让 js 代码只能在指定域名下执行</p><p>​    反格式化：即在浏览器中对 js 格式化，会导致无法执行，浏览器假死的状态</p><p>​    特殊编码：即将代码完全编码为人无法阅读的，如表情符号或特殊表示内容等等</p><p>​    可以看到对于 JavaScript 的代码进行混淆实现有很多的方法，其中主流的是实现库是 javascript-obfuscator，javascript-obfuscator 的官网地址为：<a href="https://obfuscator.io/">https://obfuscator.io/</a></p><p>​    <strong>加密：</strong>即通过一些加密算法对 JavaScript 的代码进行加密，转换为无法阅读和解析的代码</p><h3 id="javascript-obfuscator-使用"><a href="#javascript-obfuscator-使用" class="headerlink" title="javascript-obfuscator 使用"></a>javascript-obfuscator 使用</h3><p>​    这个库提供一系列方法去对代码进行混淆，并保证混淆的代码难以被复制或是盗用，且能拥有和原来一样的功能</p><p>​    怎么使用呢？首先，我们需要安装好 Node.js，可以使用 npm 命令，然后新建一个文件夹，比如 js-obfuscate，随后进入该文件夹，初始化工作空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>​    这里会提示我们输入一些信息，创建一个 package.json 文件，这就完成了项目初始化了。</p><p>​    接下来我们来安装 javascript-obfuscator 这个库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev javascript-obfuscator</span><br><span class="line"># --save-dev 表示将模块安装在开发测试的环境中</span><br></pre></td></tr></table></figure><p>​    接下来我们就可以编写代码来实现混淆了，如新建一个 main.js 文件，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let x = &#x27;1&#x27; + 1</span></span><br><span class="line"><span class="string">console.log(&#x27;x&#x27;, x)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   <span class="attr">compact</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">controlFlowFlattening</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obfuscator = <span class="built_in">require</span>(<span class="string">&#x27;javascript-obfuscator&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obfuscate</span>(<span class="params">code, options</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> obfuscator.<span class="title function_">obfuscate</span>(code, options).<span class="title function_">getObfuscatedCode</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">obfuscate</span>(code, options))</span><br></pre></td></tr></table></figure><p>​    code 变量使用模板字符串表示需要被混淆的 js 代码，options 对象则表示混淆的选项，然后引入了 javascript-obfuscator 库，并定义了一个方法来接收 code 和 options 参数，函数中调用库的方法去实现混淆并返回，最后直接在控制台输出返回内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node main.js    # 执行文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const _0x443b = [&#x27;log&#x27;];</span><br><span class="line">(function (_0x4aa98c, _0x443bf4) &#123;</span><br><span class="line">    const _0x5b1ed = function (_0x486f20) &#123;</span><br><span class="line">        while (--_0x486f20) &#123;</span><br><span class="line">            _0x4aa98c[&#x27;push&#x27;](_0x4aa98c[&#x27;shift&#x27;]());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    _0x5b1ed(++_0x443bf4);</span><br><span class="line">&#125;(_0x443b, 0x19d));</span><br><span class="line">const _0x5b1e = function (_0x4aa98c, _0x443bf4) &#123;</span><br><span class="line">    _0x4aa98c = _0x4aa98c - 0x0;</span><br><span class="line">    let _0x5b1ed = _0x443b[_0x4aa98c];</span><br><span class="line">    return _0x5b1ed;</span><br><span class="line">&#125;;</span><br><span class="line">let x = &#x27;1&#x27; + 0x1;</span><br><span class="line">console[_0x5b1e(&#x27;0x0&#x27;)](&#x27;x&#x27;, x);</span><br></pre></td></tr></table></figure><p>​    从输出的结果可以看出，也就是使用两个混淆参数，但是最后的代码混淆的结果是很可观的，这样的代码几乎无法知道实现了什么</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>​    javascript-obfuscator 也提供了代码压缩的功能，使用其参数 compact 即可完成 JavaScript 代码的压缩，输出为一行内容。默认是 true，如果定义为 false，则混淆后的代码会分行显示</p><p>​    例如，上面的实例中，只使用给一个混淆的参数，将 compact 的值设为 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let x = &#x27;1&#x27; + 1</span></span><br><span class="line"><span class="string">console.log(&#x27;x&#x27;, x)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   <span class="attr">compact</span>: <span class="literal">false</span>     <span class="comment">// 先设为 false，表示不对代码压缩成一行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">let</span> x = <span class="string">&#x27;1&#x27;</span> + <span class="number">0x1</span>;</span><br><span class="line"><span class="variable language_">console</span>[<span class="string">&#x27;log&#x27;</span>](<span class="string">&#x27;x&#x27;</span>, x);</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   <span class="attr">compact</span>: <span class="literal">true</span>      <span class="comment">// 设为 true，则会将代码压缩为只有一行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x151c=[<span class="string">&#x27;log&#x27;</span>];(<span class="keyword">function</span>(<span class="params">_0x1ce384,_0x20a7c7</span>)&#123;<span class="keyword">var</span> _0x25fc92=<span class="keyword">function</span>(<span class="params">_0x188aec</span>)&#123;<span class="keyword">while</span>(--_0x188aec)&#123;_0x1ce384[<span class="string">&#x27;push&#x27;</span>](_0x1ce384[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;;<span class="title function_">_0x25fc92</span>(++_0x20a7c7);&#125;(_0x151c,<span class="number">0x1b7</span>));<span class="keyword">var</span> _0x553e=<span class="keyword">function</span>(<span class="params">_0x259219,_0x241445</span>)&#123;_0x259219=_0x259219-<span class="number">0x0</span>;<span class="keyword">var</span> _0x56d72d=_0x151c[_0x259219];<span class="keyword">return</span> _0x56d72d;&#125;;<span class="keyword">let</span> x=<span class="string">&#x27;1&#x27;</span>+<span class="number">0x1</span>;<span class="variable language_">console</span>[<span class="title function_">_0x553e</span>(<span class="string">&#x27;0x0&#x27;</span>)](<span class="string">&#x27;x&#x27;</span>,x);</span><br></pre></td></tr></table></figure><p>​    从 compact 为 true 的输出结果可以看出，压缩为单行的时候，会对变量面进一步的混淆和控制扁平化操作</p><h4 id="变量名混淆"><a href="#变量名混淆" class="headerlink" title="变量名混淆"></a>变量名混淆</h4><p>​    变量名混淆可以通过配置 identifierNamesGenerator 参数实现，我们通过这个参数可以控制变量名混淆的方式，该参数的默认值是 hexadecimal</p><p>​    1）hexadecimal：表示将变量名替换为 16 进制形式的字符串，如 0xabc123</p><p>​    2）mangled：表示将变量名替换为普通的简写字符，如 a、b、c 等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let hello = &#x27;1&#x27; + 1</span></span><br><span class="line"><span class="string">console.log(&#x27;hello&#x27;, hello)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">compact</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">identifierNamesGenerator</span>: <span class="string">&#x27;mangled&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> a=[<span class="string">&#x27;hello&#x27;</span>];(<span class="keyword">function</span>(<span class="params">c,d</span>)&#123;<span class="keyword">var</span> e=<span class="keyword">function</span>(<span class="params">f</span>)&#123;<span class="keyword">while</span>(--f)&#123;c[<span class="string">&#x27;push&#x27;</span>](c[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;;<span class="title function_">e</span>(++d);&#125;(a,<span class="number">0x9b</span>));<span class="keyword">var</span> b=<span class="keyword">function</span>(<span class="params">c,d</span>)&#123;c=c-<span class="number">0x0</span>;<span class="keyword">var</span> e=a[c];<span class="keyword">return</span> e;&#125;;<span class="keyword">let</span> hello=<span class="string">&#x27;1&#x27;</span>+<span class="number">0x1</span>;<span class="variable language_">console</span>[<span class="string">&#x27;log&#x27;</span>](<span class="title function_">b</span>(<span class="string">&#x27;0x0&#x27;</span>),hello);</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">compact</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">identifierNamesGenerator</span>: <span class="string">&#x27;hexadecimal&#x27;</span>   <span class="comment">// 也可以不设置，因为默认就是该值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x4e98=[<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>];(<span class="keyword">function</span>(<span class="params">_0x4464de,_0x39de6c</span>)&#123;<span class="keyword">var</span> _0xdffdda=<span class="keyword">function</span>(<span class="params">_0x6a95d5</span>)&#123;<span class="keyword">while</span>(--_0x6a95d5)&#123;_0x4464de[<span class="string">&#x27;push&#x27;</span>](_0x4464de[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;;<span class="title function_">_0xdffdda</span>(++_0x39de6c);&#125;(_0x4e98,<span class="number">0xc8</span>));<span class="keyword">var</span> _0x53cb=<span class="keyword">function</span>(<span class="params">_0x393bda,_0x8504e7</span>)&#123;_0x393bda=_0x393bda-<span class="number">0x0</span>;<span class="keyword">var</span> _0x46ab80=_0x4e98[_0x393bda];<span class="keyword">return</span> _0x46ab80;&#125;;<span class="keyword">let</span> hello=<span class="string">&#x27;1&#x27;</span>+<span class="number">0x1</span>;<span class="variable language_">console</span>[<span class="title function_">_0x53cb</span>(<span class="string">&#x27;0x0&#x27;</span>)](<span class="title function_">_0x53cb</span>(<span class="string">&#x27;0x1&#x27;</span>),hello);</span><br></pre></td></tr></table></figure><p>​    从显示的结果，可以看出使用 mangled 作为参数，在压缩后代码的体积相对 hexadecimal 要小很多</p><p>​    除此之外，还有一个参数可以对变量混淆做设置，就是 identifiersPrefix ，这个变量设置的值作为混淆后变量的前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let hello = &#x27;1&#x27; + 1</span></span><br><span class="line"><span class="string">console.log(&#x27;hello&#x27;, hello)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">identifiersPrefix</span>: <span class="string">&#x27;germey&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> germey_0x3dea=[<span class="string">&#x27;log&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>];(<span class="keyword">function</span>(<span class="params">_0x348ff3,_0x5330e8</span>)&#123;<span class="keyword">var</span> _0x1568b1=<span class="keyword">function</span>(<span class="params">_0x4740d8</span>)&#123;<span class="keyword">while</span>(--_0x4740d8)&#123;_0x348ff3[<span class="string">&#x27;push&#x27;</span>](_0x348ff3[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;;<span class="title function_">_0x1568b1</span>(++_0x5330e8);&#125;(germey_0x3dea,<span class="number">0x94</span>));<span class="keyword">var</span> germey_0x30e4=<span class="keyword">function</span>(<span class="params">_0x2e8f7c,_0x1066a8</span>)&#123;_0x2e8f7c=_0x2e8f7c-<span class="number">0x0</span>;<span class="keyword">var</span> _0x5166ba=germey_0x3dea[_0x2e8f7c];<span class="keyword">return</span> _0x5166ba;&#125;;<span class="keyword">let</span> hello=<span class="string">&#x27;1&#x27;</span>+<span class="number">0x1</span>;<span class="variable language_">console</span>[<span class="title function_">germey_0x30e4</span>(<span class="string">&#x27;0x0&#x27;</span>)](<span class="title function_">germey_0x30e4</span>(<span class="string">&#x27;0x1&#x27;</span>),hello);</span><br></pre></td></tr></table></figure><p>​    另外，还有一个变量 renameGlobals ，用来指定是否要混淆全局变量和函数名称，默认值是 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">var $ = function(id) &#123;</span></span><br><span class="line"><span class="string">  return document.getElementById(id);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">renameGlobals</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x4864b0=<span class="keyword">function</span>(<span class="params">_0x5763be</span>)&#123;<span class="keyword">return</span> <span class="variable language_">document</span>[<span class="string">&#x27;getElementById&#x27;</span>](_0x5763be);&#125;;</span><br></pre></td></tr></table></figure><p>​    当 renameGlobals 设为 true 时，可以看到返回中，将原本用 $ 定义的全局函数，这个 $ 也被替换了，这会产生一个问题，就是后文会无法找到这个对象，就会产生错误，所以 <strong>renameGlobals 设为 true 会有可能导致代码执行出现问题</strong></p><h4 id="字符串混淆"><a href="#字符串混淆" class="headerlink" title="字符串混淆"></a>字符串混淆</h4><p>​    即将一个字符串声明放到一个数组中，使之无法被直接搜索到，通过参数 stringArray 来控制，默认值是 true；除此之外，还有其他的控制参数</p><p>​    rotateStringArray 控制数组化后结果的元素顺序，默认也是 true</p><p>​    stringArrayEncoding 参数来控制数组的编码形式，默认不开启编码，如果设置为 true 或 base64，则会使用 Base64 编码，如果设置为 rc4，则使用 RC4 编码</p><p>​     stringArrayThreshold 来控制启用编码的概率，范围 0 到 1，默认 0.8</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">var a = &#x27;hello world&#x27;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">stringArray</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">rotateStringArray</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">stringArrayEncoding</span>: <span class="literal">true</span>,    <span class="comment">// &#x27;base64&#x27; or &#x27;rc4&#x27; or false</span></span><br><span class="line">  <span class="attr">stringArrayThreshold</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x4215=[<span class="string">&#x27;aGVsbG8gd29ybGQ=&#x27;</span>];(<span class="keyword">function</span>(<span class="params">_0x42bf17,_0x4c348f</span>)&#123;<span class="keyword">var</span> _0x328832=<span class="keyword">function</span>(<span class="params">_0x355be1</span>)&#123;<span class="keyword">while</span>(--_0x355be1)&#123;_0x42bf17[<span class="string">&#x27;push&#x27;</span>](_0x42bf17[<span class="string">&#x27;shift&#x27;</span>]());&#125;&#125;;<span class="title function_">_0x328832</span>(++_0x4c348f);&#125;(_0x4215,<span class="number">0x1da</span>));<span class="keyword">var</span> _0x5191=<span class="keyword">function</span>(<span class="params">_0x3cf2ba,_0x1917d8</span>)&#123;_0x3cf2ba=_0x3cf2ba-<span class="number">0x0</span>;<span class="keyword">var</span> _0x1f93f0=_0x4215[_0x3cf2ba];<span class="keyword">if</span>(_0x5191[<span class="string">&#x27;LqbVDH&#x27;</span>]===<span class="literal">undefined</span>)&#123;(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">var</span> _0x5096b2;<span class="keyword">try</span>&#123;<span class="keyword">var</span> _0x282db1=<span class="title class_">Function</span>(<span class="string">&#x27;return\x20(function()\x20&#x27;</span>+<span class="string">&#x27;&#123;&#125;.constructor(\x22return\x20this\x22)(\x20)&#x27;</span>+<span class="string">&#x27;);&#x27;</span>);_0x5096b2=<span class="title function_">_0x282db1</span>();&#125;<span class="keyword">catch</span>(_0x2acb9c)&#123;_0x5096b2=<span class="variable language_">window</span>;&#125;<span class="keyword">var</span> _0x388c14=<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#x27;</span>;_0x5096b2[<span class="string">&#x27;atob&#x27;</span>]||(_0x5096b2[<span class="string">&#x27;atob&#x27;</span>]=<span class="keyword">function</span>(<span class="params">_0x4cc27c</span>)&#123;<span class="keyword">var</span> _0x2af4ae=<span class="title class_">String</span>(_0x4cc27c)[<span class="string">&#x27;replace&#x27;</span>](<span class="regexp">/=+$/</span>,<span class="string">&#x27;&#x27;</span>);<span class="keyword">for</span>(<span class="keyword">var</span> _0x21400b=<span class="number">0x0</span>,_0x3f4e2e,_0x5b193b,_0x233381=<span class="number">0x0</span>,_0x3dccf7=<span class="string">&#x27;&#x27;</span>;_0x5b193b=_0x2af4ae[<span class="string">&#x27;charAt&#x27;</span>](_0x233381++);~_0x5b193b&amp;&amp;(_0x3f4e2e=_0x21400b%<span class="number">0x4</span>?_0x3f4e2e*<span class="number">0x40</span>+<span class="attr">_0x5b193b</span>:_0x5b193b,_0x21400b++%<span class="number">0x4</span>)?_0x3dccf7+=<span class="title class_">String</span>[<span class="string">&#x27;fromCharCode&#x27;</span>](<span class="number">0xff</span>&amp;_0x3f4e2e&gt;&gt;(-<span class="number">0x2</span>*_0x21400b&amp;<span class="number">0x6</span>)):<span class="number">0x0</span>)&#123;_0x5b193b=_0x388c14[<span class="string">&#x27;indexOf&#x27;</span>](_0x5b193b);&#125;<span class="keyword">return</span> _0x3dccf7;&#125;);&#125;());_0x5191[<span class="string">&#x27;DuIurT&#x27;</span>]=<span class="keyword">function</span>(<span class="params">_0x51888e</span>)&#123;<span class="keyword">var</span> _0x29801f=<span class="title function_">atob</span>(_0x51888e);<span class="keyword">var</span> _0x561e62=[];<span class="keyword">for</span>(<span class="keyword">var</span> _0x5dd788=<span class="number">0x0</span>,_0x1a8b73=_0x29801f[<span class="string">&#x27;length&#x27;</span>];_0x5dd788&lt;_0x1a8b73;_0x5dd788++)&#123;_0x561e62+=<span class="string">&#x27;%&#x27;</span>+(<span class="string">&#x27;00&#x27;</span>+_0x29801f[<span class="string">&#x27;charCodeAt&#x27;</span>](_0x5dd788)[<span class="string">&#x27;toString&#x27;</span>](<span class="number">0x10</span>))[<span class="string">&#x27;slice&#x27;</span>](-<span class="number">0x2</span>);&#125;<span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(_0x561e62);&#125;;_0x5191[<span class="string">&#x27;mgoBRd&#x27;</span>]=&#123;&#125;;_0x5191[<span class="string">&#x27;LqbVDH&#x27;</span>]=!![];&#125;<span class="keyword">var</span> _0x1741f0=_0x5191[<span class="string">&#x27;mgoBRd&#x27;</span>][_0x3cf2ba];<span class="keyword">if</span>(_0x1741f0===<span class="literal">undefined</span>)&#123;_0x1f93f0=_0x5191[<span class="string">&#x27;DuIurT&#x27;</span>](_0x1f93f0);_0x5191[<span class="string">&#x27;mgoBRd&#x27;</span>][_0x3cf2ba]=_0x1f93f0;&#125;<span class="keyword">else</span>&#123;_0x1f93f0=_0x1741f0;&#125;<span class="keyword">return</span> _0x1f93f0;&#125;;<span class="keyword">var</span> a=<span class="title function_">_0x5191</span>(<span class="string">&#x27;0x0&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​    仅仅只是一个字符串变量，通过 base64 编码，顺序翻转，结果混淆出这么大量的代码，由于字符串被编码了，所以也就无法搜索到字符串在代码中的位置了</p><p>​    如果是使用字符串数组化混淆，即将 stringArray 设为 fasle ，输出就是明文的且不会被编码的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">&#x27;hello\x20world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    对于字符串的编码，可以使用 UnicodeEscapeSequence 参数，将其设为 true，它会将字符串进行 unicode 转码，使得更难辨认</p><h4 id="代码自我保护"><a href="#代码自我保护" class="headerlink" title="代码自我保护"></a>代码自我保护</h4><p>​    通过设置 selfDefending 参数为 true，来开启代码自我保护功能，这样混淆出来的代码会被强制以一行形式显示，并且无法被格式化的，如果想要将代码进行格式化（美化）显示或是重命名，会导致代码无法被执行</p><p>####控制流平坦化</p><p>​    通过 controlFlowFlattening 变量可以控制是否开启控制流平坦化，即让代码的执行逻辑混淆，基本思想是将一些逻辑处理快都统一加上一个前驱逻辑块，每个逻辑块由前驱逻辑块进行条件判断和分发，构成一一个个闭环逻辑块，使得整个执行逻辑几乎无法阅读</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">(function()&#123;</span></span><br><span class="line"><span class="string">    function foo () &#123;</span></span><br><span class="line"><span class="string">        return function () &#123;</span></span><br><span class="line"><span class="string">            var sum = 1 + 2;</span></span><br><span class="line"><span class="string">            console.log(1);</span></span><br><span class="line"><span class="string">            console.log(2);</span></span><br><span class="line"><span class="string">            console.log(3);</span></span><br><span class="line"><span class="string">            console.log(4);</span></span><br><span class="line"><span class="string">            console.log(5);</span></span><br><span class="line"><span class="string">            console.log(6);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    foo()();</span></span><br><span class="line"><span class="string">&#125;)();</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">compact</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">controlFlowFlattening</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0xbaf1 = [</span><br><span class="line">    <span class="string">&#x27;dZwUe&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fXqMu&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0|1|3|4|6|5|2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;chYMl&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;IZEsA&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;split&#x27;</span></span><br><span class="line">];</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">_0x22d342, _0x4f6332</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _0x43ff59 = <span class="keyword">function</span> (<span class="params">_0x5ad417</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (--_0x5ad417) &#123;</span><br><span class="line">            _0x22d342[<span class="string">&#x27;push&#x27;</span>](_0x22d342[<span class="string">&#x27;shift&#x27;</span>]());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">_0x43ff59</span>(++_0x4f6332);</span><br><span class="line">&#125;(_0xbaf1, <span class="number">0x192</span>));</span><br><span class="line"><span class="keyword">var</span> _0x1a69 = <span class="keyword">function</span> (<span class="params">_0x8d64b1, _0x5e07b3</span>) &#123;</span><br><span class="line">    _0x8d64b1 = _0x8d64b1 - <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">var</span> _0x300bab = _0xbaf1[_0x8d64b1];</span><br><span class="line">    <span class="keyword">return</span> _0x300bab;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _0x19d8ce = &#123;</span><br><span class="line">        <span class="string">&#x27;chYMl&#x27;</span>: <span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x0&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;IZEsA&#x27;</span>: <span class="keyword">function</span> (<span class="params">_0x22e521, _0x298a22</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _0x22e521 + _0x298a22;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;fXqMu&#x27;</span>: <span class="keyword">function</span> (<span class="params">_0x13124b</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">_0x13124b</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_0x4e2ee0</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _0x118a6a = &#123;</span><br><span class="line">            <span class="string">&#x27;LZAQV&#x27;</span>: _0x19d8ce[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x1&#x27;</span>)],</span><br><span class="line">            <span class="string">&#x27;dZwUe&#x27;</span>: <span class="keyword">function</span> (<span class="params">_0x362ef3, _0x352709</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> _0x19d8ce[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x2&#x27;</span>)](_0x362ef3, _0x352709);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> _0x4c336d = _0x118a6a[<span class="string">&#x27;LZAQV&#x27;</span>][<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x3&#x27;</span>)](<span class="string">&#x27;|&#x27;</span>), _0x2b6466 = <span class="number">0x0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!![]) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (_0x4c336d[_0x2b6466++]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    <span class="keyword">var</span> _0xbfa3fd = _0x118a6a[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x4&#x27;</span>)](<span class="number">0x1</span>, <span class="number">0x2</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="variable language_">console</span>[<span class="string">&#x27;log&#x27;</span>](<span class="number">0x1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    <span class="variable language_">console</span>[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x5&#x27;</span>)](<span class="number">0x6</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">                    <span class="variable language_">console</span>[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x5&#x27;</span>)](<span class="number">0x2</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">                    <span class="variable language_">console</span>[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x5&#x27;</span>)](<span class="number">0x3</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    <span class="variable language_">console</span>[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x5&#x27;</span>)](<span class="number">0x5</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                    <span class="variable language_">console</span>[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x5&#x27;</span>)](<span class="number">0x4</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    _0x19d8ce[<span class="title function_">_0x1a69</span>(<span class="string">&#x27;0x6&#x27;</span>)](_0x4e2ee0)();</span><br><span class="line">&#125;());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    可以看到，一些连续的执行逻辑被打破，代码被修改为一个 switch 语句，我们很难再一眼看出多条 console.log 语句的执行顺序了；如果不设置 controlFlowFlattening 或是设为 false，那么输出的结果依然会保留原始的 console.log 的执行逻辑</p><p>​    控制流扁平化是一个常用的混淆选项，但是缺点也很明显，就是会导致代码的执行时间变长，最长会达到 1.5 倍之多</p><p>​    除此之外，controlFlowFlatteningThreshold 这个参数来可以控制比例，范围是 0 到 1，默认是 0.75，如果为 0 相当于是 controlFlowFlattening 设为 false</p><h4 id="僵尸代码注入"><a href="#僵尸代码注入" class="headerlink" title="僵尸代码注入"></a>僵尸代码注入</h4><p>​    使用 deadCodeInjection 参数开启这个选项，默认为 false，其实就是增加了一些没有用处的代码，来造成阅读上的障碍和干扰</p><p>​    同样可以通过设置 deadCodeInjectionThreshold 参数来控制僵尸代码注入的比例，取值 0 到 1，默认是 0.4</p><h4 id="对象键名替换"><a href="#对象键名替换" class="headerlink" title="对象键名替换"></a>对象键名替换</h4><p>​    使用 transformObjectKeys 参数，设为 true 来对对象的键值进行替换</p><h4 id="禁用控制台输出"><a href="#禁用控制台输出" class="headerlink" title="禁用控制台输出"></a>禁用控制台输出</h4><p>​    设置 disableConsoleOutput 为 true，来禁用 console.log 输出功能，加大调试难度</p><h4 id="调试保护"><a href="#调试保护" class="headerlink" title="调试保护"></a>调试保护</h4><p>​    设置 debugProtection 为 true，来禁止调试模式，即进入一个无限的 debug 模式，设置后如果要去打断点调试，在调试过程中不会在断点处停下</p><p>​    此外，还有 debugProtectionInterval 参数，表示开启无限 debug 的间隔，会让代码在调试过程中不断进入断点模式，无法顺畅执行</p><h4 id="域名锁定"><a href="#域名锁定" class="headerlink" title="域名锁定"></a>域名锁定</h4><p>​    通过控制 domainLock 来控制 JavaScript 代码只能在特定域名下运行，这样就可以降低被模拟的风险</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">console.log(&#x27;hello world&#x27;)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">domainLock</span>: [<span class="string">&#x27;wei-foun.github.io&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特殊编码"><a href="#特殊编码" class="headerlink" title="特殊编码"></a>特殊编码</h4><p>​    即一些使用特殊符号来混淆代码二队工具包，如 aaencode、jjencode、jsfuck 等工具，这些混淆方式比较另类，但只需要输入到控制台即可执行，其没有真正达到强力混淆的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># jsfuck</span><br><span class="line">[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![])([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![]+!![])(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+[]))+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![])([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![]+!![])(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+!![]+[])+([][[]]+[])[!+[]+!![]])+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(+!![]+[]))(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># aaencode </span><br><span class="line">ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ / [&#x27;_&#x27;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\&#x27;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#x27;\&quot;&#x27;;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ])(ﾟΘﾟ))((ﾟΘﾟ)+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ)+(ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟoﾟ]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># jjencode </span><br><span class="line">$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+&quot;\\&quot;+$.__$+$.$$_+$.$$_+$.$_$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+&quot;\\&quot;+$.$__+$.___+$.$_$_+&quot;\\&quot;+$.$__+$.___+&quot;=\\&quot;+$.$__+$.___+$.__$+&quot;\&quot;&quot;)())();</span><br></pre></td></tr></table></figure><h3 id="JavaScript-加密技术"><a href="#JavaScript-加密技术" class="headerlink" title="JavaScript 加密技术"></a>JavaScript 加密技术</h3><p>​    不同于混淆技术，加密技术是更进一步的升级，基本思路是将一些核心逻辑使用 C/C++ 语言去编写，然后通过 JavaScript 调用，起到二进制级别的防护作用</p><p>​    加密的方式现在有 Emscripten 和 WebAssembly 等，其中后者越来越成为主流</p><h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h4><p>​    首先，不同于 Emscripten 加密技术生成的 asm.js 的文本文件，WebAssembly 则是一个二进制字节码，因此运行上会更快，体积也会更小</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript 混淆技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyquery 使用</title>
      <link href="/3792204184/"/>
      <url>/3792204184/</url>
      
        <content type="html"><![CDATA[<h2 id="pyquery使用"><a href="#pyquery使用" class="headerlink" title="pyquery使用"></a>pyquery使用</h2><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><p>​    pyquery 的出现使得对网页的元素的提取更加方便，毕竟如果全都是使用正则表达式，这样编写的话内容量会很大，并且很容易出现匹配结果不理想，pyquery 可以直接对 html 的 DOM节点结构进行解析，并且使用 DOM 节点的属性来进行内容个提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyquery</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​    <strong>在对 html 文档进行解析前，需要将内容初始化为成 pyquery 对象</strong>，包括可以直接是 html 的字符串进行初始化，也可以 <strong>直接使用 url</strong> 进行初始化，或是将 *<em>html 的本地文件 *</em>作为参数初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;1 item&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;2 item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0 active&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;&lt;span class=&quot;bold&quot;&gt;3 item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class=&quot;item-0&quot;&gt;&lt;a href=&quot;link5.html&quot;&gt;4 item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;li&#x27;</span>), <span class="built_in">type</span>(doc(<span class="string">&#x27;li&#x27;</span>)))   </span><br></pre></td></tr></table></figure><p>​    print 函数会将 html 字符串中的所有 li 元素打印出来，同过 type 函数得到 &lt;class ‘pyquery.pyquery.PyQuery’&gt; 对象，当然这并没有将标签内的文本提取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(url=<span class="string">&#x27;http://www.wei-foun.github.io&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure><p>​    通过url参数，pyquery会先请求这个url获取到响应对象，从中得到整个页面的html结构文档，并进行初始化得到 pyquery 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(filename=<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(doc(<span class="string">&#x27;title&#x27;</span>))</span><br></pre></td></tr></table></figure><p>​    通过 <strong>filename</strong> 参数可以指定本地的 html 文件，这样也可以进行初始化得到 pyquery 对象</p><h3 id="基本CSS选择器​"><a href="#基本CSS选择器​" class="headerlink" title="基本CSS选择器​"></a>基本CSS选择器​</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>*</code></td><td>选取所有节点</td></tr><tr><td><code>#container</code></td><td>选取 id 名为 container 的节点</td></tr><tr><td><code>.container</code></td><td>选取 class 名为 container 的节点</td></tr><tr><td><code>li a</code></td><td>选取所有 li 标签下的 a 标签（包括子和后代）</td></tr><tr><td><code>ul+p</code></td><td>选取 ul 后面是 p，且p与ul是同级（兄弟）的节点</td></tr><tr><td><code>ul&gt;p</code></td><td>选取父级是ul的所有p节点</td></tr><tr><td><code>p~ul</code></td><td>选择 p 标签后面出现的所有 ul 标签节点，不管是子节点，兄弟节点</td></tr><tr><td><code>a[title]</code></td><td>选取所有属性有title的 a 元素</td></tr><tr><td><code>a[href=&#39;http://ah&#39;]</code></td><td>选取href属性值是”<a href="http://ah&quot;的所有">http://ah&quot;的所有</a> a 元素</td></tr><tr><td><code>a[href*=&#39;ham&#39;]</code></td><td>选取href属性中包含’ham’字符的 a 元素</td></tr><tr><td><code>a[href^=&#39;http&#39;]</code></td><td>选取href属性中以’http’字符开头的 a 元素</td></tr><tr><td><code>a[href$=&#39;.jpg&#39;]</code></td><td>选取href属性中以’，jpg’字符结尾的 a 元素</td></tr><tr><td><code>input[type=radio]:check</code></td><td>选取所有被点击的单选按钮的 input 元素</td></tr><tr><td><code>div:not(#wapper)</code></td><td>选择所有 id 不为 wapper 的 div 元素</td></tr><tr><td><code>li:nth-child(3)</code></td><td>选择从父元素下索引为3的 li 元素</td></tr><tr><td><code>li:nth-child(2n)</code></td><td>选择从父元素下索引为偶数的 li 元素</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h4><p>​    通常使用选择器获取到的大多都是一个集合，其中包含了全部满足选择器的所以节点，所以通过循环遍历每一个节点，在使用 text 方法就可以得到标签中的文本内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> doc(<span class="string">&#x27;#container li a&#x27;</span>).itmes():</span><br><span class="line"><span class="built_in">print</span>(item.text())    <span class="comment"># 获取 a 标签的文本内容</span></span><br></pre></td></tr></table></figure><p>​    <strong>itmes 方法会返回一个生成器对象，每一次遍历都会从中取出一个元素</strong></p><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><p>​    对于子节点的查找使用的是 find 方法，传入的参数就是使用的 CSS选择器，比如在上个代码中是获取到 id 为 container 下 li 标签中 a 标签，但是如果在之后的操作中任然有要提取的内容，且同样是在 li 标签下，此时就无法在使用之前的 pyquery 对象，只能再次重新写 CSS选择器</p><p>​    所以由此可以直接将 li 这一层获取得到一个 pyquery 的对象，通过使用 find 方法，可以多次使用这个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;#container li&#x27;</span>)</span><br><span class="line">a_items = itmes.find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p_items = itmes.find(<span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    这里的 a_items， p_items  分别是包含了 li 下的所有 a 和 p 标签的一个 pyquery 对象，通过遍历后就可以获取各自对应的文本，所以 <strong>find</strong> 方法查找的范围是给出范围下的 <strong>所有子孙节点</strong>，对于 <strong>直接查找子节</strong> 点，可以使用 <strong>children</strong> 方法获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div_item = itmes.children()</span><br></pre></td></tr></table></figure><p>​    当然使用 children 查找子节点也可以使用 CSS选择器 来指定具体的某一个子节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div_item = itmes.children(<span class="string">&#x27;.active&#x27;</span>)    <span class="comment"># 获取被选中的子节点</span></span><br></pre></td></tr></table></figure><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><p>​    对应子节点，父节点也有两种，一种是直接的父级节点，也就是当前元素节点直接的上一层而不是继续往上，另一种就是继续往上找祖先节点，两种方法分别是 parent 和 parents</p><p>​    <strong>parent 方法返回的结果是直接的父级节点所以只有一个，而是用 parents 方法会把所有包含自己的上层节点全部返回</strong>，所以使用 parents 方法想要具体的一个父级节点，同样可以使用CSS选择器去指定</p><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>​    很明显这是用来查找相邻节点的，使用的方法是 <strong>siblings</strong> ，会将所有的相邻兄弟节点全部返回，如果要获取特定的一个节点，一样使用 CSS选择器 即可</p><h3 id="属性与文本"><a href="#属性与文本" class="headerlink" title="属性与文本"></a>属性与文本</h3><h4 id="属性值获取"><a href="#属性值获取" class="headerlink" title="属性值获取"></a>属性值获取</h4><p>​    在得到节点后，通过遍历可以获取到 pyquery 中每一个元素节点，接下来就是内容的提取，属性的获取可以通过 attr 方法指定属性名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">a = doc(<span class="string">&#x27;#container li&#x27;</span>).children(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.attr(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure><p>​    attr 方法还可以直接用 <strong>‘ .[属性名] ‘</strong> 的方式来得到该属性的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.attr.href      <span class="comment"># 获取 a 标签属性的 href 属性值即 url 路径</span></span><br></pre></td></tr></table></figure><p>​    <strong>需要注意的是这里的节点只有一个，当有多个节点的情况下，直接使用 attr 来获取属性，只会需要第一个元素节点的该属性的值，所以当对多个节点获取属性值，依然需要使用循环遍历的方式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">li = doc(<span class="string">&#x27;#container li&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> li.itmes():     <span class="comment"># 循环遍历每一个 li 节点</span></span><br><span class="line"><span class="built_in">print</span>(item.attr(<span class="string">&#x27;class&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="文本内容获取"><a href="#文本内容获取" class="headerlink" title="文本内容获取"></a>文本内容获取</h4><p>​    之前的文本提取中已经使用了一个方法 text，那还有另一个方法就是 html，两者都可以获取到节点的内容，区别在于：</p><p>​    <strong>text 方法会忽略节点内 html 的语法，返回纯文字的内容；</strong></p><p>​    <strong>html 方法则是会将当前节点内的子标签文本内容和html文本一并返回</strong></p><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><h4 id="样式修改"><a href="#样式修改" class="headerlink" title="样式修改"></a>样式修改</h4><p>​    对于动态修改一个节点的属性，进行属性的添加或删除，有两个方法：<strong>addClass</strong> 和 <strong>removeClass</strong> ，只需要将属性名传入即可，这两个方法只能是对节点的样式属性进行操作，有时候可能会见到 add_class 和 remove_class 的写法，实现的结果是一样的，addClass 相当于是 add_class 的别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">a = doc(<span class="string">&#x27;#container li&#x27;</span>).children(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a.addClass(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">a.removeClass(<span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="属性添加"><a href="#属性添加" class="headerlink" title="属性添加"></a>属性添加</h4><p>​    之前的 <strong>attr</strong> 方法，有两种操作方式，在不使用参数或只使用一个参数 ‘属性名’ 的情况下，attr 能够获取到这个属性的值，但是如果添加第二个参数，那么 attr 方法会将指定的属性名加入节点，并将 <strong>第二个参数作为该属性的值</strong>，如果 attr 的这个属性在节点已存在，并且给了第二个参数，那么第二个参数的值会覆盖节点原来属性的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = doc(<span class="string">&#x27;div ul&#x27;</span>).children(<span class="string">&#x27;.item-1&#x27;</span>)</span><br><span class="line">li.attr(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(li)</span><br><span class="line"><span class="comment"># &lt;li class=&quot;item-1&quot; name=&quot;new&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;2 item&lt;/a&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure><h4 id="文本内容修改"><a href="#文本内容修改" class="headerlink" title="文本内容修改"></a>文本内容修改</h4><p>​    与 attr 方法类似，text 和 html 方法可以用来获取节点中的纯文本或是整个节点字符串，text 和 html 方法中如果插入字符串参数，可以对原有内容进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">li = doc(<span class="string">&#x27;div ul&#x27;</span>).children(<span class="string">&#x27;.item-1&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;li class=&quot;item-1&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;2 item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li.text())     </span><br><span class="line"><span class="comment"># 2 item</span></span><br><span class="line"><span class="built_in">print</span>(li.text(<span class="string">&#x27;new item&#x27;</span>))    </span><br><span class="line"><span class="comment"># &lt;li class=&quot;item-1&quot;&gt;new item&lt;/li&gt;</span></span><br><span class="line"><span class="built_in">print</span>(li.html(<span class="string">&#x27;&lt;p&gt;it’s programme&lt;/p&gt;&#x27;</span>))    </span><br><span class="line"><span class="comment"># &lt;li class=&quot;item-1&quot;&gt;&lt;p&gt;it’s programme&lt;/p&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>​    有时候在得到节点后使用 text 方法会得到所有节点下的所有文本内容，但有时可能并不是却不都需要的，所以可以通过删除不用提取的子节点，使用 remove 方法即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;wrapper&quot;&gt;</span></span><br><span class="line"><span class="string">    what&#x27;s your name, Man?!</span></span><br><span class="line"><span class="string">    &lt;p&gt;24601&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">div = doc(<span class="string">&#x27;.wrapper&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(div.text())</span><br><span class="line"><span class="comment"># what&#x27;s your name, Man?!</span></span><br><span class="line"><span class="comment"># 24601</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(div.remove(<span class="string">&#x27;p&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(div.text())</span><br><span class="line"><span class="comment"># what&#x27;s your name, Man?!</span></span><br></pre></td></tr></table></figure><p>​    <strong>empty 方法同样可以删除，但是它执行的是清空的操作，会将当前调用的父元素下所有子元素删除</strong></p><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p>​    append 方法可以在父元素中将子元素进行添加，还有 append_to 方法则是将子元素追加到父元素中，伪代码就是： <strong>父元素.append(子元素)，  子元素.append_to(父元素)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(div.append(<span class="string">&#x27;&lt;p&gt;alexander hamilton&lt;/p&gt;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(div.append(<span class="string">&#x27;alexander hamilton&#x27;</span>))</span><br><span class="line"><span class="comment"># &lt;div class=&quot;wrapper&quot;&gt;</span></span><br><span class="line"><span class="comment">#    what&#x27;s your name, Man?! </span></span><br><span class="line"><span class="comment">#&lt;p&gt;alexander hamilton&lt;/p&gt;alexander hamilton</span></span><br><span class="line"><span class="comment"># &lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>​    append 默认都是在最后进行子元素的添加，所以该有 prepend 的方法来实现前置添加的效果，将子元素加入到第一个位置，和 append 对应也有 prepend_to 方法</p><p>​    除了在最前和最后这种针对父子节点之间的操作，兄弟节点也有前后进行元素添加的方法，如： after，insert_after，before，insert_before，带有 ‘_’ 的都是代表要插入的元素在指定的元素前或后进行添加</p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>​    在 CSS 中可以使用伪类来为同一种标签指定不同的状态，从而使用不同的样式，比如鼠标悬浮链接 ‘ a:hover ‘，定义这样的伪类可以让鼠标移动到a标签上，去自定制此时 a 标签的一个样式，而其他的a标签则会是使用默认的样式</p><p>​    CSS3 中提供节点位置的伪类选择器：</p><p>​        <code>li:first-child</code>：获取第一个 li 节点</p><p>​        <code>li:last-child</code>：获取最后一个 li 节点</p><p>​        <code>li:nth-child(2)</code>：获取第二个 li 节点</p><p>​        <code>li:gt(2)</code>：获取第二个 之后的所有 li 节点，gt 是大于的意思，2是下标，在 html 的节点中下标从 1 开始</p><p>​        <code>li:nth-child(2n)</code>：获取偶数位的 li 节点</p><p>​        <code>li:contains(name)</code>：获取文本内容包含 ‘name’ 的 li 节点</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> pyquery 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium 简单实例</title>
      <link href="/4093518221/"/>
      <url>/4093518221/</url>
      
        <content type="html"><![CDATA[<h3 id="使用-selenium-自动百度搜索"><a href="#使用-selenium-自动百度搜索" class="headerlink" title="使用 selenium 自动百度搜索"></a>使用 selenium 自动百度搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化浏览器对象，来执行后续的操作，参数是指定浏览器的驱动程序，实例化后会自动打开浏览器</span></span><br><span class="line">bro = webdriver.Chrome(executable_path=<span class="string">&#x27;./chromedriver.exe&#x27;</span>)  <span class="comment"># 驱动程序需要针对安装浏览器的版本下载对应版本的驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让实例化的浏览器对象去跳转网页</span></span><br><span class="line">bro.get(url=<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照id属性找到input标签</span></span><br><span class="line">text_input = bro.find_element_by_id(<span class="string">&quot;kw&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在找到的input中输入搜索内容</span></span><br><span class="line">text_input.send_keys(<span class="string">&#x27;梅西&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照id属性找到按钮点击搜索</span></span><br><span class="line">bro.find_element_by_id(<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面的源码数据</span></span><br><span class="line"><span class="built_in">print</span>(bro.page_source)</span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">bro.quit()</span><br></pre></td></tr></table></figure><p>​    上面的代码会先实例化一个 webdriver，即运行后会开启一个浏览器对象，然后利用 get 方法去请求了百度搜索（注意：代码中的 time.sleep 的目的是为了让页面能够完全加载完成，且由于 selenium 是自动化框架，运行速度会很快，睡几秒也是为了能够看到效果），等待完成后，利用 id 去找到百度搜索中的输入框，并且使用 send_keys 去输入要搜索的关键字，利用同样的方法，找到 “百度一下” 的按钮，并利用 click 实现点击搜索的步骤，完成后程序会打印出搜索页面的源码，最后使用 quit 方法将浏览器关闭</p><p><img src="https://wei-foun.github.io/img/selenium01.gif" alt="img/md5.jpg"> </p><h3 id="利用-selenium-实现模拟登录"><a href="#利用-selenium-实现模拟登录" class="headerlink" title="利用 selenium 实现模拟登录"></a>利用 selenium 实现模拟登录</h3><p>​    在日常的访问网站中，几乎可以说所有的网站都会要求登录，即使一开始不需要，也会在你要查看个人的信息下要求你登录。那在利用 selenium 去爬取的时候，也就必不可少需要对这一块进行处理，总的来说，模拟登录可以利用简单的元素查找和输入，模拟鼠标的操作来完成登录，但是现在的网站会针对于爬虫做一些反爬策略，最常见到的就是 “验证码”，之后随着技术的推进，更是出现了 计算题验证，英文和数字混合验证，指定文字顺序点击，滑动验证等等，这就需要去针对性设计代码逻辑去应对反爬策略，同时需要处理登录后的状态信息保留以及 ip 代理防止请求频繁被封等等</p><h4 id="简单的模拟登录"><a href="#简单的模拟登录" class="headerlink" title="简单的模拟登录"></a>简单的模拟登录</h4><p>​    该例子来于崔庆才专栏课程的《52讲轻松搞定网络爬虫》，对 <a href="https://login2.scrape.cuiqingcai.com/">https://login2.scrape.cuiqingcai.com/</a> 进行模拟登录，例子中直接使用 <strong>requests</strong> 模块通过参数方式进行登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;/login&#x27;</span>)      <span class="comment"># 登录页面</span></span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;/page/1&#x27;</span>)     <span class="comment"># 登录后访问的首面 </span></span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, data=&#123;     <span class="comment"># data 可以设置请求所带的参数，参数需要以键值的形式</span></span><br><span class="line">   <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">response_index = requests.get(INDEX_URL)     <span class="comment"># 请求首页</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response Status&#x27;</span>, response_index.status_code)   <span class="comment"># 显示状态码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response URL&#x27;</span>, response_index.url)              <span class="comment"># 显示请求的url</span></span><br><span class="line"><span class="comment"># Response Status 200</span></span><br><span class="line"><span class="comment"># Response URL https://login2.scrape.cuiqingcai.com/login?next=/page/1</span></span><br></pre></td></tr></table></figure><p>​    从返回的信息可以知道，200 的状态码表示成功，但是从 response 返回的 url 可知这个请求是失败的，使用 LOGIN_URL 去登录后的确是成功的，但是在第二次的 INDEX_URL 的 get 请求时，则是相当于在浏览器打开了一个新标签页去访问这个 url，也就是说 LOGIN_URL 和 INDEX_URL 的请求时相互独立的，所以 INDEX_URL 不会使用上 LOGIN_URL 成功登录后获取到后台的 Session，所以单纯利用 requests 去 post 请求登录是不奏效的，不能让后续的登录状态维持</p><p><img src="https://s0.lgstatic.com/i/image3/M01/16/03/Ciqah16lJEiACmWwAAP81rGCv5M937.png" alt="image (4).png"> </p><p>​    从登录的 post 请求可以看到，提交的表单是包含了账号和密码，并且是 302 的重定向状态码，Response Headers 的响应头中包含了 location 根页面和 set-cookie 两个字段，set-cookie 中可以看出后端是设置了 SessionID 来做为标识的</p><p>​    所以通过将登录成功后获取的 Cookies 保存，让这个信息作为参数，在之后的请求中去携带这个 Cookies 就能实现登录后的访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;/page/1&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, data=&#123;</span><br><span class="line">   <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;, allow_redirects=<span class="literal">False</span>)   <span class="comment"># requests 会自动处理重定向，所以对于登录后跳转首页，需要设置参数 allow_redirects=False，使 requests 不去自动给处理 302 的重定向  </span></span><br><span class="line"></span><br><span class="line">cookies = response_login.cookies</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cookies&#x27;</span>, cookies)</span><br><span class="line"></span><br><span class="line">response_index = requests.get(INDEX_URL, cookies=cookies)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response Status&#x27;</span>, response_index.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response URL&#x27;</span>, response_index.url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cookies &lt;RequestsCookieJar[&lt;Cookiesessionid=psnu8ij69f0ltecd5wasccyzc6ud41tc for login2.scrape.cuiqingcai.com/&gt;]&gt;</span></span><br><span class="line"><span class="comment"># Response Status 200</span></span><br><span class="line"><span class="comment"># Response URL https://login2.scrape.cuiqingcai.com/page/1</span></span><br></pre></td></tr></table></figure><p>​    这一次从相应中获取的 url 可以看到是登录的首页了，说明保存获取的 Cookies 信息让后续请求去携带就可以实现模拟登录；不过，这不是最简便的方式，如果每请求一个页面就要去手动设置 cookie 参数明显会较为繁琐，所以可以直接利用 requests 的 Session 对象来保存获取的 Cookies 信息，这样只要是继续对同一个的页面进行请求访问，就会维持这个 Session 对象去自动携带</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line">response_login = session.post(LOGIN_URL, data=&#123;</span><br><span class="line">   <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">response_index = session.get(INDEX_URL)    <span class="comment"># 之后的请求都使用 Session() 实例的对象去访问</span></span><br></pre></td></tr></table></figure><p>​    使用 requests 模块的 Session 对象去维持住获取的 Cookie 可以更加简便的去携带认证信息发送后续的请求，上面的代码最终运行结果和直接使用 cookies 属性获取并保存在利用参数添加运行结果是一样的</p><p>​    完成了会话的维持，就可以将模拟登录的逻辑交给 selenium 来完成，对于内容的提取就可以交由 requests 来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;/page/1&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(BASE_URL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 css 选择器去找到用户名和密码的输入框，send_keys 输入字符串，click 完成点击按钮的操作</span></span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;input[name=&quot;username&quot;]&#x27;</span>).send_keys(USERNAME)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;input[name=&quot;password&quot;]&#x27;</span>).send_keys(PASSWORD)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;input[type=&quot;submit&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>​    除了使用 Cookie + Session 来保存登录状态信息，维持会话的机制外，还有另一种实现就是 JWT，这几乎是现在最通用的方式，针对采用了前后端分离式的系统，前后端利用 Ajax 来传递数据，登录验证则依赖 JWT 中的 Token 值，比如 <code>https://login3.scrape.cuiqingcai.com/api/login</code> 这个网址就是利用这种形式，可以在登录后看到请求头中附加了一个新的字段表示这个 Token</p><p><img src="https://s0.lgstatic.com/i/image3/M01/16/04/Ciqah16lJcWAeoAVAAXnl2HHZic036.png" alt="image (7).png"> </p><p>​    后续的 Ajax 请求数据的时候，Request Headers 中包含一个 authorization 字段，这个键对应的值是 jwt + Token值，并且得到响应内容都是 json 格式的</p><p><img src="https://s0.lgstatic.com/i/image3/M01/16/04/Ciqah16lJc2ATGC8AAZ4n3K84ns927.png" alt="image (8).png"> </p><p>​    还是相同的思路，对于后端返回的 JWT 可以获取后将其保存，在后续的请求中可以通过 headers 参数去携带</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login3.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;/api/login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;/api/book&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, json=&#123;</span><br><span class="line">   <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data = response_login.json()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response JSON&#x27;</span>, data)</span><br><span class="line"><span class="comment"># Response JSON &#123;&#x27;token&#x27;: &#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNTg3ODc4NzkxLCJlbWFpbCI6ImFkbWluQGFkbWluLmNvbSIsIm9yaWdfaWF0IjoxNTg3ODM1NTkxfQ.iUnu3Yhdi_a-Bupb2BLgCTUd5yHL6jgPhkBPorCPvm4&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">jwt = data.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;JWT&#x27;</span>, jwt)   <span class="comment"># 获取到 token 的值</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">   <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">f&#x27;jwt <span class="subst">&#123;jwt&#125;</span>&#x27;</span>    <span class="comment"># 格式化保存创建独立的头信息字典</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response_index = requests.get(INDEX_URL, params=&#123;</span><br><span class="line">   <span class="string">&#x27;limit&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">   <span class="string">&#x27;offset&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;, headers=headers)    <span class="comment"># 设置 headers ，携带保存的 token 去认证</span></span><br></pre></td></tr></table></figure><h4 id="知乎的模拟登录"><a href="#知乎的模拟登录" class="headerlink" title="知乎的模拟登录"></a>知乎的模拟登录</h4><p>​    为了在 scrapy 中利用 selenium 实现对知乎的模拟登录，在创建好的 spider 类中，需要重新复写 start_requests 方法，让 spider 开始从 start_urls 列表获取到初始设置的 url 发起请求前，实例化 webdriver  并利用这个来访问知乎的登录 url</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># mouse 模块提供鼠标的操作</span></span><br><span class="line"><span class="keyword">from</span> mouse <span class="keyword">import</span> move, click</span><br><span class="line"><span class="comment"># Keys 模块可以让 selenium 可以控制键盘进行文本输入</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZhihuSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;zhihu&#x27;</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.zhihu.com/&#x27;</span>]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">        browser = webdriver.Chrome(executable_path=<span class="string">r&quot;.\utils\chromedriver.exe&quot;</span>)</span><br><span class="line">        <span class="comment"># 向登录的 url 发起请求</span></span><br><span class="line">        browser.get(<span class="string">&quot;https://www.zhihu.com/signin&quot;</span>)</span><br><span class="line">        <span class="comment"># maximize_window 可以将浏览器对象最大化</span></span><br><span class="line">        browser.maximize_window()</span><br><span class="line">        <span class="comment"># 通过 xpath 获取到 密码登录 的选项，并联式 click 点击切换</span></span><br><span class="line">        browser.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;SignFlow-tabs&#x27;]//div[2]&quot;</span>).click()</span><br><span class="line">        <span class="comment"># css 选择器找到账户输入的文本框，send_keys 发起输入，Keys.CONTROL 就是键盘的 &#x27;Ctrl&#x27; 键</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="comment"># 上面一步的目的是为了对文本内容全选，来实现文本输入的全覆盖</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(<span class="string">&quot;1111111111&quot;</span>)</span><br><span class="line">        <span class="comment"># 同理，找到密码的文本框对内容全选</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="comment"># send_key 输入密码</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(<span class="string">&quot;123456.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mouse 模块的 move 接收两个参数(x,y)，分别是横坐标和纵坐标，坐标像素位置是相对于整个屏幕而言，而不是相对浏览器</span></span><br><span class="line">        move(<span class="number">950</span>, <span class="number">560</span>)</span><br><span class="line">        <span class="comment"># mouse 的 click 一样可以实现鼠标单击操作</span></span><br><span class="line">        click()</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1111111</span>)</span><br></pre></td></tr></table></figure><p>​    上面的代码就是一个简单的账号输入，并不能直接通过，因为知乎的登录还需要通过验证码的检测。但是对于没有验证码的网站，如上步骤就可以正常运行。为了防止 webdiver 因为程序结束退出，所以可以在 print 语句处打上断点进行 debug，通过查看浏览器的 Network 选项可以到在一个叫 sign_in 的 post 请求抛出了 403 状态码，并在 preview 中看到如下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: &#123;code: 10001, message: &quot;10001:请求参数异常，请升级客户端后重试&quot;&#125;</span><br></pre></td></tr></table></figure><p>​    这表示使用 selenium 的 Webdriver 进行模拟登录时，被检查到是 Webdriver 发起而导致的，因为 chrome 浏览器的 driver 驱动中一些 js 变量被检测到，所以被服务器给拒绝了。对于这个问题，可以通过使用老版本的 chrome（60）和 driver（2.33）驱动去执行这个代码，但是并不容易去下载老版本；第二种方式就是通过 driver 来驱动本地的 chrome，需要先找到 chrome 的本地位置，通过命令行去启动，注意：在用命令行启动前，需要关闭已开启的 chrome 浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Google\Chrome\Application&gt;chrome.exe  --remote-debugging-port=9222</span><br></pre></td></tr></table></figure><p>​    输入完成后，本地开启一个新窗口，并且是直接在本地的 chrome 上开启的，9222 表示的是监听的端口号，可以通过在地址栏输入 <code>http://127.0.0.1:9222/json</code> ，如果能够看到 json 内容的信息则表示当前开启的 chrome 是成功的</p><p>​    接下来，就是在代码中，对实例化的 webdriver 对象添加一些参数，来正确使用启动的这个 chrom</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数让 selenium 启动自己的浏览器，而不是使用 webdriver 开启的模拟浏览器</span></span><br><span class="line">chrome_option = ChromeOptions()</span><br><span class="line"><span class="comment"># 添加参数，屏蔽掉chrome的扩展插件</span></span><br><span class="line">chrome_option.add_argument(<span class="string">&quot;--disable-extensions&quot;</span>)</span><br><span class="line"><span class="comment"># 添加测试使用的参数，设置端口</span></span><br><span class="line">chrome_option.add_experimental_option(<span class="string">&quot;debuggerAddress&quot;</span>, <span class="string">&quot;127.0.0.1:9222&quot;</span>)</span><br><span class="line"> browser = webdriver.Chrome(</span><br><span class="line">     executable_path=<span class="string">r&quot;F:\Envs\article_spider\ArticleSpider\ArticleSpider\utils\chromedriver.exe&quot;</span>,</span><br><span class="line">     chrome_options=chrome_option</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>​    另外，<strong>scrapy 的版本升级后，webdriver 的浏览器参数设置，由原来的 chrom_options 改为了 options，所以如果使用 chrome_options=chrome_option，在执行时会抛出一个警告提示 <code>DeprecationWarning: use options instead of chrome_options chrome_options=chrome_option)</code></strong></p><h5 id="cookie-信息"><a href="#cookie-信息" class="headerlink" title="cookie 信息"></a>cookie 信息</h5><p>​    以上完成后，就可以正常利用 selenium 实现模拟登录，不过还需要对 cookie 的信息进行保存，以便于在进行爬取解析时，不会出现异常要求重新登录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle    <span class="comment"># 和 json 模块一样的序列化模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">...</span><br><span class="line">    <span class="comment"># 获取cookie并保存到文件方便以后登录时，不需要再次模拟登录</span></span><br><span class="line">    COOKIES = browser.get_cookies()</span><br><span class="line">    <span class="comment"># print(COOKIES)</span></span><br><span class="line">    <span class="comment"># 可以将文件保存在文件中，并在需要时直接从文件读取</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;zhihu_cookies.text&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    pickle.dump(COOKIES, f)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="comment"># Request 请求中 cookies 参数是一个字典，所以可以直接创建一个字典来保存获取的 cookie 信息</span></span><br><span class="line">    cookies_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> COOKIES:</span><br><span class="line">    cookies_dict[cookie[<span class="string">&#x27;name&#x27;</span>]] = cookie[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">  <span class="comment"># dont_filter 为 True 表示对爬取的 url 进行过滤</span></span><br><span class="line">    <span class="keyword">return</span> [scrapy.Request(url=self.start_urls[<span class="number">0</span>], dont_filter=<span class="literal">True</span>, cookies=cookies_dict)]</span><br></pre></td></tr></table></figure><p>​    上面获取到 cookie 信息保存到文件后，如果不想在 parse 方法中 yield 时反复在 Request 中加上 cookies 参数，可以在 settings 中进行下面的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COOKIES_ENABLED = <span class="literal">True</span></span><br><span class="line"><span class="comment"># True 表示后续的request会去获取前一次的cookie信息，当在请求中手动加入cookie参数后登录后，后面的请求中就会加入这个 cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COOKIES_DEBUG = True      </span></span><br><span class="line"><span class="comment"># 打印cookie的信息</span></span><br></pre></td></tr></table></figure><p>​    同时可以将 UA 加入到配合中，并开启 scrapy 自带的 UA 中间件，让请求都携带上 UA 信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&quot;</span>: <span class="number">2</span>,   <span class="comment"># 这个中间件可以将 user—agent 加入到请求头</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    完成之后，再继续通过 debug 运行，就不会再出现知乎的 10001 的状态问题，这里可以进行手动点击验证码，然后再次点击登录按钮，就会完成登录跳转到知乎的首页中</p><h5 id="验证码逻辑"><a href="#验证码逻辑" class="headerlink" title="验证码逻辑"></a>验证码逻辑</h5><p>​    虽然上面的测试可以正常登录，但这毕竟还不是自动模拟，因为真正重要的核心是自动完成对验证码的识别，并完成自动点击或输入</p><p>​    知乎的登录验证码现阶段是两种方式：<strong>中文倒立文字点击，英文数字混合输入</strong>，其中对于英文数字这种是最常见的方式，一些普通的打码平台都可以支持对这种方式的识别。而对于中文倒立文字点击的方式，可以使用 github 上的 zheye 的包去解析倒立文字  <code>https://github.com/996refuse/zheye</code>，根据 readme 文档下载整个包或是 git clone，再去使用 pip 去安装 requirement.txt 文件下载安装需要的依赖包，因为安装中会有某些包可能无法直接使用 pip 安装，可以到 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/</code> 中搜索下载 whl 文件后再用 pip 安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start_requests</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;重写 start_requests 直接使用 selenium 去完成模拟登录&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">&quot;zhihu_cookies.text&quot;</span>):</span><br><span class="line">        <span class="comment"># 判断cookie文件是否存在，存在则是用文件的cookie进行登录</span></span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&#x27;zhihu_cookies.text&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">        cookies = pickle.load(f)</span><br><span class="line">        cookies_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">            cookies_dict[cookie[<span class="string">&#x27;name&#x27;</span>]] = cookie[<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line">            <span class="comment"># print(cookie[&#x27;name&#x27;], cookie[&#x27;value&#x27;])</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br><span class="line">        browser.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;SignFlow-tabs&#x27;]//div[2]&quot;</span>).click()</span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(<span class="string">&quot;15320146232&quot;</span>)</span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="comment"># 第一次先输入错误的密码</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(<span class="string">&quot;112233&quot;</span>)</span><br><span class="line">        WebDriverWait()</span><br><span class="line"></span><br><span class="line">        move(<span class="number">960</span>, <span class="number">600</span>)</span><br><span class="line">        click()</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># successful_login 表示是否成功登录，为 False 就进入循环重复执行模拟登录过程</span></span><br><span class="line">        successful_login = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> successful_login:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># implicitly_wait 隐式等待，会等到元素出现，如果超出时间值，则会抛出异常</span></span><br><span class="line">                <span class="comment"># browser.implicitly_wait(5)</span></span><br><span class="line">                browser.find_element_by_id(<span class="string">&quot;Popover15-toggle&quot;</span>)  <span class="comment"># 这里判断通知样式是否存在，表示登录成功</span></span><br><span class="line">                successful_login = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># print(&quot;没有成功登陆&quot;)</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 获取中文验证码元素</span></span><br><span class="line">                ch_captcha_element = browser.find_element_by_class_name(<span class="string">&quot;Captcha-chineseImg&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                ch_captcha_element = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 获取英文数字验证码元素</span></span><br><span class="line">                en_captcha_element = browser.find_element_by_class_name(<span class="string">&quot;Captcha-englishImg&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                en_captcha_element = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>​    上面可知，将整个 start_requests 逻辑分为两个部分，if 判断主要是否是使用 cookie，如果 cookie 文件存在且有效那么就直接登录，否则进入 else 中执行模拟登录部分</p><p>​    webdriver 驱动浏览器进行账号和密码的输入时，可能不会出现验证码的图片，所以需要在第一次进行输入时将密码输错，让登录页面弹出验证码的元素，然后使用 try except 去对验证码元素进行捕获，中文倒立文字的元素使用的 class 的名字是 “Captcha-chineseImg”，英文数字则是 “Captcha-englishImg”，同时在两个 except 中设置变量，如果其中某个元素没有获取，就代表当前使用的是另一种方式，将当前获取的变量设为 None，这样再去 if 判断，将两种验证码方式的逻辑分开</p><h6 id="倒立文字"><a href="#倒立文字" class="headerlink" title="倒立文字"></a>倒立文字</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ch_captcha_element:</span><br><span class="line"><span class="string">&quot;&quot;&quot;中文倒立文字验证码处理&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 获取得到验证码图片的 x 和 y 的坐标位置，这个坐标是验证码图片的左上角位置</span></span><br><span class="line">x_relative = ch_captcha_element.location[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">y_relative = ch_captcha_element.location[<span class="string">&quot;y&quot;</span>]</span><br><span class="line"><span class="comment"># execute_script 方法执行 js 的语句，这里是为了计算出浏览器的页面标签栏和搜索栏的 y 轴的宽度值</span></span><br><span class="line">browser_navigation_height = browser.execute_script(<span class="string">&quot;return window.outerHeight - window.innerHeight&quot;</span>)</span><br><span class="line"></span><br><span class="line">base64_text = ch_captcha_element.get_attribute(<span class="string">&quot;src&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># 知乎的图片使用的 base64 和 固定参数 编码后的结果，所以需要先替换没用的文本内容</span></span><br><span class="line">code = base64_text.replace(<span class="string">&quot;data:image/jpg;base64,&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;%0A&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># with open(&quot;ch_valid_code.jpeg&quot;, &quot;wb&quot;) as f:</span></span><br><span class="line"><span class="comment">#     f.write(base64.b64decode(code))</span></span><br><span class="line">fh = <span class="built_in">open</span>(<span class="string">&quot;ch_valid_code.jpeg&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">fh.write(base64.b64decode(code))</span><br><span class="line">fh.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zheye <span class="keyword">import</span> zheye  <span class="comment"># 导入 zheye 的包，使用它的方法来获取倒立文字的坐标参数</span></span><br><span class="line">z = zheye()</span><br><span class="line">    <span class="comment"># Recognize 会返回一个列表，每一个倒立文字会是一个元组形式，但是元组的第一个元素表示 y 坐标，第二元素才是 x 的坐标</span></span><br><span class="line">positions = z.Recognize(<span class="string">&#x27;ch_valid_code.jpeg&#x27;</span>)</span><br><span class="line">last_position = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(positions) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 含有两个倒立文字</span></span><br><span class="line"><span class="keyword">if</span> positions[<span class="number">0</span>][<span class="number">1</span>] &gt; positions[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">             <span class="comment"># 如果第二个元组 x 大于第一个的 x 坐标，则将两个元组位置互换，并将 x 作为第一个元素，y 作为第二个元素 </span></span><br><span class="line">last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line">last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 将每一个倒立文字的坐标值除以二，因为在浏览器的页面中，通过样式将验证码的图片长宽都缩小了一半</span></span><br><span class="line">firstfront_position = [<span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, <span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">secondfront_position = [<span class="built_in">int</span>(last_position[<span class="number">1</span>][<span class="number">0</span>]) / <span class="number">2</span>, <span class="built_in">int</span>(last_position[<span class="number">1</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用 mouse 的 move 输入两个坐标值，并用 click 进行点击</span></span><br><span class="line">move(x_relative + firstfront_position[<span class="number">0</span>], y_relative + browser_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">click()</span><br><span class="line">move(x_relative + secondfront_position[<span class="number">0</span>], y_relative + browser_navigation_height + secondfront_position[<span class="number">1</span>])</span><br><span class="line">click()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 只有一个倒立文字</span></span><br><span class="line">last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">firstfront_position = [<span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, <span class="built_in">int</span>(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">move(x_relative + firstfront_position[<span class="number">0</span>], y_relative + browser_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">click()</span><br><span class="line"></span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(<span class="string">&quot;15320146232&quot;</span>)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-password div input&quot;</span>).send_keys(<span class="string">&quot;w112233&quot;</span>)</span><br><span class="line"></span><br><span class="line">move(<span class="number">960</span>, <span class="number">645</span>)</span><br><span class="line">click()</span><br><span class="line">time.sleep(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> selenium 实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="/3391672429/"/>
      <url>/3391672429/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的内置数据结构和算法"><a href="#常用的内置数据结构和算法" class="headerlink" title="常用的内置数据结构和算法"></a>常用的内置数据结构和算法</h3><table><thead><tr><th>数据结构/算法</th><th>内置数据结构</th><th>内置库</th></tr></thead><tbody><tr><td>线性结构</td><td>list、tuple</td><td>arry(数组，不常用)、collecitons.namedtuple</td></tr><tr><td>链式结构</td><td></td><td>collections.deque(双端队列)</td></tr><tr><td>字典结构</td><td>dict</td><td>collections.Counter(计数器)、OrderedDict(有序字典)</td></tr><tr><td>集合结构</td><td>set、frozenset(不可变集合)</td><td></td></tr><tr><td>排序算法</td><td>sorted</td><td></td></tr><tr><td>二分算法</td><td></td><td>bisect 模块</td></tr><tr><td>堆算法</td><td></td><td>heapq 模块</td></tr><tr><td>缓存算法</td><td></td><td>functions.lru_cache(Least Recent Used，python3)</td></tr></tbody></table><h3 id="线性结构和链式结构"><a href="#线性结构和链式结构" class="headerlink" title="线性结构和链式结构"></a>线性结构和链式结构</h3><p>​    <strong>线性顺序：</strong>用一组地址连续的存储单元依次存储各个元素</p><p>​    <strong>线性链式：</strong>将元素节点分为两个部分，数据区存储真正的值，指针区所存储的是下一个元素节点的地址</p><p>​    <strong>优缺点：</strong></p><p>​    线性存储在读写的速度上相对要快，但是存储的结构在创建时，是有限制的（定长）的空间，即如果元素装满了，就需要重新申请一个更大的空间，再将原来的数据再次写入进去；空间的扩充是在原地址上重新申请更大的存储空间</p><p>​    链式存储不是顺序的，所以可以确定的一点是不需要担心空间的问题，但也因此相比线性顺序存储在读写的速度上要慢，并且每一个元素的节点中的指针要存储后面一个元素节点的地址，相比线性存储在存储的空间上要更大一些</p><p>​    简单来说，顺序存储例如列表（数组）在查找的时间复杂度上通过索引是 O(1)，链式存储则是 O(n)。但顺序存储在插入或删除的操作复杂度就是 O(n)，因为数据需要向后或向前移动调整，而链式存储在插入和删除的时间复杂度就是 O(1)</p><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>​    跳表的数据结构实际上是基于链式存储的一种变形，跳表对链表查询时间复杂度上进行了优化，<strong>主要的特点就是就是通过在链表上创建多级链表做为索引实现查询性能的提升</strong>，也就是利用空间换时间</p><p><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg?wh=1142*663" alt="img/md5.jpg"></p><p>​    通过多级索引的建立，当查找 16 这个元素时，只需要遍历 6 个节点就可以查找到，这相比在原链表上直接遍历查询要高效很多。假设每一级索引都是每两个节点去一个作为索引的节点，那么对于第一级索引的节点就 n/2，第二级索引就是 n/4，由此可见当进行查找时，<strong>时间复杂度是 O(m * logn)</strong>，而 m 最大为 3，因为每一级索引中需要遍历的只有三个节点，也就是索引区间的前后两个节点，以及中间节点和查找节点的比较</p><h3 id="字典底层结构"><a href="#字典底层结构" class="headerlink" title="字典底层结构"></a>字典底层结构</h3><p>​    字典的底层使用的是 hash 表（也可以称为散列表），所以在键值的查找上时间复杂度可以达到 O(1)，哈希表本身也是利用下标索引去找值，这个下标索引就是键，将键映射为下标利用算法找到对应的元素位置，所以哈希表也是数组的一种扩展。另外，<strong>哈希表 是由一个 直接寻址表 和一个 哈希函数 组成</strong></p><p>​    注意，<strong>hash 表的查找时间复杂读并不能完全意义上说是 O(1)，因为这与 hash 函数，装载程度，hash 冲突都有关系</strong>。当一个 hash 表的装载过多时，剩余的空位地址不足，会导致发生 hash 冲突的概率大幅提升，从而会使查找效率退化。同时，如果 hash 函数设计有问题，在遇到攻击者设计的数据后，这些数据可能会大量被经过 hash 函数后落在相同位置，从而应发冲突。如果解决冲突的方式是链表法，那么很有可能在查找时，大量时间可能会花在链表遍历上，也会导致时间复杂度退化到 O(n)</p><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>​    简单来说，哈希表毕竟是大小有限的，但是对于存储的数据来说，这个总量是无限的，所以势必会存在会 <strong>两个元素在使用哈希函数计算后得到同一个值，也就是两个数据最后被映射在了同一个位置，这就是 哈希冲突</strong></p><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>​    <strong>开放寻址法：</strong>如果经过哈希函数后，位置上已经有元素存在，则从该位置 <strong>往后探查</strong>，在探查到空位后将元素映射到该位置，包括以下三种探查的方式</p><p>​    <strong>线性探查：</strong>即如果位置 <code>i</code> 已有元素存在，则从该位置一次往后 <code>i+1，i+2，...，</code>依次一个个往后探查是否有空位来存放，遍历中有空位就在该位置存放，如果到最后没有空位则回到表头继续往后遍历。当查找时，通过 hash 函数后会按照同样的方式向后遍历查找</p><p>​    <strong>二次探查：</strong>即如果位置 <code>i</code> 已有元素存在，依然是从该位置往后探查，但是 <strong>步长</strong> 不同变为 二次方 <code>i + 1²，i - 1²，i + 2²，i - 2²，..</code>，即为 <code>i + 1，i - 1，i + 4，i - 4，i + 8，i - 8，...</code></p><p>​    <strong>双重散列：</strong>即 <strong>设置多个哈希函数</strong>，如果元素在使用第一个哈希函数后返回的值上有冲突了，就使用后续的哈希函数再次对其进行计算，然后判断是否还存在冲突，并如此重复到最后最后没有冲突</p><p>​    从二次探查和线性探查，可以很直接看出，使用线性探查的耗时会随数据量不断增多而增加，但也不是说线性探查就一定不好，如果数据量本身就比较少，线性探查就会比较好，如果使用二次探查可能会在扩充上有频繁的操作</p><p>​    使用开放寻址法方式，在删除元素时，则不能直接将值删除。因为这样做在查找时，线性探查只要找到空位就认为目标元素不存在，这样一来如果插入的值的位置在删除的元素后面，如果直接删除掉删除的元素，再去查找先前插入的元素就会有问题，所以使用线性探查的方式在删除元素时，是通过标记删除来标识，这样当查找先前插入的元素时，如果碰到被标记的 deleted 的元素，依然会向后遍历直到找到目标元素</p><p>​    所以线性探查的方式在 hash 表已经写入大量元素后，发生冲突的概率就会越来越高，那么在查找和删除时，时间复杂度就会退化到 O(n)</p><p>​    因此，<strong>当已知数据量比较小，且 hash 表的装载量也比较小（(已使用位置/表的大小) &lt; 1）的时候，使用开发寻址法是比较好的</strong></p><p>​    <strong>链表法：</strong></p><p>​    当在经过哈希函数后，两个元素在同一位置上有冲突，则在该位置上连接一个链表，原来存储的元素作为这个链表的第一个元素，如果新加入的元素位置与原来存储的元素位置冲突，新的元素就会被加在该位置的链表的最后</p><p>​    链表法相比开发寻址法，在 hash 表的装载量上的限制就没有那么高，即使装载量超过了 1，数据的写入只会使链表变长，虽然查找效率会降低，但这比开放寻址法的顺序查找还是要好些</p><p><img src="https://wei-foun.github.io/img/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" alt="img/md5.jpg"></p><p>​    但相对开发寻址来说，链表法需要存储指针，也就导致如果 hash 表存储的对象较少时，会占用很多的内存消耗，所以<strong>链表法更适用于存储大对象，大数据量的散列表</strong></p><p>​    除此之外，也可以更改链表法的存储，改为其他动态数据结构，例如跳表或红黑树，这样最后查找时间复杂度最多也是 O(logn)</p><h4 id="哈希表扩充"><a href="#哈希表扩充" class="headerlink" title="哈希表扩充"></a>哈希表扩充</h4><p>​    在之前的 核心技术 文章中，写到了 哈希表 的扩充，<strong>一般内部的空间会被保留 1/3 或 1/4，一旦装载量过大，这个备用的空间不足，就会触发一次扩充，需要注意一点的是，每一次的扩充都会对元素重新排列</strong></p><p>​    也就是说最好情况，就是插入没有触发扩容，那么时间复杂度就是 O(1)。<strong>如果触发了扩容机制，那么原 hash 表的所有数据会重新进行 hash 后散列到新 hash 表中新的位置上，这个时间复杂度就是 O(n)</strong></p><p>​    为了避免由于扩容导致的一次性将旧 hash 表数据全部迁移到新的 hash 表中导致的过多耗时，<strong>可以采取当扩容发生后，先将新插入的数据放入到新的 hash 表中，然后从旧 hash 表中也拿出一个数据将其放入到新 hash 表，这样每次插入新的数据，都会伴随一个旧 hash 表的数据写入，这样使用均摊的方式可以有效避免一次性迁移的耗时问题</strong></p><p>​    <strong>注意在使用新旧两个 hash 表后，查询先从新的 hash 表中查询，如果没有找到，再到旧 hash 表中查找</strong></p><h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>​    树是一种特殊的底层数据结构，树是由 n 个节点构成的一个集合，n=0 就是一棵空树，n&gt;0 时，就会有一个节点作为这棵树的根节点，根下的每一个节点来说也是一个集合</p><p>​    对于二叉树来说，很容易理解有两个分叉，由根节点分叉出左节点和右节点，而左右节点又可能会有各自的两个分叉，即每一个节点都可以有两个子节点，而两个子节点上的节点就是他们的父节点</p><p>​    在二叉树中，最顶部是单独的唯一节点，称为根节点，对于最后的节点，没有分叉的节点可以称为叶子节点</p><p>​    同时二叉树的深度，从根节点算起一直到最后叶子节点，根为第一层的话，根节点下的左右子节点就是第二层，以此类推</p><p>​    包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，<strong>第 K 层包含的节点个数就是 2^(K-1)</strong></p><p>​    根节点下，左右两个子节点也可以单独作为树，称为左子树和右子树</p><p>​    节点的度，可以理解为一个父节点下面的子节点个数，上面说到如果一个树只有根节点，那么根节点的度就是 0，如果一个子节点下只有一个左节点，没有右节点，那么这个子节点的度就是 1，所以 <strong>二叉树可以理解为是节点的度不超过 2 的树</strong></p><p>​    树的一些概念：</p><p>​    高度：节点到叶子节点的最长路径（边数），可以从节点位置往上数（从 0 开始）</p><p>​    深度：根节点到该节点经历的边的个数，可以从根节点向节点位置去数（同样从 0 开始）</p><p>​    层数：节点深度 +1，根节点的层数就是 1</p><p>​    树的高度：根节点的高度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                    高度     深度    层</span><br><span class="line">            A                        3        0      1</span><br><span class="line">      B           C                  2        1      2</span><br><span class="line">  D      E     F     G               1        2      3</span><br><span class="line">H   I  J                             0        3      4</span><br></pre></td></tr></table></figure><p>​    <strong>二叉树还有两个分类分别是：满二叉树，完全二叉树</strong></p><p>​    满二叉树，即二叉树的每一个节点，无论是左右子节点，他们的下面都会有两个节点，就是说每一层的节点数都达到了最大值，这就是满二叉树，就像是天秤，左右两边的 “重量” 是一样的</p><p>​    完全二叉树，简单理解可以认为是一棵 “不满的二叉树”，即左右子树中，可以有节点只有一个子节点，并且按照顺序，<strong>如果一个父节点只有一个子节点，这个子节点要在左侧</strong></p><p>​    所以 <strong>满二叉树 一定是 完全二叉树，但 完全二叉树 不是 满二叉树</strong></p><p>​    非完全二叉树，叶子节点并不绝对要从最左边开始，它并不遵守完全二叉树的规则</p><p><img src="https://wei-foun.github.io/img/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="img/md5.jpg"></p><p>​    <strong>二叉树的存储方式可以分为：链式存储 和 顺序存储</strong></p><p>​    链式存储，即每一个节点会分成三部分，左边是指向左子节点，中间是数据，右边则指向右子节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  leftchild  |  data  |  rightchild  |</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>​    顺序存储的方式可以看作是一个列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                   9</span><br><span class="line">        8                      7</span><br><span class="line">  6           5            0        1</span><br><span class="line">2   4      3</span><br><span class="line"></span><br><span class="line">[9, 8, 7, 6, 5, 0, 1, 2, 4, 3]</span><br></pre></td></tr></table></figure><p>​    按照列表下标是 0 开始，设父节点为 <code>i</code>，可以得到 <strong>父节点 与 左子节点 的关系是：<code>2 * i + 1</code></strong>；与 <strong>右子节点 的关系是：<code>2 * i + 2</code></strong></p><p>​    使用数组的顺序存储会相对要节省空间，而不完全的二叉树使用链表存储的方式</p><p>​    二叉树的遍历分为三种方式：前序遍历、中序遍历、后序遍历</p><p>​    <strong>前序遍历：对于任意节点，都是先打印当前这个节点，再去打印该节点的左子树，最后是右子树</strong></p><p>​    <strong>中序遍历：对于任意节点，都是先打印该节点的左子树，再是打印自身节点，最后是右子树</strong></p><p>​    <strong>后序遍历：对于任意节点，都是先打印该节点的左子树，然后是右子树，最后是自己</strong></p><p>​    <img src="https://wei-foun.github.io/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg" alt="img"></p><p>​    所以，整个二叉树的遍历，其实就是其中任意一种方式，利用递归思想去实现，注意三种遍历的结果是不相同的，可以根据具体场景去使用，<strong>如果想要实现倒序，那就是先去递归右边，再去递归左边</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;前序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;中序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    <span class="built_in">print</span>(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;后序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    <span class="built_in">print</span>(root.val) <span class="comment"># 根</span></span><br></pre></td></tr></table></figure><h3 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a>二叉搜索树（Binary Search Tree）</h3><p>​    对节点的值做了规定，如果这个树结构有左右两个子树，那么 <strong>左子树 上任意的节点上的值都是小于 根节点</strong> 的，<strong>右子树 上任意的节点值也都大于 根节点</strong></p><p><img src="https://wei-foun.github.io/img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="img"></p><h3 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h3><p>​    平衡二叉树要求，<strong>树结构中的任意一个节点，它的左右两个子树的高度差不能超过 1</strong>。一个节点的高度指的是，从它所在一侧的最底层叶子节点向上数的层数，比如下图中 50 这个子节点，它的高度是 2，而 125 这个子节点的高度是 0</p><p>​    左右子树的高度不能大于 1，即限制住左右子树的层数差，尽可能使得这棵树的左右节点的数量能够近似平衡，这样就避免了二叉树左右失衡的最糟结构，比如二叉树某一侧的节点关联过多，使得二叉树的一侧退化成链表的结构，导致查找性能骤降</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">           10</span><br><span class="line">         /    \</span><br><span class="line">        9     12 </span><br><span class="line">       /  </span><br><span class="line">      8</span><br><span class="line">     /                             # 二叉树结构的最糟情况，使得查找的时间复杂度变成 O(n)</span><br><span class="line">    7</span><br><span class="line">   /  </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>​    这也使得平衡二叉树在搜索上可以实现和二分法查找类似的效率，而且相比二分法查找需要的是一个有序的数组，是一个元素地址连续的容器，树的结构在扩充上相对要高效</p><p><img src="https://wei-foun.github.io/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="img"></p><h4 id="平衡二叉查找树和散列表"><a href="#平衡二叉查找树和散列表" class="headerlink" title="平衡二叉查找树和散列表"></a>平衡二叉查找树和散列表</h4><p>​    <strong>平衡二叉查找树在节点的插入，删除，查找上时间复杂度可达到 O(logn)</strong>，而使用散列表的字典结构同样的操作在时间复杂度上则可以是常量级的 O(1)。但是，平衡二叉查找树相比起散列表来说，有其独特的优势</p><p>​    散列表的数据存储是无序的，而平衡二叉查找树得益于左右子树的设定，通过中序遍历可以在 O(n) 的时间复杂度内完成有序输出。其次，散列表在遇到哈希冲突的情况下，依赖于哈希函数以及策略，在不稳定的情况下明显会更加耗时，平衡二叉查找树相对而言要更加稳定</p><p>​    散列表的结构需要考虑的因素要更多，比如哈希函数，哈希冲突策略，装填比列和扩容。平衡二叉查找树则只需关注树的平衡性</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>​    R-B Tree，顾名思义在红黑树中，节点有两种颜色区分，分别是红色和黑色。红黑色是一种特殊的二叉树，是平衡二叉树的一种延伸优化，因为 <strong>平衡二叉树的要求是左右子树的高度不能超过 1，使得平衡二叉树在节点的插入和删除操作的同时对树结构的要求非常严格，可能会涉及到大量的节点和结构的调整。而红黑树相对而言对树的结构在平衡性上没有那么严格，只要结构能够趋近平衡，从而不影响在查找效率，所以相对在节点的添加和删除上实现要较容易</strong></p><p>​    <strong>Java 集合中的 TreeSet 和 TreeMap，C++ STL 中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的</strong></p><p>​    <strong>红黑树的特性：</strong></p><p>​    <strong>1）节点只有红和黑两种颜色，并且树的根节点颜色是黑色</strong></p><p>​    <strong>2）树的每一个叶子节点通过 NIL 或 NULL 表示，并且叶子节点的颜色也是黑色，即叶子节点本身不存数据</strong></p><p>​    <strong>3）如果一个节点的颜色是红色，那么它的两个子节点也都必须是黑色（即所有的路径上不能存在连续两个红色节点）</strong></p><p>​    <strong>4）从一个节点到该节点的子孙节点的所有路径上包含的黑色节点数量是相同的</strong></p><p>​    <img src="https://wei-foun.github.io/img/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt="img"></p><p>​    第 4 个性质，可以反推出来得到，如果一个节点存在黑子节点，那么该节点肯定有两个节点。同时，该性质的黑色节点数量，还可以理解成从任意一个叶子节点到根节点或其他其他节点，层数都是相同的，即俗称的 “黑高”</p><p>​    注意：红黑树并不完全是一个平衡二叉树，因为满足第 4 个性质的红黑树中，可能会有一边的子树比另一边要高的情况，但是只要满足第 4 性质，黑高是相同的，那么这个红黑树就不会完全失衡，就可以称为是黑色完美平衡，所以红黑树可以保证稳定的时间复杂度是 O(logn)</p><p>​    <strong>红黑树维持平衡主要有三个操作：变色，左旋，右旋</strong></p><p>​    变色：即红色变黑色，或者黑色变红色</p><p>​    左旋：向左边旋转某个节点，将该节点的右子节点上升变为该节点的父节点，同时这个右子节点的左子节点变为要旋转的节点</p><p><img src="https://wei-foun.github.io/img/%E5%B7%A6%E6%97%8B.gif" alt="img"></p><p>​    右旋：向右边旋转某个节点，将该节点的左子节点上升变为该节点的父节点，同时这个左子节点的右子节点变为要旋转的节点</p><p><img src="https://wei-foun.github.io/img/%E5%8F%B3%E6%97%8B.gif" alt="img"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>​    <strong>B 树 是一种 多路搜索树</strong>，包括以下特点：</p><p>​    <strong>1）根节点可以有 m 个子节点，这个 m 要至少是大于等于 2</strong></p><p>​    <strong>2）非叶子节点的子节点数是 [m/2，m]</strong></p><p>​    <strong>3）每一个节点中，最少要存放 m/2 - 1（向上取整）个关键字，最多存放 m-1 个关键字，其中每一个节点至少是要有两个关键字</strong></p><p>​    <strong>4）非叶子节点的关键字个数，是指向叶子节点的指针个数 - 1</strong></p><p>​    <strong>5）非叶子节点的关键字，排序是 k[1]，k[2]，…，k[m-1]，大小总是 k[i] &lt; k[i+1]，即是一个升序排列</strong></p><p>​    <strong>6）非叶子节点的指针，比如一个非叶子节点有 m 个指针，p[1] 指针指向的子节点的关键字是 小于 k[1] 的子树，p[m] 就指向大于 k[m-1]，中件的指针 p[i] 指向的子树是大于 k[i-1]，小于 k[i]</strong></p><p>​    <strong>7）整个 B 树 上的所有叶子节点都在同一层</strong></p><p><img src="https://wei-foun.github.io/img/B%E6%A0%91.jpg" alt="img"></p><p>​    如果是一个 5 阶 B 树，也就是说非叶子节点的关键字最大有 4 个，对应的指针就是有 5 个，即使这个节点中只有 2 个关键字，也是属于 5 阶 B 树</p><p>​    B 树总的来说，每个节点都会有数据和关键字的存储，而关键字则可以用来作为索引加速搜索，但是 B 树的非叶子节点相互之间没有联系，也就说 B 树结构不适合做区间的搜索，但是对于可能访问的节点，在 B 树上查找会很快，这也正是因为除了非叶子节点外，其他的节点上也会存放数据</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>​    实际上与 B 树 非常相似，但是最明显的区别是，<strong>B+ 树 的 非叶子节点 上并不存储数据，非叶子节点 的目的用来做叶子节点的索引，叶子节点上包含所有的关键字，指向真正的记录</strong></p><p>​    对于非叶子节点中每一索引项，都对应着子树结构中最大关键字和指向该子树的指针</p><p>​    除此之外，<strong>B+ 树 中叶子节点以单链表的形式进行关联</strong>，使得查询效率更高</p><p>​    另外，与 B 树 不同的是，在 B 树 中非叶子节点有 n 个关键字，则会有 n+1 个指针（分支），而在 B+ 树 中非叶子节点有 n 个关键字，就是有 n 个分支</p><p>​    而且，B 树 非叶子节点的关键字个数是 m/2 - 1 到 m - 1 个，而 B+ 树 上非叶子节点的关键字个数是 m/2 到 m 个</p><p><img src="https://wei-foun.github.io/img/B+%E6%A0%91.jpg" alt="img"></p><p>​    B+ 树除了只将数据存在叶子节点上，还通过顺序指针让各个叶子节点能够实现关联，这样一来 B+ 树的结构就优化了 B 树不能做区间搜索的问题，相比 B 树的非叶子节点来说，B+ 树的非叶子节点不存放数据，所以相对而言 B 树层数靠上越容易得到数据，而 B+ 树则必须要到叶子节点获取，但是 B+ 将非叶子节点的数据省去可以存放更多的指针来做索引，这样一来 <strong>对比 B 树，B+ 树的树高会更矮，搜索效率会更高</strong> </p><h3 id="LruCache-缓存算法"><a href="#LruCache-缓存算法" class="headerlink" title="LruCache 缓存算法"></a>LruCache 缓存算法</h3><p>​    <strong>Least Recently Used，即最近最少使用的，核心思想是将近期使用次数最少的缓存对象进行淘汰删除</strong>，将空间留给使用频繁，和最近加入的新的缓存对象</p><p>​    LRU 只是众多缓存提出策略中的一种，除此之外还有 LFU (优先淘汰使用次数最少的，LRU 则是时间上的概念，优先删除使用时间最久的)，随机选择剔除或是直接使用队列来做为缓存容器等等</p><p>​    对于 LRU 的实现来说，使用循环双端队列不断把最新的访问对象放在表头，将访问时间离得最久的则是移动末尾，python 中可以利用 OrderedDict 来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lru</span>：</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_num=<span class="number">64</span></span>):</span><br><span class="line">self.od = OrderedDict()</span><br><span class="line">self.max_num = max_num</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> self.od:</span><br><span class="line">             val = self.od[key]    </span><br><span class="line">             self.od.move_to_end(key)</span><br><span class="line">             <span class="keyword">return</span> val</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, val</span>)：</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(self.od) == self.capacity <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.od:</span><br><span class="line">         self.od.popitem(last=<span class="literal">False</span>)</span><br><span class="line">         self.od[key] = value</span><br><span class="line">         self.od.move_to_end(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lru = Lru(max_num=<span class="number">4</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3), (&#x27;d&#x27;, 4)])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lru.get(<span class="string">&#x27;c&#x27;</span>))            <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;d&#x27;, 4), (&#x27;c&#x27;, 3)])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lru.get(<span class="string">&#x27;a&#x27;</span>))            <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;b&#x27;, 2), (&#x27;d&#x27;, 4), (&#x27;c&#x27;, 3), (&#x27;a&#x27;, 1)])</span></span><br><span class="line"></span><br><span class="line">lru.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;d&#x27;, 4), (&#x27;c&#x27;, 3), (&#x27;a&#x27;, 1), (&#x27;e&#x27;, 5)])</span></span><br></pre></td></tr></table></figure><p>​    <strong>OrderedDict 实际上使用两种数据结构，hash 表来存储 键-值 对，保证查找和删除的时间复杂度，同时利用了双向链表，实现将 键-值 对的节点关联以此体现有序性</strong>。在 OrderedDict 的实现中，通过 root 作为 双向链表 的头部，当插入一个新节点，会将这个节点的 next 指向 root，后续插入的节点的 next 依次指向上一个插入节点</p><h3 id="利用内置数据结构实现更高级的数据结构"><a href="#利用内置数据结构实现更高级的数据结构" class="headerlink" title="利用内置数据结构实现更高级的数据结构"></a>利用内置数据结构实现更高级的数据结构</h3><p>​    通常情况下，随着业务需求或数据量非常大的情况下，依然去使用 python 自带的基本数据结构就会显得有些心有余而力不足，python 中内置的结构里没有 链表，队列，栈，二叉树，堆 这样更为高级的结构，但是 python 的内置库 collections 或修改 列表 也能去实现如队列和链表等结构</p><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>​    链表又分三种：<strong>单链表，双向链表，循环双端链表</strong></p><p><img src="https://wei-foun.github.io/img/linklist.jpg" alt="img/md5.jpg"> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建节点类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data = data     <span class="comment"># 存储值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>     <span class="comment"># 作为指针，用来存储下一个节点</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linklist</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,li</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">        self.create_linklist_tail(li)     </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_linklist_tail</span>(<span class="params">self, li</span>):</span><br><span class="line">        self.head = Node(<span class="number">0</span>)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> li:</span><br><span class="line">            n = Node(v)</span><br><span class="line">            self.tail.<span class="built_in">next</span> = n</span><br><span class="line">            self.tail = n</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_linklist</span>(<span class="params">self</span>):</span><br><span class="line">        p = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span>(p.data)</span><br><span class="line">            p = p.<span class="built_in">next</span>           </span><br><span class="line"></span><br><span class="line">li = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">linklist = Linklist(li)</span><br><span class="line">linklist.print_linklist()</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure><p>​    Node 类用于初始化元素作为链表中的节点，Linklist 类用于创建单向的链表，其中 create_linklist_tail 表示尾插法，该方法中首先修改类中初始化的头尾节点，头结点赋予值为 0，同时将尾结点赋为头结点，然后利用循环，将传入的列表中的每一个元素实例化为一个节点，并且实例化一个节点后，需要修改尾结点指向，将尾结点的 next 指向当前的元素节点，尾结点赋值为当前元素节点，目的是为了，下一个元素节点进来后，让前一个元素的 next 可以指向自己，并且为了将 next 去指向后面可能还有的元素节点，所以将尾结点赋值为当前加入的节点</p><p>​    Linklist 类中的 print_linklist 方法是为了将元素通过调用节点的 next 进行一一输出，因为在建立节点是，为了清晰一些，给 head 的头节点，也就是整个链表的第一个节点赋上 0 这个值，所以方法中做了一步 p = self.head.next，来从第二个节点去开始遍历</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>​    队列同样分好几种，常见的有先进先出，优先级队列等等，同样可以用 collections 模块和内置的 list 去实现，但是如果利用 list 去实现队列，要实现比如在最前面插入一个元素，那么就需要原来的所有元素后移，将位置让出后进行插入，相对而言就会比较麻烦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft()     <span class="comment"># FIFO 先进先出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">q.append(<span class="number">1</span>)</span><br><span class="line">q.append(<span class="number">2</span>)</span><br><span class="line">q.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(q.pop())      <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(q.pop())      <span class="comment"># 2 </span></span><br><span class="line"><span class="built_in">print</span>(q.pop())      <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(q.empty())    <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>​    是一种和 队列 非常相似的结构，与 FIFO 的队列不同，栈的元素存储和获取是一个 <strong>后进先出（LIFO）</strong>的效果，同样可以用内置的 list 和 collections 模块去实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = deque()    <span class="comment"># self.stack = []</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Stack()</span><br><span class="line">s.append(<span class="number">1</span>)   </span><br><span class="line">s.append(<span class="number">2</span>)</span><br><span class="line">s.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(s.pop())       <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(s.pop())       <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(s.pop())       <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(s.empty())     <span class="comment"># True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python2 与 python3 的区别</title>
      <link href="/4125439603/"/>
      <url>/4125439603/</url>
      
        <content type="html"><![CDATA[<h3 id="py2-和-py3-的区别"><a href="#py2-和-py3-的区别" class="headerlink" title="py2 和 py3 的区别"></a>py2 和 py3 的区别</h3><h4 id="输入与输出的区别"><a href="#输入与输出的区别" class="headerlink" title="输入与输出的区别"></a>输入与输出的区别</h4><p>​    <strong>对于输入，python2 中使用的是 raw_input，python3 则直接是 input 函数</strong></p><p>​    <strong>对于输出，python2 中 print 是一个关键字，python3 中 print 则是将其改成了函数</strong>，所以在 py3  中使用 print 必须加上 ‘ () ‘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># py3 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># a </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># py2 的 print 也是可以加 ()，但是输出则是一个元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;)</span></span><br></pre></td></tr></table></figure><p>​    补充：如果要在 py2 中想要和 py3 一样使用 print 作为函数来调用，需要需引入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure><h4 id="编码不同"><a href="#编码不同" class="headerlink" title="编码不同"></a>编码不同</h4><p>​    <strong>python2  中使用 ASCII 码，python3 则使用 utf-8</strong>，所以可能常见到在 py2 的文件中最上方会有 <code>＃-*-coding:utf-8-*-</code> 来指明使用 utf-8 编码，py3 则可以不用去主动添加</p><p>​    补充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2.7</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.now()</span><br><span class="line"><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%m月%d日 %H:%M&#x27;</span>))</span><br><span class="line"><span class="comment"># UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode character &#x27;\u6708&#x27; in position 2: encoding error</span></span><br><span class="line"><span class="comment"># 在 2.7 中如果日期的格式化中有中文，需要通过 .encode(&#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%m月%d日 %H:%M&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">now = datetime.now()</span><br><span class="line"><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%m月%d日 %H:%M&#x27;</span>))</span><br><span class="line"><span class="comment"># UnicodeEncodeError: &#x27;locale&#x27; codec can&#x27;t encode character &#x27;\u6708&#x27; in position 2: encoding error</span></span><br><span class="line"><span class="comment"># 在 3 的版本中，如果要格式化需要使用字符串的 format 方法</span></span><br><span class="line"><span class="built_in">print</span>(now.strftime(<span class="string">&#x27;%m&#123;y&#125;%d&#123;d&#125; %H:%M&#x27;</span>).<span class="built_in">format</span>(y=<span class="string">&#x27;月&#x27;</span>, d=<span class="string">&#x27;日&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h4><p>​    <strong>py2 中如果要定义中文的字符或字符串，需要加上 ‘ u ‘ 的前缀，因为在 py2  中字符串的类型使用的是 unicode</strong>，不使用这个前缀的字符串或字符，都是利用字节去储存</p><p>​    py3 中字符串的类型直接是 str，并且支持 unicode，所以 py3 可以直接定义中文字符，对于字节来说，py3 使用的前缀是 ‘ b ‘ 来表示；如果要传输中文字符，需要 encode 方法去编码成字节串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">b&#x27;60.210.133.62:9000&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s))                       <span class="comment"># &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(s, encoding=<span class="string">&#x27;utf8&#x27;</span>))       <span class="comment"># 60.210.133.62:9000</span></span><br></pre></td></tr></table></figure><h4 id="计算除法"><a href="#计算除法" class="headerlink" title="计算除法"></a>计算除法</h4><p>​    <strong>py2 中使用 ‘ / ‘ 做整数除法操作后，得到的结果是会是整型</strong>，且会对结果进行截断，只取前面的整数</p><p>​    <strong>py3 中的整数除法操作，会得到一个 float，如果需要得到整型值，需要使用整除符号 ‘ // ‘</strong></p><h4 id="注解提示"><a href="#注解提示" class="headerlink" title="注解提示"></a>注解提示</h4><p>​    这是 py3 做的一个小改进之一，目的是方便 IDE 对参数类型进行检查提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">8</span>))    <span class="comment"># 64</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func(<span class="string">&#x27;8&#x27;</span>))    <span class="comment"># TypeError: can&#x27;t multiply sequence by non-int of type &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><p>​    在 pycharm 中，上面的 ‘8’  会被用黄色底标记提示参数类型问题，如果去除注解提示，则不会显示这个问题，所以这个注解提示的主要目的是进行提示</p><p>​    补充：这个注解提示并不完全的对类型进行检查和限制，如果需要执行参数类型检查，可以使用第三方的 mypy 库</p><h4 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h4><p>​    这是 py2 不支持的， <strong>py3 中利用 <code>*</code> 可以对集合参数进行打散解包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b, *c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(a)               <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(b)               <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># [3,4,5]</span></span><br></pre></td></tr></table></figure><h4 id="限定关键字指明传参"><a href="#限定关键字指明传参" class="headerlink" title="限定关键字指明传参"></a>限定关键字指明传参</h4><p>​    同样是 py3 的一个语法，要求函数中 ‘ * ‘ 之后的参数在传递时，需要指明参数的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, *, c</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))       <span class="comment"># TypeError: func() takes 2 positional arguments but 3 were given</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>))     <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h4 id="chained-exception"><a href="#chained-exception" class="headerlink" title="chained exception"></a>chained exception</h4><p>​    在 py2 中如果需要在一个异常中再去抛出一个异常，那么后者的异常信息栈会被忽略掉，py3 中则更好的支持这个，可以将链式的异常信息栈全部保留，来更好的去进行排错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://www.bccn.net/run/  使用 编程中国 在线的 py 环境</span></span><br><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mycopy</span>(<span class="params">source, dest</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        shutil.copy2(source, dest)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">raise</span> <span class="literal">NotImplemented</span>(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mycopy(<span class="string">&#x27;old&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;2404985.py&quot;</span>, line <span class="number">19</span>, <span class="keyword">in</span> </span><br><span class="line">    mycopy(<span class="string">&#x27;old&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;2404985.py&quot;</span>, line <span class="number">14</span>, <span class="keyword">in</span> mycopy</span><br><span class="line">    shutil.copy2(source, dest)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/shutil.py&quot;</span>, line <span class="number">130</span>, <span class="keyword">in</span> copy2</span><br><span class="line">    copyfile(src, dst)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/shutil.py&quot;</span>, line <span class="number">82</span>, <span class="keyword">in</span> copyfile</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">IOError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;old&#x27;</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># py3</span></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;8725165.py&quot;</span>, line <span class="number">14</span>, <span class="keyword">in</span> mycopy</span><br><span class="line">    shutil.copy2(source, dest)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.5/shutil.py&quot;</span>, line <span class="number">251</span>, <span class="keyword">in</span> copy2</span><br><span class="line">    copyfile(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.5/shutil.py&quot;</span>, line <span class="number">114</span>, <span class="keyword">in</span> copyfile</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(src, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;old&#x27;</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;8725165.py&quot;</span>, line <span class="number">19</span>, <span class="keyword">in</span> </span><br><span class="line">    mycopy(<span class="string">&#x27;old&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;8725165.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> mycopy</span><br><span class="line">    <span class="keyword">raise</span> <span class="literal">NotImplemented</span>(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">TypeError: <span class="string">&#x27;NotImplementedType&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></table></figure><h4 id="内置的迭代"><a href="#内置的迭代" class="headerlink" title="内置的迭代"></a>内置的迭代</h4><p>​    <strong>在 py2 中内置函数返回列表的，在 py3 中则被改进为返回迭代对象</strong>，例如：<strong>range，zip，map，dict.values 等等</strong>，使用迭代器对象返回的好处自然就是为了节省内存，有其是在大量数据的集合更为明显</p><p>​    另外，<strong>py2 中 range 返回列表，如果也想返回迭代器可以使用另一种 xrange，而在 py3 中舍弃了原来返回列表的 range ，而直接使用返回迭代器的 xrange，但是函数名依旧是使用 range</strong></p><h4 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h4><p>​    在 <strong>py2 中有一个判断符 <code>&lt;&gt;</code> 表示不等于，在 py3 中则被废弃，统一使用 <code>!=</code></strong></p><h4 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a>pyc</h4><p>​    相比 py2，在 3 中导入的模块所产生的 pyc 文件都会被统一放入一个文件夹 <code>__pycache__</code></p><h3 id="py3-的新增"><a href="#py3-的新增" class="headerlink" title="py3 的新增"></a>py3 的新增</h3><h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><p>​    生成器中增加了一个 <code>yield from</code> 语法，来连接子生成器，当然也可以是迭代器或是可迭代对象，可以理解他相比直接用 <code>yield</code> ，可以减少循环嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mychain</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> args:</span><br><span class="line">        <span class="comment"># print(obj)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">c = mychain(&#123;<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>&#125;,[<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mychain1</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> obj</span><br><span class="line"></span><br><span class="line">c = mychain1(&#123;<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>&#125;,[<span class="string">&#x27;abc&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="新增内置库"><a href="#新增内置库" class="headerlink" title="新增内置库"></a>新增内置库</h4><p>​    <strong>asyncio：</strong>这是一个新增的用来处理异步并发的库，提供关键字 async / await 提供简便的方式让协程支持异步编程</p><p>​    <strong>enum：</strong>新增的枚举库，可以得到元素的下标索引</p><p>​    <strong>concurrent.futures：</strong>提供简便接口来实现线程，进程与池等相关的创建</p><p>​    除此之外，py3 还有其他的新增和改进</p><h3 id="py2-转-3"><a href="#py2-转-3" class="headerlink" title="py2 转 3"></a>py2 转 3</h3><p>​    1） six 模块</p><p>​    2）2to3 等工具也可以实现代码转换</p><p>​    3） <code>__future__</code> 模块，可以在 py2 中去支持 py3 的一些实现</p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> py 2 和 3 的区别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 整理</title>
      <link href="/1895144058/"/>
      <url>/1895144058/</url>
      
        <content type="html"><![CDATA[<h3 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h3><p>​    一句话概括 “描述事物的符号记录”</p><h3 id="数据库（Database，DB）"><a href="#数据库（Database，DB）" class="headerlink" title="数据库（Database，DB）"></a>数据库（Database，DB）</h3><p>​    一句话概括 “按照数据结构来组织、存储和管理数据的仓库”</p><h3 id="数据管理系统（Database-Management-System，DBMS）"><a href="#数据管理系统（Database-Management-System，DBMS）" class="headerlink" title="数据管理系统（Database Management System，DBMS）"></a>数据管理系统（Database Management System，DBMS）</h3><p>​    即为了对数据库进行管理而设计的软件系统，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的增删改查操作和用户管理以及权限管理等</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>​    根据基本的实现可以分为：关系型数据库，非关系性数据库（NoSQL）</p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>​    MySQL 就是一个非常流行的关系型数据库（Relational Database Management System），关系型数据的存储格式可以直观地反映实体间的关系，在关系型数据库中：数据以表格的形式出现，每一行是各个记录的名称，每一列为记录名所对应的数据域，多个行和列会形成一张表，多张表最后组成一个数据库</p><p>​    关系型数据库除了基础的库，表，行，列之外，还有一些其他的术语：</p><p>​    1）主键：在表中是唯一的，一张表只能拥有一个字段（列）设为主键</p><p>​    2）外键：用于和其他的表形成关联，一张表中可以拥有多个外键，关联多个不同的表</p><p>​    3）复合键：将多个列作为一个索引键</p><p>​    4）索引：是对表中一列或多列的值进行排序的一种结构，用来快速查找指定的信息</p><p>​    5）冗余：相同的数据存储了两次，冗余会降低性能</p><p>​    6）参照完整性：及不允许一同不存在的实体，与实体完整性是关系模型必须满足的完整性约束条件， 目的是为了保证数据的一致性</p><p>​    除了 mysql 一种关系型数据库外，当然还有 sqllite，db2，oracle，sqlserver 等，他们各自之间都存在不同的差异，但是对于大部分的 sql 语句来说在关系型数据库上都可以使用</p><h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p>​    是随着技术的快速发展而不断扩展的一种数据库，简化了存储的数据结构并舍去了表结构，支持快速的查找需求，<strong>非关系型数据库可以分为四大类：键值对（key-value）存储结构（Redis），列存储，文档数据库存储（MongoDB），图形数据存储</strong></p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>​    SQL 是由 IBM 开发的，用户存储、查询、更新和管理数据库系统的语言，简单可分为 4 种：DDL，DQL，DML，DCL；除此之外还有 DPL（事务处理语言），CCL（指针控制语言）</p><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>​    <strong>数据定义语言</strong> ，即 数据库、表、视图、索引、存储过程，例如 CREATE ，DROP， ALTER </p><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><p>​    <strong>数据查询语言</strong> ，查询数据（SELECT）</p><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>​    <strong>数据操纵语言</strong> ，即 插入数据（INSERT）、删除数据（DELETE）、更新数据（UPDATE）</p><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>​    <strong>数据控制语言</strong> ，即 控制用户的访问权限（GRANT）等 </p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h4><p>​    是一个基于 CS 架构的服务器软件</p><p>​    mysql 服务端：1）server 端开启    2）解析指令    3）对库，表，记录进行 crud 操作</p><p>​    mysql 客户端：1）连接服务端        2）发送指令（sql 语句）</p><p><img src="https://wei-foun.github.io/img/mysql.png" alt="img/md5.jpg"></p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>​    MySQL有很多不同的引擎，对于不同的应用场景可以选择合适的存储引擎来存储数据，例如：MyISAM，InnoDB，Memory，CSV 等等</p><p>​    <strong>MyISAM：用来管理非事务表，可以提供高速存储和检索，以及全文搜索能力，不支持外键</strong>，是 5.5 之前使用的默认存储引擎</p><p>​    <strong>InnoDB：支持事务，也支持外键，同时也支持崩溃修复能力和并发控制（MVCC），5.5 之后使用的默认存储引擎</strong></p><p>​    Memory：即将数据全部会存在内存中，特点就是速度极快，但也因此不安全，而且表的大小受内存限制，也就是不能存储大量的数据</p><p>​    CSV：将数据使用逗号来隔开的形式存储在文件中</p><p>​    <strong>‘.frm’</strong> 文件存储的是 <strong>表的结构</strong> ，在 lnnoDB 的存储中，<strong>‘.ibd’</strong> 文件存储的表中的 <strong>数据</strong>；MyISAM 中，表的数据文件后缀则是 <strong>‘.MYD’</strong>，另外 MyISAM 还有一个索引文件 <strong>‘.MYI’</strong>，如果是 Memory 作为使用的存储引擎则只会有 ‘.frm’ 的表结构文件，不会生成数据的文件</p><h4 id="可存储的数据类型"><a href="#可存储的数据类型" class="headerlink" title="可存储的数据类型"></a>可存储的数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 整数类型（默认是使用有符号的，无符号的话就是从 0 开始到有符号的两数之和）</span><br><span class="line">tinyint  1字节   （-128，127）</span><br><span class="line">int      4字节    (-2 147 483 648，2 147 483 647)</span><br><span class="line">bigint   8字节    (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</span><br><span class="line"></span><br><span class="line"># 建表时，设置 modify unsigned 使用无符号数字</span><br><span class="line">alter table t1 modify unsigned;</span><br><span class="line"></span><br><span class="line"># 对于数字，还可以设置 modify zerofill 来对长度不足的数据前面填充 0，例如月份 1 的填充就为 01</span><br><span class="line"># 其次，对于整数类型括号中的数字来说，并不影响存储，int(2) 依然能存储 2³²-1 长度的数字</span><br><span class="line">`month` int(2) unsigned zerofill</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 浮点数类型</span><br><span class="line">float     单精度   4字节     小数位越多   数据会不精准</span><br><span class="line">double    双精度   8字节     小数位越多   数据同样会不精准</span><br><span class="line">decimal  （m，d），m&gt;d，m+2 字节，否则 d+2 字节，是以字符串形式进行存储，始终精准</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日期与时间类型</span><br><span class="line">date       3 字节  年月日  YYYY-MM-DD</span><br><span class="line">time       3 字节  时分秒  HH:MM:SS</span><br><span class="line">year       1 字节  年              YYYY</span><br><span class="line">datetime   8 字节  年月日时分秒    YYYY-MM-DD HH:MM:SS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 字符串类型</span><br><span class="line">char         0-255 字节            定长（超出固定长度会报错），简单粗暴，浪费空间（使用空格来满足长度），存取速度快</span><br><span class="line">varchar      0-65535 字节          变长，精准，节省空间，存取速度慢</span><br><span class="line">tinyblob     0-255 字节         不超过 255 个字符的二进制字符串</span><br><span class="line">tinytext     0-255 字节         短文本字符串</span><br><span class="line">longtext     0-4294967295 字节 极大文本数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 枚举类型和集合类型</span><br><span class="line">enum    表示单选</span><br><span class="line">set     表示多选</span><br><span class="line"># 两者的子弹只能是指定的范围中选择，存储其他的值则会为空</span><br></pre></td></tr></table></figure><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><p>​    简单理解就是，对要写入磁盘的数据进行检测，防止不符合定义和规范的数据，来保证数据库中存储的数据是正确和有效性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="keyword">null</span>        # 该列的值不能为空</span><br><span class="line"><span class="keyword">null</span>            # 可以为空</span><br><span class="line"><span class="keyword">default</span> 值      # 设置默认值，如果插入数据没有设置该列的值，就使用这个默认值</span><br><span class="line"><span class="keyword">unique</span>          # 设置单列唯一，即该列上记录的值不能有重复</span><br><span class="line"><span class="keyword">unique</span>(列<span class="number">1</span>,列<span class="number">2.</span>.)    # 联合唯一，设置记录的多个列上的值不可重复</span><br><span class="line"></span><br><span class="line"><span class="keyword">primary</span> key     # 主键，自带唯一与不能为空的约束，所以不能给多个列都去加主键，但是可以使用复合主键，类似联合唯一</span><br><span class="line">单列主键：  id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">多列主键：  <span class="keyword">primary</span> key(ip,port),</span><br><span class="line"></span><br><span class="line">auto_increment       # 约束列的自动增加，前提是该列是整数类型</span><br><span class="line">自增主键：id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">创建记录时指定了 id，即使用指定的 id，如果没有，则在最后记录的 id 值上进行 <span class="operator">+</span><span class="number">1</span> 作为这次的 id</span><br><span class="line">并且如果删除一个记录后，新记录的 id 依旧是使用删除前 id 的值 <span class="operator">+</span><span class="number">1</span> 来自增</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreign</span> key     # 外键，建立两表的关系</span><br><span class="line"># 注意：</span><br><span class="line"># 创建外键时，需要加上 </span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade    # 表示同步删除           <span class="keyword">on</span> <span class="keyword">update</span> cascade    # 表示同步更新</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"># 部门表（被关联表）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dep(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">comment <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 员工表（关联表）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_info(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dep_id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">constraint</span> FK_depid_id <span class="keyword">foreign</span> key(dep_id) <span class="keyword">references</span> dep(id)   <span class="comment">-- references 表示关联</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> cascade  # 关联的表删了，被关联的表也删了</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade  # 关联的表修改了，被关联的表也修改了</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># <span class="keyword">constraint</span> FK_depid_id <span class="keyword">foreign</span> key(dep_id) <span class="keyword">references</span> dep(id)</span><br><span class="line"># <span class="keyword">constraint</span> 约束名 <span class="keyword">foreign</span> key(列) <span class="keyword">references</span> 关联表(列)</span><br><span class="line"># 注意：</span><br><span class="line"># <span class="keyword">constraint</span> 约束名，也可以不用自己写，这样系统会产生一个约束名来标记这个外键</span><br><span class="line"></span><br><span class="line"># 使用外键会有三种关系：一对一、一对多、多对多；对于外键关联是多对多的关系情况下，会需要第三张表，用该表做关联表和被关联表的中间表</span><br></pre></td></tr></table></figure><h4 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h4><p>​    常用的是三大范式，除此之外关系型数据库有六个范式，巴斯-科德范式，第四范式，第五范式</p><p>​    <strong>第一范式（1NF）：是对属性的原子性约束，要求字段（列）必须是不可分解的原子数据项</strong>；例如地址信息，如果是 “上海市，虹口区”，这样就不行，需要查出来，分为两个列  “省（市）”  和  “县（区）” 来进行存储</p><p>​    <strong>第二范式（2NF）：满足第一范式的基础上，要求非主属性不能出现部分依赖主键</strong>，即每一列都与主键相关，不能只与主键的某一部分相关（主要针对联合主键而言）；例如订单表来说，一个订单会有多个产品，所以是 “订单号” 与 “产品号” 组成一个联合主键，但是对于 “金额” 和 “订单时间” 两个列，他们与产品并没有关系，如果这些存储在一张表中，就无法满足第二范式，所以可以拆出两个表将 “订单号” ，”金额” 和 “订单时间” 另组一张表</p><p>​    <strong>第三范式（3NF）：满足第二范式的基础上，要求非主键字段不能出现依赖传递</strong></p><h4 id="查询语句关键字"><a href="#查询语句关键字" class="headerlink" title="查询语句关键字"></a>查询语句关键字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name,column_name FROM ..     # 表示从表中选取数据返回</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT column_name,column_name    # 表示从表中返回唯一的不同的结果</span><br><span class="line"></span><br><span class="line">WHERE            # 指定条件，找出满足条件的数据</span><br><span class="line"></span><br><span class="line">AND / OR         # 用于多个字段之间关系</span><br><span class="line"></span><br><span class="line">ORDER BY column_name ASC|DESC      # 用于对结果进行排序，可以按照一个或多个字段，ASC 表示升序排序也是默认排序，DESC 表示降序</span><br><span class="line"></span><br><span class="line">GROUP BY column_name      # 用于对一个多或多个列返回的结果集进行分组</span><br><span class="line"></span><br><span class="line">HAVING        # 用于筛序数据，可以用于分组后对各组的数据进行筛选，和 having 函数相似的 where 关键字因为无能和聚合函数一起使用，所以才有了 having 函数的出现</span><br><span class="line"></span><br><span class="line">LIMIT         # 有两个参数，第一个参数是开始位置，第二个参数表示从该位置开始获取多少条数据</span><br><span class="line"></span><br><span class="line"># 一般查询语句</span><br><span class="line">select 字段1,字段2... from 表名 </span><br><span class="line">where 条件</span><br><span class="line">group by 字段</span><br><span class="line">having    # 后面通常会跟上例如 sum 等函数等，并加上 &lt;,&gt; 去筛选</span><br><span class="line">order by 字段   # 默认 asc 升序</span><br><span class="line">limit a,b   # 限制结果集的记录条数  </span><br></pre></td></tr></table></figure><p>​    <strong>对于查询来说，关键字的优先级是：</strong></p><p>​    <strong>1）from    2）where    3）group by    4）having    5）select    6）distinct    7）order by    8）limit</strong></p><h4 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个库</span><br><span class="line"><span class="keyword">create</span> database 数据库名字 charset utf8;</span><br><span class="line"></span><br><span class="line"># 删除一个库</span><br><span class="line"><span class="keyword">drop</span> database 数据库名字;</span><br><span class="line"></span><br><span class="line"># 更改数据库使用的编码</span><br><span class="line"><span class="keyword">alter</span> database 数据库名 charset utf8;</span><br><span class="line"></span><br><span class="line"># 查看系统中存在的所有库</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ...                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"></span><br><span class="line"># information_schema 表示虚拟库，不占用磁盘的空间，存储的是 mysql 数据库中维护的所有库的信息，例如库名，表名，字段类型和访问权限等等</span><br><span class="line"># preformance_schema 用来收集数据库服务器的性能参数，是 <span class="number">5.5</span> 版本中新增的一个库</span><br><span class="line"># mysql 负责存储系统用户，访问权限等信息</span><br><span class="line"># sys 是 <span class="number">5.7</span> 中一个加入的一个库，提供了一些视图，数据都来自于 preformance_schema，方便开发者和使用者去查看性能问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看单个数据库创建信息</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database imooc_spider;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Database     <span class="operator">|</span> <span class="keyword">Create</span> Database</span><br><span class="line">                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> imooc_spider <span class="operator">|</span> <span class="keyword">CREATE</span> DATABASE `imooc_spider` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h4 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 操作表之前需要先进入到该表所在的数据库</span><br><span class="line">use 数据库名;</span><br><span class="line"></span><br><span class="line"># 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="operator">&gt;</span> OK</span><br><span class="line"><span class="operator">&gt;</span> 时间: <span class="number">0.024</span>s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 更改表中的字段或结构</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">TABLE</span> test <span class="keyword">add</span> phone <span class="type">int</span>(<span class="number">13</span>) <span class="keyword">not</span> <span class="keyword">null</span>;   # 添加一列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test modify name <span class="type">varchar</span>(<span class="number">8</span>);       # 修改字段设置需要使用 modify</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 列名<span class="operator">/</span>索引<span class="operator">/</span>主键<span class="operator">/</span>外键等；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名<span class="operator">/</span>索引<span class="operator">/</span>主键<span class="operator">/</span>外键等；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ALTER</span> 仅用来改变某列的默认值；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME 列名<span class="operator">/</span>索引名 <span class="keyword">TO</span> 新的列名<span class="operator">/</span>新索引名；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span><span class="operator">/</span><span class="keyword">AS</span> 新表名;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列的定义但不改变列名；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 列名和定义都可以改变。</span><br><span class="line"></span><br><span class="line"># 给表添加外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> fk_外键字段(这个作为外键名) <span class="keyword">foreign</span> key(外键字段) <span class="keyword">references</span> 关联表(主键或其他字段)</span><br><span class="line"></span><br><span class="line"># 删除一张表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test;    # <span class="keyword">drop</span> 会将表的 结构 和 所有数据 都会删除</span><br><span class="line"></span><br><span class="line"># 只删除表的数据，保留表的结构</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> test;      # <span class="keyword">truncate</span> 会保留表的结构，同时删除表中的所有数据</span><br><span class="line"></span><br><span class="line"># 表的查询</span><br><span class="line"><span class="keyword">show</span> tables;          # 查询使用的数据库下存在的所有表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test;          # 查看 test 表的创建信息</span><br><span class="line"><span class="keyword">desc</span> test;            # 查看表的结构信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test；             # 查询 test 表所有的数据</span><br></pre></td></tr></table></figure><p>​    <strong>复制表的流程：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个新的数据库，并进入这个数据库下</span><br><span class="line"><span class="keyword">create</span> database db1 charset utf8;</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line"># 复制 db1 库中 test 表的结构与记录到该数据库下的 test1 表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.test;</span><br><span class="line"></span><br><span class="line"># 只复制 test1 表的结构，并创建新表，需要给一个 <span class="keyword">where</span> 条件，为 <span class="literal">false</span> 就表示值复制表的结构</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.test <span class="keyword">where</span> <span class="number">1</span><span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"># 除了使用 <span class="keyword">where</span> 进行条件判断来只实现表结构的复制外，还可以用 <span class="keyword">like</span> 语法</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">like</span> db1.test</span><br></pre></td></tr></table></figure><h4 id="记录的操作"><a href="#记录的操作" class="headerlink" title="记录的操作"></a>记录的操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 增</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);    # 单记录插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>),(值<span class="number">3</span>,值<span class="number">4</span>);    # 多记录插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表<span class="number">1</span> <span class="keyword">select</span> 列<span class="number">1</span>，列<span class="number">2</span> <span class="keyword">from</span> 表<span class="number">2</span>     # 从 表<span class="number">2</span> 中查询结果插入到 表<span class="number">1</span> 的对应的字段中</span><br><span class="line"></span><br><span class="line"># 删</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;      # 删除整表，即删除该表所有记录</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列<span class="operator">=</span>值   # 删除指定列的指定值的记录</span><br><span class="line"></span><br><span class="line"># 改</span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,列<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span> <span class="keyword">where</span> 列<span class="operator">=</span>值      # 筛选出匹配的记录再进行修改</span><br><span class="line"><span class="keyword">update</span> 表名 列<span class="number">1</span><span class="operator">=</span>replace(列<span class="number">1</span>,要更新的值,更新后的值) <span class="keyword">where</span> 列<span class="operator">=</span>值   # replace 做字段值的替换更新</span><br><span class="line"></span><br><span class="line"># 查</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名       # 查询指定表的所有记录</span><br><span class="line"><span class="keyword">select</span> 列<span class="number">1</span>,列<span class="number">2.</span>.  <span class="keyword">from</span> 表名       # 返回表的 列<span class="number">1</span>,列<span class="number">2.</span>. 的所有记录</span><br><span class="line"><span class="keyword">select</span> 列<span class="number">1</span>,列<span class="number">2.</span>.  <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列<span class="operator">=</span>值       # 返回匹配条件的 列<span class="number">1</span>,列<span class="number">2.</span>. 的所有记录</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------补充-----------------补充-----------------补充-------------------补充------------------</span></span><br><span class="line"># 主键约束，主键相同的数据，忽略创建</span><br><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);     # ignore 在 <span class="keyword">insert</span> 和 <span class="keyword">into</span> 中间</span><br><span class="line"></span><br><span class="line"># 数据已存在，使用新增命令创建数据，将新数据更新原数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>) <span class="keyword">on</span> duplicate key <span class="keyword">update</span> 列<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>，列<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 字段的值合并返回</span><br><span class="line"><span class="keyword">select</span> concat(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">as</span> 查询集需要的列名 <span class="keyword">from</span> 表   # concat 函数会将后面的参数依次拼接得到一个值</span><br><span class="line"><span class="keyword">select</span> concat_WS(列<span class="number">1</span>,列<span class="number">2</span>,列<span class="number">3</span>) <span class="keyword">as</span> 查询集需要的列名 <span class="keyword">from</span> 表   # concat_WS 函数会将第一个参数依次拼接到后面参数的中间</span><br><span class="line"># 注意<span class="operator">!</span><span class="operator">!</span> concat 和 concat_WS 中的参数如果有 <span class="keyword">null</span>，那返回的值最后也是 <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"># 排名</span><br><span class="line"><span class="keyword">select</span> emp_no, salary, <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank <span class="keyword">from</span> salaries</span><br><span class="line"># <span class="built_in">rank</span>() 返回的排名序数不是连续的，一样的值会属于一个排名，但是后面的排名会有间距，即 <span class="number">1</span>，<span class="number">2</span>，<span class="number">2</span>，<span class="number">4</span>，...</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> emp_no, salary, <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank <span class="keyword">from</span> salaries</span><br><span class="line"># <span class="built_in">dense_rank</span>() 返回的是一个连续的排名，一样的值会处于一个排名，但是排名的序数是 <span class="number">1</span>，<span class="number">2</span>，<span class="number">2</span>，<span class="number">3</span>，... 这样递增</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> emp_no, salary, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank </span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">order</span> <span class="keyword">by</span> emp_no</span><br><span class="line"># <span class="built_in">row_number</span>() 返回的是一个严格的序数排名，即 <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，...，不过一般会再去搭配一个排序字段，比如上面的 <span class="keyword">sql</span> 意思是按照薪资降序排名，薪资一样的按照员工号正序排名</span><br></pre></td></tr></table></figure><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>​    在需要返回多个字段且来自不同的表的时候，可以利用 join 将多张表关联在一起形成一张表，对于多表的连接，有 <strong>交叉连接，内连接，左连接，右连接</strong>，还有一种 <strong>全外连接</strong>，不过 <strong>mysql 并不支持</strong>，但可以通过其他方式间接实现</p><p>​    <strong>交叉连接：</strong>是一种特殊意外情况，不使用 join 关键字，会将第一张表得到每一行记录都和第二张表的所有的记录关联，会产生大量的没用的数据，交叉连接所返回的结果所表现的是就是一个 <strong>笛卡尔积</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列1,列2 from 表1,表2</span><br></pre></td></tr></table></figure><p>​    <strong>内连接：</strong>即只返回的结果就是两张表所匹配的行，就是在原来交叉连接的基础上加上了条件来筛选出最后匹配的结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">sex enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​    假设对上面两张表进行内连接，两张表有一个关联的字段，分别是 employee 的 dep_id 与 department 的 id 是对应的，所以在使用 <code>inner join</code> 内连接后，可以用 <code>on</code> 将这两个进行关联，完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select employee.id,employee.name,employee.sex,department.name from employee inner join department on employee.dep_id=department.id</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+----+---------+--------+--------------+</span><br><span class="line">| id | name    | sex    | name         |</span><br><span class="line">+----+---------+--------+--------------+</span><br><span class="line">|  1 | ham     | male   | 财政部       |</span><br><span class="line">+----+---------+--------+--------------+</span><br></pre></td></tr></table></figure><p>​    另外，如果两张表存在数据无法对应的情况，在内连接的方式下，不能匹配对应的记录则不会放在最后的结果集中；比如，在 employee 中有个员工记录的 dep_id 在 department 中没有对应的 id，那么内连接后，查询的结果集中就不会存在该员工</p><p>​    <strong>左连接：</strong>字面上看就是从左边把表进行连接，实则也是这样，左连接的关键字是 left join，关键字前的表会作为左表，关键字后的就是从主表左边加入的右表，即优先显示左表的全部记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select employee.id,employee.name,department.name from employee left join department on employee.dep_id=department.id</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | name     | depart_name  |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 | ham      | 财政部        |</span><br><span class="line">|  5 | burr     | 法务部        |</span><br><span class="line">|  7 | jackson  | NULL         |</span><br><span class="line">+----+----------+--------------+</span><br></pre></td></tr></table></figure><p>​    可以看出代码上实现和内连接几乎是一样的，只是将 inner 改为了 left，但是返回上就有所不同了；在内连接中，不会显示没有对应匹配的记录，但是在左连接中，主表是 employee，这个表中有一个员工所指的 dep_id 在 department 表中不存在的话，左连接的返回结果集中，department.name 的位置会自动填充一个 NULL，并且可以看到最后的左连接的结果集是无序的，所以要返回有序集，还是要去加上 order by 的</p><p>​    <strong>右连接：</strong>和左连接的思路是一致的，同样关键字上使用 right join</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select employee.id,employee.name,department.name from employee right join department on employee.dep_id=department.id</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+----+------------+--------------+</span><br><span class="line">| id | name       | depart_name  |</span><br><span class="line">+----+------------+--------------+</span><br><span class="line">|  1 | hamilton   | 技术         |</span><br><span class="line">|  2 | alexander  | 技术         |</span><br><span class="line">|NULL| NULL       | 财政部       |</span><br><span class="line">+----+------------+--------------+</span><br></pre></td></tr></table></figure><p>​    可见右连接中，即优先显示右表的全部内容，上面代码中 employee 表作为了加入表也就是右表，department 表则是为左表，并且如果 employee 中没有对应记录，同样左表的 department 的会用 NULL 填充</p><p>​    <strong>全外连接：</strong>可以看做是对内连接的补充，在内连接里，包括左或右连接都会有因为其中一张表的部分数据无法和另一张去对应匹配上，导致最后结果集中只能是在其中的主表上查看，全外连接则是相当于增加原本左连接中没有的结果，以及增加右连接中没有的结果</p><p>​    但是     <strong>InnoDB 不支持全外连接</strong>，却依然可以去实现最后的效果，使用 <code>union</code> 和 <code>union all</code> 关键字，<strong>将左连接与右连接合并</strong>，对于 <code>union all</code> 来说，它的结果集中的列名是 union 前面的查询语句的表的列名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select * from employee left join department on employee.dep_id = department.id </span><br><span class="line">union all </span><br><span class="line">select * from employee right join department on employee.dep_id = department.id;</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+------+----------+--------+------+--------+------+--------------+</span><br><span class="line">| id   | name     | sex    | age  | dep_id | id   | name         |</span><br><span class="line">+------+----------+--------+------+--------+------+--------------+</span><br><span class="line">|    1 | alex     | male   |   18 |    200 |  200 | 财务部       |</span><br><span class="line">|    5 | hamilton | male   |   21 |    201 |  201 | 财务部       |</span><br><span class="line">|    7 | tony     | male   |   28 |    202 |  202 | 研发部       |</span><br><span class="line">|    6 | burr     | male   |   18 |    204 | NULL | NULL         |</span><br><span class="line">| NULL | NULL     | NULL   | NULL |   NULL |  203 | 运营         |</span><br><span class="line">+------+----------+--------+------+--------+------+--------------+</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>​    即将一个查询语句嵌套在另一个查询语句中，在查询中可以包含：IN，NOT IN，ANY，ALL，EXISTS，NOT EXISTS 等关键字，同时也支持比较运算符如：=、!=、&gt;、&lt; 等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">in        # 判断指定值是否在子查询的结果集中存在</span><br><span class="line">not in    # 返回指定值不在子查询的结果集中的记录</span><br><span class="line">exists    # 用来对子查询的结果判断是否存在，如果存在执行外部查询，不存在就不会执行外部查询</span><br><span class="line">not exists   # 和 exists 相反，如果子查询没有结果返回会是 true</span><br><span class="line"></span><br><span class="line">=         # 比较与子查询的值是否一致，一致为 true 返回</span><br><span class="line">&lt;=&gt;       # 个人理解是类似于，绝对等于的意思</span><br><span class="line">!=, &lt;&gt;    # 两者都表示不等于的意思</span><br><span class="line"></span><br><span class="line">any       # 会将外部的值与子查询的结果中的任意一个值进行比较</span><br><span class="line">all       # 即外部的结果会对子查询的每个结果去比较，any 和 all 可以与比较运算联合使用</span><br><span class="line"></span><br><span class="line">= any     # 比较子查询的每一个结果，一致返回 ture，和 in 类似</span><br><span class="line">&lt;&gt; all    # 类似 not in</span><br></pre></td></tr></table></figure><p>​    简单来说，利用子查询也涉及了多表或单个表需要进行多次过滤的操作，子查询的目的是为了给外部查询提供满足需要的结果集，来让外部查询做进一步的过滤等操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 使用 in 嵌套的子查询</span><br><span class="line"># 查询平均年龄超过 30 的部门名字</span><br><span class="line">select id，department_name from department </span><br><span class="line">where id in (select dep_id from employee group by dep_id having avg(age) &gt; 30) </span><br><span class="line"></span><br><span class="line"># 最后要查看的部门名字，所以 from 的表是 department，select 中的 id 可要可不要，但是由于 department 和 employee 两张表中 department.id 和 employee.dep_id 是对应的，所以子查询外可以利用 id 作为 where 的筛选条件</span><br><span class="line"></span><br><span class="line"># 员工的年龄要统计平均超过 30，所以 子查询 中，from 的是 employee，且 select 需要选择 dep_id 字段用来和外面的 where 去做筛选，平均年龄超过 30 的部门名字也就是说是每个部门分开统计，那么 子查询 中需要使用 group by 对 dep_id 进行分组，这样可以得到每一个组中的所有成员，最后就是求平均数，where 无法和函数搭配，所以要会使用 having 和 avg 来对 age 字段求平均数，利用比较符号 &gt; 来返回满足的结果集</span><br><span class="line"></span><br><span class="line"># 最后，在 子查询 中所返回就是满足超过 30 的部门的 id，利用 in 关键，就可以得到在 department 所有的 id 在 子查询 所返回的 id 结果集中，就表示是 平均年龄超过 30 的部门的 id</span><br></pre></td></tr></table></figure><p>​    子查询的分类：</p><p>​    1）标量子查询：返回集中只包含单一值的标量</p><p>​    2）列子查询：返回结果集是 N 行一列 的形式</p><p>​    3）行子查询：返回结果集是 一行 N 列 的形式</p><p>​    4）表子查询：即返回结果是 N 行 N 列</p><p>​    针对 标量子查询，外部可以使用像 = ，&lt; ，&gt; 等之类的运算去比较值，如果子查询返回返回类型是 列，行，表的话，就不能使用比较运算符，而是使用 in，not in 之类的关键字</p><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>​    <strong>mysql 的备份有：逻辑备份，物理备份，全量备份，以及增量备份</strong></p><p>​    <strong>逻辑备份，即备份表的结构</strong>，以及数据添加的 sql 语句，整个备份的过程会需要先对表做查询，再将结构与 sql 语句信息转为逻辑格式存储，适用于少量的数据备份和还原</p><p>​    物理备份，即拷贝数据库的目录结构，包括数据文件，简单来说就像是对整个库做了一个镜像</p><p>​    全量备份，即对某一时刻的所有数据做备份，相当于是给某一时刻数据库中的所有数据做了一个快照</p><p>​    增量备份，即对某一个时间段中发生改变的数据做备份，增量备份的操作，需要开启 mysql 的二进制日志，用来对数据的改变做记录</p><p>​    mysql 的备份通常使用  mysqldump 来实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 备份所有的数据库</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p 密码 <span class="comment">--all-databases &gt; bak.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 备份指定的数据库</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p 密码 <span class="comment">--databases db1 db2 db4 &gt; bak.sql</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p 密码 <span class="comment">--database db3 &gt; bak.sql     -- 如果只备份一个数据库，参数 -- database 可以省略，但是这样备份的文件中不会含有库的创建语句，如果使用该文件还原时，库不存在的话会要求先创建数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 备份指定数据库的指定表</span></span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p 密码 <span class="comment">--databas db1 --tables t1 t2 &gt; /tmp/bak.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还原备份库</span></span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">&lt;</span> bak.sql</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p db3 <span class="operator">&lt;</span> bak.sql</span><br></pre></td></tr></table></figure><h4 id="触发器（trigger）"><a href="#触发器（trigger）" class="headerlink" title="触发器（trigger）"></a>触发器（trigger）</h4><p>​    <strong>是一个特殊的存储过程，会监视情况发生，来触发对应操作</strong>，即在 insert，update，delete 的时候自动执行的代码块，且触发器必须定义在永久的表上，不能对临时表去使用创建触发器，常用于加强数据的完整性约束以及业务规则需求</p><p>​    <strong>四要素：</strong></p><p>​    1）监视地点（table）</p><p>​    2）监视事件（insert，update，delete）</p><p>​    3）触发时间（after，before）</p><p>​    4）触发事件（insert，update，delete）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name           </span><br><span class="line">after<span class="operator">/</span>before <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span> <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span> 语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>​    MySQL 中提供了丰富的函数，来简化用户的操作，常用的例如：sum，max，min，avg 等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 关于字符串函数</span><br><span class="line">LENGTH()          # 返回字符串字节长度</span><br><span class="line"><span class="keyword">select</span> name, length(name) <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line">CAHR_LENGTH()     # 返回字符串的长度</span><br><span class="line"></span><br><span class="line">MID()             # 从某个位置获取指定长度的字符</span><br><span class="line"><span class="keyword">select</span> name, mid(name,<span class="number">2</span>,<span class="number">1</span>) <span class="keyword">from</span> student;    # 第二个参数表示开始截取的位置，最小值是 <span class="number">1</span>，第三个参数表示要截取的长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关于数字的函数， 除了前面提到的常用的还有 </span><br><span class="line">ROUND()           # 表示四舍五入</span><br><span class="line"><span class="keyword">select</span> round(<span class="number">22.1234</span>,<span class="number">2</span>)     # 第二个参数表示四舍五入并保留两位小数，如果没有第二个参数就是四舍五入取整</span><br><span class="line"></span><br><span class="line">LEAST()           # 取最小的数字</span><br><span class="line"><span class="keyword">select</span> least(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">GREATEST()        # 取最大的数字</span><br><span class="line"><span class="keyword">select</span> greatest(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关于日期，时间的函数</span><br><span class="line">NOW               # 获取数据库服务器的当前日期时间</span><br><span class="line"><span class="keyword">select</span> NOW()</span><br><span class="line"></span><br><span class="line"><span class="built_in">CURRENT_DATE</span>      # 获取当前的日期</span><br><span class="line"></span><br><span class="line"><span class="built_in">CURRENT_TIME</span>      # 获取当前的时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 关于控制类的函数</span><br><span class="line">IF()              # 判断条件并输出，if 函数有三个参数，第一个参数为 <span class="keyword">condition</span> 条件；当条件满足，返回第二个参数，不满足则返回第三个参数</span><br><span class="line"></span><br><span class="line">IFNULL()          # 需要两个参数，如果第一个参数为空，则会返回第二个参数，否则就直接返回第一个参数</span><br></pre></td></tr></table></figure><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>​    是一张由查询结果组成的 <strong>虚拟表</strong>，但是本身并不存储数据，数据是从其他表中查询得到的；并且如果在视图上进行修改，会影响数据来源的基表本身的数据（前提是视图中的记录要与基表的记录一一对应），即对视图的修改会影响到实体表的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 视图基本创建语法</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"># 插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 视图名(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"># 修改视图</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 语句;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 视图;</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">from</span>  视图名  <span class="keyword">where</span> 条件;        # 删除视图里的数据</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名<span class="number">1</span>[,视图名<span class="number">2.</span>..];       # 直接删除视图</span><br><span class="line"></span><br><span class="line"># 查看视图</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.views <span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​    对于视图的创建是需要对应的 <strong>create view 权限</strong>，在根据涉及的增删改也会需要对应的权限，这样做可以对列的访问和修改进行限制</p><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>​    <strong>把一段代码封装起来，当要执行的时候，通过调用存储过程来实现执行 sql</strong>（对于重复性的 sql 操作使用此方法可以提高效率 ，因为执行 sql 语句会存在一个编译过程 ，这种方法相当于将编译好的 sql 存在内存中，执行就直接从内存获取）</p><p>​    优点：</p><p>​    1）存储过程可封装，并隐藏复杂的商业逻辑</p><p>​    2）存储过程可以回传值，且可以接受参数</p><p>​    3）无法使用 select 指令</p><p>​    4）可以用来数据校验</p><p>​    缺点：</p><p>​    1）存储过程，往往定制化于特定的数据库，当切换到其他的厂商的数据库上，就需要进行重写</p><p>​    2）性能调校与撰写，受限于数据库系统</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>​    <strong>普通索引：</strong>可以在建表时就直接创建，也可以后续在需要的时候去添加（对于各种索引都可以在后续需要的时候去添加或删除），普通索引没有声明声明限制，纯粹是在单个字段上起到加速查询作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建表时添加，使用 index 关键字，然后是 索引名(字段)</span><br><span class="line">create table userinfo(</span><br><span class="line">                   nid int not null auto_increment primary key,</span><br><span class="line">                   name varchar(32) not null,</span><br><span class="line">                   email varchar(64) not null,</span><br><span class="line">                   index ix_name(name)    </span><br><span class="line">               );</span><br><span class="line">               </span><br><span class="line">               </span><br><span class="line"># create 方法来添加</span><br><span class="line">create index 索引的名字 on 表名(列名)      # 创建普通索引</span><br><span class="line">create unique index 索引的名字 on 表名(列名)     # 创建唯一索引</span><br><span class="line"></span><br><span class="line"># 修改表结构添加</span><br><span class="line">alter 表名 index 索引名 on 表名(列名)</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">drop index 索引的名字 on 表名</span><br></pre></td></tr></table></figure><p>​    <strong>唯一索引：</strong>即对使用唯一索引的字段附加了限制，要求该字段的值必须是唯一的，但是 <strong>允许字段的值为空 null，注意虽然允许值为 null，但是并不代表允许重复，因为 null 和 null 的比较永远是 False 的，所以并不会违反唯一的约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 建表时直接添加，使用 unique index 关键字</span><br><span class="line">create table userinfo(</span><br><span class="line">                   id int not null auto_increment primary key,</span><br><span class="line">                   name varchar(32),</span><br><span class="line">                   email varchar(64) not null,</span><br><span class="line">                   unique index ix_name(name)</span><br><span class="line">               );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create unique index 索引名 on 表名(列名)</span><br></pre></td></tr></table></figure><p>​    <strong>主键索引：</strong>和唯一索引类似但是除了要求值 <strong>必须是唯一，并且不允许为空</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 主键索引的关键字就是 primary key，这和其他稍微有点不同，所以一个表中主键字段是会默认加上索引的</span><br><span class="line">create table userinfo(</span><br><span class="line">                   id int not null auto_increment,</span><br><span class="line">                   name varchar(32) not null,</span><br><span class="line">                   email varchar(64) not null,</span><br><span class="line">                   primary key(id),</span><br><span class="line">                   unique  index  ix_name(name)</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line"># 通过修改表结构去添加</span><br><span class="line">alter table 表名 add primary key(列名);</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></table></figure><p>​    <strong>联合索引：</strong>也可以称组合索引或是复合索引，即将多个字段列组合成一个索引，使用复合索引的好处就是避免了因为建立太多的单个索引，造成部分单个索引因为使用效率问题低而造成空间上的浪费，联合索引其实又可以分成，联合主键索引，联合唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以 create 方法添加为例，和创建普通索引几乎一样，只是多了列字段</span><br><span class="line">create index 索引名 on 表名(列名1,列名2)</span><br></pre></td></tr></table></figure><p>​    <strong>最左前缀：</strong>使用联合索引的一个匹配的机制，例如组合索引为：(name,email) ，那么查询中使用的字段会去按照最左前缀的性质去匹配使用</p><p>​    1）如果查询使用到 name and email，会使用该组合索引加速查询</p><p>​    2）如果只使用 name 字段，也可以使用该组合索引</p><p>​    3）如果只使用到 email 字段，无法使用组合索引 </p><p>​    所以，在创建复合索引的时候，一定要将频繁需要查询的字段放在复合索引的第一个</p><p>​    <strong>覆盖索引：</strong>即在语句执行中，能从索引文件中直接获取数据（注意：这里的索引文件不是指磁盘上存储的索引文件，而是在内存中的，当语句中的字段是有索引的情况下，会优先在索引结构中去查找，然后根据结果回到表中去得到对应的数据，对于各个字段的索引都会有一个自己的树结构，这些结构会随着数据页加载到内存而被一起加载）</p><p>​    所以，如果一个查询使用了索引的话，如果返回的数据是完全利用索引在内存中查询返回，而不是需要另外从磁盘中引入的话，那么使用的索引就可以称为是 覆盖索引，使用覆盖索引的好处，可以减少对磁盘的访问提升效率</p><p>​    <strong>索引合并：</strong>即在语句中使用多个单列的索引进行搜索，最后将他们查询后的结果进行合并，多个单列之间使用 and 或是 or 关联</p><p>​    <strong>补充：查询时优化器的选择可能并不一定会是最优的，从而导致即使字段有索引，但最后查询的操作却很慢</strong>，可以通过强制使用索引来要求优化器去使用指定的索引，<strong>强制使用索引的语法是 <code>force index()</code></strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表 force index(索引名) <span class="keyword">where</span> 条件<span class="operator">=</span>值</span><br></pre></td></tr></table></figure><p>​    <strong>索引的注意事项：</strong></p><p>​    1）避免直接使用 select *</p><p>​    2）count(1) 或 count(字段列) 代替 count(*) </p><p>​    3）创建表时，如果能使用 char 可以代替使用 varchar 的话，优先使用 char</p><p>​    4）表的字段顺序应该是固定长度的字段优先</p><p>​    5）利用组合索引代替使用多个普通单列索引</p><p>​    6）尽量使用短索引</p><p>​    7）使用连接 join 去代替利用子查询的多表查询</p><p>​    8）连接多表时，需要注意条件类型</p><p>​    9）对于一些字段，例如性别这种，会有非常多一样的值的情况，不适合去建立索引</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>​    <strong>mysql 的锁，大体使用方式上有两种，也就是常说的 乐观锁 和 悲观锁</strong></p><p>​    <strong>乐观锁：</strong>最常听到的解释是，<strong>乐观锁认为数据在操作的过程，一般不会造成冲突，也就说同一个数据的操作不会造成读取错误，但是在对数据更新时，会去判断数据修改时是否有其他事务对值做修改，如果产生冲突，则返回错误信息</strong></p><p>​    也就是说，<strong>乐观锁 是在应用层面上做的并发控制</strong>，<strong>乐观锁的实现，常见的有两种：版本号控制，CAS 算法</strong></p><p>​    <strong>版本号控制：</strong>即在数据表中，<strong>添加一个 version 版本号的字段，每一次数据被修改后，version 的字段值就 +1，最后在提交这个更新前，会再去获取版本号，判断这次获取的版本和开始时获取的是否一致</strong>，一致就提交更新修改字段的值，不一致就表示在操作期间，数据被其他事务操作，这次的操作即使提交也不会进行数据更改，并返回信息给客户端</p><p>​    <strong>CAS 算法：compare and swap（比较和交换）</strong>，也就说不通过锁来进行多线程的同步，做到非阻塞的同步</p><p>​    CAS 简单来说，<strong>涉及三个变量值，比如 V，A，B。V 表示主内存的值，A 表示各线程本地内存的值，B 表示各线程要修改后的值</strong></p><p>​    最后对于数据的更新，<strong>当且仅当 V = A 时，才会用 B 去更新 V，否则线程将不能进行数据更新，并且会不断 自旋（重试），之后自己的 V = A</strong></p><p>​    <strong>悲观锁：</strong>即与乐观锁相反，<strong>悲观锁认为每一次的数据操作都会出现冲突，为了保证线程安全，每一次的操作都需要进行加锁</strong>，这也直接导致数据操作会产生较多的耗时</p><p>​    并且悲观锁是由数据库自己实现，也就是在 <strong>数据库层面上做并发控制</strong></p><p>​    <strong>mysql 中使用悲观锁的前提是，需要关闭自动提交 <code>set autocommit = 0</code>，默认是开启自动提交的，即事务提交后会自动将锁进行释放，让其他事务去获取锁</strong></p><p>​    对于 <strong>悲观锁，有两种实现方式：共享锁，排他锁</strong></p><p>​    <strong>共享锁：也叫 读锁</strong>，当一个数据出现并发操作，通过在 sql 语句后面加上 <strong><code>lock in share mode</code></strong> 来实现对一个资源的加锁操作<strong>，允许事务进行读取，但不能进行修改操作</strong></p><p>​    同时，<strong>如果一个事务给数据加上了 共享锁，其他的事务也只能对该数据加 共享锁，而不能加排它锁</strong></p><p>​    <strong>排他锁：也叫 写锁</strong>，与共享锁类似，但是语法上是在 sql 最后加上 <strong><code>for update</code></strong> 实现，<strong>当数据被加上 排他锁，其他事务不能对其进行操作，必须要先获取到被释放的 排它锁</strong></p><p>​    并且，<strong>一个数据被加上了 排他锁 后，其他事务不能对这个数据再去加其他的锁</strong></p><p>​    <strong>对于 mysql 来说，在 insert ，update，delete 的命令都是默认使用的 排它锁</strong></p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 常见模块</title>
      <link href="/4221941290/"/>
      <url>/4221941290/</url>
      
        <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    简单的理解，就是一堆可以调用的代码集合，一个 py 文件可以是一个模块被导入，一个模块（包）也可以是由多个 py 文件组成</p><p>​    大致上模块可以分为三种：自定义模块；内置模块；开源模块</p><p>​    自定义模块很好理解，即使程序员根据特殊需求和场景所定义的模块；开源模块就是需要通过 pip 下载的，有其他的程序员所构建的模块</p><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>​    pip 是 python 的包管理工具，提供查看、下载、安装、卸载的功能，在 py2 中使用 pip，py3 中则是使用 pip3，但是使用 pip 去安装也不会有问题，只是推荐是 pip3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip --version           # 查看 pip 版本</span><br><span class="line">pip --help              # 获取帮助信息</span><br><span class="line">pip install -U pip      # 升级 pip</span><br></pre></td></tr></table></figure><p>​    使用 pip 安装模块，例如 <code>pip install django</code>，但是默认情况是去安装最新的版本，有时候通常会要安装指定的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install Django==2.2     # 安装 2.2 的版本</span><br><span class="line">pip install Django&gt;=2.2     # 最低安装 2.2 的版本</span><br></pre></td></tr></table></figure><p>​    另外，安装默认是去国外的资源下载安装，所以速度容易受影响，可能会出现一些超时或是无法下载，导致安装失败</p><p>​    所以，可以使用国内的源去下载，大部分都会含有最新的版本，如果只是临时安装一个包，也可以直接使用 <code>-i</code> 参数可以指定国内的镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package    # 清华大学</span><br><span class="line">https://pypi.douban.com/simple    # 豆瓣</span><br><span class="line">https://mirrors.aliyun.com/pypi/simple/    # 阿里云</span><br></pre></td></tr></table></figure><p>​    除了使用参数，临时指定下载的源，也可以对配置做修改，实现永久的下载线路更改，在 linux 中找到 <code>~/.pip/pip.conf</code>  的配置文件 pip.conf，如果文件不存在可以自己创建，然后编辑内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>​    windows 下，需要在 user 目录下创建 pip 目录，并创建一个 pip.ini 文件，内容与上方一致</p><p>​    卸载一个包，使用 <code>pip uninstall Django</code>；搜索包，使用 <code>pip search Django</code></p><p>​    有时，通常会需要根据给定的包配置去安装环境，或是要将当前环境使用的包配置打包，pip 的包配置文件是 requirement.txt 的文本文件，内容类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Django==3.0.6</span><br><span class="line">django-filter==2.2.0</span><br><span class="line">djangorestframework==3.11.0</span><br><span class="line">idna==2.9</span><br><span class="line">importlib-metadata==1.6.0</span><br><span class="line">itypes==1.2.0</span><br><span class="line">Jinja2==2.11.2</span><br><span class="line">Markdown==3.2.2</span><br><span class="line">MarkupSafe==1.1.1</span><br><span class="line">Pygments==2.6.1</span><br><span class="line">pytz==2020.1</span><br><span class="line">requests==2.23.0</span><br></pre></td></tr></table></figure><p>​    在有环境依赖包配置文件时，安装通过参数  <code>-r</code>  并给出 requirement.txt 的目录，比如 <code>pip install -r ./requirements.txt</code></p><p>​    如果要根据当前环境，生成一个包配置文件，使用 <code>pip freeze &gt; ./requirements.txt</code></p><h3 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h3><p>​    包括时间模块，random 模块，os 模块，sys 模块，序列化模块，re 模块，collocations 模块等等</p><h4 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h4><p>​    对于 <strong>时间的表示有三种形式：时间戳，时间字符串 以及 结构化时间</strong></p><p>​    时间戳是纯数字的形式，时间字符串则是含有符号的表示的字符串，结构化时间是一个对象，将各个值赋给对应的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(time.time())          <span class="comment"># 返回当前时间的时间戳，是一个 float 类型</span></span><br><span class="line"><span class="comment"># 1592037600.7337763</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.localtime())     <span class="comment"># 返回当前时间的本地结构化时间</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=6, tm_mday=13, tm_hour=16, tm_min=40, tm_sec=0, tm_wday=5, tm_yday=165, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">t = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(t.tm_yday)            <span class="comment"># 调用 tm_yday 属性，返回今天是本年的第几天    </span></span><br><span class="line"><span class="comment"># 165</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.localtime(<span class="number">1592037992</span>))     <span class="comment"># 结构化可以接受时间戳参数，返回特定的结构化时间</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=6, tm_mday=13, tm_hour=16, tm_min=46, tm_sec=32, tm_wday=5, tm_yday=165, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.mktime(time.localtime()))   <span class="comment"># mktime 将结构化时间转为时间戳，注意是一个浮点数类型时间戳</span></span><br><span class="line"><span class="comment"># 1592039366.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>, time.localtime()))   </span><br><span class="line"><span class="comment"># 2020-06-13</span></span><br><span class="line"><span class="comment"># strftime 返回指定格式的时间字符串，第一个参数是格式，第二参数是结构化时间；如果不传参数默认就是当前的结构化时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.strptime(<span class="string">&#x27;1998-04-22 12:30:17&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=1998, tm_mon=4, tm_mday=22, tm_hour=12, tm_min=30, tm_sec=17, tm_wday=2, tm_yday=112, tm_isdst=-1)</span></span><br><span class="line"><span class="comment"># strptime 返回结构化时间，第一参数是时间字符串，第二个参数是格式（这里必要和字符串能够匹配，比如完整的年份要使用 %Y，而不能是 %y，否则会抛出异常）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %Y  完整年份表示</span></span><br><span class="line"><span class="comment"># %m  表示月份</span></span><br><span class="line"><span class="comment"># %d  表示日子</span></span><br><span class="line"><span class="comment"># %y  只返回年份的最后两位</span></span><br><span class="line"><span class="comment"># %H  表示小时（24小时制）</span></span><br><span class="line"><span class="comment"># %M  表示分钟</span></span><br><span class="line"><span class="comment"># %S  表示秒</span></span><br><span class="line"><span class="comment"># %a  本地简写的星期名称 </span></span><br><span class="line"><span class="comment"># %A  完成的星期名称</span></span><br><span class="line"><span class="comment"># ..    ..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.ctime())     <span class="comment"># 以 %a %b %d %H:%M:%S %Y 返回 时间字符串</span></span><br><span class="line"><span class="comment"># Sat Jun 13 17:47:46 2020</span></span><br><span class="line"><span class="built_in">print</span>(time.ctime(<span class="number">1592039366</span>))  <span class="comment"># 可以接受时戳为参数来返回指定的时间字符串</span></span><br><span class="line"><span class="comment"># Sat Jun 13 17:09:26 2020</span></span><br><span class="line"><span class="built_in">print</span>(time.asctime(time.localtime(<span class="number">1592039366</span>)))</span><br><span class="line"><span class="comment"># Sat Jun 13 17:09:26 2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctime 可以直接接收时间戳为参数返回字符串时间，asctime 则是接收结构化时间为参数来返回</span></span><br></pre></td></tr></table></figure><h4 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其实 datetime 更应该说是包，它其中包括了其他不同类，能针对处理</span></span><br><span class="line"><span class="comment"># datetime.date        用于表示年月日构成的日期</span></span><br><span class="line"><span class="comment"># datetime.time        用于表示时分秒微妙构成的一天24小时中的具体时间</span></span><br><span class="line"><span class="comment"># datetime.datetime    上面两个合在一起  既包含时间有包含日期</span></span><br><span class="line"><span class="comment"># datetime.timedelta   用来创建时间间隔对象，用于加减时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime.datetime</span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.now())        <span class="comment"># 2021-04-14 15:39:36.236317   &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.today())      <span class="comment"># 2021-04-14 15:39:36.236317   &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">d = datetime.datetime(<span class="number">2019</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">22</span>)   <span class="comment"># datetime 可以按照位置参数，接受数字，返回一个时间对象</span></span><br><span class="line"><span class="built_in">print</span>(d, <span class="built_in">type</span>(d))   <span class="comment"># 2019-07-13 20:22:22 &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">d = datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span>(d.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))  <span class="comment"># strftime 方法可以将时间对象格式化成字符串时间</span></span><br><span class="line"><span class="comment"># 2021-04-14 15:41:57</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;2019-07-13&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.strptime(d, <span class="string">&#x27;%Y-%m-%d&#x27;</span>))  <span class="comment"># strptime 方法用来将字符串时间按照格式返回一个时间对象  &lt;class &#x27;datetime.datetime&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 2019-07-13 00:00:00</span></span><br><span class="line"></span><br><span class="line">d = datetime.datetime.strptime(d, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.timestamp(d))   <span class="comment"># timestamp 方法需要接受一个时间对象，返回一个时间戳</span></span><br><span class="line"><span class="comment"># 1562947200.0</span></span><br><span class="line"></span><br><span class="line">t = datetime.datetime.timestamp(d)</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.fromtimestamp(t))  <span class="comment"># fromtimestamp 方法需要接受一个时间戳，返回一个时间对象</span></span><br><span class="line"><span class="comment"># 2019-07-13 00:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.timetuple(datetime.datetime.strptime(d, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)))</span><br><span class="line"><span class="comment"># timetuple 方法用来返回结构化时间，需要接受一个参数，参数是一个时间对象</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=7, tm_mday=13, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=194, tm_isdst=-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime.timedelta</span></span><br><span class="line">h = datetime.timedelta(hours=<span class="number">2</span>)   <span class="comment"># timedelta 方法通过位置参数，可以返回 timedelta 对象，用于时间 +-</span></span><br><span class="line"><span class="built_in">print</span>(d + h)    <span class="comment"># 2019-07-13 22:22:22</span></span><br><span class="line"></span><br><span class="line">t = datetime.timedelta(days=<span class="number">17</span>)</span><br><span class="line"><span class="built_in">print</span>(d + t)    <span class="comment"># 2019-07-30 20:22:22</span></span><br></pre></td></tr></table></figure><h4 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()            <span class="comment"># 返回当前的工作目录</span></span><br><span class="line">os.chdir(<span class="string">&#x27;dirname&#x27;</span>)    <span class="comment"># 切换工作目录，相当于 cd 命令</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;dirname1/dirname2&#x27;</span>)      <span class="comment"># 可以递归生成多层结构的目录</span></span><br><span class="line">os.removedirs(<span class="string">&#x27;dirname1&#x27;</span>)    <span class="comment"># 递归删除多层目录，对目录调用 rmdir，所以只能删除 ！！空目录</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;dirname&#x27;</span>)          <span class="comment"># 生成一个目录</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;dirname&#x27;</span>)          <span class="comment"># 删除一个 !空目录! ，如果目录不存在或非空则会抛出异常</span></span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>)        <span class="comment"># 列出目录下的所有文件和子目录，包括隐藏文件</span></span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">&#x27;old&#x27;</span>, <span class="string">&#x27;new&#x27;</span>)      <span class="comment"># 重命名文件</span></span><br><span class="line">os.remove(<span class="string">&#x27;file&#x27;</span>)            <span class="comment"># 删除一个文件</span></span><br><span class="line">os.stat(<span class="string">&#x27;path/file&#x27;</span>)         <span class="comment"># 获取目录或文件信息的结构说明</span></span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&#x27;bash command&#x27;</span>)    <span class="comment"># 运行 shell 命令，直接显示</span></span><br><span class="line">os.popen(<span class="string">&#x27;bash command&#x27;</span>)     <span class="comment"># 运行 shell 命令，获取执行得到结果</span></span><br><span class="line">os.environ                   <span class="comment"># 获取系统环境变量信息</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">&#x27;path&#x27;</span>)      <span class="comment"># 返回 path 路径的规范化绝对路径</span></span><br><span class="line">os.path.split(<span class="string">&#x27;path&#x27;</span>)        <span class="comment"># 将指定的路径分割成目录和文件，并以一个元组返回</span></span><br><span class="line">os.path.dirname(<span class="string">&#x27;path&#x27;</span>)      <span class="comment"># 返回这个路径的上级目录，也就是 split 元组的第一个元素</span></span><br><span class="line">os.path.basename(<span class="string">&#x27;path&#x27;</span>)     <span class="comment"># 返回路径的最后的文件名，即 split 元组的第二个元素</span></span><br><span class="line">os.path.exists(<span class="string">&#x27;path&#x27;</span>)       <span class="comment"># 判断路径是否存在</span></span><br><span class="line">os.path.isabs(<span class="string">&#x27;path&#x27;</span>)        <span class="comment"># 如果路径是一个绝对路径，返回 True</span></span><br><span class="line">os.path.isfile(<span class="string">&#x27;path&#x27;</span>)       <span class="comment"># 判断路径是否是一个存在的文件</span></span><br><span class="line">os.path.isdir(<span class="string">&#x27;path&#x27;</span>)        <span class="comment"># 判断路径是否是一个存在的目录</span></span><br><span class="line">os.path.join(<span class="string">&#x27;path1&#x27;</span>, <span class="string">&#x27;path2&#x27;</span>, ...)     <span class="comment"># 将路径进行拼接返回</span></span><br><span class="line"></span><br><span class="line">os.path.getatime(<span class="string">&#x27;path&#x27;</span>)     <span class="comment"># 返回路径指向的文件或目录的最后访问时间</span></span><br><span class="line">os.path.getmtime(<span class="string">&#x27;path&#x27;</span>)     <span class="comment"># 返回路径指向的文件或目录的最后修改时间</span></span><br><span class="line">os.path.getsize(<span class="string">&#x27;path&#x27;</span>)      <span class="comment"># 返回路径指向的文件或目录的大小，以字节为单位</span></span><br><span class="line"></span><br><span class="line">os.walk(<span class="string">&#x27;path&#x27;</span>)              <span class="comment"># 用于遍历给定的目录，会返回含有三个元素的元组，分别是 root（指当前遍历的根目录），dirs（是一个列表，包含当前遍历目录中的一级目录，不包含其中的子目录），files（也是一个列表，包含当前目录下的所有文件，不会包含目录中的文件）</span></span><br><span class="line"></span><br><span class="line">os.walk(top=<span class="string">&#x27;path&#x27;</span>, topdown=<span class="literal">True</span>)     <span class="comment"># walk 方法中还有一个参数 topdown，默认是 True，表示的是在遍历 top 目录时，如果文件夹目录有子目录，会去先遍历子目录，然后再往后去遍历</span></span><br><span class="line"></span><br><span class="line">os.pid()                     <span class="comment"># 获取当前进程 id</span></span><br><span class="line">os.ppid()                    <span class="comment"># 获取当前进程的父进程 id</span></span><br></pre></td></tr></table></figure><p>​    os 模块中 <strong>如果要删除一个目录，这个目录不是一个空目录的话，是会抛出 OSError 的异常的，也就说模块的 rmdir 以及 removedirs 通常都不能直接删除目录，因此可以通过递归的方法来判断，先将目录的文件删除，再将目录删除</strong></p><p>​    除此之外，还可以用 <strong>shutil 模块的 rmtree 的方法将一个路径的目录直接删除 <code>shutil.rmtree(path)</code></strong></p><h4 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a>sys 模块</h4><p>​    需要注点的一点是，<strong>os 模块 所操作的是对于 操作系统 的，而 sys 模块 则是用来操作 python 解释器 进行交互的接口模块</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.argv               <span class="comment"># 实现从命令行向程序传递参数，返回的是一个列表，会将命令行的字符串通过空格切割</span></span><br><span class="line">sys.version            <span class="comment"># 返回 python 解释器的版本</span></span><br><span class="line">sys.maxsize            <span class="comment"># 返回最大能表示的数字，该值与操作系统是多少位的有关</span></span><br><span class="line">sys.path               <span class="comment"># 返回模块的搜索路径</span></span><br><span class="line">sys.platform           <span class="comment"># 返回操作系统平台名称</span></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br><span class="line">name = sys.argv[<span class="number">1</span>]</span><br><span class="line">pwd = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(name, pwd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;alexham&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;17&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;继续执行程序&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行中执行程序</span></span><br><span class="line"><span class="comment"># (base) C:\Users\DELL\Desktop\chapter_18&gt;python test.py alexham 17</span></span><br><span class="line"><span class="comment"># [&#x27;test.py&#x27;, &#x27;alexham&#x27;, &#x27;17&#x27;]</span></span><br><span class="line"><span class="comment"># alexham 17</span></span><br><span class="line"><span class="comment"># 继续执行程序</span></span><br></pre></td></tr></table></figure><h4 id="json-序列化模块"><a href="#json-序列化模块" class="headerlink" title="json 序列化模块"></a>json 序列化模块</h4><p>​    python 中有两个用来序列化得到字符串的模块分别是：json 和 pickle，json 是一个数据传输的一个标准类型，而 pickle 只能是对 python 自己的类型和特性去做序列化，对比 json 来说支持的范围有限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># josn</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">d = &#123;<span class="string">&#x27;tony&#x27;</span>: <span class="string">&#x27;stark&#x27;</span>, <span class="string">&#x27;alexander&#x27;</span>: <span class="string">&#x27;hamilton&#x27;</span>, <span class="string">&#x27;leo&#x27;</span>: <span class="string">&#x27;messi&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(json.dumps(d), <span class="built_in">type</span>(json.dumps(d)))</span><br><span class="line"><span class="comment"># &#123;&quot;tony&quot;: &quot;stark&quot;, &quot;alexander&quot;: &quot;hamilton&quot;, &quot;leo&quot;: &quot;messi&quot;&#125; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;&#123;&quot;tony&quot;: &quot;stark&quot;, &quot;alexander&quot;: &quot;hamilton&quot;, &quot;leo&quot;: &quot;messi&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(json.loads(s), <span class="built_in">type</span>(json.loads(s)))</span><br><span class="line"><span class="comment"># &#123;&#x27;tony&#x27;: &#x27;stark&#x27;, &#x27;alexander&#x27;: &#x27;hamilton&#x27;, &#x27;leo&#x27;: &#x27;messi&#x27;&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;tony&#x27;</span>: <span class="string">&#x27;stark&#x27;</span>, <span class="string">&#x27;alexander&#x27;</span>: <span class="string">&#x27;hamilton&#x27;</span>, <span class="string">&#x27;leo&#x27;</span>: <span class="string">&#x27;messi&#x27;</span>&#125;</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;json.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">json.dump(d,f)</span><br><span class="line">f.close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json.dumps()     <span class="comment"># 序列化得到字符串</span></span><br><span class="line">json.loads()     <span class="comment"># 反序列，得到原来的类型</span></span><br><span class="line">json.dump()      <span class="comment"># 需要一个 文件句柄 参数，将序列化后的字符串直接写入文件</span></span><br><span class="line">json.load()      <span class="comment"># 同上，从 文件 中反序列化 json 字符串得到原来的类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pickle</span></span><br><span class="line">pickle.dumps   <span class="comment"># 序列化得到二进制数据</span></span><br><span class="line">pickle.loads   <span class="comment"># 反序列化二进制数据得到原来类型</span></span><br><span class="line">pickle.dump    <span class="comment"># 和 json 的 dump 一样，需要一个文件句柄，将内容序列化为二进制数据入文件</span></span><br><span class="line">pickle.load    <span class="comment"># 同上，进行反序列化</span></span><br></pre></td></tr></table></figure><h4 id="hashlib-模块"><a href="#hashlib-模块" class="headerlink" title="hashlib 模块"></a>hashlib 模块</h4><p>​    利用 hash 算法来对字符串进行编码操作，例如对登录用户的密码加密等，hashlib 中整合了 md5 和 sha，支持多种不同算法，编码的操作是不可逆的，无法通过编码后的数据来还原成原来的加密前的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">obj = hashlib.md5()                 <span class="comment"># 构造指定算法的 hashlib 对象</span></span><br><span class="line"><span class="comment"># obj.update(&#x27;alexham&#x27;)             # update 中需要对加密的字符串做编码，否则抛出异常</span></span><br><span class="line"></span><br><span class="line">obj.update(<span class="string">&#x27;alexham&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(obj, <span class="built_in">type</span>(obj))               <span class="comment"># &lt;md5 HASH object @ 0x00000216CB5165A8&gt; &lt;class &#x27;_hashlib.HASH&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.hexdigest())              <span class="comment"># 4ab585f1e143ca2ba5c3fcf12441745b</span></span><br></pre></td></tr></table></figure><p>​    注意，使用普通的方式去进行编码，是能够被破解的，可以在一些破解网站中得到原字符串</p><p><img src="https://wei-foun.github.io/img/md5.jpg" alt="img"></p><p>​    除此之外，编码的对象中还有一种 “加盐” 的方式，即在对象中加入字符再去做编码，这样的方式要比纯用普通方式加密安全很多，只要特定的密文不被泄露，基本就不可以被破解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">obj = hashlib.md5(<span class="string">&#x27;1q2w3e&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">obj.update(<span class="string">&#x27;alexham&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.hexdigest())               <span class="comment"># cd4915d4878f75d51698d5bf3de8201c</span></span><br></pre></td></tr></table></figure><h4 id="logging-模块"><a href="#logging-模块" class="headerlink" title="logging 模块"></a>logging 模块</h4><p>​    默认情况下 Python 的 logging 模块将日志打印到了标准输出中，且只显示了大于等于 WARNING 级别的日志，因为日志记录级别默认是设置为 WARNING</p><p>​    日志级别等级：<strong>CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过属性抛出错误记录到日志</span></span><br><span class="line">logging.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">logging.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line">logging.warning(<span class="string">&#x27;warning message&#x27;</span>)           <span class="comment"># warning 警告</span></span><br><span class="line">logging.error(<span class="string">&#x27;error message&#x27;</span>)               <span class="comment"># error 错误</span></span><br><span class="line">logging.critical(<span class="string">&#x27;critical message&#x27;</span>)         <span class="comment"># 更严重的错误级别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># CRITICAL = 50</span></span><br><span class="line"><span class="comment"># ERROR    = 40</span></span><br><span class="line"><span class="comment"># WARNING  = 30</span></span><br><span class="line"><span class="comment"># INFO     = 20</span></span><br><span class="line"><span class="comment"># DEBUG    = 10</span></span><br><span class="line"><span class="comment"># NOTSET   = 0</span></span><br><span class="line"><span class="comment"># 默认等级是 30，以上的错误信息都会被记录在 logging 日志中，该级别可以在实例对象时用通过参数修改</span></span><br></pre></td></tr></table></figure><p>​    通过 <code>logging.basicConfig()</code> 来实现最基本的日志创建，通过参数对其进行设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">log = logging.basicConfig(</span><br><span class="line">    filename=<span class="string">&#x27;log.txt&#x27;</span>,     <span class="comment"># 会在当前目录下创建该文件</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(module)s:  %(message)s&#x27;</span>,  <span class="comment"># 设置显示的格式</span></span><br><span class="line">    <span class="comment"># datefmt=&#x27;%Y-%m-%d %H:%M:%S %p&#x27;,   # 指定日志中记录的时间格式</span></span><br><span class="line">    level=<span class="number">10</span>      <span class="comment"># 设置默认记录的级别为 10，以上的级别都会被记录到日志</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其余的参数</span></span><br><span class="line"><span class="comment"># filemode      指定文件的打开方式，默认是 a，即内容都是追加写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 显示参数的格式化字符</span></span><br><span class="line"><span class="comment"># %(name)s         # Logger 的名字</span></span><br><span class="line"><span class="comment"># %(levelno)s      # 记录数字形式的级别</span></span><br><span class="line"><span class="comment"># %(levelname)s    # 以等级名记录</span></span><br><span class="line"><span class="comment"># %(filename)s     # 记录文件名</span></span><br><span class="line"><span class="comment"># %(module)s       # 记录模块的名字 </span></span><br><span class="line"><span class="comment"># %(funcName)s     # 记录函数名</span></span><br><span class="line"><span class="comment"># %(lineno)d       # 记录错误位置的所在行数</span></span><br><span class="line"><span class="comment"># %(created)f      # 记录当前时间的时间戳</span></span><br><span class="line"><span class="comment"># %(asctime)s      # 记录格式后的当前时间，默认按照 &#x27;%Y-%m-%d %H:%M:%S,%p&#x27;，逗号后面是毫秒</span></span><br><span class="line"><span class="comment"># %(message)s      # 记录返回的输出信息</span></span><br><span class="line"><span class="comment"># %(thread)d       # 记录线程ID</span></span><br><span class="line"><span class="comment"># # ...            # ....</span></span><br></pre></td></tr></table></figure><p>​    除此之外，logger 的创建还支持通过配置文件的方式进行配置，需要先创建好 logging.conf，对于 <strong>logging 模块提供了有 记录器，处理器，过滤器 和 格式器 四个组件</strong>，所以在配置文件中也需要对应定义这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,simpleExample    # 定义了 root, simpleExample 两个日志记录器</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=consoleHandler        # 定义了 consoleHandler 处理器</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=simpleFormatter       # 定义 simpleFormatter 格式化器</span><br><span class="line"></span><br><span class="line">[logger_root]              # 针对 root 记录器定义</span><br><span class="line">level=DEBUG                # 定义日志过滤等级为 debug</span><br><span class="line">handlers=consoleHandler    # 定义所使用的处理器 consoleHandler</span><br><span class="line"></span><br><span class="line">[logger_simpleExample]     # 针对 simpleExample 记录器定义</span><br><span class="line">level=DEBUG                # 过滤等级为 debug</span><br><span class="line">handlers=consoleHandler    # 使用 consoleHandler 处理器</span><br><span class="line">qualname=simpleExample     # </span><br><span class="line">propagate=0                # 0 表示 false，即关闭子记录器向父级记录器传播消息</span><br><span class="line"></span><br><span class="line">[handler_consoleHandler]   # 针对 consoleHandler 处理器</span><br><span class="line">class=StreamHandler        # 定义处理形式是流处理</span><br><span class="line">level=DEBUG                # 设置等级是 debug</span><br><span class="line">formatter=simpleFormatter  # 设置格式器，使用 simpleFormatter</span><br><span class="line">args=(sys.stdout,)         # 将输出作为参数给到格式化器</span><br><span class="line"></span><br><span class="line">[formatter_simpleFormatter]    # 定时 formatter_simpleFormatter 的格式化器</span><br><span class="line">format=%(asctime)s - %(name)s - %(levelname)s - %(message)s</span><br></pre></td></tr></table></figure><p>​    完成配置之后，可以使用 logging 的 fileConfig 去读取配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">logging.config.fileConfig(<span class="string">&#x27;logging.conf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simpleExample&#x27;</span>)  <span class="comment"># getLogger 方法接收一个字符换串作为日志中 name 的名字，如果没有，则默认日志文件 name 属性的值是 root</span></span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;warn message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    除了上面这种文件配置方式，logging 还可以使用 dict 去进行配置，通过 dictConfig 去读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line">LOG_DIR = <span class="string">&#x27;./&#x27;</span></span><br><span class="line"></span><br><span class="line">LOGGING = &#123;    <span class="comment"># 定义 django 的日志记录</span></span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;%(asctime)s %(name)-12s %(lineno)d %(levelname)-8s %(message)s&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;    <span class="comment"># 定义日志处理器</span></span><br><span class="line">        <span class="comment"># 设置控制台输出</span></span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 设置文件日志记录</span></span><br><span class="line">        <span class="string">&#x27;file&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.FileHandler&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: os.path.join(LOG_DIR, <span class="string">&#x27;recruitment.admin.log&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;console&#x27;</span>, <span class="string">&#x27;file&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;INFO&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logging.config.dictConfig(LOGGING)</span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;simpleExample&#x27;</span>)</span><br><span class="line">logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br><span class="line">logger.info(<span class="string">&#x27;info message&#x27;</span>)</span><br><span class="line">logger.warning(<span class="string">&#x27;warn message&#x27;</span>)</span><br><span class="line">logger.error(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">logger.critical(<span class="string">&#x27;critical message&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    补充关于配置文件的可选参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">when:           # 用于日志文件轮转的时间点，例如：&#x27;H&#x27; 表示小时，&#x27;D&#x27; 表示天</span><br><span class="line"></span><br><span class="line">interval:       # 用于日志文件轮转的范围，数值类型，配合 when 实现每小时或每天的文件轮转</span><br><span class="line"></span><br><span class="line">maxBytes：      # 设置日志文件的最大空间，达到该值后将进行日志文件轮转</span><br><span class="line"></span><br><span class="line">backupCount:    # 用于设置日志文件的保留备用文件数</span><br></pre></td></tr></table></figure><h4 id="itertools-模块"><a href="#itertools-模块" class="headerlink" title="itertools 模块"></a>itertools 模块</h4><p>​    补充 itertools 模块中的 groupby 方法，该方法接收两个参数，第一个参数是一个可迭代对象，第二个参数 key 是一个函数，用于遍历第一个参数，和 filter，map 等方法类似，所以第二个参数可以是 lambda 表达式，方法返回的同样是一个可迭代的对象 itertools.groupby</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">4</span>)]</span><br><span class="line">itertools.groupby(L, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]) </span><br><span class="line"><span class="comment"># &lt;itertools.groupby object at 0x0000000002CD1778&gt;</span></span><br></pre></td></tr></table></figure><p>​    通过 list 方法将 groupby 对象转为数组，可以看到每个元素是一个数组，元组的第一个元素的 groupby 函数操作后每一个分类的名称，元素的第二个参数是一个 grouper 对象，该对象同样是一个可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(itertools.groupby(L, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])) </span><br><span class="line"><span class="comment"># [(&#x27;a&#x27;, &lt;itertools.grouper object at 0x0000000002CD0B08&gt;), (&#x27;b&#x27;, &lt;itertools.grouper object at 0x0000000002CD0B48&gt;)]</span></span><br></pre></td></tr></table></figure><p>​    同样使用 list 来转换类型，可以得到每个 grouper 对象的元素，每个元素同样也是元组类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,g <span class="keyword">in</span> itertools.groupby(L, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]):</span><br><span class="line"> <span class="built_in">print</span> k, <span class="built_in">list</span>(g)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a [(&#x27;a&#x27;, 1), (&#x27;a&#x27;, 2)]</span></span><br><span class="line"><span class="comment"># b [(&#x27;b&#x27;, 3), (&#x27;b&#x27;, 4)]</span></span><br></pre></td></tr></table></figure><h4 id="dis-模块"><a href="#dis-模块" class="headerlink" title="dis 模块"></a>dis 模块</h4><p>​    dis — Disassembler for Python bytecode，<strong>把 python 代码反汇编为字节码指令</strong>；python 代码是先被编译为字节码后，再由 python 虚拟机来执行字节码， python 的字节码是一种类似汇编指令的中间语言， 一个 python 语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比 &#123;&#125; 和 dict() 创建字典的性能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"></span><br><span class="line">    a = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">    b = <span class="built_in">dict</span>(&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">dis.dis(func)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">6221</span>           <span class="number">0</span> LOAD_CONST                <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">               <span class="number">2</span> LOAD_CONST                <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">               <span class="number">4</span> LOAD_CONST                <span class="number">3</span> ((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">               <span class="number">6</span> BUILD_CONST_KEY_MAP       <span class="number">2</span></span><br><span class="line">               <span class="number">8</span> STORE_FAST                <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line"><span class="number">6222</span>          <span class="number">10</span> LOAD_GLOBAL               <span class="number">0</span> (<span class="built_in">dict</span>)</span><br><span class="line">              <span class="number">12</span> LOAD_CONST                <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">14</span> LOAD_CONST                <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">16</span> LOAD_CONST                <span class="number">3</span> ((<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">              <span class="number">18</span> BUILD_CONST_KEY_MAP       <span class="number">2</span></span><br><span class="line">              <span class="number">20</span> CALL_FUNCTION             <span class="number">1</span></span><br><span class="line">              <span class="number">22</span> STORE_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">24</span> LOAD_CONST                <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比可以看出，创建同样的字典，直接利用 &#123;&#125; 执行的效率更高</span></span><br></pre></td></tr></table></figure><h4 id="collections-模块"><a href="#collections-模块" class="headerlink" title="collections 模块"></a>collections 模块</h4><p>​    是一个实现特定的目标容器，提供对 python 内置的数据结构上的补充</p><table><thead><tr><th>补充结构</th><th>说明</th></tr></thead><tbody><tr><td>namedtuple()</td><td>可命名的元组，元素访问可以通过访问属性获取，也支持索引访问</td></tr><tr><td>deque()</td><td>双端对列，左右都可以进行增删操作</td></tr><tr><td>OrderedDict()</td><td>有序的字典结构，会按照 键-值 插入的顺序来返回，字典的子类</td></tr><tr><td>defaultdict()</td><td>给创建的字典附上默认的值，字典的子类</td></tr><tr><td>Counter()</td><td>用来统计集合中每一个元素的次数，字典的子类</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">point = collections.namedtuple(<span class="string">&#x27;Point&#x27;</span>, <span class="string">&#x27;x, y&#x27;</span>)</span><br><span class="line">p = point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p))             <span class="comment"># &lt;class &#x27;__main__.Point&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(p.x)                 <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(p.y)                 <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(p.x == p[<span class="number">0</span>])         <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">myque = collections.deque()</span><br><span class="line">myque.append(<span class="number">1</span>)</span><br><span class="line">myque.append(<span class="number">2</span>)</span><br><span class="line">myque.appendleft(<span class="number">3</span>)            <span class="comment"># 左端插入</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(myque))             <span class="comment"># &lt;class &#x27;collections.deque&#x27;&gt;  </span></span><br><span class="line"><span class="built_in">print</span>(myque)                   <span class="comment"># deque([3, 1, 2])</span></span><br><span class="line"></span><br><span class="line">myque.extendleft([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])      <span class="comment"># extendleft 左端扩展，元素按顺序依次在左边插入</span></span><br><span class="line"><span class="built_in">print</span>(myque)                   <span class="comment"># deque([6, 5, 4, 3, 1, 2])</span></span><br><span class="line"></span><br><span class="line">myque.rotate(<span class="number">1</span>)                <span class="comment"># rotate 的参数是正数，相当于 d.appendleft(d.pop())</span></span><br><span class="line"><span class="built_in">print</span>(myque)                   <span class="comment"># deque([2, 6, 5, 4, 3, 1])</span></span><br><span class="line"></span><br><span class="line">myque.rotate(-<span class="number">1</span>)               <span class="comment"># rotate 的参数是负数，相当于 d.append(d.popleft())</span></span><br><span class="line"><span class="built_in">print</span>(myque)                   <span class="comment"># deque([6, 5, 4, 3, 1, 2])</span></span><br><span class="line"></span><br><span class="line">myque.pop()</span><br><span class="line">myque.popleft()                <span class="comment"># 左端删除</span></span><br><span class="line"><span class="built_in">print</span>(myque)                   <span class="comment"># deque([5, 4, 3, 1])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myque.maxlen)            <span class="comment"># None，maxlen 返回队列界限，如果在初始化队列时设置 maxlen 的界限，则一旦队列长度到达该值就无法继续插入，如果插入就会抛出异常</span></span><br><span class="line"></span><br><span class="line">myque = collections.deque(maxlen=<span class="number">3</span>)</span><br><span class="line">myque.append(<span class="number">1</span>)</span><br><span class="line">myque.append(<span class="number">2</span>)</span><br><span class="line">myque.appendleft(<span class="number">3</span>)</span><br><span class="line">myque.insert(<span class="number">8</span>,<span class="number">88</span>)             <span class="comment"># IndexError: deque already at its maximum size</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">c = collections.Counter(<span class="string">&#x27;aasxddaz&#x27;</span>)    <span class="comment"># Counter 通常当做计数器使用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))                 <span class="comment"># &lt;class &#x27;collections.Counter&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(c)                       <span class="comment"># Counter(&#123;&#x27;a&#x27;: 3, &#x27;d&#x27;: 2, &#x27;s&#x27;: 1, &#x27;x&#x27;: 1, &#x27;z&#x27;: 1&#125;)</span></span><br><span class="line"><span class="built_in">print</span>(c.most_common(<span class="number">3</span>))        <span class="comment"># [(&#x27;a&#x27;, 3), (&#x27;d&#x27;, 2), (&#x27;s&#x27;, 1)]，most_common 将统计出的次数使用键值的元组形式返回在列表中，有一个参数 n，用来设置返回的个数，会按照频次排列</span></span><br><span class="line"></span><br><span class="line">c = collections.Counter(&#123;<span class="string">&#x27;red&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;blue&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;green&#x27;</span>])              <span class="comment"># 0，键不存在返回 0</span></span><br><span class="line"></span><br><span class="line">c_a = collections.Counter(a=<span class="number">3</span>,b=<span class="number">2</span>,c=<span class="number">0</span>)</span><br><span class="line">c_b = collections.Counter(a=<span class="number">2</span>,b=<span class="number">4</span>,c=<span class="number">1</span>)</span><br><span class="line">c_a.subtract(c_b)              <span class="comment"># subtract 方法可以用作两个队列相减</span></span><br><span class="line"><span class="built_in">print</span>(c_a)                     <span class="comment"># Counter(&#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: -1, &#x27;b&#x27;: -2&#125;)</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">d = collections.OrderedDict.fromkeys(<span class="string">&#x27;abcd&#x27;</span>)    <span class="comment"># OrderedDict 的返回会按照键值插入的顺序，内部是使用了双向链表来保存键进入的顺序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d))                 <span class="comment"># &lt;class &#x27;collections.OrderedDict&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(d)                       <span class="comment"># OrderedDict([(&#x27;a&#x27;, None), (&#x27;b&#x27;, None), (&#x27;c&#x27;, None), (&#x27;d&#x27;, None)])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d.popitem())             <span class="comment"># (&#x27;d&#x27;, None)</span></span><br><span class="line"><span class="built_in">print</span>(d.popitem(<span class="literal">False</span>))        <span class="comment"># (&#x27;a&#x27;, None)</span></span><br><span class="line"><span class="comment"># popitem 有一个参数 last，默认为 True，表示删除最后一个键值（LIFO），如果为 false，则是删除第一个元素（FIFO）</span></span><br><span class="line"></span><br><span class="line">d.move_to_end(<span class="string">&#x27;b&#x27;</span>)      <span class="comment"># move_to_end 方法将执行的键与其对应值，移动到字典的最后，最右侧</span></span><br><span class="line"><span class="built_in">print</span>(d)                <span class="comment"># OrderedDict([(&#x27;a&#x27;, None), (&#x27;c&#x27;, None), (&#x27;d&#x27;, None), (&#x27;b&#x27;, None)])</span></span><br><span class="line"> </span><br><span class="line">d.move_to_end(<span class="string">&#x27;b&#x27;</span>, last=<span class="literal">False</span>)   <span class="comment"># 如果 last=False，则表示将指定的键值移动到字典的最左侧</span></span><br><span class="line"><span class="built_in">print</span>(d)                <span class="comment"># OrderedDict([(&#x27;b&#x27;, None), (&#x27;a&#x27;, None), (&#x27;c&#x27;, None), (&#x27;d&#x27;, None)])</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">d = collections.defaultdict(<span class="built_in">list</span>)    <span class="comment"># defaultdict 和字典的 setdefault 的方法一致，给字典中不存在的键赋上默认值</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])           <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>]+[<span class="number">1</span>])       <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;a&#x27;: []&#125;)</span></span><br><span class="line"></span><br><span class="line">d = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])           <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>)       <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;a&#x27;: 0&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="mmap-模块"><a href="#mmap-模块" class="headerlink" title="mmap 模块"></a>mmap 模块</h4><p>​    是一个内存映射模块，用来提升对大本文的内容处理，其本质是将文件或是其他对象映射到进程的地址空间，来实现文件所在磁盘的地址与进程虚拟地址空间中的一块虚拟地址进行对映关系，<strong>相对于频繁要去读或写的大文件而言，利用 mmap 方法处理就显得更加高效且优雅，因为文件不会真正的被移入到内存中，而是利用虚拟地址关联对文件进行操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap <span class="keyword">from</span> mmap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 mmap 对象</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;log.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    m = mmap(f.fileno(), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># fileno() 方法会返回一个整型的文件描述符</span></span><br><span class="line">    <span class="comment"># 第二个参数 length 表示要映射的文件的大小，0 表示映射整个文件</span></span><br><span class="line">------------------------------------------------------------------------------------------------------  </span><br><span class="line"><span class="comment"># 一些常见的方法</span></span><br><span class="line">m.find(<span class="built_in">str</span>, start=<span class="number">0</span>)    <span class="comment"># 从 start 开始，找到 str 字符串在 m 对象中第一次出现的下标</span></span><br><span class="line"></span><br><span class="line">m.read(n)               <span class="comment"># 返回从指针对应位置向后到 n 的字节的字符串，一开始指针为 0，会根据 n 向后移动，注意返回的字符串是 bytes 类型的</span></span><br><span class="line"></span><br><span class="line">m.readline()            <span class="comment"># 按行读取，包含 \n 的字节内容，如果已经读到了 EOF（指文件没有更多可读取内容）则会抛出 ValueError 异常</span></span><br><span class="line"></span><br><span class="line">m.read_byte()           <span class="comment"># 读取 1 个字节的内容，</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>:<span class="number">10</span>]                 <span class="comment"># m 对象也支持切片读取内容的形式</span></span><br><span class="line"></span><br><span class="line">m.size()                <span class="comment"># 返回映射的文件的大小</span></span><br><span class="line"></span><br><span class="line">m.tell()                <span class="comment"># 返回文件指针当前的位置</span></span><br><span class="line"></span><br><span class="line">m.seek(pos, how=<span class="number">0</span>)      <span class="comment"># 修改光标指针的位置</span></span><br><span class="line"></span><br><span class="line">m.write(<span class="built_in">str</span>)            <span class="comment"># 在指针的当前位置，写入 str，str 的内容必须要要是 byte 类型的，且如果 m 的空间不满足 str 的 len，也会抛出 ValueError 的异常</span></span><br></pre></td></tr></table></figure><h3 id="pip-查看包的依赖关系"><a href="#pip-查看包的依赖关系" class="headerlink" title="pip 查看包的依赖关系"></a>pip 查看包的依赖关系</h3><p>​    可以使用 pip 先安装 pipdeptree 这个库，然后就可以使用 pipdeptree 命令查看当前环境下所有已安装的包的依赖关系，也可以使用 <code>-p 包名</code> 查看具体的包依赖关系</p><h3 id="tenacity-重试库"><a href="#tenacity-重试库" class="headerlink" title="tenacity 重试库"></a>tenacity 重试库</h3><p>​    该模块中提供了一个用于对函数进行重试的 retry 装饰器函数，并提供了一些参数来丰富功能</p><p>​    官方案例：<a href="https://tenacity.readthedocs.io/en/latest/">https://tenacity.readthedocs.io/en/latest/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt, stop_after_delay</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_attempt(<span class="params"><span class="number">7</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stop_after_7_attempts</span>():</span><br><span class="line"> <span class="comment"># 重试 7 次后抛出异常</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Stopping after 7 attempts&quot;</span>)</span><br><span class="line"> <span class="keyword">raise</span> Exception</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_delay(<span class="params"><span class="number">10</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stop_after_10_s</span>():</span><br><span class="line"> <span class="comment"># 重试 10 秒后抛出异常</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Stopping after 10 seconds&quot;</span>)</span><br><span class="line"> <span class="keyword">raise</span> Exception</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=(<span class="params">stop_after_delay(<span class="params"><span class="number">10</span></span>) | stop_after_attempt(<span class="params"><span class="number">5</span></span>)</span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stop_after_10_s_or_5_retries</span>():</span><br><span class="line"> <span class="comment"># 重试 10 秒或 5 次后抛出异常</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Stopping after 10 seconds or 5 retries&quot;</span>)</span><br><span class="line"> <span class="keyword">raise</span> Exception</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="requests-库"><a href="#requests-库" class="headerlink" title="requests 库"></a>requests 库</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    requests 库可以实现通过发送请求获取到网页的源代码，在 http 协议中最常用的请求就是 GET，POST</p><p>​    requests 是 python 的一个第三方库，所以可以使用 pip 去进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>​    直接上例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">reponse = requests.get(url=<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>​    这便是最简单的方式获取到网页源代码，text 方法可以看到整个网页的 html 结构</p><h5 id="带参数的-GET-请求"><a href="#带参数的-GET-请求" class="headerlink" title="带参数的 GET 请求"></a>带参数的 GET 请求</h5><p>​    有时候通常在使用 GET 请求进行数据获取时，需要携带一些参数发给服务器，使用 <strong>GET 请求下，参数都是跟在访问的 url 后面使用 “?” 隔开</strong>，通过键值形式添加参数，<strong>多个参数之间使用 “&amp;” 隔开</strong></p><p>​    例如：<a href="https://www.baidu.com/s?wd=requests">https://www.baidu.com/s?wd=requests</a> ，那此时使用这个 url 的情况下，用 requests.get 一样可以实现对网页结构源码的获取，但是这样的写法明显不是最优的，requests 提供了使用参数的形式进行传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reuqests</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;hamilton&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">&quot;http://httpbin.org/get&quot;</span>, params=params)</span><br><span class="line"><span class="comment"># r = requests.get(&quot;http://httpbin.org/get&quot;, params=&#123;&#x27;name&#x27;:&#x27;hamilton&#x27;&#125;)</span></span><br></pre></td></tr></table></figure><p>​    通过关键字参数 <strong>params</strong> 可以指定所需要携带的参数，这样省去了对 url 的构造，注意参数要以 <strong>字典形式</strong> 传入</p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>​    使用 requests.post 发起 POST 请求，对于携带 <strong>参数</strong> 的 POST 的请求 <strong>使用 data 进行指定</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, data=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;hamilton&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><h4 id="请他的请求类型"><a href="#请他的请求类型" class="headerlink" title="请他的请求类型"></a>请他的请求类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新</span></span><br><span class="line">response = requests.put(<span class="string">&#x27;http://httpbin.org/put&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">response = requests.delete(<span class="string">&#x27;http://httpbin.org/delete&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取头部信息</span></span><br><span class="line">response = requests.head(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取服务端支持的请求方法</span></span><br><span class="line">response = requests.options(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>​    请求完成后，得到的便是响应，requests 库对于响应也提供了很多属性和方法来获取对应的信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">reponse = requests.get(url=<span class="string">&quot;https://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)          <span class="comment"># text 方法会对获取的 response 进行解码返回 str 类型</span></span><br><span class="line"><span class="built_in">print</span>(response.content)       <span class="comment"># content 方法返回的就是下载后原数据，这是一个 bytes 类型的</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)       <span class="comment"># 返回头部</span></span><br><span class="line"><span class="built_in">print</span>(response.cookies)       <span class="comment"># 获取 cookie，如果要返回字典形式，使用 respone.cookies.get_dict()</span></span><br><span class="line"><span class="built_in">print</span>(response.url)           <span class="comment"># 获取请求的 url</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)   <span class="comment"># 获取响应的状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.history)       <span class="comment"># 返回的是一个列表，用来记录重定向的响应</span></span><br></pre></td></tr></table></figure><p>​    其中 headers 获取到响应头的信息，返回的是一个CaseInsensitiveDict 对象；cookies 则是获取 Cookies，返回的是 RequestsCookieJar 对象</p><p>​    对于状态码，status_code 的到状态码返回的是 int 类型，在 requests 库中也包含一个内置的状态码查询对象 codes，通常判断是否成功会直接使用数字和 status_code 进行判断，使用 codes 即省去数字从而使用字符串形式来表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.status_code = requests.codes.ok</span><br></pre></td></tr></table></figure><h5 id="codes-对应的状态码查询条件"><a href="#codes-对应的状态码查询条件" class="headerlink" title="codes 对应的状态码查询条件"></a>codes 对应的状态码查询条件</h5><p><img src="https://s0.lgstatic.com/i/image3/M01/72/AB/CgpOIF5on8OATn1rAApl7Kdp5_0626.png" alt="img"> </p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>​    requests 也可以完成文件的上传，同样可以使用关键字参数  <code>files</code> 来指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;hamilton.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, files=files)</span><br></pre></td></tr></table></figure><p>​    上面的代码得到的响应结果中会有一个 “form” 字段，但是这是一个空字典，所以这样的文件上传会单独有一个 file 字段来标识</p><h4 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h4><p>​    Requests 支持 <strong>流式上传</strong>，来 <strong>允许大的数据流或文件上传，且无需先将文件的数据全部读取到内存中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;massive-body&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    requests.post(<span class="string">&#x27;http://some.url/streamed&#x27;</span>, data=f)</span><br></pre></td></tr></table></figure><p>​    对于流式上传方式，官方强烈建议是 <strong>使用二进制的方式打开文件进行上传</strong>，因为 requests 可能会因为 header 请求头中的 Content-Length，而被指定了文件的字节数，如果以文本打开，可能会出现错误</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>​    之前已经提到了对于 cookie 的获取，使用响应对象的 <code>cookies</code> 属性即可，但是这样获取得到的是一个对象 CookieJar，所以还需要进行遍历才可得到 cookies 中详细的键值数据</p><p>​    cookie 作用是对用户进行状态标识，在网站登录之后请求头中有一个 “Cookie” 字段记录信息，对于这样的 cookie，可以直接复制到关键字参数 headers 中，以此获取登录后的页面结构数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;_uuid=606D9B4B-11DB-9D50-5AA3-AE6F0BBB844B75574infoc; buvid3=96E1A462-DAEA-4891-8E51-0E095E45D98A155820infoc; INTVER=1; bsource=seo_baidu; sid=5ngoikai; CURRENT_FNVAL=16; LIVE_BUVID=AUTO1915857969872848; rpdid=|(Jll|Y|Ykuu0J&#x27;</span>ul)l~mYmmk; JSESSIONID=E7DF9412F60678D6EE1DCD93BF9A9A0A; PVID=<span class="number">3</span>; DedeUserID=<span class="number">279360708</span>; DedeUserID__ckMd5=ac4e0f481883027d; SESSDATA=<span class="number">44033985</span>%2C1601538481%2C21a79*<span class="number">41</span>; bp_t_offset_279360708=<span class="number">380854030251818839</span>; CURRENT_QUALITY=<span class="number">64</span><span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">response = requests.get(&#x27;</span>http://httpbin.org<span class="string">&#x27;, headers=headers)</span></span><br></pre></td></tr></table></figure><p>​    由于 cookies 属性获取得到的是 CookieJar 对象，因此也可以自己构建一个这样一个对象，然后赋给关键字 cookies</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">impost requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">&#x27;_uuid=606D9B4B-11DB-9D50-5AA3-AE6F0BBB844B75574infoc; buvid3=96E1A462-DAEA-4891-8E51-0E095E45D98A155820infoc; INTVER=1; bsource=seo_baidu; sid=5ngoikai; CURRENT_FNVAL=16; LIVE_BUVID=AUTO1915857969872848; rpdid=|(Jll|Y|Ykuu0J&#x27;</span>ul)l~mYmmk; JSESSIONID=E7DF9412F60678D6EE1DCD93BF9A9A0A; PVID=<span class="number">3</span>; DedeUserID=<span class="number">279360708</span>; DedeUserID__ckMd5=ac4e0f481883027d; SESSDATA=<span class="number">44033985</span>%2C1601538481%2C21a79*<span class="number">41</span>; bp_t_offset_279360708=<span class="number">380854030251818839</span>; CURRENT_QUALITY=<span class="number">64</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">headers = &#123;&#x27;</span>User-Agent<span class="string">&#x27;: &#x27;</span>Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">78.0</span><span class="number">.3904</span><span class="number">.70</span> Safari/<span class="number">537.36</span><span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 实例化 request.cookie 的 RequestsCookieJar，通过遍历设置 cookie 中键值对信息</span></span><br><span class="line"><span class="string">cookie_jar = request.cookie.RequestsCookieJar()</span></span><br><span class="line"><span class="string">for cookie in cookies.split(&quot;;&quot;):</span></span><br><span class="line"><span class="string">key,value = cookie.split(&quot;=&quot;, 1)</span></span><br><span class="line"><span class="string">cookie_jar.set(key,value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">response = requests.get(&#x27;</span>http://httpbin.org<span class="string">&#x27;, cookies=cookie_jar, headers=headers)</span></span><br></pre></td></tr></table></figure><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​    在 requests 中，直接使用 get 或 post 等方法可以模拟网页的请求，但实际上是相当于是不同的 Session 访问，相当于每次都打开一个新的浏览器并访问对应的页面，而不是在一个浏览器中打开多个标签访问页面，当然可以在请求中每次访问都加上获得的 cookie，但这样会略显麻烦</p><p>​    对此使用 Session，则相当于是维持了浏览器的会话，这样就不用担心 cookie 的问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">&#x27;http://httpbin.org/cookies/set/name/hamilton&#x27;</span>)</span><br><span class="line">response = s.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;cookies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;hamilton&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line">requests.get(<span class="string">&#x27;http://httpbin.org/cookies/set/name/hamilton&#x27;</span>)</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/cookies&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;cookies&quot;</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面分别使用了 session 的 get 和 直接使用 requests 的 get 请求去设置一个 cookie 参数，使用 session 的返回结果会将设置的 cookie 键值在字典中的 “cookies” 返回，而 requests.get 结果返回的字典中 “cookies” 的值是一个空字典</p><h4 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h4><p>​    这是针对 https 协议产生的一个验证方式，有时候某些网站可能会因为没有设置好 https 的证书或是证书不被 CA 认证机构认可，此时访问页面会出现 SSL 证书的错误提示，但是这样页面并不是完全不可访问</p><p><img src="https://s0.lgstatic.com/i/image3/M01/72/AB/Cgq2xl5on8WARK6YAABlizks2bg479.png" alt="img"> </p><p>​    对于这样的页面，直接使用 requests 去 get 网页的 url 的时候，requests 是会抛出一个 SSLError 的错误，来告知请求的 url 的证书是无效的，如果必须要爬取这个页面，可以通过 <code>verify</code> 的参数指定 False 来控制不对证书进行验证，默认情况下该参数的值是 True</p><p>​    当然也可以通过证书文件的路径来指定认证证书（如果 <code>verify</code> 设为文件夹路径，文件夹必须通过 OpenSSL 提供的 c_rehash 工具处理），并且也可以通过 Session 将认证证书保持在会话中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, verify=<span class="literal">False</span>)</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, verify=<span class="string">&#x27;path/certfile&#x27;</span>)</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">s = requests.Session()</span><br><span class="line">s.verify = <span class="string">&#x27;/path/to/certfile&#x27;</span></span><br></pre></td></tr></table></figure><p>​    注意， <strong>通过 <code>verify</code> 指定 False 后</strong>，虽然可以成功请求，但是 <strong>依然会抛出一个警告</strong>，被建议去指定证书</p><p><img src="https://s0.lgstatic.com/i/image3/M01/72/AB/Cgq2xl5on8aAYCOAAAH4qQ_1ws4776.png" alt="img"> </p><p>​    对此，<strong>可以通过忽略警告的方式去屏蔽抛出的警告或是通过捕获警告到日志的形式忽略</strong>，分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.captureWarnings(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><p>​    网页的请求操作是 IO型 的，这意味可能会由于各种原因，例如网络状态不好或服务器出现高延迟等，使得 get 页面时需要等待很长时间，甚至是无法收到响应而报错，对此为了拒绝长时间等待一个响应，<strong>设置超时时间 <code>timeout</code> 参数指定一个最大等待时间，在此时间内无法得到结果则主动抛出异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, timeout=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>​    <code>timeout</code> 参数的值单位是秒，这个值包含了 <strong>连接（connect）</strong>和 <strong>读取（read）</strong>两个阶段的时间总和，因此也可以分别对这两个阶段的超时单独指定通过元组的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, timeout=(<span class="number">3</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>​    在不设置 <code>timeout</code> 的情况下，<strong>默认值是 None</strong>，也就是死等，不等到结果不罢休，直到最后报错</p><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>​    在之前我们是通过登录后获取 cookie 再对网页使用 requests 进行请求，但是 requests 其实提供了身份认证的功能，也就是 <strong><code>auth</code> 参数，来设置用户名和密码</strong>，默认是使用 auth 模块的 HTTPBasicAuth 去传递来进行认证，不过 request 为了更加简便，可以直接传递一个元组，默认会去自动去调用 HTTPBasicAuth 做认证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, auth=HTTPBasicAuth(<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>))</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, auth=(<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>))</span><br></pre></td></tr></table></figure><p>​    除了自带的认证方式，还有其他的认证如 OAuth 认证，不过需要安装对应的 oauth 的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests_oauthlib</span><br></pre></td></tr></table></figure><p>​    OAuth 的文档：<a href="https://requests-oauthlib.readthedocs.io/en/latest/">https://requests-oauthlib.readthedocs.io/en/latest/</a> </p><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p>​    代理设置是反爬的一种策略之一，因为通常网站的后台会对网站的流量进行检测，如果一个时间段内频繁的请求页面可能会被检测到，从而网站会要求进行验证码的验证，或是跳回登录页面认证，又或者是将请求的 ip 加到黑名单中禁封一段时间等等，这样导致爬取程序就会停止，为了解决这个反爬策略，通过设置参数 proxies 设置代理 ip</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&#123;ip&#125;:&#123;port&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://&#123;ip&#125;:&#123;port&#125;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(<span class="string">&quot;http://httpbin.org/get&quot;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><p>​    除了 http 协议外，requests 还支持 socks 协议，前提需要使用 pip 安装第三方的 requests[socks] 库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;socks5://user:password@host:port&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;socks5://user:password@host:port&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><h4 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h4><p>​    其实在使用 get，post 等方法进行请求发送的时候，requests 的内部构造了一个 Request 对象，并在给对象赋上参数，包括 url，headers，datas 等</p><p>​    最后是直接将这个 Request 对象发送出去，在请求成功后得到有服务器返回的 Response 对象，所以发送出去的这个 Request 其实就是内部的 Prepared Request 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Session, Request</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">s = Session()</span><br><span class="line">request = Request(method=<span class="string">&#x27;POST&#x27;</span>, url=<span class="string">&#x27;http://httpbin.org/post&#x27;</span>, data=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;hamilton&#x27;</span>&#125;， headers=headers)</span><br><span class="line">prepped = s.prepare_request(request)</span><br><span class="line"><span class="comment"># prepped = request.prepare()</span></span><br><span class="line">response = s.send(prepped)</span><br></pre></td></tr></table></figure><p>​    当直接实例化 Request 的对象后，使用 prepare 方法就可以建立 Prepared Request 对象，通过 session 的 send 方法就可以发起请求，如注释的代码那样</p><p>​    但是这样的请求就失去了 Session 对象的优势，因为 cookie 不会被应用到请求上，所以通常使用 Session 对象的 prepare_request 方法将实例的 Request 作为参数传入，再使用 send 发出请求</p><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>​    在开发项目时，安装模块都是会是直接利用 pip 去安装，这些包会下载到 python3 的 site_packages 的目录下，但是如果多个项目使用的包都不同，如果使用同一个包目录，会导致包目录非常冗余，多个项目在实现开发和部署时，都会比较麻烦，因为有的框架和包之间可能存在依赖或是版本上的不支持等</p><p>​    所以，开发不同的项目时，正确的方式是创建各个项目自己的虚拟环境，虚拟环境的创建相当于是给项目指定了自己的包目录，这样一来就不会将包安装在全局 python3 的包目录下，从而实现项目之间包和模块的隔离</p><h4 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h4><p>​    Python 的虚拟环境使用的是 virtualenv 这个库，使用 pip 去下载安装 <code>pip install virtualenv</code></p><p>​    <strong>创建虚拟环境：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先创建好项目文件夹，通过命令行进入到项目目录</span></span><br><span class="line">&gt; cd C:/Users/DELL/Desktop/myproject</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 virtualenv 命令创建项目的虚拟环境，默认使用系统中安装的 python 解释器</span></span><br><span class="line">&gt; virtualenv myproject</span><br><span class="line">created virtual environment CPython3<span class="number">.7</span><span class="number">.1</span>.final<span class="number">.0</span>-<span class="number">64</span> <span class="keyword">in</span> 813ms</span><br></pre></td></tr></table></figure><p>​    创建完成后，项目下就会出现一个虚拟环境的文件夹，当进入到项目虚拟环境后使用 pip 安装就会安装到该目录下 Lib 下的 site-packages 中</p><p>​    如果系统中安装了多个 python 版本，项目需要使用指定的版本，可以通过参数 p 来指定使用的 python 解释器的目录位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; virtualenv -p /usr/<span class="built_in">bin</span>/python2<span class="number">.7</span>  myproject</span><br></pre></td></tr></table></figure><p>​    <strong>激活与退出虚拟环境：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; source myproject/<span class="built_in">bin</span>/activate</span><br><span class="line"><span class="comment"># 进入虚拟环境需要执行 bin 下的 activate 的 bat 文件，进入到虚拟环境后，就可以根据需求用 pip 去安装所需要的库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是在 windows 系统，是没有 bin 目录的，并且不需要使用 source 命令，直接启动 activate 就能进入</span></span><br><span class="line"><span class="comment"># &gt; ./myptoject/Script/activate</span></span><br><span class="line"></span><br><span class="line">&gt; deactivate</span><br><span class="line"><span class="comment"># 退出虚拟环境，可以直接执行 deactivate，也可以到 bin 目录下执行</span></span><br></pre></td></tr></table></figure><h5 id="python-virtualenv-虚拟环境问题"><a href="#python-virtualenv-虚拟环境问题" class="headerlink" title="python virtualenv 虚拟环境问题"></a>python virtualenv 虚拟环境问题</h5><p>​    在本机安装了 python2 和 python3 两个版本后，两个版本都把安装目录的 python.exe 执行文件分别更名为 python2.exe  和 python3.exe，但是再使用 <code>python3 -m virtualenv venv</code> 创建 py3 的虚拟环境后，在 pycharm 中选择解释器时，总是提示说 python 的 sdk 是无效的</p><p>​    思来想去一直以为是电脑的环境变量的问题，在删除了一些可能无用的变量后，在命令行上测试 python2 和 python3 都是可以进入解释器的。在排查生成的 py2 和 py3 的虚拟环境后，发现两个虚拟环境唯一的区别是 Scripts 目录下解释器文件名不同，分别是 python2.exe 和 python.exe，原来虚拟环境里的解释器文件名和实际安装目录的解释器文件名是不统一的</p><p>​    对此，解决办法就是将 python3 安装目录下的执行文件改回 python.exe 和 pythonw.exe，同时将环境变量的 python3 改为 python，然后才测试发现 pycharm 中可以读取虚拟环境中的解释器了</p><p>​    如果要保留 python3，可以将 python3 的安装目录拷贝一份，再按照上述方法修改，这样系统的 python 和 python3 都可以打开本机安装的 python3 本版本的解释器，但是虚拟环境创建就需要用 python 而不是 python3</p><h4 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h4><p>​    virtualenvwrapper 是 virtualenv 的一个扩展包，使得对虚拟环境的管理更加方便，前提是需要先安装 virtualenv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># win 安装</span></span><br><span class="line">pip install virtualenvwrapper-win</span><br><span class="line"><span class="comment"># linux 安装</span></span><br><span class="line">pip install virtualenvwrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装好之后，需要配置环境变量</span></span><br><span class="line">export WORKON_HOME=~/Envs</span><br><span class="line"><span class="comment"># 然后创建虚拟环境的管理目录</span></span><br><span class="line">mkdir -p $WORKON_HOME</span><br><span class="line"><span class="comment"># 使用 find 命令找到 virtualenvwrapper.sh 文件</span></span><br><span class="line">find / -name virtualenvwrapper.sh</span><br><span class="line"><span class="comment"># 使用 source 去执行这个目录</span></span><br><span class="line">source  virtualenvwrapper.sh 的路径</span><br></pre></td></tr></table></figure><p>​    <strong>创建虚拟环境：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkvirtualenv  myproject  --python=python2<span class="number">.7</span></span><br><span class="line"><span class="comment"># 创建使用 mkvirtualenv，如果要指定解释器使用 --python= 去指定</span></span><br></pre></td></tr></table></figure><p>​    <strong>激活与退出虚拟环境：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; workon </span><br><span class="line"><span class="comment"># 进入前可以先使用 workon 命令，查看所有的虚拟环境</span></span><br><span class="line"></span><br><span class="line">&gt; workon myproject</span><br><span class="line"><span class="comment"># workon 后面加上虚拟环境的名字，就能进入该虚拟环境下</span></span><br><span class="line"></span><br><span class="line">&gt; deactivate</span><br><span class="line"><span class="comment"># 退出虚拟环境还是一样执行 deactivate</span></span><br></pre></td></tr></table></figure><p>​    如果要删除一个虚拟环境使用 <code>rmvirtualenv 虚拟环境的名字</code></p><h3 id="mysqlclient-操作数据库"><a href="#mysqlclient-操作数据库" class="headerlink" title="mysqlclient 操作数据库"></a>mysqlclient 操作数据库</h3><p>​    mysqlclient 和 pymysql 两个第三方库都可以实现 python 对 mysql 数据库的操作，pymysql 是纯 Python 去实现，所以在效率上会比 mysqlclient 差一些，使用 pip 安装的命令 <code>pip install mysqlclient</code>，如果出现安装的问题，也可以使用 whl 的文件进行安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line">conn = MySQLdb.connect(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, passwd=<span class="string">&#x27;root&#x27;</span>, db=<span class="string">&#x27;test1&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"><span class="comment"># 创建连接后，需要使用 cursor 来创建游标，只要游标才能去执行 sql</span></span><br><span class="line"></span><br><span class="line">insert_sql = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            insert into article(title, url, content, create_date) </span></span><br><span class="line"><span class="string">            values(%s, %s, %s, %s)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cur.execute(insert_sql, (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;https://xx/xx&#x27;</span>, <span class="string">&#x27;life is short&#x27;</span>, <span class="string">&#x27;2021-05-05&#x27;</span>))</span><br><span class="line"><span class="comment"># 使用游标的 execute 去执行 sql 语句，防止直接执行拼接字符串的 sql，导致程序出现 sql 注入问题</span></span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line"><span class="comment"># 关闭与数据库的连接前，应该先关闭游标，如果不想手动管理游标，可以使用 with connect as cursor 来创建游标上下文</span></span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment"># 连接对象的 commit 方法用来将执行的事务提交到 mysql 数据库上，插入语句必须要有 commit</span></span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># 完成提交后，关闭当前连接对象与数据库的连接</span></span><br></pre></td></tr></table></figure><p>​    如果一个插入语句存在多个值，可以使用 excutemany 方法来执行 sql 语句，但是需要先将多个值放入到列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cur.executemany(insert_sql, </span><br><span class="line">                [</span><br><span class="line">                    (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;https://xx/xx&#x27;</span>, <span class="string">&#x27;life is short&#x27;</span>, <span class="string">&#x27;2021-05-05&#x27;</span>),</span><br><span class="line">                 (<span class="string">&#x27;c++&#x27;</span>, <span class="string">&#x27;https://xxx/xxx&#x27;</span>, <span class="string">&#x27;life is shit&#x27;</span>, <span class="string">&#x27;2021-03-12&#x27;</span>),</span><br><span class="line">                 (<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;https://xxx/xx&#x27;</span>, <span class="string">&#x27;life is easy&#x27;</span>, <span class="string">&#x27;2021-01-22&#x27;</span>),</span><br><span class="line">                ])</span><br></pre></td></tr></table></figure><p>​    对于查询语句来说，使用 execute 执行后得到结果并不会是查询集结果，而是返回查询集中记录的数量，要想得到查询集的结果可以使用 fetchone 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur.execute(<span class="string">&quot;select * from student&quot;</span>)</span><br><span class="line">res = cur.fetchone()</span><br><span class="line"><span class="comment"># 如果查询集有多个对象，使用 fetchone 会逐一向后获取一个记录</span></span><br></pre></td></tr></table></figure><p>​    fetchone 的目的是为了得到查询集中的一个记录，同时还有 fetchmany 方法用来将多个记录获取，fetchmany 需要接受一个参数，这个参数就是要获取的记录的数量，获取到所有的记录对象后，可以通过 for 循环来遍历。如有要一次获取所有的查询结果，可以使用 fetchall 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cur.execute(<span class="string">&quot;select * from student&quot;</span>)</span><br><span class="line">res = cur.fetchmany()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>​    Python 操作 redis，直接安装 <code>pip install redis</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">r = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>，decode_responses=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># r = redis.Redis(host=&#x27;localhost&#x27;, port=6379, db=0)   Redis 是 StrictRedis 的子类，Redis 的连接可以兼容旧版本</span></span><br><span class="line"><span class="comment"># decode_responses 的参数是用于将 redis 返回的字节数解码成字符串</span></span><br></pre></td></tr></table></figure><p>​    Redis 的每一个实例，都会维护自己的一个连接池，可以使用 ConnectionPool 来创建一个连接池，然后通过参数传给 Redis</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, max_connections=<span class="number">5</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br></pre></td></tr></table></figure><h4 id="pipline"><a href="#pipline" class="headerlink" title="pipline"></a>pipline</h4><p>​    pipline 方法其实就是用来实现 redis 中事务的功能，redis 的事务其概念更像是将命令打包，目的是尽可能在一次请求中，去执行更多的命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, max_connections=<span class="number">5</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">pipe = r.pipline(transaction=<span class="literal">True</span>)    <span class="comment"># 这里 transaction 默认就是 True</span></span><br><span class="line"></span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;football&quot;</span>)</span><br><span class="line">pipe.<span class="built_in">set</span>(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;22&quot;</span>)</span><br><span class="line"></span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure><p>​    实例化 pipline 的管道对象后，通过这个 pipline 对象去执行操作时，会将这些命令放入到队列中，最后使用 execute 方法来执行</p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式使用</title>
      <link href="/3968319514/"/>
      <url>/3968319514/</url>
      
        <content type="html"><![CDATA[<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>​    首先，正则表达式的语法规则在任何语言中都可以使用，python中提供一个内置的 re 库并且支持了正则表达式的所有匹配语法规则</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>\w</td><td>匹配一个字母，数字和下划线</td></tr><tr><td>\W</td><td>匹配一个非字母，数字和下划线</td></tr><tr><td>\s</td><td>匹配一个任意空白字符，等同于使用 [\n\t]</td></tr><tr><td>\S</td><td>匹配一个非任意空白字符</td></tr><tr><td>\d</td><td>匹配一个任意数字，等同于 [0-9]</td></tr><tr><td>\D</td><td>匹配一个非数字字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果有换行，只匹配到换行符前面的最后一个字符</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果有换行，只匹配到换行符位置</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个tab制表符</td></tr><tr><td>^</td><td>匹配匹配一行字符串开头</td></tr><tr><td>$</td><td>匹配匹配一行字符串结尾</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td>[…]</td><td>匹配方括号中的一组字符，将结果单独列出，在字符组中的 :  ，.， ( )， |会失去原有的意义，- 不能单独放在字符组中，需加上 \ 防止转义</td></tr><tr><td>[^…]</td><td>匹配不在方括号中的一组字符</td></tr><tr><td>*</td><td>匹配0或多次表达式</td></tr><tr><td>+</td><td>匹配1或多次表达式</td></tr><tr><td>？</td><td>匹配0或1次表达式，表示非贪婪匹配</td></tr><tr><td>{n}</td><td>匹配指定字符出现次数是n的表达式</td></tr><tr><td>{n,m}</td><td>匹配出现次数范围是n到m</td></tr><tr><td>a|b</td><td>匹配字符a或b</td></tr><tr><td>()</td><td>匹配括号内的表达式，表示一个分组</td></tr><tr><td>.*</td><td>通用匹配，表示匹配所有的任意字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>​    match 是 re 模块中的一个常用匹配方法，第一个参数是正则表达式，第二个参数是待匹配字符串。该方法会从字符串的起始位置开始匹配传入的正则表达式，有匹配项则返回结果，如果字符串中没有匹配项则返回None</p><p>​    通过 match 方法匹配后得到是 SRE_Match 的正则对象，说明字符串中有匹配项。通过使用 group 方法可以将匹配的内容进行返回；另一个方法 span，则是返回匹配的结果在原字符串的下标位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&#x27;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;&#x27;</span></span><br><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">&#x27;&lt;html&gt;&lt;h1&gt;(.*?)&lt;/h1&gt;&lt;/html&gt;&#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(ret.group())   <span class="comment"># &lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="built_in">print</span>(ret.group(<span class="number">1</span>))  <span class="comment"># www.itcast.cn</span></span><br></pre></td></tr></table></figure><h4 id="目标匹配"><a href="#目标匹配" class="headerlink" title="目标匹配"></a>目标匹配</h4><p>​    通常，在 <strong>使用分组匹配后，会使用 group(1) 去得到返回的结果，而 group()  返回的其实是一个完整的结果，如果在正则表达式中有多个分组，可以使用 group(2)， group(3) 等等</strong></p><p>​    可以使用 groups 方法，这个方法会返回一个元组，将匹配的所有分组返回</p><h3 id="贪婪与非贪婪匹配"><a href="#贪婪与非贪婪匹配" class="headerlink" title="贪婪与非贪婪匹配"></a>贪婪与非贪婪匹配</h3><p>​    通用匹配 .* 可以很大程度简化对没必要匹配的字符规则，但是有时候使用这种方式得到的结果可能并不是想要的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&#x27;hello 517 world to you&#x27;</span></span><br><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">&#x27;^he.*(\d+).*you&#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(ret.group(<span class="number">1</span>))   <span class="comment"># 7</span></span><br></pre></td></tr></table></figure><p>​    <strong>.* 会导致的问题就是贪婪匹配，会尽可能多的去匹配字符串</strong>，对于数字的匹配这里使用的是 \d+ ，也就是最少的匹配是一个数字，因此贪婪匹配会将5， 51 ，一直向后匹配还剩一个数字 7 这也是满足 \d+ 的规则，但是因为 7 之后是非数字了，就不满足 + 了，那么 7 就是最后的满足匹配结果</p><p>​    所以贪婪匹配，可以理解为就是尽可能多地去进行匹配，是要匹配要求满足，就依次进行匹配</p><p>​    因此，就出现了非贪婪匹配，来解决最后的结果不完整的情况，非贪婪匹配的规则很简单，就是 <strong>.*？</strong>。<strong>非贪婪就是尽肯能少地去进行匹配</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&#x27;hello 517 world to you&#x27;</span></span><br><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">&#x27;^he.*?(\d+).*you&#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(ret.group(<span class="number">1</span>))   <span class="comment"># 517</span></span><br></pre></td></tr></table></figure><p>​    非贪婪匹配下，上面的正则就是说尽可能少去匹配，直到匹配到出现第一个数字来满足 \d，所以可以看到使用 .<em>? 后，得到了需要的完整结果 517，但是 *</em>如果要匹配的内容是在字符串的最后，使用非贪婪匹配时就不能获取到想要的结果**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;http://musical.com/name/alexanderhamilton&#x27;</span></span><br><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">&#x27;http.*?name/(.*?)&#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(ret.group(<span class="number">1</span>))</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">s = <span class="string">&#x27;http://musical.com/name/alexanderhamilton&#x27;</span></span><br><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">&#x27;http.*?name/(.*)&#x27;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(ret.group(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># alexanderhamilton</span></span><br></pre></td></tr></table></figure><p>​    上面的的第一种情况便是 .*? 出现在最后匹配，导致打印的返回值是空的，而下面没有 ？的则可以将匹配的内容进行返回</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>​    在正则额表达式中可以通过参数设置修饰符来控制匹配的模式，修饰符是一个可选的标志。例如当匹配的字符串由换行符的情况下，使用正则表达式匹配时，在没有指定换行匹配下，是得不到匹配的结果的，此时如果用 group 方法去获取则会抛出 AttributeError 异常，所以可以通过参数添加修饰符 re.S 来修正错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.<span class="keyword">match</span>(<span class="string">&#x27;http.*?name/(.*)&#x27;</span>, s, re.S)</span><br></pre></td></tr></table></figure><p>​    re.S 通常会在网页源码的匹配中使用，因为在 html 的文档结构中，节点与节点之间基本都是换行的，除了这个修饰符网页的中常用的匹配修饰符还有 re.I ，当然还有其他类型的修饰符来针对的处理其他的匹配情况</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>re.I</td><td>是匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，该标志会影响 \w， \W ，\b 和 \B</td></tr><tr><td>re.X</td><td>该标志通过基于更灵活的格式用来将正则表达式写得更易于理解</td></tr></tbody></table><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>​    search 是另一种匹配的方法，与 match 方法从以正则表达式的开头匹配字符串不同</p><p>​    <strong>match 的正则表达式的开头如果和待匹配字符串的开头不一致，则是会直接返回 None</strong>，可以理解为 match 匹配自带了开头字母匹配的规则</p><p>​    <strong>search 匹配则是会从待匹配字符串开头扫描到结尾，然后返回第一个成功匹配正则的字符串结果</strong></p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>​    对于有相同规律的文本，在使用 search 匹配后，能够得到的是匹配正则的第一个内容，对于这样的情况，要同时将所有的文本匹配出来就可以使用 findall 方法，该方法 <strong>会返回一个列表，每一个元素是元组的形式存储匹配的内容</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">&#x27;&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;AS&lt;/html&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(re.findall(<span class="string">&#x27;&lt;html&gt;&lt;h1&gt;(.*?)&lt;/h1&gt;(.*?)&lt;/html&gt;&#x27;</span>, s))</span><br><span class="line"><span class="comment"># [(&#x27;www.itcast.cn&#x27;, &#x27;AS&#x27;)]</span></span><br></pre></td></tr></table></figure><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>​    使用 sub 方法来直接对匹配的内容进行字符串替换，返回新的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.sub(<span class="string">&#x27;正则表达式&#x27;</span>，<span class="string">&#x27;要替换的字符串&#x27;</span>，<span class="string">&#x27;需要被匹配并进行替换的完整字符串&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>​    该方法是用来提高正则匹配的效率，来复用已经别写好的正则匹配规则，compile 会将编写的正则表达式进行编译，得到一个正则表达式对象，在之后的匹配中如果需要使用规则，就不需要反复写相同的表达式，而是将第一个参数使用已经编译好的正则表达式对象</p><h3 id="常见的正则表达式"><a href="#常见的正则表达式" class="headerlink" title="常见的正则表达式"></a>常见的正则表达式</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单手机号匹配</span></span><br><span class="line">/^[<span class="number">1</span>][<span class="number">3</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]<span class="string">&#123;9&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 身份证匹配</span></span><br><span class="line">/^[<span class="number">1</span>-<span class="number">9</span>]\d<span class="string">&#123;5&#125;</span>(<span class="number">18</span>|<span class="number">19</span>|([<span class="number">23</span>]\d))\d<span class="string">&#123;2&#125;</span>((<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>])|(<span class="number">10</span>|<span class="number">11</span>|<span class="number">12</span>))(([<span class="number">0</span>-<span class="number">2</span>][<span class="number">1</span>-<span class="number">9</span>])|<span class="number">10</span>|<span class="number">20</span>|<span class="number">30</span>|<span class="number">31</span>)\d<span class="string">&#123;3&#125;</span>[<span class="number">0</span>-<span class="number">9</span>Xx]$/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮箱匹配</span></span><br><span class="line">/^([A-Za-z<span class="number">0</span>-<span class="number">9_</span>\-\.])+\@([A-Za-z<span class="number">0</span>-<span class="number">9_</span>\-\.])+\.([A-Za-z]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;)$/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 年月日匹配，YYYY-MM-DD</span></span><br><span class="line">\d<span class="string">&#123;4&#125;</span>-(<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>]|<span class="number">1</span>[<span class="number">0</span>-<span class="number">2</span>])-(<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>]|<span class="number">1</span>[<span class="number">0</span>-<span class="number">9</span>]|<span class="number">2</span>[<span class="number">1</span>-<span class="number">9</span>]|<span class="number">3</span>[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 核心技术</title>
      <link href="/3998260423/"/>
      <url>/3998260423/</url>
      
        <content type="html"><![CDATA[<p>文章内容来自极客时间的《Python核心技术与实战》以及个人的整理</p><h3 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a>列表与元组</h3><p>​    列表和元组在 python 中非常相似，内部的元素允许任何的数据类型，并且都支持嵌套，切片获取，排序等操作，形式上的区别可能就是列表使用 [] 表示，元组使用 () 表示</p><p>​    但是实际的区别是：</p><p>​    <strong>列表是动态（可变）的，长度大小不固定，可以任意的增删改其中的元素</strong></p><p>​    <strong>元组是静态（不可变）的，即长度大小固定，不能在原元组做增删改的操作</strong>，如果要修改只能重新创建一个新的空间，用来存储新的元组</p><p>​    <strong>注意：</strong>通常解释都是列表是可变的，元组是不可变的，但是元组并不是完全的 “不可变”，我们知道 python 中的传递方式，既不是值传递，也不是引用传递，python 中一切皆对象，所以 <strong>python 的传递是对象的引用传递或者说是赋值传递</strong>，所以元组的元素保存的是引用对象的不可变，如果元素本身是一个可变对象，那么元组是可以对该元素进行操作的，但是不能对元素进行增删改或是利用下标索引赋值，所以元组理解上是一个 “不可变” 对象，但是如果其中的元素是可变的，元组依然是可以对其操作的</p><h4 id="列表和元组的存储区别"><a href="#列表和元组的存储区别" class="headerlink" title="列表和元组的存储区别"></a>列表和元组的存储区别</h4><p>​    <strong>对于一个空列表来说，本身的存储会占用 40 个字节，对于空元组来说，则是占用 24 个字节</strong>，所以 <strong>元组相比列表来说，存储上更加轻量化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line"><span class="built_in">print</span>(li.__sizeof__())       <span class="comment"># 40</span></span><br><span class="line">tup = ()</span><br><span class="line"><span class="built_in">print</span>(tup.__sizeof__())      <span class="comment"># 24</span></span><br></pre></td></tr></table></figure><p>​    由于列表是可变的，所以对其来说需要存储指针来指向对应的元素，这就会需要使用额外的空间，并且列表中空间不足后，会立即再分配额外的空间；对于元组来说，由于不可变，所以存储空间是固定的，不会涉及空间不足又分配的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(li.__sizeof__())    <span class="comment"># 72   </span></span><br><span class="line"><span class="comment"># 加入一个元素后，列表的存储变为了 72 个字节，对于数字 int 来说本身是 8 字节</span></span><br><span class="line"><span class="comment"># 所以 (72 - 40)/8 = 4，加入一个元素后，列表分配了 4 个可以存储数字的空间</span></span><br><span class="line">li.append(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(li.__sizeof__())    <span class="comment"># 72  </span></span><br><span class="line">li.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(li.__sizeof__())    <span class="comment"># 72</span></span><br><span class="line">li.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(li.__sizeof__())    <span class="comment"># 72   </span></span><br><span class="line">li.append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(li.__sizeof__())    <span class="comment"># 104</span></span><br><span class="line"><span class="comment"># 当超过了 4 个元素后，列表的空间不足，所以额外有分配了 4 个元素的空间</span></span><br></pre></td></tr></table></figure><p>​    所以，为了减小每一次增加或删除时的空间分配开销，python 会在每一次都多分配一些（over-allocating），以此来保证增删操作在时间复杂度上都是 O(1)</p><h4 id="列表和元组的性能区别"><a href="#列表和元组的性能区别" class="headerlink" title="列表和元组的性能区别"></a>列表和元组的性能区别</h4><p>​    对于不使用且占用空间不大的静态的变量，python 会对这类静态的变量做资源缓存（resource caching），这样就使得下一次再去创建元组，就会去内存中寻找，而不是系统发起请求来分配资源创建，以此来加快程序运行的速度</p><p>​    那由于列表的可变性，所以 <strong>初始化</strong> 的操作上，<strong>列表的性能要慢于元组</strong>，但是在对于 <strong>元素的获取</strong> 上，两则 <strong>几乎没有什么性能的差别</strong></p><p>​    总体来说，元组的性能相比列表会稍微高一些。但是依然要根据场景去合理使用，如果要<strong>存储的元素比较少且不会发生变化或增加/减少，使用元组会更好</strong>；但如果要存储的数据会出现改动或元素总数会发生变化，使用列表来操作显然更加方便</p><h4 id="非要改天命的元组"><a href="#非要改天命的元组" class="headerlink" title="非要改天命的元组"></a>非要改天命的元组</h4><p>​    上面已经说到元组可以看作是不可变的列表，因为元组没有相应的方法去实现增删改，但是非要对元组进行修改难道就不能实现吗？当然不是，<strong>实现元组的修改也很简单，利用索引切片操作就可以实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="string">&quot;what&#x27;s&quot;</span>, <span class="string">&quot;your&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup, <span class="built_in">type</span>(tup), <span class="built_in">id</span>(tup))     </span><br><span class="line"><span class="comment"># (&quot;what&#x27;s&quot;, &#x27;your&#x27;, &#x27;name&#x27;) &lt;class &#x27;tuple&#x27;&gt; 2254194522224</span></span><br><span class="line"></span><br><span class="line">tup = tup[::] + (<span class="string">&#x27;man&#x27;</span>,)    <span class="comment"># 两个元组的合并，可以使用 + 来操作，这会产生一个新元组，而不是原地合并</span></span><br><span class="line"><span class="built_in">print</span>(tup, <span class="built_in">id</span>(tup))</span><br><span class="line"><span class="comment"># (&quot;what&#x27;s&quot;, &#x27;your&#x27;, &#x27;name&#x27;, &#x27;man&#x27;) 2254175722616</span></span><br><span class="line"></span><br><span class="line">tup = tup[:-<span class="number">1</span>] + (<span class="string">&#x27;?&#x27;</span>,)</span><br><span class="line"><span class="built_in">print</span>(tup, <span class="built_in">id</span>(tup))</span><br><span class="line"><span class="comment"># (&quot;what&#x27;s&quot;, &#x27;your&#x27;, &#x27;name&#x27;, &#x27;?&#x27;) 2254177496184</span></span><br></pre></td></tr></table></figure><p>​    利用切片操作时要注意，添加或修改的部分也要是元组， <strong>单个元素的元组时一定要加上 <code>,</code></strong> 表示，虽然说这样可以实现对元组的修改，但从 id 上也可知这其实是另外创建的</p><h4 id="补充点"><a href="#补充点" class="headerlink" title="补充点"></a>补充点</h4><p>​    1）<strong>列表和元组的内部实现都是基于 array 的形式</strong></p><p>​    2）python 中对于初始化一个容器来说，都有简便的方法，例如列表可以使用 <strong><code>[]</code></strong> 来初始化，来代替使用 <strong><code>list()</code></strong> 进行初始化，因为前者是一个可直接调用的内置 C 函数，后者则是会走一套函数调用的逻辑会有额外的开销，所以前者用来初始化效率更高</p><h3 id="字典与集合"><a href="#字典与集合" class="headerlink" title="字典与集合"></a>字典与集合</h3><p>​    <strong>从 3.6 开始，字典 被确定是 有序 的，而 集合 一如既往都是无序的</strong>，两者都提供了查找，添加和删除的操作；对比列表来说，字典的相关操作在性能上要优于列表</p><p>​    集合对字典的 key-value 的存储结构来说，前者相同于是没有 value 的字典，另外 <strong>集合 中能存储的元素只能是可哈希的类型，否则会抛出异常</strong> ，且集合也支持增删改的操作，但是对于使用 pop 方法删除时，会由于集合的无序性，导致删除的键是无法判断的</p><p>​    字典与列表一样是支持索引（字典指明的不是索引值，而是保存的 key）查找的，但是这种方式在没有找到键对应的值的情况下会抛出异常，因此 <strong>字典提供了 get 方法去取键的值，而使用 get 则不会向前者那样抛出异常</strong></p><p>​    <strong>集合 在元素的访问上就不支持索引操作，因为 集合 本身是一个哈希表，</strong>内部的元素不是连续的</p><h4 id="字典和集合的原理"><a href="#字典和集合的原理" class="headerlink" title="字典和集合的原理"></a>字典和集合的原理</h4><p>​    <strong>字典 和 集合 使用的是 哈希表</strong>，通过哈希算法得到固定长度的值作为数据的存储地址，利用哈希值作为表的索引可以快速的定位到一条数据，远比列表需要通过循环遍历才能找到指定的元素的速度要快得多，所以 <strong>字典 和 集合都运用在对元素的高效查找，去重等场景</strong></p><p>​    对于字典来说，内部的哈希表存储了哈希值，键以及对应的值三个元素</p><p>​    对于集合来说，只存了哈希值和唯一的键</p><p>​    在老版本的 python 中的 hash 表结构是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--+-------------------------------+</span><br><span class="line">  | 哈希值(hash)  键(key)  值(value)</span><br><span class="line">--+-------------------------------+</span><br><span class="line">0 |    hash0      key0    value0</span><br><span class="line">--+-------------------------------+</span><br><span class="line">1 |    hash1      key1    value1</span><br><span class="line">--+-------------------------------+</span><br><span class="line">2 |    hash2      key2    value2</span><br><span class="line">--+-------------------------------+</span><br><span class="line">. |           ...</span><br><span class="line">__+_______________________________+</span><br></pre></td></tr></table></figure><p>​    这样的结构容易导致一个问题就是随着数据的扩张，这样表会变的非常稀疏，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;mike&#x27;, &#x27;dob&#x27;: &#x27;1999-01-01&#x27;, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">entries = [</span><br><span class="line">[&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;]</span><br><span class="line">[-230273521, &#x27;dob&#x27;, &#x27;1999-01-01&#x27;],</span><br><span class="line">[&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;],</span><br><span class="line">[&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;],</span><br><span class="line">[1231236123, &#x27;name&#x27;, &#x27;mike&#x27;],</span><br><span class="line">[&#x27;--&#x27;, &#x27;--&#x27;, &#x27;--&#x27;],</span><br><span class="line">[9371539127, &#x27;gender&#x27;, &#x27;male&#x27;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>​    显然这样的结构会存在资源浪费，所以新的哈希表则是将索引单独存储来提高空间使用效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Indices</span><br><span class="line">----------------------------------------------------</span><br><span class="line">None | index | None | None | index | None | index ...</span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">Entries</span><br><span class="line">--------------------</span><br><span class="line">hash0   key0  value0</span><br><span class="line">---------------------</span><br><span class="line">hash1   key1  value1</span><br><span class="line">---------------------</span><br><span class="line">hash2   key2  value2</span><br><span class="line">---------------------</span><br><span class="line">        ...</span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">indices = [None, 1, None, None, 0, None, 2]</span><br><span class="line">entries = [</span><br><span class="line">[1231236123, &#x27;name&#x27;, &#x27;mike&#x27;],</span><br><span class="line">[-230273521, &#x27;dob&#x27;, &#x27;1999-01-01&#x27;],</span><br><span class="line">[9371539127, &#x27;gender&#x27;, &#x27;male&#x27;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>​    当新的元素被插入，python 会去通过设置的键 key 用算法得到一个 hash 值，然后和 mask = PyDicMinSize - 1 做与操作，来得到元素要插入的位置 index = hash(key) &amp; mask ，如果得到的位置是空的就会将元素放到该位置上</p><p>​    如果得到的位置不是空的，就接着比较两个元素的 hash值 和 键 是否都一致：</p><p>​    一致，就对内容进行更新</p><p>​    不一致，就产生了 哈希冲突（hash collision），这就是 hash算法 可能产生的问题，在内容各不一样的情况通过算法得到了相同的结果。在这种情况下，则会在表中找其他的空位将本次元素插入，通常来说都是线性寻找，即从当前位往后找空位，不过 python 内部还是进行优化的，具体方法需要通过源码查看</p><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>​    即通过算出 hash 值，在索引表中找到对应的值，利用这值到哈希表中取出键和值，在取出之前会做一个比较判断是否一致，一致就返回，不一致就继续寻找，直到找到或是抛出异常为止</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>​    <strong>删除是一个特殊的操作，python 会对要删除的位置的元素赋予一个特殊值，等到重新调整哈希表的大小时，才会将其删除</strong>。如果是直接删除，就会留下空位，如果出现多个查找，在这种情况下就需要对整表扫描，而且找到了空位也无法判断，再加上本身会有的 hash 冲突问题</p><h4 id="补充点-1"><a href="#补充点-1" class="headerlink" title="补充点"></a>补充点</h4><p>​    hash 冲突会直接影响到字典和集合的操作速度，所以为了避免问题发生，<strong>哈希表通常内部会保留表 1/3 的空间，但表中的空间小于 1/3 之后，python 会去像列表一样重新获取更大的空间来扩充 hash表</strong>，但是在这种情况下，<strong>表中的元素位置也都会重新排放来减少稀疏问题</strong></p><p>​    虽然 hash表 会有 hash冲突 的产生，导致处理效率降低，但是这种情况是非常少见的，正常情况下操作的时间复杂度都是 O(1)</p><p>​    <strong>字典 和 集合 的 键 必须都是 不可变，可哈希的数据类型</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>​    在 python 中字符串是不可变的类型，使得对字符串的修改和删除字符的操作都需要创建新的字符串来存储，因此操作的 <strong>时间复杂度往往会是 O(n)</strong> 的，n 指的是新字符串的长度；但是在其他如 Java，是有可变的字符串类型的（StringBuilder）</p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>​    字符串的拼接支持 ‘+=’ 这样的方法，它是打破了字符串不可变的特性，但实际上依旧是将拼接后的字符串放在了新的位置上，重新赋给这个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>): </span><br><span class="line">s += <span class="built_in">str</span>(n)</span><br></pre></td></tr></table></figure><p>​    这里例子中首先是一个循环，就是 O(n)，再算上每一拼接，那最后就是 O(1) + O(2) + … + O(n) = O(n^2) 的时间复杂度，但是这个分析只是适用于非常老版本的 python</p><p>​    <strong>从 2.5 之后，对于字符串 ‘+=’ 的拼接（str1 += str2 ），python 会首先检测  str1 还有没有其他的引用；如果没有，则会尝试原地对字符串的 buffer 进行扩充，而不是重新申请内存来存储新的字符串并拷贝，</strong>这样最后的时间复杂度就只是 O(n) 了，所以 ‘+=’ 来做拼接不会影响最终的性能</p><p>​    拼接方法还有另一种 <code>string.join(iterable)</code> ，会将每一个元素按照指定格式去拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    l.append(<span class="built_in">str</span>(n))</span><br><span class="line">l = <span class="string">&#x27; &#x27;</span>.join(l) </span><br></pre></td></tr></table></figure><p>​    但是，对比这两种方法，从性能分析上会有两种情况：</p><p>​    <strong>如果需要拼接的次数是比较少的情况下，比如只是 range(100) 的话，使用 ‘+=’ 在时间复杂度上就是 O(n)，而 join 则会是 O(2n)；但是对于 range(0, 100000) ，这样大的数字的话，join 相对来说速度会快一点</strong></p><p>​    补充一个更加 pythonic 的 join 拼接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>)))</span><br><span class="line"><span class="built_in">print</span>(s, <span class="built_in">type</span>(s))       <span class="comment"># 0123456789 &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>​    对于 python 来说，只有 for 和 while 两种循环方式，在其他语言中还会有一种 switch （3.10版本已加入）来用于多种条件的判断。如果在循环中出现多次的嵌套会非常冗余和难读也不利于调试和修改，所以要尽量避免出现多层的嵌套</p><p>​    循环中一般的判断方法如下：</p><p><img src="https://static001.geekbang.org/resource/image/94/45/949742df36600c086c31e399ce515f45.png" alt="img"></p><p>​    在实际的过程中，对于除了 bool 类型的数据，条件的判断最好是显性的，比如判断一个整数不能为 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if i != 0:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>​    多数情况下，for 和 while 的循环是可以相互转换的，但 <strong>一般在遍历一个已知的集合，使用 for 循环会简便一些；如果操作是要在满足某个条件下的，且需要不停执行类似操作和不是特定的一个集合的话，利用 while 循环则更好</strong></p><h4 id="for-和-while-的性能"><a href="#for-和-while-的性能" class="headerlink" title="for 和 while 的性能"></a>for 和 while 的性能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 1000000:</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">for i in range(0, 1000000):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>​    两个循环的次数是一致的，for 中使用 range 函数，这个函数是 C 直接编写的，所以执行速度非常快，对比 while 中的 ‘+=’ ，同样是会调用 C 来执行，不过数字是不可变的，所以每一次 ‘+=’ 都涉及了创建和删除的过程，所以这两个循环中，for 的执行效率要比 while 更好一些</p><h4 id="条件和循环的复用"><a href="#条件和循环的复用" class="headerlink" title="条件和循环的复用"></a>条件和循环的复用</h4><p>​    也就是将条件和循环并做为一行代码进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expression1 <span class="keyword">if</span> condition <span class="keyword">else</span> expression2 <span class="keyword">for</span> item <span class="keyword">in</span> iterable   <span class="comment"># 表达式中 if 的判断写在 for 之前</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        expression1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        expression2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果其中不涉及 else 判断的话</span></span><br><span class="line">expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​    对于异常的捕获需要根据异常的类型去指定，<strong>如果程序有多个 except block ，最多也只有一个会被匹配（如果多个 except 声明的异常类型都与实际相匹配，那么只有最前面的 except block 会被执行，其他则被忽略 ）</strong>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​    通常情况下，可能无法保证所定义的异常能够覆盖可能的异常类型，所以可以通过 Exception 来捕获所有的异常，<strong>Exception 是其他所有非系统异常的基类</strong>，所以上面的代码如果有其他的异常没有被定义的匹配捕获，可以改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> err:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> err:</span><br><span class="line">...</span><br><span class="line">eccept Exception <span class="keyword">as</span> err:    <span class="comment"># 万能捕获</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​    在处理异常的时候，如果有必须要执行的语句，例如使用 open 操作文件时，都需要加上异常捕获，但是最后需要在 finally 的 block 中要 close 文件，使得无论程序遇到什么异常，最后都能保证文件被关闭，来保证文件的完整性。不过，通常对于文件的操作都是使用 with 上下文来管理文件，自动在不使用的情况去关闭</p><p>​    异常的处理，指的是无法确定代码是否能够成功执行和判断的情况下，比如数据库的连接，文件读取等等，对于正常的 flow-control（流程控制，如 if 等）逻辑 ，都不使用异常处理</p><h4 id="补充点-2"><a href="#补充点-2" class="headerlink" title="补充点"></a>补充点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">except E as N:</span><br><span class="line">    foo</span><br><span class="line">    </span><br><span class="line"># 等同于</span><br><span class="line">except E as N:</span><br><span class="line">    try:</span><br><span class="line">        foo</span><br><span class="line">    finally:</span><br><span class="line">        del N</span><br></pre></td></tr></table></figure><p>​    对于数据操作来说，会需要很多的异常捕获，比如连接的时候，数据获取都可能会抛出异常，如果逐一对其中的代码加上各自的异常捕获会显得非常繁琐，所以可以只利用一个异常捕获，来按照异常的顺序进行匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db = DB.connect(<span class="string">&#x27;&lt;db path&gt;&#x27;</span>)           <span class="comment"># 连接可能会抛出异常</span></span><br><span class="line">    raw_data = DB.queryData(<span class="string">&#x27;&lt;viewer_id&gt;&#x27;</span>)          <span class="comment"># 查询可能会抛出异常</span></span><br><span class="line"><span class="keyword">except</span> (DBConnectionError, DBQueryDataError) err:        <span class="comment"># 按顺序显示连接，再是查询集</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(err))</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    python 中使用 def 来声明函数，和其他需要编译的（如C语言等）不一样的是，def 是一个可执行语句，所以函数直达被调用前，都是不存在的。当程序调用函数的时候，def 才会创建一个函数对象，并赋予其名字</p><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><p>​    <strong>lambda 是一个表达式</strong>（expression），并不是一个语句（statement），匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次</p><p>​    所谓表达式，就是用一系列 “公式” 去表达一个东西，比如 x+1，x**2 等等</p><p>​    语句，则一定是完成了某些功能，比如赋值语句 x = 1，完成了变量赋值的操作，print 语句完成了打印，条件语句 if x &lt; 0，完成了选择功能等等 </p><p>​    lambda 可以用在一些常规函数 def 可以简化的地方，比如在列表生成式中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">lambda</span> x: x*x)(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>​    或者，是将 lambda 作为某些函数的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">1</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">2</span>, -<span class="number">1</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])     <span class="comment"># 按列表中元组的第二个元素，对数组排序</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"><span class="comment"># [(2, -1), (3, 0), (9, 10), (1, 20)]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;mike&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;lucy&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;ben&#x27;</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(<span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)))  </span><br><span class="line"><span class="comment"># 通过 sorted 接收 (k,v) 元组作为 lambda 参数，按照 v 的值进行倒序</span></span><br><span class="line"><span class="comment"># &#123;&#x27;ben&#x27;: 30, &#x27;mike&#x27;: 10, &#x27;lucy&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure><h4 id="补充点-3"><a href="#补充点-3" class="headerlink" title="补充点"></a>补充点</h4><p>​    关于作用域，<strong>在函数的内部中使用全局的变量如果是不可变的，例如数字，字符串等，要在函数内部进行修改，在不使用 global 关键字的情况下，会抛出异常</strong></p><p>​    但是，函数中使用的全局变量是一个可变类型的，像字典和列表等，是允许修改的操作的，比如 append 一个元素，append 只是访问了变量指向的这个列表，并在列表最后添加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x.append(<span class="number">2</span>)</span><br><span class="line">func()</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>​    对于多继承来说，py2 和 3 在方法的搜索调用上是不同的算法，在 2 中 <strong>经典类</strong> 对多继承的 mro 使用的是 <strong>深度优先 *<em>，而在 3 中 *</em>新式类</strong> 全部都是一种方式 <strong>C3 算法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">B</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A,D):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        D.__init__(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="comment"># C</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># B</span></span><br><span class="line"><span class="comment"># D</span></span><br><span class="line"><span class="comment"># B</span></span><br></pre></td></tr></table></figure><p>​    这个例子模仿的时菱形继承，可以看到这种查找的方法会出现某一个方法被重复调用，所以正确的做法是使用 super 来召唤父类的构造函数</p><h4 id="slots-插槽"><a href="#slots-插槽" class="headerlink" title="__slots__ 插槽"></a><code>__slots__</code> 插槽</h4><p>​    正常情况下，创建一个类后，可以对这个类动态的去添加属性或方法，这得益于 python 动态语言的特性，实例对象或是类都能利用 <code>__setitem__</code> 或 <code>__setattr__</code> 来动态设置</p><p>​    注意！！<strong>使用实例对象去创建一个属性时，这个属性所在作用域是在该实例对象上，而不是在类上创建了一个属性，所以通过实例对象的 . 方式的属性只对这个对象可见</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fx, fy</span>):</span><br><span class="line">        self.fx = fx</span><br><span class="line">        self.fy = fy</span><br><span class="line"></span><br><span class="line">f = F(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line">f.fz = <span class="number">33</span></span><br><span class="line"><span class="built_in">print</span>(F.fz)    <span class="comment"># AttributeError: type object &#x27;F&#x27; has no attribute &#x27;fz&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(f.__dict__)     <span class="comment"># &#123;&#x27;fx&#x27;: 11, &#x27;fy&#x27;: 22, &#x27;fz&#x27;: 33&#125;</span></span><br><span class="line"><span class="built_in">print</span>(F.__dict__)     <span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__init__&#x27;: &lt;function F.__init__ at 0x0000024EBA926400&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;F&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;F&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure><p>​    上面分别利用 f 这个对象以及 F 类分别调用 dict 的方法，对于 f 而言，返回的字典会保存实例化后的变量和值，对于 F 类，dict 的字典中只会保存所创建的方法，并不会保留值</p><p>​    <strong>对于每一个实例对象而言，都会创建一个 dict 的字典来动态保存实例化过程中所要保存的值，这就会导致大量的内存开销</strong>，所以出现了 slots 插槽，字面理解就是说在变量赋值前，提前创建出这个变量的位置，当操作中得到对应的值，就将该值对应插入</p><p>​    <strong>slots 本身默认是元组的形式，意味着 slots 中的变量只为了提供只读操作，也就说使用了 slots 会限制实例对象的动态创建属性和方法的操作，但好处就是在大量实例对象的情况下，会减少非常多的空间占用问题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>():</span><br><span class="line">    __slots__ = (<span class="string">&#x27;fx&#x27;</span>, <span class="string">&#x27;fy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fx, fy</span>):</span><br><span class="line">        self.fx = fx</span><br><span class="line">        self.fy = fy</span><br><span class="line"></span><br><span class="line">f = F(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line">f.fz = <span class="number">33</span>           <span class="comment"># AttributeError: &#x27;F&#x27; object has no attribute &#x27;fz&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(F.__dict__)   <span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__slots__&#x27;: (&#x27;fx&#x27;, &#x27;fy&#x27;), &#x27;__init__&#x27;: &lt;function F.__init__ at 0x00000153096A6400&gt;, &#x27;fx&#x27;: &lt;member &#x27;fx&#x27; of &#x27;F&#x27; objects&gt;, &#x27;fy&#x27;: &lt;member &#x27;fy&#x27; of &#x27;F&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="built_in">print</span>(f.__dict__)   <span class="comment"># AttributeError: &#x27;F&#x27; object has no attribute &#x27;__dict__&#x27;</span></span><br></pre></td></tr></table></figure><p>​    <strong>注意！！一旦声明的类中使用 <code>__slots__</code> 属性，那么对于类而言就不存在原本含有的 <code>__dict__</code> 属性</strong></p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    最简单的一种，就是所有的文件全部放在一个目录下，这种的模块导入就非常简单，可以直接利用 import 来导入其他文件的代码，但是正常情况下，文件都是分门别类的，所以如果要在文件中使用上一级目录的模块就需要使用 ‘..’ 来表示</p><p>​    对于 pycharm 来说，模块的搜索目录全部会放在一个列表中，而对于第一个元素，pycharm 会将其作为项目的根目录，因此除了 pycharm 之外，就需要手动去更改来保证导入的正常，或是使用虚拟环境</p><p>​    <strong>使用 import 去导入文件内容的时候，会自动把所有暴露在外面的代码全部执行一遍。因此，如果要去运行一个模块，就必须将执行的代码放到 <code>if __name__ == &#39;__main__&#39;</code> 下面，</strong>因为 <code>__name__</code> 本身就是一个魔法方法，是模块对象的一个属性，在被导入后 <code>__name__</code> 就被赋值为导入的模块的名字，自然就不等于 <code>__main__</code> 了 </p><h4 id="补充点-4"><a href="#补充点-4" class="headerlink" title="补充点"></a>补充点</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> module_name</span><br></pre></td></tr></table></figure><p>​    对于这两个模块导入方法来说，本质上来说是一样的都是使用 module_name 的所有方法，但是第一种方式导入模块容易有一个问题：就是可能与自己的函数或类名冲突，亦或是和其他模块中相同名字的函数或类冲突</p><p>​    而第二种导入的方法，在该模块的调用时，需要使用 module_name.func 来实现调用，这样有效避免了冲突的产生</p><h3 id="is-和"><a href="#is-和" class="headerlink" title="is 和 =="></a>is 和 ==</h3><p>​    <strong>is 判断，比较的是两个变量的 ID，而 == 判断，则是判断两个变量的内容或值是否相等</strong>，比如 a == b，实际上是执行了 <code>a.__eq__(b)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a == b)           <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))     <span class="comment"># 2165494757920 2165496332576</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a[-<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a == b)           <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))     <span class="comment"># 2165494757920 2165496332576</span></span><br></pre></td></tr></table></figure><p>​    需要注意，对于不可变数据类型，比如上面的元组内部又嵌套了一个列表，对于列表来说，元素是可以增删改的，所以再用 is 或 == 判断时需要小心</p><h3 id="浅拷贝-和-深拷贝"><a href="#浅拷贝-和-深拷贝" class="headerlink" title="浅拷贝 和 深拷贝"></a>浅拷贝 和 深拷贝</h3><p>​    浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的 <strong>元素是原对象中子对象的引用</strong></p><p>​    深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，<strong>以递归的方式</strong>，通过创建新的子对象 <strong>拷贝到新对象 **中。因此，</strong>新对象和原对象没有任何关联** </p><h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><p>​    可以有多种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1 == l2）     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(l1 <span class="keyword">is</span> l2）     <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = l1[:]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1 == l2）     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(l1 <span class="keyword">is</span> l2）     <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy 模块</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = copy.copy(l1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1 == l2）     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(l1 <span class="keyword">is</span> l2）     <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>​    注意，<strong>对于不可变类型来说，使用 类型转换 或是 切片操作 进行的浅拷贝，对象的指向都是相同的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = <span class="built_in">tuple</span>(t1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1 == l2）     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(l1 <span class="keyword">is</span> l2）     <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="浅拷贝的问题"><a href="#浅拷贝的问题" class="headerlink" title="浅拷贝的问题"></a>浅拷贝的问题</h4><p>​    如果使用的结构较为复杂，比如可变类型中嵌套了不可变类型，使用浅拷贝来避免对原结构数据操作时会产生副作用，<strong>浅拷贝中的嵌套可变对象，会受到操作影响，导致 浅拷贝体 和 本体 被相互影响</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1)     <span class="comment"># [[1, 2, 3], (30, 40), 100]</span></span><br><span class="line"><span class="built_in">print</span>(l2)     <span class="comment"># [[1, 2, 3], (30, 40)]</span></span><br><span class="line"></span><br><span class="line">l1[<span class="number">1</span>] += (<span class="number">50</span>,<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(l1)     <span class="comment"># [[1, 2, 3], (30, 40, 50, 60), 100]</span></span><br><span class="line"><span class="built_in">print</span>(l2)     <span class="comment"># [[1, 2, 3], (30, 40)]</span></span><br></pre></td></tr></table></figure><p>​    <code>l1.append(100)</code> 是在 l1 的列表中末尾加上了 100 这个元素，但是两个并不指向同一个对象，所以 l1 添加的元素对于 l2 来说是不可见的</p><p>​    <code>l1[0].append(3)</code> 的操作是在 l1[0] 上进行的，而由于 l2 是浅拷贝 l1，两者的 index 为 0 的元素都指向同一个列表对象，因为列表是可变元素，列表中的元素存储的是引用，也就说 l1[0] 和 l2[0] 的引用是相同的，所以 l2 中的子列表也会有 3</p><p>​    <code>l1[1] += (50,60)</code> 是对原列表中的子元组进行操作，但是元组是不可变的，所以会开一个新地址，将子元组中的 30，40 加入，然后再将 50，60 也加入构成在索引位置 1 上的一个新元组，因此对于 l1 而言，列表中的元组已经不再和原列表中的子元组指向同一个地址的对象了。但是 l2 是浅拷贝，它里面的子元组还是指向原来那个元组的对象，用于因此不会对子元组进行改变</p><p>​    由此，就会产生使用浅拷贝的副作用，那对于这样的操作，可以使用深拷贝来避免相互影响的问题</p><h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 copy 模块</span></span><br><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = copy.deepcopy(l1)</span><br><span class="line"></span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1)      <span class="comment"># [[1, 2, 3], (30, 40), 100]</span></span><br><span class="line"><span class="built_in">print</span>(l2)      <span class="comment"># [[1, 2], (30, 40)]</span></span><br></pre></td></tr></table></figure><p>​    可以看出，深拷贝的 l2 对象在不会随着 l1 的改变而产生改变，l1 和 l2 是完完全全的两个对象</p><h4 id="深拷贝的问题"><a href="#深拷贝的问题" class="headerlink" title="深拷贝的问题"></a>深拷贝的问题</h4><p>​    <strong>深拷贝中，当对象存在对自身的引用，程序就容易进入死循环中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x.append(x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)   <span class="comment"># [1, [...]]</span></span><br><span class="line"></span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line"><span class="built_in">print</span>(y)   <span class="comment"># [1, [...]]</span></span><br></pre></td></tr></table></figure><p>​    但是，<strong>上面的代码执行却不会出现溢出问题，是因为 deepcopy 的内部会去维护一个字典，来存储保存过的对象，如果内部的字典内有了一样的对象就会直接返回，以次防止出现无限递归</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deepcopy</span>(<span class="params">x, memo=<span class="literal">None</span>, _nil=[]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Deep copy operation on arbitrary Python objects.</span></span><br><span class="line"><span class="string">  See the module&#x27;s __doc__ string for more info.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">memo = &#123;&#125;</span><br><span class="line">d = <span class="built_in">id</span>(x)        <span class="comment"># 查询被拷贝对象x的id</span></span><br><span class="line">y = memo.get(d, _nil)       <span class="comment"># 查询字典里是否已经存储了该对象</span></span><br><span class="line"><span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> _nil:</span><br><span class="line"><span class="keyword">return</span> y         <span class="comment"># 如果字典里已经存储了将要拷贝的对象，则直接返回</span></span><br><span class="line">...    </span><br></pre></td></tr></table></figure><p>​    那如果比较上面的 x 和 y，会有什么结果，答案是抛出异常 <code>RecursionError: maximum recursion depth exceeded in comparison</code>。因为 x 本身自己是一个无限嵌套的列表，y 是深度拷贝的一个无限嵌套列表，当执行 <code>x == y</code> 时，会去判断这两个列表的每一个元素的值是否相等，因为都是无限嵌套的，所以 <strong>比较时就会出现溢出异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x == y)</span><br><span class="line"><span class="comment"># RecursionError: maximum recursion depth exceeded in comparison</span></span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>​    对于赋值来说，当两个变量赋的值是一样的，其实本质上是让两个变量同时指向了这个对象。并且，<strong>当删除一个变量时，并不是代表就将指向的对象也一起删除了，而是断开了这个变量对该对象的指向，对于对象的删除，则是按照 python 内部的一套垃圾回收机制去判断一个对象是否要删除</strong></p><p>​    由此，python 的参数传递既不是值传递，也不是引用传递，而是 <strong>赋值传递，或者是叫对象的引用传递，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象</strong></p><p>​    <strong>如果对象是可变类型，当其被改变时，所有指向这个对象的变量都会改变</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">d</span>):</span><br><span class="line">    d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">10</span></span><br><span class="line">    d[<span class="string">&#x27;b&#x27;</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">func(d)</span><br><span class="line"><span class="built_in">print</span>(d)      <span class="comment"># &#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20&#125;</span></span><br></pre></td></tr></table></figure><p>​    <strong>如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响</strong></p><h3 id="metaclass-黑魔法"><a href="#metaclass-黑魔法" class="headerlink" title="metaclass 黑魔法"></a>metaclass 黑魔法</h3><p>​    首先，关于 <strong>python 中的用户自定义类，其本身都是 type 这个类的实例，并且 python 所有的对象最底层的类都是有 type 去实现的</strong></p><p>​    其次，<strong>对实例化对象调用时，真正调用的是 type 中的 <code>__call__</code> 运算符</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> = <span class="built_in">type</span>(classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure><p>​    <code>type(classname, superclasses, attributedict)</code> 就是 type 的 <code>__call__</code> 运算重载符，它会进一步去调用 <code>__new__</code> 和 <code>__init__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>.__new__(typeclass, classname, superclasses, attributedict)</span><br><span class="line"><span class="built_in">type</span>.__init__(<span class="keyword">class</span>, classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure><p>​    而 <strong>对于 metaclass 来说，其实是 type 的子类，本质上是通过替换 type 的 <code>__call__</code> 运算符重载，来实现 “超类” 的编程</strong></p><p>​    相比使用原本 type 去创建的类，<strong>利用 metaclass 来实现的 “超类” 可以实现父类对子类的修改，而这在正常的类中是不可行的，父类只是可以提供子类</strong>，而在调用时则是利用 mro 查找去使用。metaclass 就脱离这一点，使得在继承中，父类可以修改子类的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,bases,dic</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,bases,dic)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==&gt;Mymeta.__init__&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.__name__)</span><br><span class="line">        <span class="built_in">print</span>(dic)</span><br><span class="line">        <span class="built_in">print</span>(self.yaml_tag)</span><br><span class="line">        self.yaml_tag = <span class="string">&quot;My&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==&gt;Mymeta.__new__&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cls.__name__)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==&gt;Mymeta.__call__&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;==&gt;cls <span class="subst">&#123;cls&#125;</span>&quot;</span>)</span><br><span class="line">        obj = cls.__new__(cls)</span><br><span class="line">        cls.__init__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(metaclass=Mymeta):</span><br><span class="line">    yaml_tag = <span class="string">&quot;!Foo&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.__init__&quot;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(name)</span><br><span class="line">        <span class="built_in">print</span>(self.yaml_tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Foo.__new__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">object</span>.__new__(cls)</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">==&gt;Mymeta.__new__</span><br><span class="line">Mymeta</span><br><span class="line">==&gt;Mymeta.__init__</span><br><span class="line">Foo</span><br><span class="line">&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>: <span class="string">&#x27;Foo&#x27;</span>, <span class="string">&#x27;yaml_tag&#x27;</span>: <span class="string">&#x27;!Foo&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>: &lt;function Foo.__init__ at <span class="number">0x0000023C08A62268</span>&gt;, <span class="string">&#x27;__new__&#x27;</span>: &lt;function Foo.__new__ at <span class="number">0x0000023C08A622F0</span>&gt;&#125;</span><br><span class="line">!Foo</span><br><span class="line">==&gt;Mymeta.__call__</span><br><span class="line">==&gt;cls &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Foo&#x27;</span>&gt;</span><br><span class="line">Foo.__new__</span><br><span class="line">Foo.__init__</span><br><span class="line">foo</span><br><span class="line">My</span><br></pre></td></tr></table></figure><p>​    从这个例子，可以看到 Foo 使用 meateclass 来定义，并且元类是自定义的 Mymeta，其中在 Mymeta 的 <code>__init__</code> 里修改了原本 Foo 中的属性。从结果也能看到，Foo 的实例对象在调用原本自己的属性时，值却已经是 Mymeta 中修改过后的</p><p>​    首先，<code>class Foo(metaclass=Mymeta)</code> 指定了 Foo 类的实现元类 Mymeta，注意这种方式是在 python3 中的，python2 里是在 Foo 下创建一个属性 <code>__metaclass__=Mymeta</code></p><p>​    type 是一切对象的 元类，类是 type 的实例对象，所以这里 Mymeta 直接继承了 type 去做一些重写</p><p>​    在实例化 Foo 的时候，由于指定了 metaclass，也就是通过 Mymeta 这个元类来进行实例，因此就好像 Foo 是一个套在 Mymeta 外的一个类，而 Foo 又是 Mymeta 这个元类的实例对象，所以实例化 Foo，会先进行 Mymeta 的实例化，也就是会先走到 Mymeta 的 <code>__new__</code> 中去创建对象。而 new 方法中，cls 指的是当前类，所以返回的是 Mymeta，而返回则是调用 <code>type.__new__</code> 方法去创建 Foo 这个类</p><p>​    然后，就会进行初始化步骤，来到 Mymeta 的 <code>__init__</code> 方法中，其中 <strong>self 参数指的就是刚才 new 所返回的 Foo</strong> 这个类，并最后修改了原本 Foo 类中的 yaml_tag</p><p>​    接着 Foo 类进行实例，<code>Foo(&quot;foo&quot;)</code>，此时这个 Foo 是 Mymeta 的实例，所以会触发 Mymeta 的 <code>__call__</code> 方法，因此该方法中的 cls 指向的是 Foo 这个类。同时在这个方法中，又去调用了 <code>__new__</code> 和 <code>__init__</code> 方法，这时才会真正执行原本 Foo 类中创建的这两个方法</p><p>​    对于 metaclass 的使用，最典型就是 django 中的 ORM 的 Model</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):   <span class="comment"># class Model(metaclass=ModelBase)   # class ModelBase(type)</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">22</span>)</span><br><span class="line">    age = models.IntegerField()</span><br></pre></td></tr></table></figure><p>​    这个类创建对象 people，再去利用 <code>people.name</code> 或是 <code>people.age</code>，返回一个字符串或一个数字，正是由于 models.Model 定义了 metaclass 实现了直接利用这样简单的方式就可以得到数据里对应的数据</p><h3 id="迭代器-和-生成器"><a href="#迭代器-和-生成器" class="headerlink" title="迭代器 和 生成器"></a>迭代器 和 生成器</h3><p>​    对于 字符串，列表，字典，元组 简单来说这些都是容器，而 容器 是一个 可迭代对象，<strong>可迭代对象是由内部的 iter() 函数定义</strong></p><p>​    <strong>迭代器 则是在 可迭代对象 基础上，添加了 next() 函数来实现向后取出元素，从而支持遍历操作</strong></p><p>​    生成器 是一个种特殊的迭代器，在大体量的数据处理上，<strong>使用 生成器 会占用更低的内存，也可以优化程序结构，提高程序执行速度</strong></p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>​    简单通俗来说，<strong>Python 的垃圾回收机制有三种方式：引用计数、标记-清除，分代回收</strong>。三种方式并不需要手动实现，Python 会对使用的对象自动进行内存管理，防止出现 OOM（out of memory）内存泄漏问题</p><p>​    内存泄漏，不是物理层面上让内存消失，而是指程序的代码执行需要获取有计算机划分的一块内存，由于程序代码的问题导致，程序的结束没有释放掉这个内存，失去了对这个内存的控制，造成了内存资源的浪费</p><h4 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h4><p>​    Python 中一切皆对象，对于实际的对象而言都是存储在内存的堆空间中，所以本质上对象像是一个指针。程序会判断一个对象的引用（指针数）是否为 0，默认程序运行时，内部会维护一个计数器用来做计数，当值为 0 说明这个对象就称为垃圾，需要被回收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_memory</span>(<span class="params">hint</span>):</span><br><span class="line">    <span class="comment"># 显示当前 Python 程序占用的内存大小</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    show_memory(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory(<span class="string">&#x27;after a created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">show_memory(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># initial memory used: 26.921875 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 414.98828125 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 27.43359375 MB</span></span><br></pre></td></tr></table></figure><p>​    在函数 <code>func</code> 中使用 <code>show_memory</code> 来查看当前的占用内存大小，从返回结果可以看出，<code>func</code> 函数内部在创建 a 这个列表时，内存瞬间增大到了超过 400M，在函数完成后又回到了几乎原本的大小。因为 a 这个列表对象是在函数中创建的（此时变量 a 的引用计数会 +1，即 1），函数执行完成后，局部变量的 a 就会被自动注销掉（引用计数 -1），即 a 的引用计数变成了 0，所以 Python 执行了引用计数的回收机制，将 a 占用的空间回收</p><p>​    所以，如果上面的 <code>func</code> 函数中使用了 <code>global a</code>，那么最后 a 这个列表就会作为全局作用域上的变量，即使这个函数执行结束了，内存也不会将其释放</p><p>​    同样，如果 <code>func</code> 函数最后使用了 return 将列表 a 返回，那么这个 a 就会被主程序接收。此时如果使用 <code>a = func()</code>，那么返回的列表 a 就会被主程序的 a 接收，最后的引用计数不会是 0，内存依旧是超过 400M，如果只是 return a，外部没有变量对其接收，a 也会被自动回收</p><p>​    总结一下，对于 <strong>python 中的对象，当被创建，引用，作为参数传递，作为元素加入到容器，那么计数器中这个对象的计数都会 +1，相反，当对象被删除，对象的别名（变量名）被重新赋予新的对象，对象离开了原本自身在的容器作用域，计数都会 -1。当值为 0，就会自动触发来回收内存</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))   <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))   <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(b))   <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="built_in">print</span>(sys.getrefcount(a))    <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">func(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">c = [a]</span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​    <strong>sys 模块的 <code>sys.getrefcount()</code> 方法可以查看一个对象的引用计数值，不过这个方法也会对变量的计数 +1</strong></p><p>​    对于上面的 <code>func</code> 函数来说，如果不算 <code>b=a</code>，一个对象的引用会是 4，首先 a 自身创建是 +1，python 的函数调用栈 +1，对象作为函数参数 +1，sys 模块的 <code>getrefcount</code> +1，所以是 4</p><p>​    虽然 python 内部会根据 引用计数 自动去管理程序运行的对象占用的内存，但是也可以通过 <strong>手动的方式调用 <code>gc.collect()</code> ，进行强制的内存回收，将没有引用的对象内存进行回收</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">gc.collect() </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.getrefcount(a))</span><br><span class="line"><span class="comment"># NameError: name &#x27;a&#x27; is not defined</span></span><br></pre></td></tr></table></figure><p>​    计数器中对象的引用计数 = 0，不是垃圾回收的充要条件，虽然对象计数为 0，会自动被程序进行回收，但是通过 <strong><code>gc.collect()</code> 是可以进行手动回收</strong>，所以 <strong>计数为 0，并不是垃圾回收的充分必要的条件</strong>。而且除此之外，还有 标记-清除，以及 分代回收 同样会去自动进行垃圾回收</p><p>​    引用计数，不是一个万能之策。<strong>引用计数存在一个问题，当对象出现循环引用，会导致对象不能被回收</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_memory</span>(<span class="params">hint</span>):</span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    show_memory(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory(<span class="string">&#x27;after a, b created&#x27;</span>)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="comment"># gc.collect()</span></span><br><span class="line">show_memory(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># initial memory used: 27.21484375 MB</span></span><br><span class="line"><span class="comment"># after a, b created memory used: 803.1015625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 803.1015625 MB</span></span><br></pre></td></tr></table></figure><p>​    从上述代码中，可以看到最后的结果是内存没有被释放，因为在函数内部，a 和 b 两个列表相互引用了对方，所以 a 和 b 的引用计数都 +1，导致最后不能进行释放</p><p>​    但是，通过 <code>gc.collect()</code> 手动回收，依然能将 a 和 b 占用的空间进行回收，所以对于引用计数中出现的循环引用问题，可以使用 gc 模块来处理</p><h4 id="标记-清除（mark-sweep）"><a href="#标记-清除（mark-sweep）" class="headerlink" title="标记-清除（mark-sweep）"></a>标记-清除（mark-sweep）</h4><p>​    标记-清除，实际上分为了两个阶段，即 标记阶段 与 清除阶段，标记-清除 的出现也是为了解决 循环引用 的问题</p><p>​    <strong>标记阶段，会对所有活动的对象打上标记，通过他们之间的关系进行关联（即彼此的引用），形成一个 有向图</strong></p><p>​    <strong>清除阶段，会从全局对象出发进行遍历，所有能够遍历到的对象都是可达对象，反之就是不可达对象，清除阶段的遍历目的就是将有向图中不可达的节点进行清除，从而达到内存的回收</strong></p><p><img src="https://foofish.net/images/mark-sweep.svg" alt="img"></p><p>​    上图的黑点，就是根节点，即全局对象，后面的对象会与它进行关联，那后续的对象会根据各自作用域去做关联，构成一个有向图。标记阶段，会将从全局对象开始，逐一进行标记，清除阶段会去判断根据根据有向图的方向能够直接或间接到达的活动对象会保留，比如图中的 1，2，3，但是 4 和 5 就不能从全局对象遍历到达，最后被视为不可达对象进行回收</p><p>​    标记清除虽然可以解决引用计数可能造成的循环引用问题，但是代价是，对于标记清除的回收，需要从全局开始做遍历，以此来扫描不可达对象，但 <strong>对 python 来说频繁的触发标记清除是一种极大的性能浪费</strong></p><p>​    <strong>所以 Python 内部在垃圾回收的实现上，利用了 mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类型的对象，因为只有这些对象会存在循环引用问题</strong>，同时对于新创建的对象，python 都会将其加入到零代链表中</p><h4 id="分代回收（generation-collection）"><a href="#分代回收（generation-collection）" class="headerlink" title="分代回收（generation collection）"></a>分代回收（generation collection）</h4><p>​    是建立在 标记-清除 之上的一种回收优化，可以看作是一种空间换时间的做法。毕竟在标记清除中对有向图的遍历，会随着对象的增多而导致性能受影响</p><p>​    Python 的分代回收，实际将所有对象分成 3 类。刚刚创立的对象是第 0 代，经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。每一代的触发阈值都是可以进行指定的，一旦达到阈值就自动进行一次内存的回收</p><p>​    每一代的默认阈值，可以 <strong>通过 gc 模块的 <code>get_threshold()</code> 去查看默认是 <code>700,10,10</code>，即当总对象个数减去被回收释放的对象数值大于 700 ，就对第一代进行一次回收；10 次第一代回收会触发一次第二代的回收；10 次第二代回收会触发第三代的一次回收</strong></p><p>​    分代回收基本思想是，新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高 Python 的性能</p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> Python 深入理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium 使用</title>
      <link href="/3156073279/"/>
      <url>/3156073279/</url>
      
        <content type="html"><![CDATA[<h2 id="selenium-使用"><a href="#selenium-使用" class="headerlink" title="selenium 使用"></a>selenium 使用</h2><p>​    selenium 是一个自动化测试工具，可以利用它来驱动浏览器执行一些动作，例如点击，下拉滚动，并且还可以获取浏览器当前所呈现的源代码，这对于现在基本都使用动态数据的页面而言非常有用，因为网页的 html 文件中会通过 ajax 请求去向后台获取页面所需要的数据，浏览器则会使将得到 html 文档渲染，同时会将 ajax 响应回来的数据渲染到 html 页面对应的地方。这样一来如果只是使用第三方的库去进行网页爬取时，得到的响应其实只会是纯 html 的页面，而不能得到数据，只能手动去向 ajax 的 url 发起请求获取。使用 <strong>selenium 可以做到的就是所见即所爬</strong>，能最直观的感受到爬取的 url 返回得到数据内容</p><p>​    selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器，使用时需要根据不同的浏览器的版本下载对应的驱动文件</p><p>​    chrome各版本地址：<a href="https://www.chromedownloads.net/chrome64win/">https://www.chromedownloads.net/chrome64win/</a> </p><p>​    chrome驱动下载地址：<a href="https://npm.taobao.org/mirrors/chromedriver/">https://npm.taobao.org/mirrors/chromedriver/</a> </p><h3 id="声明浏览器对象和访问页面"><a href="#声明浏览器对象和访问页面" class="headerlink" title="声明浏览器对象和访问页面"></a>声明浏览器对象和访问页面</h3><p>​    首先必须通过驱动文件实例出浏览器对象，通过 get方法 向 url 发送请求，在执行时会打开浏览器并跳转到指定 url 得到页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">&#x27;浏览器驱动的.exe执行文件的地址&#x27;</span>)</span><br><span class="line">response = browser.get(url=<span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h3><p>​    <strong>selenium 的节点查找支持 xpath，css 选择器，或是元素的 id 以及其他的属性等等</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first = browser.find_element_by_id(<span class="string">&quot;wrapper&quot;</span>)</span><br><span class="line">second = browser.find_element_by_css_selector(<span class="string">&quot;#wrapper&quot;</span>)       <span class="comment"># css 选择器</span></span><br><span class="line">third = browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;wrapper&quot;]&#x27;</span>)     <span class="comment"># xpath</span></span><br></pre></td></tr></table></figure><p>​    上面的三行代码分别使用了直接从页面找 id 元素；使用 css 选择器查看 id 元素；使用 xpath 查找 id 的元素，<strong>返回的类型都是 <code>selenium.webdriver.remote.webelement.WebElement</code></strong>，除此之外还有其他的单节点的获取方法：</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>find_element_by_name</td><td>通过属性 name 获取</td></tr><tr><td>find_element_by_link_text</td><td>通过链接文本获取例如 a标签 的超链接</td></tr><tr><td>find_element_by_partial_link_text</td><td>和上述一样，只是 partial_link_text 获取的是包含指定文本的所有超链接</td></tr><tr><td>find_element_by_tag_name</td><td>通过标签名获取</td></tr><tr><td>find_element_by_class_name</td><td>通过 class 的样式名字获取</td></tr></tbody></table><p>​    在使用时，<strong>如果方法所指定的内容在 html 中不存在，找不到任何元素时，会抛出  <code>NoSuchElementException</code>的异常</strong></p><p>​    另外， <strong>selenium 还提供了单独的 <code>find_element</code> 这个通用方法</strong>，需要两个参数：<strong>查找方式(By) 和 要查找的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> senlenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">browser.find_element(By.ID, <span class="string">&#x27;wrapper&#x27;</span>) </span><br><span class="line"><span class="comment"># find_element(By.ID, &#x27;wrapper&#x27;) 和 find_element_by_id(&#x27;wrapper&#x27;) 这个方法是一致的</span></span><br></pre></td></tr></table></figure><p>​    需要注意的是，如果是想要获取 <strong>多个节点</strong>，是需要在这些方法的 <strong>element 后加上一个 s</strong> 就可以进行多节点的获取，同样对于 <strong>多节点也提供了通用方法 <code>find_elements</code></strong></p><h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><p>​    用来模拟点击等操作，实现让浏览器执行一些动作：</p><p>​    <code>.click</code> 方法用来实现点击按钮，链接等</p><p>​    <code>.send_keys</code> 方法可以将内容进行输入</p><p>​    <code>.clear</code> 方法用来清除文本框的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_xpath(<span class="string">&quot;//div[@class=&#x27;SignFlow-tabs&#x27;]//div[2]&quot;</span>).click()</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&quot;.SignFlow-accountInput.Input-wrapper input&quot;</span>).send_keys(Keys.CONTROL + <span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    这里使用   <code>Keys.CONTROL</code> 来模拟键盘按下 ‘Ctrl’ 键，Keys 可以通过 <code>from selenium.webdriver.common.keys import Keys</code></p><p>​    上述的方法可以实现常见的网页中的操作，但是对于一些像鼠标点击拖拽，点击滑动就不能实现，因此需要使用另一种方式即 <strong>动作链，selenium 中有一个对象 ActionChains 可以实现这类的操作</strong></p><p>​    在使用前，需要 <strong>实例化 ActionChains 对象，需要一个参数即实例化的 webdriver 对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrom()</span><br><span class="line">actions = ActionChains(browser)</span><br></pre></td></tr></table></figure><p>​    <code>click_and_hold(on_element)</code>：鼠标单击长按操作，在实现滑动验证时会使用，参数即要点击的对象</p><p>​    <code>drop_and_drop(source, target)</code>：拖拽操作，source 是点击拖拽的对象，target 是放置的对象</p><p>​    <code>double_click(on_element)</code>：双击操作</p><p>​    <code>move_by_offset(xoffset, yoffset)</code>：移动操作，参数分别 横坐标x，纵坐标y，这个 x 和 y 是相对浏览器页面显示部分的左上角位置开始</p><p>​    <code>move_to_element(on_element)</code>：移动鼠标到指定的元素的中间</p><p>​    <code>release(on_element)</code>：释放鼠标的长按点击</p><p>​    <code>perform()</code>：执行操作</p><p>​    <strong>注意：对于动作链的操作，最后的执行，都需要链式操作的最后调用 perform 方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(self.browser).click_and_hold(slider).perform()</span><br><span class="line">ActionChains(self.browser).move_by_offset(xoffset=<span class="number">100</span>, yoffset=<span class="number">100</span>).perform()</span><br><span class="line">ActionChains(self.browser).release().perform()</span><br></pre></td></tr></table></figure><h3 id="执行-JavaScript"><a href="#执行-JavaScript" class="headerlink" title="执行  JavaScript"></a>执行  JavaScript</h3><p>​    对于下拉滚动条，selenium 并没有方法去实现，所以可以通过执行 js 的代码来操作浏览器，实例化的浏览器对象可以<strong>使用 <code>execute_scrpit</code> ，将 js 命令以字符串形式传入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现滚动条下拉到底部</span></span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>​    在选取指定的节点元素后，<strong>使用 <code>get_attribute</code> 方法，参数为要获取的属性名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;logo-image&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(logo.get_attribute(<span class="string">&#x27;src&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>​    同样指定好节点后，<strong>使用 <code>text</code> 方法获取节点中文本内容</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title = browser.find_element_by_class_name(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(title.text)</span><br></pre></td></tr></table></figure><h3 id="延迟等待"><a href="#延迟等待" class="headerlink" title="延迟等待"></a>延迟等待</h3><p>​    在使用个 get 方法发送请求后，该方法会在网页框架加载结束后就结束执行，此时如果使用 page_source 方法获取页面源代码，很有可能无法获取完整的内容，因为浏览器中可能会有 ajax 请求等，导致某些数据和内容可能是例如下拉的时候才会发起请求获取数据，如果不设置一个等待的时间，就无法确保当前页面的节点是否全部加载完毕</p><p>​    设置等待时间有两种方式：<strong>显式等待；隐式等待</strong>，目的都是为了等待节点能够被加载出来</p><h4 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h4><p>​    会设置一个 <strong>最长的等待时间</strong> ，当指定的节点在一开始没有被加载出来，则会在设置的时间范围内一直等待其最后加载成功，<strong>如果超出指定的时间，依然没有加载成功就抛出（TimeoutException）异常</strong>，在设定的最长等待时间内，<strong>每隔一段时间会去判断一次节点是否存在</strong></p><p>​    显式等待的调用需要引入 <strong>WebDriverWait</strong> 这个对象，默认由参数 <strong>poll_frequency</strong> 控制，<strong>0.5秒 就检查一次</strong>，ignored_exceptions 参数可以指定超时后的异常信息，通过传入浏览器实例和最长时间参数来实例化这个对象，并通过调<strong>用 until 或 until_not 方法传入要等待的条件 expected_conditions</strong>， 通过返回 True 或 False 来判断节点是否存在，如果存在则将节点进行返回，<strong>expected_conditions 的参数是一个元组</strong></p><p>​    <code>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrom()</span><br><span class="line">wait = WaitDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">input_question = wait.until(EC.presence_of_element_located((By.ID, <span class="string">&#x27;question&#x27;</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">&#x27;.btn&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>​    上面的代码使用两个判断条件，<strong>presence_of_element_located 方法用于判断节点是否存在</strong>，<strong>element_to_be_clickable 方法判断节点是否能被点击</strong> ，如果在10秒内，节点被加载出来，并且按钮可以被点击则表示在指定的时间内，这两个节点都被加载完成，会将节点返回；反之，则会抛出异常</p><p>​    <strong>expected_conditions类提供的预期条件判断的方法</strong> </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>title_is</td><td>判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值</td></tr><tr><td>title_contains</td><td>判断当前页面的 title 是否包含预期字符串，返回布尔值</td></tr><tr><td>presence_of_element_located</td><td>判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见</td></tr><tr><td>visibility_of_element_located</td><td>判断某个元素是否可见，可见代表元素非隐藏，并且元素的宽和高都不等于 0</td></tr><tr><td>visibility_of</td><td>跟上面的方法做一样的事情，只是上面的方法要传入 locator，这个方法直接传定位到的 element 就好了</td></tr><tr><td>presence_of_all_elements_located</td><td>判断是否至少有 1 个元素存在于 dom 树中。举个例子，如果页面上有 n 个元素的 class 都是’column-md-3’，那么只要有 1 个元素存在，这个方法就返回 True</td></tr><tr><td>text_to_be_present_in_element</td><td>判断某个元素中的 text 是否 包含 了预期的字符串</td></tr><tr><td>text_to_be_present_in_element_value</td><td>判断某个元素中的 value 属性是否包含 了预期的字符串</td></tr><tr><td>frame_to_be_available_and_switch_to_it</td><td>判断该 frame 是否可以 switch 进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False</td></tr><tr><td>invisibility_of_element_located</td><td>判断某个元素中是否不存在于 dom 树或不可见</td></tr><tr><td>element_to_be_clickable</td><td>判断某个元素中是否可见并且是 enable 的，这样的话才叫 clickable</td></tr><tr><td>staleness_of</td><td>等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False</td></tr><tr><td>element_to_be_selected</td><td>判断某个元素是否被选中了，一般用在下拉列表</td></tr><tr><td>element_selection_state_to_be</td><td>判断某个元素的选中状态是否符合预期</td></tr><tr><td>element_located_selection_state_to_be</td><td>跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator</td></tr><tr><td>alert_is_present</td><td>判断页面上是否存在 alert</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>​    同样设置一个等待时间，如果 selenium 没有在 DOM 中找到节点，则等待，如果超出时间依然没有则抛出异常，隐式等待其实相当于是设置全局的等待，在 <strong>设置的时间内不断刷新来判断节点元素是否存在</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式等待直接可以通过浏览器实例进行调用</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 参数是 int 类型，默认单位是秒</span></span><br></pre></td></tr></table></figure><h3 id="浏览器的前进后退"><a href="#浏览器的前进后退" class="headerlink" title="浏览器的前进后退"></a>浏览器的前进后退</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>) </span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>) </span><br><span class="line"><span class="comment"># 后退到上一个页面</span></span><br><span class="line">browser.back()</span><br><span class="line"><span class="comment"># 跳转回刚才的页面</span></span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>​    使用 selenium 自动框架时，自带了对 Cookie 信息的获取方法    <code>get_cookies()</code>，除此之外也可使用 <code>add_cookies()</code>来向 cookies 中添加自定义的键值信息，而 <code>delete_all_cookies()</code> 可以清空所有的 cookie 信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">browser.add_cookie(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;www.zhihu.com&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br></pre></td></tr></table></figure><h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><p>​    在访问多个页面的情况下，可以使用选项卡来打开多个页面窗口，selenium 的选项卡使用的是   <code>execute_script</code> 执行 js 代码来实现，通过浏览器实例对象的  <strong><code>window_handles</code></strong> 方法来获取所有开启的选项卡列表，列表中的元素是选项卡的代号，选卡项的切换使用 <strong><code>switch_to.window</code></strong> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开一个新的选项卡</span></span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.open()&#x27;</span>)</span><br><span class="line"><span class="comment"># 查看开启的所有选项卡</span></span><br><span class="line"><span class="built_in">print</span>(browser.window_handles)</span><br><span class="line"><span class="comment"># [&#x27;CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435&#x27;, &#x27;CDwindow-6e05f076-6d77-453a-a36c-32baacc447df&#x27;]</span></span><br><span class="line"></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​    在使用 selenium 去获取节点会遇到很多可能的异常错误，比如网络问题导致超时，或是节点是动态的导致无法获取等，所以需要 try…except 去捕获异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 超时异常 TImeException</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.github.com&#x27;</span>) </span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Time Out&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有匹配节点或节点找不到 NoSuchElementException</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;hello&#x27;</span>) </span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No Element&#x27;</span>) </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># 关闭浏览器实例使用 close 方法</span></span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><h3 id="反屏蔽"><a href="#反屏蔽" class="headerlink" title="反屏蔽"></a>反屏蔽</h3><p>​    使用 selenium 来模拟浏览器时，可能会被一些网站监测到并屏蔽掉来防止恶意爬取，其原理是通过检测当前浏览器窗口下的 <strong>window.navigator</strong> 对象是否包含 webdirver 属性，因为正常安装浏览器客户端访问页面时，该属性是 undefined，但在 <strong>使用 selenium 时，就会给 window.navigator 设置为 webdriver 属性，那么网站通过 js 就可以判断访问者是否使用了 selenium</strong> </p><p>​    因此可以使用 execute-script 执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defindProperty</span>(nvaigator, <span class="string">&quot;webdriver&quot;</span>, &#123;<span class="attr">get</span>:<span class="function">() =&gt;</span> <span class="literal">undefined</span>&#125;)</span><br></pre></td></tr></table></figure><p>​    但是执行这行代码并不能起效，因为 <strong>execute_script 方法会在整个页面加载完毕后才会执行</strong>，然而此时 window.navigator 在页面渲染情况就就已经被检测了</p><p>​    因此可以使用 CDP(Chrome Devtools-Protocol，chrome 开发工具协议) 来解决这个问题，CDP 可以使用 <strong>Page.addScriptToEvaluateOnNewDocument</strong> 方法，<strong>允许在页面开始加载是就执行 js 代码</strong>，这样即可将 webdriver 属性置空来得到页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line"><span class="comment"># 通过参数方法开启开发者模式，隐藏自动化扩展信息</span></span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">&#x27;Page.addScriptToEvaluateOnNewDocument&#x27;</span>, &#123;</span><br><span class="line">   <span class="string">&#x27;source&#x27;</span>: <span class="string">&#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider1.scrape.cuiqingcai.com/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    大多数情况下使用上面的方式可以实现网站对 selenium 的屏蔽，但 webdriver 还有很多其他特征可以被设置检测</p><p>###不加载图片</p><p>​    如果使用 selenium 去爬取网站数据，且不需要爬取图片内容的情况下，可以通过设置来让 selenium 的 webdriver 去禁止对页面图片的加载，这样可以加速整个页面的加载速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chrome_opt = webdirver.ChromOptions()</span><br><span class="line">prefs = &#123;<span class="string">&quot;profile.managed_default_content_settings.images&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">chrom_opt.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, prefs)</span><br><span class="line">browser = webdriver.Chrome(options=chrome_opt)</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="无头模式（无界面）"><a href="#无头模式（无界面）" class="headerlink" title="无头模式（无界面）"></a>无头模式（无界面）</h3><p>​    在之前的代码运行下，都会开启一个由驱动程序开启的浏览器，通常情况下，在做爬取时并不需要有这样一个浏览器实现一种可视化的操作，chrome 从 60 版本后支持了无头模式(headless)，该模式上可以不弹出浏览器的窗口，也可以减少一些资源的加载，可以某种程度上节省资源加载和网络带宽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> selenium 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-四</title>
      <link href="/779013646/"/>
      <url>/779013646/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​    <strong>进程 是 计算机资源分配的最小单位</strong>，程序运行时会默认创建一个进程（主）和一个线程（主），所谓进程就是指正在运行的一个任务或过程</p><p>​    程序是一系列提供给 CPU 执行的指令集，而进程是程序的执行而产生的一个静态到动态概念，对于程序而言进程就是其执行的载体，且程序与程序之间的进程是相互隔离的，他们分配得到的内存地址都是不同的</p><p>​    进程由 CPU 进行资源分配，所以与操作系统是息息相关，系统在初始化的过程中会开启很多进程，其中又分前台和后台进程，<strong>前台进程负责与用户的输入进行输出交互</strong>，<strong>后台进程</strong> 用户是无法直接观察到的，<strong>会在运行程序时被动的唤醒为前台进程，通常也称守护进程</strong></p><p>​    对于新的进程的创建，都是由一个已经存在的进程去执行用于创建进程的系统调用而创建的，<strong>在 linux 的系统中，采用 fork 系统调用</strong>，也就是创建一个与父进程一样的副本进程，两者拥有相同的存储映像、同样的环境字符串和同样的打开文件；而 <strong>在 windows 系统中，使用的是 CreateProcess 系统调用</strong> 来创建进程，但是与 fork 的不同的是，父进程与子进程的地址空间并不相同</p><p>​    进程的执行过程是会有多种状态的包括：<strong>就绪，运行，阻塞</strong></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>​    <strong>线程 是 CPU 计算的最小单位</strong>，在一个进程中是可以有多个线程的，相对而言，进程对于线程来说就是一个资源的集合单位，对于任务的执行则由 CPU 通过调度线程来进行</p><p>​    由于线程位于进程中，所以多线程下，线程之间是可以数据共享的，并且相比进程而言，创建多线程的开销比多进程的创建要小很多，因为线程的创建无需像进程那样去申请空间</p><p>​    但是对于 python 而言，多线程却无法发挥最大实力，原因在于 GIL 对多线程下的进行了限制</p><p>​    所以，在 python 中，对于 <strong>计算密集型的操作使用多进程，对于 I/O 密集型操作则是用多线程</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>​    通常，也有称 “微线程”，协程同样是一种并发编程的方式之一，<strong>协程则是一种在单个线程下实现的并发方式</strong>，不过只是创建协程是没有意义的，并不能提高效率，<strong>协程的并发实现是基于事件循环和阻塞切换，由程序员决定在代码的什么地方交出控制权，切换到其他的任务上</strong></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    多线程下，线程是可以资源共享的，使得任意一个线程都可以修改其他线程操作中使用的数据，这显然就出问题了，也就是线程是不安全的</p><p>​    线程安全的前提是需要操作是原子性的，和数据库的原子性一样，一次操作只有两种状态，要么全成功，要么全失败回到原始状态。不过在 python 中，<strong>理论上对与 列表、字典、队列 的操作都是线程安全的，但是 列表 和 字典 如果出现批量的更新，这可能触发到回收机制来影响数据；同时，就 列表 来说，元素操作过程中可能会出现线程的切换，就会导致两个线程所执行的操作从原本的 ‘两次’ 变为 ‘一次’，自然就导致结果出现问题</strong> ，所以推荐使用队列的结构来存储。除此之外，如果要实现原子性的操作，还可以通过自己加锁来实现</p><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>​    global interpreter lock，全局解释器锁是由 python 内部自己会加上的一把锁，<strong>目的是为了去确保在同一时间只能有一个线程在操作</strong>，但这只是做到了解释器级别的数据安全，在 python 中线程的切换主要有两种方式：</p><p>​    1）当线程出现 <strong>I/O 阻塞</strong> 的情况下，<strong>GIL 会被自动的释放</strong>，让其他等待的线程开始执行</p><p>​    2）<strong>在 py2 中</strong>，如果一个线程没有阻塞，无中断地执行了 <strong>1000 个字节码 **会释放 GIL，</strong>py3 中** 则是执行 <strong>15 毫秒</strong> 也会将 GIL 释放</p><p>​    因为 GIL 的问题，造成了 python 中多线程无法达到其他语言那样的并发效果，但是 <strong>GIL 不是语言的特性，这是 CPython 解释器的设计特点</strong>，而 JPython 中就没有 GIL</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p><img src="https://wei-foun.github.io/img/%E5%B9%B6%E5%8F%91.jpg" alt="img"></p><p>​    <strong>并发</strong></p><p>​    从图中可知，<strong>并发是由单核 CPU 中对进程或线程通过多道技术实现的</strong>。多道技术指的是 <strong>CPU 通过快速的切换，从一道切到另一道的执行过程，这种切换的速度是非常快的，从某一道执行几十或几百毫秒就立刻切换下一个进或线程</strong>，虽然依旧是一个时间点上，只有一道在进行，但是在 1 秒内，CPU 则可以在这个时间段内去执行多个进或线程，则就造成了一种是在 “并行” 处理的感觉，也就有说 “并发” 是伪 “并行”</p><p>​    <strong>并行</strong></p><p>​    对于多道技术而言，可以用于单核 CPU ，也可在多核中使用，<strong>并行就是基于多核使用的方式，让多个 CPU 分配到任务，可以理解为开启了多个进程，让每个进程下的线程去同时执行。</strong>一旦其中某一个任务被阻塞，多道技术就会让等待的任务获取被阻塞任务的时间片并执行，如果被阻塞的任务结束阻塞状态，多道技术会重新获取分配去继续执行这个任务</p><p>​    <strong>总结：</strong></p><p>​    并发是由单核 CPU 进行调度，处理进程或线程，通过多道技术实现之间的快速切换，来隐式的做到一个同时执行的效果；并行发挥多核 CPU 优势，实现线程的同时执行，同样可以利用多道技术来达到阻塞即切换，完成即调度</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>​    同步：线程是一个接一个地执行，如果前一个出现等待，后面的线程也只能等待，直到前者完成，后者才能执行</p><p>​    异步：如果某一个出现了等待，其他的线程不会等待其完成才执行，而是继续往下执行，如果等待的操作返回了就通过回调来进行后续的处理</p><p>​    简单来说，同步相当于是报数，前面一个人不报数后面的人就不能喊数字，异步就相当于点名签到，如果叫到的人不在，点名依然会继续，如果这个人后来出现了，再去给他做签到</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>​    阻塞：即程序执行过程中，某一个操作无法立即返回结果，那么程序会挂起，并一直等待结果返回，在等待期间不会执行其他的操作</p><p>​    非阻塞：即遇到需要等待结果的时候，程序只会将当前的阻塞挂起，并立即执行后续其他的操作</p><p>​    同步与异步，阻塞和非阻塞的概念非常容易混淆，个人理解是：同步与异步关注的是执行或顺序，多个进、线程是否是逐个进行，阻塞和非阻塞关注的是等待，也就是关注点是一种状态，即当某一个执行的线程是否出现等待结果返回的情况</p><h3 id="Python-3-进程、线程、协程的创建"><a href="#Python-3-进程、线程、协程的创建" class="headerlink" title="Python 3 进程、线程、协程的创建"></a>Python 3 进程、线程、协程的创建</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>​    python 中创建进程可以使用模块 <strong>multiprocessing</strong> 中的 Process 类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br><span class="line"><span class="comment"># 由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：</span></span><br><span class="line"><span class="comment"># 需要使用关键字的方式来指定参数</span></span><br><span class="line"><span class="comment"># args 指定的为传给 target 函数的位置参数，是一个元组形式，必须有逗号</span></span><br></pre></td></tr></table></figure><p>​    另外，<strong>在 windows 下，进程创建必须写在 main 下，不然会报错。</strong>因为对于 python 文件来说有两种使用方式：</p><p>​    1）直接作为程序去执行</p><p>​    2）通过被 import 导入到其他的 python 程序中，被调用来执行 </p><p>​    在 <code>if __name__ == &#39;main&#39;</code> 中，只有第一种情况下，<code>if __name__ == &#39;main&#39;</code> 中的代码才会执行，而当被导入后，这其中的代码就不会被执行</p><p>​    进程写在 main 下，就是防止在模块被导入的时候就去执行模块的代码，导致最后形成递归创建进程，从而报错</p><p>​    对于 <strong>创建可以有两种方式，一种是实例化，另一种是继承，使用继承的话，需要在类中重写 run 方法，如果也有参数，还需要在 init 方法中 super 父类的该方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(i,))  <span class="comment"># 循环创建 4 个进程对象</span></span><br><span class="line">        p.start()   <span class="comment"># start 方法用来启动进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myprocess</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line"><span class="built_in">super</span>().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"><span class="built_in">print</span>(os.getppid(), os.getpid())  <span class="comment"># getppid 父进程id  getpid 当前进程id</span></span><br><span class="line"><span class="built_in">print</span>(self.arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p1 = Myprocess(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">p2 = Myprocess(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">p3 = Myprocess(<span class="string">&#x27;third&#x27;</span>)</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 27580 1572</span></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># 27580 5032</span></span><br><span class="line"><span class="comment"># second</span></span><br><span class="line"><span class="comment"># 27580 26932</span></span><br><span class="line"><span class="comment"># third</span></span><br><span class="line"><span class="comment"># 三个进程都是一个父进程，即当前程序运行的主进程</span></span><br></pre></td></tr></table></figure><h4 id="进程对象的其他属性和方法"><a href="#进程对象的其他属性和方法" class="headerlink" title="进程对象的其他属性和方法"></a>进程对象的其他属性和方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性</span></span><br><span class="line">p.daemon           <span class="comment"># 设置当前进程对象为守护进程，即父进程如果结束，当前进程p也必须结束</span></span><br><span class="line">p.name             <span class="comment"># 查看当前进程p的名字</span></span><br><span class="line">p.pid              <span class="comment"># 查看当前进程的id</span></span><br><span class="line">p.exitcode         <span class="comment"># 当前进程p如果在运行，返回 None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">p.start()          <span class="comment"># 启动当前的进程</span></span><br><span class="line">p.run()            <span class="comment"># 进程刚启动会执行该方法，去找到指定的 target 函数，但并不是真正的启动方法，而是一个普通的函数</span></span><br><span class="line">p.is_alive()       <span class="comment"># 判断当前进程是否还存活，返回 True or False</span></span><br><span class="line">p.join(timeout)    <span class="comment"># 让主进程等待当前的进程 p 执行完成，才会结束。参数 timeout 是主进程的最大等待时间，需要注意的是，join 方法只能用于 start 开启的线程，而不能用于 run 方法的线程 AssertionError: can only join a started process</span></span><br><span class="line">p.terminate()      <span class="comment"># 强制终止当前进程，但是不会对该进程执行清理操作。如果该进程开启了子进程，子进程会变成僵尸进程，又或是该进程设置了锁，会导致出现死锁</span></span><br></pre></td></tr></table></figure><h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><p>​    进程与进程之间的数据是隔离的，但是共享一套文件系统，但不代表进程之间不能通信，使用同一资源的时候，进程之间会有竞争，也就会出现数据安全问题或顺序问题</p><p>​    所以，要解决这个问题就需要通过加锁来实现，让并发变为串行，虽然牺牲了效率，但是保证了数据的安全，<strong>在 multiprocess 模块中有 Lock 类来提供锁对象</strong></p><p>​    <strong>Lock 是同步锁（也叫互斥锁），它只能锁一次（acquire），释放一次（release）</strong>，如果要实现多次加锁，则 <strong>会造成出现死锁</strong> 的问题，死锁和死循环类似，如果出现双方都在等待对方的资源释放才能处理的情况下就会造成死锁的现象，在 python 中有多种不同的锁来处理不同的情况</p><p>​    除了锁之外，<strong>使用 队列 的方式实现进程的通信</strong>，队列是一种特殊的线性表，因为其只允许在表的最前端删除和末尾进行插入，所以对于队列来说，元素是先进先出的（FIFO，first in first out），但是队列的操作都是内存中进行，所以一旦进程结束退出，队列也就会被清空</p><p>​    队列也不只是有先进先出这一种，也有其他的类型。实现上还一个必要的参数指的是队列中允许的最大项数，如果不给参数则不对总数量做限制，如果加入到队列的元素超出了这个对最大值，队列会阻塞该元素加入，直到有元素从队列中被拿出，有空余空间才将其加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize])           <span class="comment"># 常规的先进先出队列</span></span><br><span class="line">LifoQueue([maxsize])       <span class="comment"># 后进先出队列</span></span><br><span class="line">PriorityQueue([maxsize])   <span class="comment"># 优先级队列</span></span><br><span class="line">deque([maxsize])           <span class="comment"># 双线队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列的方法</span></span><br><span class="line">q.put()</span><br><span class="line"><span class="comment"># 将元素加入到队列中，有两个可选参数是 block 和 timeout</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，如果队列已满，会按照 timeout 的值阻塞，直到队列中有空间可以将其加入，如果超出了 timeout 的时间，抛出 queue.Full 异常</span></span><br><span class="line"><span class="comment"># 如果 block 改为 False，并且队列已满，会立即抛出 queue.Full 异常，而无视 timeout 的值</span></span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line"><span class="comment"># 从队列中取出并删除一个元素，同样有 block 和 timeout 两个参数</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，此时从队列中去元素，如果在 timeout 的阻塞时间内没有元素可以获取，会抛出 _queue.Empty 的异常</span></span><br><span class="line"><span class="comment"># 如果 block 为 False，则无视 timeout 的值，如果没有可以获取的元素，立即抛出 _queue.Empty 异常</span></span><br><span class="line"></span><br><span class="line">q.empty()</span><br><span class="line"><span class="comment"># 判断队列是否是空的，返回 True or False，但是对返回结果不能绝对保证，因为这个结果只是针对于调用此方法的那一刻，很有可能在判断到为空的时候，有新的元素被加入到队列，但是返回的值却是 False</span></span><br><span class="line"></span><br><span class="line">q.full()</span><br><span class="line"><span class="comment"># 判断队列是否已满，同上，如果在判断得到 True 的时候，某一个元素被删除，但是返回结果却依旧是 True，所以同样不能绝对保证返回的结果是正确的</span></span><br><span class="line"></span><br><span class="line">q.qsize()</span><br><span class="line"><span class="comment"># 返回队列中目前的元素总个数，不过依然不能保证返回的值绝对正确，该方法同样只是正对调用执行的那一刻所得到的结果</span></span><br></pre></td></tr></table></figure><h4 id="僵尸进程-和-孤儿进程"><a href="#僵尸进程-和-孤儿进程" class="headerlink" title="僵尸进程 和 孤儿进程"></a>僵尸进程 和 孤儿进程</h4><p>​    <strong>僵尸进程：</strong>当进程通过 fork 创建子进程后，如果子进程退出，而父进程也没有获取子进程的状态信息，描述符依然存储在系统中的这些子进程就是所谓的僵尸进程，<strong>僵尸进程没有任何可执行的代码，所以也无法被调度</strong>，只是一个子进程的退出，但却不是完完全全地销毁关闭</p><p>​    避免僵尸进程可以通过三种方式：</p><p>​    1）fork 创建进程时，创建一个孙子进程去完成子进程的任务，当子进程退出，孙子进程就成了孤儿进程会被 init 进程管理</p><p>​    2）利用 wait 函数让父进程处于阻塞中</p><p>​    3）使用信号量，在 single hander 中调用 waitpid 等待子进程结束，来获取状态信息，且这种方式不会让父进程被阻塞</p><p>​    <strong>孤儿进程：</strong> <strong>父进程退出后，子进程依然在运行，那这些还在运行的子进程就成了孤儿进程</strong>，孤儿进程不同于僵尸进程，<strong>孤儿进程会被 init 进程接管</strong>，由该进程对状态信息做处理</p><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>​    <strong>线程模块使用的 threading 模块，通过实例化 Thread 类得到线程对象</strong>，和进程的 multiprocess 模块非常类似，所以创建和方法上基本都一致，一样支持两种创建方式，使用继承类的话，一样要在自己的类中从写 run 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">t = Thread(target=task, args=(i,))</span><br><span class="line">t.start()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line"><span class="built_in">super</span>().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"><span class="built_in">print</span>(self.arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">t1 = MyThread(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">t2 = MyThread(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># second</span></span><br></pre></td></tr></table></figure><p>​    对比进程而言，线程的开启速度要远快于进程的开启速度；并且 <strong>多线程</strong> 下，<strong>每一个线程的 pid 与 主进程 是一致的</strong>，而 <strong>多进程</strong> 下，<strong>每一个子进程的 pid 与 主进程 的则并不一致</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line"><span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">t = Thread(target=task, args=(<span class="string">&#x27;thread&#x27;</span>,))</span><br><span class="line">t.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># thread     </span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># 在不设置等待情况下即按顺序正常执行输出，如果设置 sleep，最后就会先输出 main，再是 thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line"><span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p = Process(target=task, args=(<span class="string">&#x27;process&#x27;</span>,))</span><br><span class="line">p.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># 对于进程来说，无论设不设置这个 sleep，最后都是会先输出 main，再是 process</span></span><br></pre></td></tr></table></figure><h4 id="线程对象的属性和方法"><a href="#线程对象的属性和方法" class="headerlink" title="线程对象的属性和方法"></a>线程对象的属性和方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t.getName()         <span class="comment"># 返回当前线程的名字</span></span><br><span class="line">t.setName()         <span class="comment"># 给线程设置名字</span></span><br><span class="line">t.isAlive()         <span class="comment"># 判断当前线程是否还存活（活动状态），和 is_alive 是一样的</span></span><br><span class="line">t.setDaemon(daemonic)     <span class="comment"># 通过设置 daemonic 为 True，将当前线程变为守护线程（即主线程结束，该线程不管是否执行完毕都一起结束）</span></span><br><span class="line">t.daemon = <span class="literal">True</span>     <span class="comment"># 等同于 t.setDaemon(True)</span></span><br><span class="line">t.join(block, timeout)    <span class="comment"># 和进程中 join 一样，主要就是让主线程等待当前线程执行完成，才会继续执行</span></span><br><span class="line">t.run()             <span class="comment"># 并不会真正创建一个线程，只是在主线程下的一个普通函数，感觉像是让主线程去做 target 的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># threading 的模块也提供了关于线程的方法</span></span><br><span class="line">threading.currentThread()     <span class="comment"># 返回当前线程的变量</span></span><br><span class="line">threading.<span class="built_in">enumerate</span>()         <span class="comment"># 返回包含正在运行的线程的列表，不包括启动前和结束后的线程</span></span><br><span class="line">threading.activeCount()       <span class="comment"># 同上，但是返回的一个总计值，而不是列表</span></span><br></pre></td></tr></table></figure><h4 id="join-同步"><a href="#join-同步" class="headerlink" title="join 同步"></a>join 同步</h4><p>​    <strong>join() 方法的目的是让主进程，主线程在执行时，要等待当前所有的进程或线程的执行完成，才能继续执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># t = Thread(target=task, args=(&#x27;thread&#x27;,))</span></span><br><span class="line">p = Process(target=task, args=(<span class="string">&#x27;process&#x27;</span>,))</span><br><span class="line"><span class="comment"># t.start()</span></span><br><span class="line"><span class="comment"># t.join()</span></span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># main</span></span><br></pre></td></tr></table></figure><h4 id="setDaemon-守护进程-线程"><a href="#setDaemon-守护进程-线程" class="headerlink" title="setDaemon 守护进程/线程"></a>setDaemon 守护进程/线程</h4><p>​    <strong>守护进程，是一种后台运行的特殊进程，生存周期要长，守护进程不会与终端关联，是脱离控制终端的，目的是为了不会被终端执行中产生的信息打断，或是将自己的信息显示在终端上，所以守护进程也是一个特殊的孤儿进程</strong></p><p>​    比如，你点开了播放器开始听歌，相当于建立了一个主进程，然后循环播放一首歌，关闭了播放器的窗口，这相当于设置了守护进程，因为音乐会一直播放，并且是在后台做处理</p><p>​    由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭</p><p>​    但是守护进程却能够突破这种限制，它会从被执行开始运转，直到整个系统关闭时才退出。例如 docker 运行容器时，会有一个 -d 参数，如果不加这个参数，运行的所有显示都会直接在终端上，一旦使用 ctrl + C 退出后，容器就是结束了。而使用了 -d 参数后，运行就变成了后台运行</p><p>​    <strong>守护线程，目的是为了守护非守护线程，所以守护线程的生存周期也要长于其他非守护线程，容易想到的应用场景就是垃圾回收，非守护线程结束后，由守护线程这个 “清道夫” 做善后，完成垃圾回收</strong></p><p>​    <strong>守护进程的执行：主进程的代码执行结束，守护进程就会立刻结束，主进程会去等待其他子进程执行结束，并最后回收</strong></p><p>​    <strong>守护线程的执行：主线程同样先等待其他所有非守护线程的结束，并且最后如果守护线程依然没有结束，也会被主线程给强制结束</strong></p><p>​    简单理解，守护进程会在主进程结束时一起结束，注意这里是指主进程代码执行结束，不意味着整个程序结束；守护线程的结束需要在其他非守护线程结束后，再跟随主线程的结束而结束</p><p>​    设置守护线程，可以通过 <code>setDaemon</code>，为 True 就是主线程结束，子线程也随之一起结束，无论是否执行完成。可以和 <code>join</code> 搭配实现线程同步，通过给 <code>join</code> 设置一个超时时间来让主线程进行等待，一旦超时后不管能否得到结果，都将其结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thead finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    t1 = Thread(target=thread)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main thread finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># thead finished</span></span><br><span class="line"><span class="comment"># main thread finished</span></span><br></pre></td></tr></table></figure><p>​    如果 <code>t1.join</code> 设置的 timeout 的时间是 1，那么最后这个返回只会有 <code>main thread finished</code>，因为 t1 线程被设置为了守护线程，而这里有没有其他的子线程，所以主线程不会要等待其他子线程完成，同时 t1 线程执行的任务需要 <code>sleep</code> 2 秒，但是 t1 被设置了 join 同步，且超时时间是 1 秒，所以主线程只会等待 1 秒，而 t1 线程无法在 1 秒内完成返回，所以 t1 守护线程最终被主线程强制结束，因此只会输出主线程的 print</p><h4 id="进程-线程池"><a href="#进程-线程池" class="headerlink" title="进程 / 线程池"></a>进程 / 线程池</h4><p>​    python 中给提供了一个标准模块 <strong>concurrent.futures</strong>，该模块可以用来创建并行的任务，提供了更高级的接口用于异步执行的调用，同时该模块支持实现进程池与线程池；concurrent.futures 还有一个抽象类 Executor，该抽象提供一些类关于异步执行的方法来使用，并且进程池和线程池类都继承于该类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常见的一些方法</span></span><br><span class="line">submit(fn,*args,**kwargs)   </span><br><span class="line"><span class="comment"># 提交 fn 函数到池中执行，返回的是一个 Future 对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(func, *iterables, timeout=<span class="literal">None</span>, chunksize=<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 和 python 中的 map 函数类似，从可迭代对象中取出每一个线程执行 func 任务 ，同样会返回一个生成器对象，chunksize 参数只对进程池有效，使用进程池时会将 iterables 分成多个块作为单独进行提交</span></span><br><span class="line"></span><br><span class="line">as_completed(iterables)</span><br><span class="line"><span class="comment"># 接收一个可迭代的序列，返回的是由 Future 对象组成的生成器，如果序列中的任务没有完成，会阻塞，如果其中某个任务完成，则会被 yield 出去，通过 result 可以去查看结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shutdown(wait=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 默认 wait 参数为 True，为 True 时，程序会等待池中所有的任务执行完成后再释放执行器使用的资源，然后再返回；如果设为 False ，则会立即返回，对于等待的任务会在执行后进行释放；但是该值的设置不会影响程序的执行，程序总归到等到任务完成后才会退出，所以对于 shotdown 方法可以利用 with 上下文来实例化进程，线程池的执行器，这样就省去了自己手动调用 shutdown 来释放资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">future.cancel()              <span class="comment"># 尝试取消任务，成功就返回 True，否则就返回 False</span></span><br><span class="line">future.done()                <span class="comment"># 判断方法任务是否执行完成或被取消</span></span><br><span class="line">future.result(timeout)       <span class="comment"># 返回任务执行后的结果，如果超时会抛出异常</span></span><br></pre></td></tr></table></figure><p>​    池的概念和 <strong>生产-消费者模型</strong> 很有相似之处，通过创建池，来规定一个最大的并发数，任务的执行需要从池中获取进程或线程对象来执行，如果池中的资源被取完了，后面的任务就只能等待正在执行的任务将资源释放，然后再去池中获取并执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程池</span></span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">i</span>):</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        obj = pool.submit(task, i)</span><br><span class="line">        <span class="built_in">print</span>(obj.result())</span><br><span class="line">    pool.shutdown()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">50</span>)</span><br><span class="line">    <span class="built_in">print</span>(time.time() - s_start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># --------------------------------------------------</span></span><br><span class="line"><span class="comment"># 8.49578046798706</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        tasks.append(pool.submit(task, i))</span><br><span class="line">   pool.shutdown()</span><br><span class="line">    <span class="built_in">print</span>([obj.result() <span class="keyword">for</span> obj <span class="keyword">in</span> tasks])</span><br><span class="line">    <span class="built_in">print</span>(time.time() - s_start)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># 3.4920427799224854</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 异步代码</span></span><br><span class="line">    <span class="comment"># with ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     s_start = time.time()</span></span><br><span class="line">    <span class="comment">#     t_li = []</span></span><br><span class="line">    <span class="comment">#     for i in range(5):</span></span><br><span class="line">    <span class="comment">#         f = pool.submit(task, i)</span></span><br><span class="line">    <span class="comment">#         t_li.append(f)</span></span><br><span class="line">    <span class="comment">#     print([f.result() for f in t_li])</span></span><br><span class="line">    <span class="comment">#     print(time.time() - s_start)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        s_start = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            f = pool.submit(task, i)</span><br><span class="line">            <span class="built_in">print</span>(f.result())</span><br><span class="line">        <span class="built_in">print</span>(time.time() - s_start)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后的结果和进程池类似，异步花费3秒左右，同步则是8秒</span></span><br><span class="line"><span class="comment"># 有一点要注意的是，线程池在实例的时候，max_workers 如果不设置，默认是按照当前CPU核数乘以5得到最大工作线程的值</span></span><br></pre></td></tr></table></figure><h4 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h4><p>​    需要知道的一点是 <strong>py2 中对于协程都是利用生成器来创建</strong>，在 <strong>py3.7 中则是提供了更加简便的基于 asyncio 和 async / await 的方法</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>/<span class="keyword">await</span>    </span><br><span class="line"><span class="comment"># 定义协程时需要使用 async 关键字；await 关键字则用于阻塞异步等待结果，即当程序会在 await 这里阻塞，并进入被调用的协程函数，执行完毕返回后在继续执行</span></span><br><span class="line"></span><br><span class="line">coroutine</span><br><span class="line"><span class="comment"># async 关键字定义的函数所返回的就是 coroutine，表示一个协程对象，而这个协程不能直接运行，需要注册到事件循环中进行调用</span></span><br><span class="line"></span><br><span class="line">task</span><br><span class="line"><span class="comment"># 协程的真正运行是由任务 task 来进行处理的，任务的执行会有多种状态表现，在执行任务前状态是 pending，完后的状态则是 finished；并且 Task 对象是 Future 的子类</span></span><br><span class="line"></span><br><span class="line">future</span><br><span class="line"><span class="comment"># 表示等待执行或是没有完成的任务的对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 用于创建是一个事件循环对象</span></span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"><span class="comment"># 将协程对象加入到事件循环中去执行得到返回，会将协程对象转为 task 对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了直接将协程放入事件循环等待执行，也可以将其直接转换为 task 任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="comment"># create_task 的参数只能是 coroutine</span></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有另一种可以创建任务的方法 ensure_future</span></span><br><span class="line">task = asyncio.ensure_future(coro_or_future, *, loop=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># ensure_future 的参数可以是 coroutine 或 future，在内部其实也是调用 create_task</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定回调，指任务完成后会出去触发这个回调的函数就对应的处理</span></span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">future</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;callback:&quot;</span>,future.result())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 并发执行，需要手动控制任务的挂起和调用，可以使用 for 循环遍历任务，使用 await 关键对其阻塞获取结果</span></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line"><span class="keyword">await</span> task</span><br><span class="line"><span class="comment"># 或是使用 asyncio.gather 来接收任务，自动在内部对阻塞进行切换，参数是一堆任务</span></span><br><span class="line">asyncio.gather(*tasks)</span><br><span class="line"><span class="comment"># 这里的 * 实现就是打散操作，事件循环会对其中每一个任务进行处理</span></span><br><span class="line"><span class="comment"># 另一个类似的是 wait 方法，但是参数接收的是一个列表</span></span><br><span class="line">asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，在3.7中还有一个简便的运行方法</span></span><br><span class="line">asyncio.run()</span><br><span class="line"><span class="comment"># run 方法是作为协程运行的入口函数，特点是使用 run 方法可以省去原本显式的事件循环的定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;crawling <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">    sleep_time = <span class="built_in">int</span>(url[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;done <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;url_1&#x27;</span>, <span class="string">&#x27;url_2&#x27;</span>, <span class="string">&#x27;url_3&#x27;</span>, <span class="string">&#x27;url_4&#x27;</span>]</span><br><span class="line">    tasks = [asyncio.create_task(func(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s_time = time.time()</span><br><span class="line">    asyncio.run(run())</span><br><span class="line">    <span class="built_in">print</span>(time.time() - s_time)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># crawling url_1</span></span><br><span class="line"><span class="comment"># crawling url_2</span></span><br><span class="line"><span class="comment"># crawling url_3</span></span><br><span class="line"><span class="comment"># crawling url_4</span></span><br><span class="line"><span class="comment"># done url_1</span></span><br><span class="line"><span class="comment"># done url_2</span></span><br><span class="line"><span class="comment"># done url_3</span></span><br><span class="line"><span class="comment"># done url_4</span></span><br><span class="line"><span class="comment"># 4.002416133880615   可见异步协程，最后得到时长是最后一个url_4的时间，远比同步的10秒要快</span></span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    前文提到了 <strong>GIL 锁，目的是确保同一时间只有一个线程得到执行的权限进行操作</strong>，来保证数据的安全性，但却是针对于解释器的数据，例如垃圾回收的数据等，并不能保证编写的代码在执行过程中的数据安全，所以在线程安全中提到了手动的再去加上一把锁 Lock</p><p>​    所以，对于线程的执行来说，GIL 就是一个通行证，只有得到 GIL 的才被允许运行，而其他的线程只能处于等待状态。但是由于 <strong>Python 在遇到阻塞时会释放 GIL</strong>，导致其他线程就会获取到这个通行证从而可以执行自己的代码，那么也就导致如果操作的数据是一个对象，那么这个数据就不是安全的了</p><p>​    因此需要 Lock，来再做一次执行前的认证，一旦一个数据被前一个已经被释放 GIL 的线程做了操作，后一个线程即使得到 GIL 有了执行的权限，由于内部的数据还处在前一个线程的 Lock 中，没有释放，那么其就不能对该数据进行处理​</p><p>​    线程中还有一个方法 join()，这个方法会让主线程必须等待该线程完成后才能继续，这个方法同样可以让多个线程实现串行化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">t2.join()</span><br><span class="line"># 这样最后的结果同样是串行的，t1 开始后，由于 join 方法，其他的线程和主线程会等其完成，t2 也是如此</span><br></pre></td></tr></table></figure><p>​    不过 join 和 Lock 还是不同的，<strong>join 实现的串行会将整个线程的代码锁住</strong>，而 <strong>Lock 锁可以只是对数据来进行上锁</strong>，其他的操作依旧允许线程在得到 GIL 后去执行，效率上对比来说会更好</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​    前文也提到了死锁的产生，如果线程相互等待对方锁住的数据，就会产生这个现象，<strong>Lock 锁就是常说的 互斥锁（同一时刻只能有一个线程可以访问对象）</strong>，能够解决一定的线程安全问题，但是会导致死锁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doA</span>(<span class="params">self</span>):</span><br><span class="line">        lock.acquire()     <span class="comment"># acquire 加锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockA&quot;</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockB&quot;</span>)</span><br><span class="line">        lock.release()     <span class="comment"># release 释放锁</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doB</span>(<span class="params">self</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockB&quot;</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockA&quot;</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># 程序会持续执行，但不会有任何输出</span></span><br></pre></td></tr></table></figure><p>​    所以，<strong>使用 Lock 互斥锁去对代码加锁，只能是加一次锁，多次加锁就会出现相互等待释放的死锁现象</strong></p><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>​    RLock 是一种可以支持重复添加的锁，所以 <strong>RLock 也叫 递归锁 或是 深度锁</strong>，在 RLock 的内部，<strong>维护者一个 Lock 和 counter 的变量，counter 用来记录 acquire 的次数</strong>，所以递归锁可以多次加锁，对于其他线程来说，只有线程加的锁全部都释放后，才可以获取锁中的数据，这一点和 Lock 是一样的，因此 Rlock 对比 Lock 来看，解决了互斥锁可能产生的死锁问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doA</span>(<span class="params">self</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockA&quot;</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockB&quot;</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">doB</span>(<span class="params">self</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockB&quot;</span>）</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;gotlockA&quot;</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​    Semaphore 用来控制线程的并发数，<strong>其内部会管理一个计数器，每一次调用 acquire 加锁，则计数器 - 1，反之释放调用 release，计数器 + 1</strong></p><p>​    <strong>计数器中的值不能小于 0，否则会抛出异常</strong> ValueError(“semaphore initial value must be &gt;= 0”)，<strong>当值为 0 时，加锁的操作就会进行阻塞，直到其中有线程将锁释放</strong>，初始值即实例化信号量对象所指定的并发数</p><p>​    threading 中有两个信号量对象 BoundedSemaphore 和 Semaphore，两者的区别是前者在调用释放锁的时候会去检查计数器的值是否大于初始设定的值，超过初始值则会抛出异常 ValueError(“Semaphore released too many times”)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,arg</span>):</span><br><span class="line"><span class="built_in">super</span>().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">semaphore.acquire()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(self.arg)</span><br><span class="line">semaphore.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">semaphore = threading.Semaphore(<span class="number">2</span>)    <span class="comment"># Semaphore(2) 指的是每次允许 2 个线程通过并在内部创建一个初始值为 2 计数器，其他的线程就处于等待状态，而通过的两个线程根据计数器来进行锁定，防止数据不安全</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">t = MyThread(i)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1    结果返回的状态是每次返回两个结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>​    threading 模块中的 <strong>Event 对象，用来设置一个标志，通过该标志的值来让线程进行等待。默认初始化 Event 对象时，该标志被设置为 False，那么线程会被一直阻塞直到这个标志的返回为 True，一旦标志的返回是 True，所有的线程都会被唤起</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事件对象的方法</span></span><br><span class="line">e.isSet()              <span class="comment"># 返回标签的状态值</span></span><br><span class="line">e.wait()               <span class="comment"># 如果标志返回值是 False，则将线程设为阻塞</span></span><br><span class="line">e.<span class="built_in">set</span>()                <span class="comment"># 如果标志返回的是 True，则将被阻塞的线程全部激活</span></span><br><span class="line">e.clear()              <span class="comment"># 清除设置的状态，恢复标志的初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    e.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等待中&quot;</span>)</span><br><span class="line">    e.wait()      <span class="comment"># 等待 func1 的执行，将 event 的标志改为 True</span></span><br><span class="line">    <span class="built_in">print</span>(arg)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t2 = Thread(target=func2, args=(i,))</span><br><span class="line">        t2.start()</span><br><span class="line">    t1 = Thread(target=func1)</span><br><span class="line">    t1.start()    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待中   </span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 0          </span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5个线程创建后处于类似挂起的状态，func1开始等待2秒后，将标志改为 True，唤醒所有被挂起的线程继续进行处理</span></span><br></pre></td></tr></table></figure><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>​    通过条件是否满足来触发阻塞的线程执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition_func</span>():</span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">    inp = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">n</span>):</span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait_for(condition_func)    <span class="comment"># 等待某个函数的返回结果是否为 True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;run the thread: %s&quot;</span> %n)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一次线程会判断你输入的值是否 == 1，等于才会触发任务的执行，输出正在运行的线程</span></span><br></pre></td></tr></table></figure><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>​    类似定时器，设置一个指定的等待时间，任务会在指定时间后触发执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">2</span>, func, [<span class="number">10</span>,])</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 程序会在2秒后，输出 10</span></span><br></pre></td></tr></table></figure><h3 id="asyncio-异步-IO"><a href="#asyncio-异步-IO" class="headerlink" title="asyncio 异步 IO"></a>asyncio 异步 IO</h3><p>​    asyncio 是 py3 之后引入了一个支持单线程高并发的异步 IO 模块，在 py3.4 开始成为 python 的标准库</p><p>​    在 python 中要想在单线程中实现异步 IO，就需要通过编写协程来实现，而其主要实现方式是基于 yield 的生成器去编写的，这使得应用程序如果要是去实现异步高并发，编写就会非常困难，而且大量的 yield 也会导致代码可读性降低，因此就有了 asyncio 的出现</p><h4 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h4><p>​    <strong>事件循环对象，是 asyncio 的核心点，eventloop 支持将异步任务注册到事件循环的队列上，循环执行队列上的异步任务，如果一个异步任务的函数出现 IO 等待，就会挂起，跳掉下一个等待执行的异步任务</strong>，如果异步任务完成了 IO 完成返回，那么在下一次循环执行事件队列中的这个异步任务后，就会继续执行后续的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;what&#x27;s your name, man?!  <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;l&#x27;m 24601                <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line"></span><br><span class="line"><span class="comment"># what&#x27;s your name, man?!  1620376688.8756835</span></span><br><span class="line"><span class="comment"># l&#x27;m 24601                1620376689.886691</span></span><br></pre></td></tr></table></figure><p>​    get_event_loop 的方法用于创建一个事件循环对象 loop，loop 使用 run_until_complete 方法将异步的任务注册到事件循环的队列上，然后会一直运行直到异步任务完成，如果异步任务有 return 结果，可以直接接收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;what&#x27;s your name, man?!  <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;l&#x27;m 24601                <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;24601&quot;</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">res = loop.run_until_complete(hello())</span><br><span class="line"><span class="built_in">print</span>(res)    <span class="comment"># 24601</span></span><br></pre></td></tr></table></figure><p>​    在 py3.7 之后，asyncio 提供 run 方法来运行一个协程程序，内部也是去调用了 get_event_loop 和 run_until_complete 两个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asyncio.run(hello())</span><br><span class="line"><span class="comment"># what&#x27;s your name, man?!  1620382910.8756835</span></span><br><span class="line"><span class="comment"># l&#x27;m 24601                1620382911.886691</span></span><br></pre></td></tr></table></figure><h4 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h4><p>​    表示协程，asyncio 中的每一个异步任务，也就是每一个函数，实际上是变成了一个协程对象，协程对象主要注册到事件循环上，由事件循环来调度执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(hello()))    <span class="comment"># &lt;class &#x27;coroutine&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>​    <strong>在 asyncio 中定义一个协程，需要在 def 前使用关键字 async 来声明</strong>。如果协程中出现异步方法，需要使用 await 关键字，<strong>await 是用与阻塞的异步接口，获取返回后继续执行</strong></p><p>​    另外，当前代码的 asyncio.sleep 的目的是造成阻塞，将当前的任务调度控制权交出去，让其他的异步任务得到调用</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>​    <strong>表示的是正在处理中或是将要处理的异步任务</strong>，也就是说 future 对象实际上都是没有返回结果的异步任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;what&#x27;s your name, man?!  <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;l&#x27;m 24601                <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;24601&quot;</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">res = loop.run_in_executor(<span class="literal">None</span>, hello)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># what&#x27;s your name, man?!  1620385478.9482934</span></span><br><span class="line"><span class="comment"># l&#x27;m 24601                1620385478.9482934</span></span><br><span class="line"><span class="comment"># &lt;Future pending cb=[_chain_future.&lt;locals&gt;._call_check_cancel() at ...]&gt;</span></span><br></pre></td></tr></table></figure><p>​    这里的 <strong>run_in_executor 方法主要的作用是将同步函数转换为异步函数执行</strong>，从执行结果可知函数已经执行了，但是返回的 future 对象，且处于 pending 状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future.done()   <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>​    <strong>异步任务可以通过 done 方法去查看当前的任务是否执行完成</strong>，可见对于当前这个 future 是未完成执行的</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>​    即正在运行的协程对象，通过 async 创建的协程可以被封装成一个异步任务，任务会包含协程运行的状态信息。简单来说，future 和 task 其实是类似的，因为 <strong>task 本身就是 future 的子类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;what&#x27;s your name, man?!  <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;l&#x27;m 24601                <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;24601&quot;</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">task = loop.create_task(hello())</span><br><span class="line"><span class="built_in">print</span>(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(task))</span><br><span class="line"><span class="built_in">print</span>(task.done())</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;Task pending coro=&lt;hello() running at ...&gt;&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;_asyncio.Task&#x27;&gt;</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>​    上面的例子运行的结果都是未执行完成的 future 和 task 异步任务，future 和 task 也都可以去进行扩展，比如添加完成的回调函数，设置异常处理，或是取消任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(future):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">cancel</span><br><span class="line">cancelled</span><br><span class="line">done</span><br><span class="line">exception</span><br><span class="line">get_loop</span><br><span class="line">remove_done_callback</span><br><span class="line">result</span><br><span class="line">set_exception</span><br><span class="line">set_result</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(task):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> i.startswith(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">add_done_callback</span><br><span class="line">all_tasks</span><br><span class="line">cancel</span><br><span class="line">cancelled</span><br><span class="line">current_task</span><br><span class="line">done</span><br><span class="line">exception</span><br><span class="line">get_loop</span><br><span class="line">get_stack</span><br><span class="line">print_stack</span><br><span class="line">remove_done_callback</span><br><span class="line">result</span><br><span class="line">set_exception</span><br><span class="line">set_result</span><br></pre></td></tr></table></figure><p>​    现在要将 pending 中的 task 完成执行，同时给执行完成的 task 异步任务设置一个完成后的回调函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;what&#x27;s your name, man?!  <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;l&#x27;m 24601                <span class="subst">&#123;time.time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;24601&quot;</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(hello())    <span class="comment"># create_task 方法将在事件循环队列上把参数协程对象转为任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(args)       <span class="comment"># (&lt;Task finished coro=&lt;hello() done, defined at ...&gt; result=&#x27;24601&#x27;&gt;,)</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)     <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">task.add_done_callback(func)       <span class="comment"># add_done_callback 方法可以给任务添加一个完成后的回调函数</span></span><br><span class="line"></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(task.result())    <span class="comment"># 24601</span></span><br><span class="line"><span class="built_in">print</span>(task.done())      <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># what&#x27;s your name, man?!  1620387429.6504166</span></span><br><span class="line"><span class="comment"># l&#x27;m 24601                1620387430.6512332</span></span><br><span class="line"><span class="comment"># func</span></span><br></pre></td></tr></table></figure><p>​    这里使用了事件循环的 run_until_complete 方法将异步 task 任务注册进去执行，可见最后 done 返回的就是 True，表示异步任务执行完成，并且任务的结果通过 result 方法来得到</p><p>​    在执行前，使用 add_done_callback 给 task 设置了一个完成后的回调函数，注意回调函数必须要接受一个参数，这个参数就是 task 对象，从 func 的回调函数中可知 task 的状态是 finish，也就说在 run_until_complete 后，触发了 add_done_callback 设置的回调函数</p><p>​    <strong>补充：</strong>除了事件循环的对象可以使用 create_task 将协程函数变为异步任务之外，<strong>asyncio 也可以使用 create_task 方法，这个语法是 3.7 开始支持的</strong>，对于 asyncio.create_task() 实际会获取一个正在运行的事件循环，再去使用 loop 去 create_task，创建出 task 对象给运行的事件循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_task</span>(<span class="params">coro</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Schedule the execution of a coroutine object in a spawn task.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return a Task object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    loop = events.get_running_loop()</span><br><span class="line">    <span class="keyword">return</span> loop.create_task(coro)</span><br></pre></td></tr></table></figure><h4 id="多任务异步-IO"><a href="#多任务异步-IO" class="headerlink" title="多任务异步 IO"></a>多任务异步 IO</h4><p>​    虽然在 py3 的版本对协程的编写可以通过 asyncio 模块能更加简单地去实现，但是只是在函数中声明前使用 async，以及使用 await ，并不能完全起到协程异步 IO 的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start func1&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end func1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start func2&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end func2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">await</span> func1()</span><br><span class="line">    <span class="keyword">await</span> func2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_perf</span>(<span class="params">func</span>):</span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    asyncio.run(func())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span> Cost: <span class="subst">&#123;time.perf_counter() - start&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show_perf(func)</span><br><span class="line"><span class="comment"># start func1</span></span><br><span class="line"><span class="comment"># end func1</span></span><br><span class="line"><span class="comment"># start func2</span></span><br><span class="line"><span class="comment"># end func2</span></span><br><span class="line"><span class="comment"># func Cost: 4.0199531</span></span><br></pre></td></tr></table></figure><p>​    上例代码中，使用 async 和 await 定义了两个比作处理 IO 阻塞的异步任务，同时在 func 协程中用 await 去执行这两个协程。从 show_perf 的执行返回来看，最后的耗时是 4 秒，也就是 func1 异步函数中阻塞的 3 秒与 func2 中阻塞的 1秒的和</p><p>​    可见，在多个 IO 任务中，<strong>单纯利用 async 和 await 关键字，并不能起到协程的作用，因为 asyncio 模块中最主要的是 eventloop 事件循环，await 的重点是异步任务，无论这个任务是 future 还是 task，前提条件是对象是 awaitable 的</strong></p><p><strong>asyncio.gather</strong></p><p>​    所以对于多个协程任务，可以通过 asyncio 的 gather 方法将多个异步任务收集到一个事件循环的队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(func1(), func2())</span><br><span class="line">    </span><br><span class="line"><span class="comment"># start func1</span></span><br><span class="line"><span class="comment"># start func2</span></span><br><span class="line"><span class="comment"># end func2</span></span><br><span class="line"><span class="comment"># end func1</span></span><br><span class="line"><span class="comment"># func Cost: 3.0101468000000002</span></span><br></pre></td></tr></table></figure><p>​    从 show_perf 执行返回的输出可见，这里最后的耗时只有 3 秒，也就说两个任务做到异步处理，打印的结果上也是先是 func1 调用，func2 是紧接着 func1 被调度执行，两个协程在异步处理，所以最后的耗时接近 func1 中 sleep 的时间</p><p>​    另外，<strong>gather 执行完成后，会按照参数中协程的顺序，将异步执行完成的结果返回</strong>，所以 gather 的关注点在于将异步任务的结果返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start func1&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end func1&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;func1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start func2&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end func2&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;func2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a,b = <span class="keyword">await</span> asyncio.gather(func1(), func2())</span><br><span class="line">    <span class="built_in">print</span>(a,b)   <span class="comment"># func1 func2</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：</strong>如果 task 任务调用了 cancel 方法取消执行，那么在 gather 中就不能将这个任务放入，否则会抛出 CancelledError 的异常，如果这个任务后期可能会被取消，可以使用 asyncio.shield() 方法传入协程，这样后前面如果使用 cancel 取消后，在 gather 中就不会抛出异常，而是将异常作为返回结果</p><p><strong>asyncio.wait</strong></p><p>​    asyncio.wait 和 gather 类似，只是参数的形式不同，<strong>wait 接收的参数需要使用列表的形式</strong>，每一个协程作为这个列表的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait([func1(), func2()])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># start func2</span></span><br><span class="line"><span class="comment"># start func1</span></span><br><span class="line"><span class="comment"># end func2</span></span><br><span class="line"><span class="comment"># end func1</span></span><br><span class="line"><span class="comment"># func Cost: 3.0099885000000004</span></span><br></pre></td></tr></table></figure><p>​    除了参数形式上的不同，wait 的返回也和 gather 不同，wait 并不是直接将异步任务的结果返回，而是返回两个状态集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait([func1(), func2()])</span><br><span class="line">    <span class="built_in">print</span>(done)</span><br><span class="line">    <span class="built_in">print</span>(pending)</span><br><span class="line">    <span class="comment"># &#123;&lt;Task finished coro=&lt;func2() done, defined at C:/Users/DELL/Desktop/chapter_18/test.py:14294&gt; result=&#x27;func2&#x27;&gt;, &lt;Task finished coro=&lt;func1() done, defined at C:/Users/DELL/Desktop/chapter_18/test.py:14288&gt; result=&#x27;func1&#x27;&gt;&#125;</span></span><br><span class="line">    <span class="comment"># set()</span></span><br></pre></td></tr></table></figure><p>​    <strong>wait 的返回值有两个，一个是 done 表示已经完成的异步任务</strong>，注意在 done 中元素都是任务，而不是异步处理完成后的返回结果，<strong>另一个是 pending 表示的就是还未完成的异步任务</strong>。对比 gather 来说，gather 的返回结果就是事件循环处理的每一个异步任务的返回的值，会存在多个，而 wait 只有两个返回结果</p><p>​    对于 done 来说，如果有多个异步任务，返回的是一个列表，每一个元素都是 task 对象，所以如果要获取到异步函数处理得到的结果，需要使用 task.result() 来得到返回值</p><p>​    而对于 pending 来说，如果有未完成的异步任务，这个 future 对象就会在 pending 的列表中出现，否则返回的就是一个空集合</p><p>​    <strong>补充：</strong> asyncio.wait 还可以接受第二个参数，return_when，该参数设置事件循环在处理到什么状态就进行返回，默认情况下 return_when 的值是 asyncio.tasks.ALL_COMPLETED，即表示事件循环中的任务全部执行完成才返回。除此之外，还可以设置这个值为 asyncio.tasks.FIRST_COMPLETED，表示有第一个异步任务处理完成就直接返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    done,pending = <span class="keyword">await</span> asyncio.wait([func1(), func2()], return_when=asyncio.tasks.FIRST_COMPLETED)</span><br><span class="line">    <span class="built_in">print</span>(done)</span><br><span class="line">    <span class="built_in">print</span>(pending)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># start func2</span></span><br><span class="line"><span class="comment"># start func1</span></span><br><span class="line"><span class="comment"># end func2</span></span><br><span class="line"><span class="comment"># &#123;&lt;Task finished coro=&lt;func2() done, defined at C:/Users/DELL/Desktop/chapter_18/test.py:14294&gt; result=&#x27;func2&#x27;&gt;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&lt;Task pending coro=&lt;func1() running at C:/Users/DELL/Desktop/chapter_18/test.py:14290&gt; wait_for=&lt;Future pending cb=[&lt;TaskWakeupMethWrapper object at 0x000002D6E773B828&gt;()]&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment"># func Cost: 1.0052916</span></span><br></pre></td></tr></table></figure><p>​    更改上面的代码，将 asyncio.wait 的 return_when 参数设为 asyncio.tasks.FIRST_COMPLETED，从最后执行时间上可见程序耗时只有 func2 的 1 秒，并且在 pending 中出现了一个未处理完成的异步任务 func1</p><p>​    所以，多个异步任务 asyncio 提供了 gather 和 wait 两个方法来将所任务集中到一个事件循环中去调度处理，除了这两种方式之外，使用 await 单独去做也能实现异步，但是不能只是 await 一个协程，而是需要挂起异步任务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">await</span> func1()</span><br><span class="line">    <span class="keyword">await</span> func2()</span><br><span class="line">    <span class="comment"># 在最开的例子中，直接 await 分别处理两个协程，最后耗时会总和，并不能起到异步效果</span></span><br></pre></td></tr></table></figure><p>​    既然 await 的作用是将异步任务的阻塞进行结果等待，那么使用 await 就需要将协程对象变为 task 异步任务，可以使用 loop，也可以使用 asyncio 去 create_task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    t2 = asyncio.create_task(func2())</span><br><span class="line">    <span class="keyword">await</span> func1()</span><br><span class="line">    <span class="keyword">await</span> t2</span><br><span class="line">    </span><br><span class="line"><span class="comment"># start func1</span></span><br><span class="line"><span class="comment"># start func2</span></span><br><span class="line"><span class="comment"># end func2</span></span><br><span class="line"><span class="comment"># end func1</span></span><br><span class="line"><span class="comment"># func Cost: 3.0090041</span></span><br></pre></td></tr></table></figure><p>​    asyncio.create_task 会去获取一个正在运行的事件循环，并将协程封装返回一个异步任务，当 await func1() 执行时，await 会阻塞等待，而 t2 是一个异步任务，已经在事件循环中开始执行，func1 并不在这个事件循环中，所以 t2 的异步任务执行结束，最后当 func1 sleep 了 3 秒后完成</p><p>​    除了 asyncio.create_task 去创建一个异步任务，还可以使用 ensure_future 创建异步任务，ensure_future 的目的是确保最后返回能得到一个可以 await 的对象，即 future 或是 task（task 是 future 的子类） </p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-三</title>
      <link href="/1656529424/"/>
      <url>/1656529424/</url>
      
        <content type="html"><![CDATA[<h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><h4 id="面向过程（Procedural-Programming-PP）"><a href="#面向过程（Procedural-Programming-PP）" class="headerlink" title="面向过程（Procedural Programming, PP）"></a>面向过程（Procedural Programming, PP）</h4><p>​    函数式的编程其实就是一种面向过程的方式，面向过程的核心即过程， 也就是每一步都是流水式的进行处理。函数各自之间完成逻辑处理来返回值，或是将值给之后调用的函数使用，就像是正常的思维过程，先做什么，然后接着做什么</p><h4 id="面向对象（Object-Oriented-Programming-OOP）"><a href="#面向对象（Object-Oriented-Programming-OOP）" class="headerlink" title="面向对象（Object-Oriented Programming, OOP）"></a>面向对象（Object-Oriented Programming, OOP）</h4><p>​    面向对象的核心是事务，将构成问题作为事务的分解对象，对象不像函数只是为出了处理来得到一个结果，对象主要描述的是事务的某一种实例，因此相比面向过程来说，面向对象更为抽象，因为一个类可以有多种不同的实现，类所产生的实例对象即有共同点，也可以有自己的特点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Music</span>(<span class="title class_ inherited__">object</span>):         <span class="comment"># object 可以不写，在 Python3 中默认所有的类都是继承 object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,t_name</span>):   <span class="comment"># __init__ 初始化方法，类在进行实例的时候，会默认调用这个方法，给类实例的参数需要在这个方法中初始化</span></span><br><span class="line">self.t_name = t_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kind</span>(<span class="params">self</span>):         <span class="comment"># 对于方法而言，self 是必不可少的参数，它所代表的就是一个实例对象 </span></span><br><span class="line"><span class="built_in">print</span>(self.t_name)</span><br><span class="line"></span><br><span class="line">a = Music(<span class="string">&#x27;pop&#x27;</span>)       <span class="comment"># 创建类的实例对象</span></span><br><span class="line">b = Music(<span class="string">&#x27;jazz&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a.kind()         <span class="comment"># pop    通过实例对象可以调用类中的方法</span></span><br><span class="line">b.kind()         <span class="comment"># jazz</span></span><br></pre></td></tr></table></figure><p>​    两者的区别：</p><p>​    面向过程：相对来说耦合性会高，这就导致代码复用性与扩展性自然也不会太好，因此对于代码的维护会较麻烦，但是这种方式编写更加直观，也降低了编写的复杂度，并且对于结果输出也更加直接</p><p>​    面向对象：由于自身的特性使得其易维护，复用和扩展，自然耦合度更低，代码相对来说更加灵活，但由于不是过程化的方式，理解和编写会较为复杂</p><h3 id="面向对象的三个特性"><a href="#面向对象的三个特性" class="headerlink" title="面向对象的三个特性"></a>面向对象的三个特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​    <strong>封装：</strong> 将相关的代码整合在一起，就像函数一样，函数是将一系列对同一个问题的处理打包在一起，来方便调用</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​    <strong>继承：</strong> 又分单继承和多继承，单继承即只有一个父类，如果当前的类中没有对应实现的方法就会去父类中寻找；对于多继承，也就是都多个类，<strong>python3 中对父类方法的查找使用的是 C3 算法</strong></p><h5 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h5><p>​    对于继承的查看，可以使用 <strong><code>类名.mro()</code> (mro，method resolution order 方法解析顺序)</strong>，该方法会返回当前类的继承顺序，是指方法查找会按照这个顺序去父类逐一寻找</p><p>​    <strong>对于 python2 来说，继承的查找使用深度优先（DFS）的算法；同时两者还有个区别，python2 中的类既支持经典类，同时也支持了新式类，而 python3 中的类都是新式类，且默认继承 object</strong></p><p>​    <strong>python 的 2.2 版本中第一次加入新式类，但是这里的新式类使用并不是 C3 算法，而是 BFS，即广度优先算法。</strong>直到 2.3 版本开始，py2 中的新式类才使用了 C3 算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am A&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am C&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">d = D()</span><br></pre></td></tr></table></figure><p>​    上面这段代码，如果在 Python 2 的版本中去运行，实例对象 d 如果去调用 <code>who_am_i</code> 方法，最终调用的会是 A 类的该方法，因为对于 D 类来说，虽然直接父类是 B 和 C，但是两个父类都是继承了 A 类的，也就是说这段代码的继承形状是一个菱形的，mro 的顺序是 D，B，A，C。最后一次没有再去找 A，因为 A 在之前已经存在，父类搜索路径中不能有重复类的出现，所以 C 继承的 A 类，不会在 mro 中存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   A       查找顺序                   A           </span><br><span class="line">B     C  ------------&gt; B   ------&gt; B    ------&gt;    C  </span><br><span class="line">   D                     D           D           D         </span><br></pre></td></tr></table></figure><p>​    简单来说，py2 中经典类的 mro 查找顺序就是，一条路走到底，如果父类没有调用的方法，就继续往这个父类的父类去寻找，直到最开始的父类的所有父类都没有该方法，那就向后继续同样的方式去寻找。即递归去向父类寻找，没有回溯一层，同样递归再去寻找</p><p>​    另外，在 py2 中要获取类的继承 mro 顺序，需要使用 inspect 的模块，使用 <code>inspect.getmro(D)</code> 去查看</p><p>​    由于 py2 的深度优先算法存在问题，即上面的菱形继承的关系，C 作为 A 的子类，在查找方法时，C 如果同样复写的 A 的方法，结果就会导致 d 这个对象先去执行最终父类的方法，而没有去执行父类 C 中的方法</p><p>​    也正是由于经典类的 mro 的 DFS 遍历的问题，所以 2.2 引入了新式类，并使用了 BFS 作为了新式类的 mro 算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   A       查找顺序                               A</span><br><span class="line">B     C  ------------&gt; B   ------&gt;    C ------&gt;     C  </span><br><span class="line">   D                     D          D            D       </span><br></pre></td></tr></table></figure><p>​    还是一样的菱形继承下，可见 BFS 的广度优先的算法，mro 的寻找顺序就是 D，B，C，A。由此，解决了在经典类下 DFS 中，菱形继承会先找 A 而不是找 C 的问题</p><p>​    但是，BFS 的广度优先依旧存在问题，比如在正常的继承状态下，会出现与经典类中类似的问题，导致查找时结果与预期不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 非菱形继承</span><br><span class="line">D       E     查找顺序                                  D               D    E</span><br><span class="line">B       C --------------&gt; B    -------&gt; B   C -------&gt; B    C -------&gt; B    C</span><br><span class="line">    A                       A             A               A               A</span><br></pre></td></tr></table></figure><p>​    如上，可见 BFS 在正常的继承模式下，mro 所返回的结果是 A，B，C，D，E。但是对于 B 而言，父类是 D，所以当 a 对象去调用一个 D 类的方法时，如果 C 类中也有同样的方法，按照 mro 的顺序就会执行到 C 类的方法，但是按照继承关系来说，A 类的直接父类是 B 和 C，而 B 继承自 D，当调用 D 类的方法，应该是从 B 去查找父类 D，而不是走到 C 类中去</p><p>​    所以在 py2.2 中虽然加入了新式类，并且使用 BFS 做 mro 的算法，但是导致 <strong>新式类中在正常的继承关系下，会违背继承的单调性原则</strong>。上面的流程也可以看出，当调用 D 时，没有从 B 去往上找，而是找到了 C 类中，但是 C 并不是 B 的父类，这就破坏了 B 继承 D 的单调性</p><h5 id="C3-算法"><a href="#C3-算法" class="headerlink" title="C3 算法"></a>C3 算法</h5><p>​    由于 2.2 中经典类和新式类都存在继承查找出错的问题，所以 <strong>2.3 中新式类将 mro 的算法改为了 C3 算法</strong></p><p>​    C3 算法在思路上和经典类的 DFS 有相似之处，但不同之处在于每遍历一个继承的节点，解释器会去判断该节点是否是一个好节点，如果是不好的节点就会从 mro 的搜索路径中被移除</p><p>​    好的节点的判断标准是，如果 N 是一个好节点，那么在 mro 的搜索路径中，在 N 之后的节点不能存在继承自 N 的节点</p><p>​    C3 算法在数学公式相对复杂，$L[C(B_1 ··· B_n)] = C + merge(L[B_1], ···, L[B_n], B_1 ··· B_n)$，假设类 C 是继承 $B_1 ··· B_n$，那么类 C 的最后的 mro 就是等式右边的第一个 C，这里 C 最后会是一个列表，列表的元素顺序就是方法调用时，mro 的查找顺序</p><p>​    上面的公式中，最重要的一步操作就是 merge 这一步，每经过一次 merge 的操作，都会从 merge 后面 L 的列表里返回一个类，加到 C 的列表中</p><p>​    merge 的是一个循环遍历的步骤：</p><p>​    首先，取出 $L[B_1]$ 的第一个元素，将这个元素和后面的列表的第二位，一直到最后的元素判断，如果没有重复出现，即将这个元素（类）从原列表移除并放入到 C 列表中，如果有重复出现就拒绝加入，同时下一次 merge 去元素的时候，如果之前是第一个列表的元素有重复，那这次就从第二个列表开始取出做判断（这个判断是判断所有的列表，包括之前存在重复的那个列表）</p><p>​    所有的列表都分为两部分，第一个元素即 head，后面所有的元素都作为 tail，所以每一次 merge 都是比较 head 是否在其余所有的列表的 tail 中有出现</p><p>​    如此往复，知道最后 merge 中没有列表元素可以移除，就表示整个算法计算结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am a X&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am a Y&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(X, Y):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am a A&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(Y, X):</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;I am a B&quot;</span>)</span><br><span class="line">         </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(A, B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">who_am_i</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I am a F&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    首先，最上层 X 和 Y 两个类，在他们各自的继承搜索路径的队列中，只有他们自己，因为他们不继承自其它类（编写上这么说，但是要知道 py3 所有新式类全部默认继承 object 这个对象），所以可以得到 <code>L[X]=X</code>，<code>L[Y]=Y</code></p><p>​     接着，A 和 B 有分别继承自 X 与 Y，那么代入可得：</p><p>​    $L[A] = A + merge(L[X], L[Y], X, Y) = [A, X] + merge(L[Y], Y) = [A, X, Y]$</p><p>​    $L[B] = B + merge(L[Y], L[X], Y, X) = [B, Y] + merge(L[X], X) = [B, Y, X]$</p><p>​    最后，F 分别继承了 A 和 B，依然通过公式代入：</p><p>​    $L[F] = F + merge(L[A], L[B], A, B) = F + merge([A, X, Y], [B, Y, X], A, B)$，进行两次 merge 后得到：</p><p>​    $L[F] = [F, A, B] + merge([X, Y], [Y, X])$</p><p>​    此时，再次 merge 后，因为第一个列表的第一个元素 X 出现在了第二个列表的尾部（[1:]），所以 X 不能内加入到 B 后面。接着就会去取出第二个列表的 Y，遇到同样的问题，Y 出现在了第一个列表的尾部，所以也不能添加</p><p>​    但是 Y 之后已经没有满足的条件了，因为没有下一个列表的，两个列表元素都各处出现在对方的尾部，此时就会抛出异常，python 不会允许你去创建 F 这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">17</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">F</span>(A, B):</span><br><span class="line">TypeError: Cannot create a consistent method resolution</span><br><span class="line">order (MRO) <span class="keyword">for</span> bases X, Y</span><br></pre></td></tr></table></figure><p>​    简而言之，一个类的 mro 是根据 C3 线性化算法来实现，最后的 mro 的列表实际上是合并了这个类的所有父类的mro 列表得到的</p><p>​    <strong>对于 mro 的列表遵循三个准则：</strong></p><p>​    <strong>1）子类会优先于父类被检查</strong></p><p>​    <strong>2）多个父类，根据各自在列表中的顺序（按照继承从左到右）被检查</strong></p><p>​    <strong>3）如果对下一个类中存在两个合法的选择，选择使用第一个父类的</strong></p><p>​    回到之前的例子中，一个是菱形继承，和正常的继承关系，在 C3 中各自的过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菱形继承关系</span></span><br><span class="line"><span class="comment">#    A</span></span><br><span class="line"><span class="comment"># B     C</span></span><br><span class="line"><span class="comment">#    D</span></span><br><span class="line"></span><br><span class="line">L[A] = [A, O]</span><br><span class="line">L[B] = [B, A, O]</span><br><span class="line">L[C] = [C, A, O]</span><br><span class="line">L[D] = [D] + merge(L[B],L[C], B, C, A)</span><br><span class="line">     = [D] + merge([B,A,O], [C,A,O], B, C, A)</span><br><span class="line">     = [D,B] + merge([A,O], [C,A,O], C, A)</span><br><span class="line">     = [D,B,C] + merge([A,O], [A,O], A)</span><br><span class="line">     = [D,B,C,A,O]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 正常继承关系</span></span><br><span class="line"><span class="comment"># D     E</span></span><br><span class="line"><span class="comment"># B     C</span></span><br><span class="line"><span class="comment">#    A</span></span><br><span class="line"></span><br><span class="line">L[D] = [D, O]</span><br><span class="line">L[E] = [E, O]</span><br><span class="line">L[B] = [B] + merge([D,O], D) = [B, D, O]</span><br><span class="line">L[C] = [C] + merge([E,O], E) = [C, E, O]</span><br><span class="line">L[A] = [A] + merge(L[B] + L[C], B, C)</span><br><span class="line">     = [A] + merge([B, D, O], [C, E, O], B, C, D, E)</span><br><span class="line">     = [A, B] + merge([D, O], [C, E, O], C, D, E)</span><br><span class="line">     = [A, B, D] + merge([O], [C, E, O], C, E)</span><br><span class="line">     = [A, B, D, C] + merge([O], [E, O], E)</span><br><span class="line">     = [A, B, D, C, E, O] </span><br></pre></td></tr></table></figure><p>​    对比：</p><p>​    经典类中，菱形关系的 mro 返回是，D，B，A，C</p><p>​    2.2 中新式类，BFS 解决原本 DFS 的问题，菱形关系 mro 返回 D，B，C，A；但是在正常的继承关系中，BFS 所返回的 mro 是 A，B，C，D，E</p><p>​    2.3 之后的新式类，采用 C3 算法，菱形关系返回 B，D，C，A；正常关系返回 A，B，D，C，E</p><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>​    多继承中，可能子类是会直接使用父类的方法的，可以用 <code>类名.方法</code> 去使用，但是需要从传入参数 self，在 python3 中有一种更简便的语法  super，<strong>super() 方法会自己去找当前类的下一个父类中寻找调用的方法，会 <em>按照 mro 的顺序</em> 去寻找</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">ret = <span class="string">&#x27;func_a&#x27;</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">ret = <span class="string">&#x27;func_b&#x27;</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="comment"># ret = A.func(self)      # 调用 A 中的方法</span></span><br><span class="line">ret = <span class="built_in">super</span>().func()      <span class="comment"># python3 中的简便写法，python2 如果使用 super，需要传入当前类和参数 </span></span><br><span class="line"><span class="comment"># ret = super(C, self).func()   # python2 中的 super 方法的写法，这里的当前类是 C，如果改成 A，c.func() 返回的结果就是类 func_b</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(c.func())   <span class="comment"># func_a</span></span><br></pre></td></tr></table></figure><p>​    在多继承中，使用 <code>类名.方法()</code> 的方式去调用父类方法时，如果一个子类的多个父类都调用同一个类的方法，那么导致该子类在调用时，会重复调用这个祖父类的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Base.__init__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A,B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">A.__init__</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">C.__init__</span><br><span class="line"><span class="comment"># 可见 Base.__init__ 的初始化方法被重复调用，虽然对于初始化方法来说，即使重复调用没有影响，但也不是绝对的</span></span><br></pre></td></tr></table></figure><p>​    当利用 super 的方式去调用方法时，就会避免上面出现的问题，super 根据 mro 的列表中继续搜索下一个类，也就是说重复的方法，最后只会被调用一次。如果一个类并没有父类的话，使用 super 去调用某一个方法是会抛出异常的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Base.__init__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;A.__init__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B.__init__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A,B):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        <span class="comment"># py2  super(C, self).__init__()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C.__init__&#x27;</span>)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">A.__init__</span><br><span class="line">C.__init__</span><br></pre></td></tr></table></figure><p>​    从返回结果能很清晰的知道利用 super 可以只对所有父类的中的共同方法调用一次，上面的执行顺序是当实例化 C 类的时候，创建完对象就会调用 init 进行参数初始化。此时 C 的 init 的使用了 super  方法来调用父类中的 init，按照 mro 的顺序寻找当前 C 类的下一个父类 A</p><p>​    当执行到 A 时，因为 A 类中定义了 init 方法，所以该方法会被触发，但是 A 的 init 同样使用了 super 来进行父类 init 的调用，<strong>注意！！这里不是说按照 A 的继承，直接调用 Base 的 init 方法。因为对于 A 的 super 而言，super 中的 self 指的是 C 类的实例对象，所以按照 C 的 mro 顺序是寻找到 B 类上，触发 B 的 init 方法</strong></p><p>​    最后在 B 类中的 super 还是按照 mro 找到 B 之后的父类，也就说最后的 Base，所以实例化 C 类的时候，只会调用一次 Base 的 init 方法</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​    python 是原生就支持多态，所谓多态即通过定义接口，来达到多种实现。也有个常用语来形容多态就是 “鸭子模型”，也就是只要会嘎嘎叫、会游泳的就属于鸭子这个类，不管到底最后实现的是何种形态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;first_class.myfunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondClass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;second_class.myfunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_obj = FirstClass()</span><br><span class="line">s_obj = SecondClass()</span><br><span class="line"></span><br><span class="line">f_obj.myfunc()       <span class="comment"># first_class.myfunc</span></span><br><span class="line">s_obj.myfunc()       <span class="comment"># second_class.myfunc</span></span><br></pre></td></tr></table></figure><p>​    比如列表 <code>list.extand()</code> 这个方法，extand 中并不关心参数是具体什么类型，是字符串，列表，字典或其他类型，extand 需要的只是一个能够迭代的可迭代对象</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​    类即表示拥有相同特征（即属性和方法）的事物，类的实例称为对象（即具体的某一个事物），对类而言有两种作用，一个是类的属性引用，二就是产生实例化对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:        <span class="comment"># 类的命名必须首字母是大写的，并且按照驼峰式规范</span></span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>        <span class="comment"># 类文档字符串，可以通过  ClassName.__doc__ 查看帮助信息</span></span><br><span class="line">   class_suite          <span class="comment"># 类体，由类的成员去组成</span></span><br></pre></td></tr></table></figure><h4 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h4><p>​    大体可以分：<strong>方法 和 属性</strong> ，对于变量而言在类中使用属性的方式来表示，并且在其中会分公有或私有，一般是为了进行一个限制和划分，不让实例化的对象去进行调用，而用于类的内部使用</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Suit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Iron Man&#x27;</span>             <span class="comment"># 静态属性或称变量或字段</span></span><br><span class="line">    __creator = <span class="string">&#x27;Tony·Stark&#x27;</span>      <span class="comment"># 双下划线开头 的 静态属性 表示类 的 私有属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model, system</span>):       <span class="comment"># 在类中，双下划线开头和结尾表示是内置方法</span></span><br><span class="line">    self.model = model         <span class="comment"># 方法中的属性称为动态的属性，对于对象而言，就是实例属性</span></span><br><span class="line">        self.__system = system     <span class="comment"># 同样，双下划线表示私有的实例属性         </span></span><br></pre></td></tr></table></figure><p>​    对于属性而言，在类中还有一种特殊的特殊，本身的写法是方法的表现，但是与方法而言不同是，使用了装饰器  <code>property</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property             </span><span class="comment"># 添加 property 装饰器的方法会被默认转换为属性来调用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">contact</span>(<span class="params">self</span>):      </span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    此外，<strong>使用 <code>property</code> 装饰器的属性，支持类和实例对象对其调用，并且调用它就像正常的属性调用一样，无需加上 ()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;属性&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.func)     <span class="comment"># &lt;property object at 0x000001D5F2F9DD18&gt;</span></span><br><span class="line"></span><br><span class="line">a = A()           </span><br><span class="line"><span class="built_in">print</span>(a.func)     <span class="comment"># 属性</span></span><br></pre></td></tr></table></figure><p>​    不仅如此，<code>property</code> 的属性还有多种访问方式，来实现对静态值的修改或是删除，后者的前提得要是方法是使用的 <code>property</code> 的属性，<strong>对于设置或修改属性，使用 <code>@属性的函数名.setter</code> ，删除则是 <code>@属性的函数名.deleter</code></strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, original_price, discount</span>):</span><br><span class="line">self.original_price = original_price</span><br><span class="line">self.discount = discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.original_price * self.discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_price.setter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self, val</span>):</span><br><span class="line">self.original_price = val</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_price.deleter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">del</span> self.original_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">car = Car(<span class="number">320000</span>, <span class="number">0.9</span>)</span><br><span class="line"><span class="built_in">print</span>(car.get_price)        <span class="comment"># 288000.0</span></span><br><span class="line"></span><br><span class="line">car.get_price = <span class="number">250000</span></span><br><span class="line"><span class="built_in">print</span>(car.get_price)        <span class="comment"># 225000.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> car.original_price</span><br><span class="line"><span class="built_in">print</span>(car.get_price)        <span class="comment"># AttributeError: &#x27;Car&#x27; object has no attribute &#x27;original_price&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Suit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Iron Man&#x27;</span>             </span><br><span class="line">    __creator = <span class="string">&#x27;Tony·Stark&#x27;</span>      </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model, system</span>)     </span><br><span class="line">    self.model = model </span><br><span class="line">        self.__system = system</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):          <span class="comment"># 实例方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__energy</span>(<span class="params">self</span>):     <span class="comment"># 私有方法，以双下划线开头</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    对于类的方法来说，还有两个比较特殊的方法：<strong>静态方法 和 类方法</strong> ，两者表现是也是通过装饰器来表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod     </span><span class="comment"># 静态方法使用装饰器 staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">size</span>():</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@classmethod      </span><span class="comment"># 类方法使用装饰器 classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">cls</span>):   <span class="comment"># 必须传入 cls 作为参数</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​    <strong>静态方法和类方法的区别：静态方法中无需传入 self，类方法中必须的一个参数就是 cls</strong> ，代表的是当前类</p><p>​    <strong>所以对于静态方法而言，它不能使用类或实例对象的任何属性和方法；对于类方法，则可以通过 cls 这个参数，传递类的属性和方法</strong></p><p>​    静态方法，由于没有 self 参数，所以也就可以不用实例对象，用类就可以调用这个方法，同时无法去使用类中的属性和方法，所以整体来看，静态方法在类中像是独立的存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">name = <span class="string">&#x27;ClassA&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;A.func&quot;</span>)     <span class="comment"># 静态方法内部由于没有 self，无法调用 name 属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">A.func()         <span class="comment"># A.func</span></span><br><span class="line">a.func()         <span class="comment"># A.func</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.name)    <span class="comment"># ClassA</span></span><br><span class="line"><span class="built_in">print</span>(a.name)    <span class="comment"># ClassA  </span></span><br></pre></td></tr></table></figure><p>​    类方法，同样也没有 self，但是要求第一个参数必须是 cls，<strong>对于不需要实例对象进行处理的方法，就可以使用类方法，因此类方法也可以通过接受参数来修改类内部的属性值</strong>，同时 <strong>对于继承来说，父类可以用动态方法来定制子类调用该方法的返回</strong></p><p>​    <em>注意，如果类有多个不同的实例对象，当类或某一个实例对象使用类方法修改了属性，一旦有实例对象调用的方法中使用了该属性，那么就意味着所有的实例对象都会受到影响</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">name = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">cls</span>):</span><br><span class="line"><span class="built_in">print</span>(cls.name)         <span class="comment"># A</span></span><br><span class="line">cls.name = <span class="string">&#x27;ClassA&#x27;</span>     <span class="comment"># 修改当前类的属性值，当然对类方法而言用 self 也可以修改</span></span><br><span class="line"><span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.func())    <span class="comment"># ClassA</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">name = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">cls</span>):          <span class="comment"># 当 B 调用该方法，cls 就是指 类 B</span></span><br><span class="line"><span class="built_in">print</span>(cls)          <span class="comment"># &lt;class &#x27;__main__.B&#x27;&gt;</span></span><br><span class="line">cls.name = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B.func())    <span class="comment"># B</span></span><br></pre></td></tr></table></figure><p>​    <strong>总结：</strong></p><p>​    类的方法来说有 <strong>实例方法，静态方法，类方法</strong> ，实例方法只能由类的实例对象去调用；静态和类方法则允许类或实例对象都可直接调用。同时在成员中有某些例如 <code>__init__</code>  这样的内置方法，这些方法的调用会因实例化过程中自己进行触发调动</p><h4 id="私有和公有成员修饰符"><a href="#私有和公有成员修饰符" class="headerlink" title="私有和公有成员修饰符"></a>私有和公有成员修饰符</h4><p>​    对类来说，成员有两种形式：<strong>私有成员，公有成员</strong>；私有成员，表示只能在类的内部才能进行使用，公有成员，则在任何地方都可以访问</p><p>​    变量属性也分 <strong>公有变量属性</strong> 和 <strong>私有变量属性</strong>：</p><p>​    1）公有变量属性，在类的内部可以访问，实例化的对象也可以调用这个属性，对于继承其的派生类同样由于是继承特性自然可以访问</p><p>​    2）<strong>私有变量属性，即只有在类中进行使用，私有变量属性表示 <code>__变量属性名</code></strong></p><p>​    同理，对象属性也有公有和私有：</p><p>​    1）公有对象属性，允许实例对象访问，且对于对象属性和变量属性不同的是，变量属性是定义在类的全局中的，对象属性则是在方法中使用参数 self 定义，所以同样借由 self，对象属性可以在类的内部方法中去访问，派生类也可访问</p><p>​    2）私有对象属性，同样只允许了在类的内部访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要设置一个属性是只读形式，推荐使用 property 装饰器来实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __weight = <span class="number">60</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">weight</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__weight</span><br></pre></td></tr></table></figure><p>​    方法自然也分公有方法和私有方法：</p><p>​    1）公有方法，同之前一样，允许实例对象访问，类在内部可以访问，派生类也可以对其访问</p><p>​    2）<strong>私有方法，依然只允许在内部访问，在定义方法名时，需要前置双下划线</strong></p><p>​    <strong>总结：</strong></p><p>​    公有的成员，允许了类在内部访问，实例对象的访问，派生类的访问；私有成员，只允许类在内部访问</p><p>​    但是 <strong>对于私有的成员来说，只是限制了外部的访问，并没有完全的拒绝。</strong>实例化得到的对象，其实可以对私有成员访问，需要通过  <code>对象._类名__私有的属性名</code>，但是一般不允许这么操作</p><p>​    既然私有的成员是可以访问到的，那为什么用常规的写法不行，需要使用在前面加上 ‘_类名’，这是因为类在加载的过程中，为了区分出私有的成员故意在保存其名字时做了修改，来防止对其的访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">name = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">__author = <span class="string">&#x27;Legacy&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(A.__author)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;name&#x27;: &#x27;A&#x27;, &#x27;_A__author&#x27;: &#x27;Legacy&#x27;, &#x27;func&#x27;: &lt;function A.func at 0x00000176B08F6400&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A._A__author)   <span class="comment"># Legacy</span></span><br></pre></td></tr></table></figure><p>​    对于私有变量，<strong>除了前置双下划线，还有一种是前置单下划线，唯一的区别在于，单下划线的变量虽然也表示私有，但是并不像双下划线那样无法直接访问，类在内部加载时并不会对其修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">_name = <span class="string">&#x27;legacy&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A._name)       <span class="comment"># legacy</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a._name)       <span class="comment"># legacy</span></span><br><span class="line"><span class="built_in">print</span>(A.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;_name&#x27;: &#x27;legacy&#x27;, &#x27;func&#x27;: &lt;function A.func at 0x00000277D5546400&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;A&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：如果一个类的方法被通过 单下划线 或是 双下划线 开头表示私有成员，那么这样的方法是不能通过 <code>from module import *</code> 来进行导入使用</strong></p><h4 id="类的特殊成员（魔法方法）"><a href="#类的特殊成员（魔法方法）" class="headerlink" title="类的特殊成员（魔法方法）"></a>类的特殊成员（魔法方法）</h4><p>​    即一些以双下划线开头和结尾的方法，这些方法有其特殊意义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__doc__           <span class="comment"># 表示类的描述和帮助信息的方法</span></span><br><span class="line">__module__        <span class="comment"># 表示当前操作的对象在哪个模块</span></span><br><span class="line">__class__         <span class="comment"># 表示当前操作的对象的类是什么</span></span><br><span class="line">__init__          <span class="comment"># 类的初始化方法，实例化对象后会自动对其调用</span></span><br><span class="line">__del__           <span class="comment"># 析构方法，当对象被释放时由Python的回收机制去触发执行</span></span><br><span class="line">__call__          <span class="comment"># 由对象后 + ()，来对其调用</span></span><br><span class="line">__dict__          <span class="comment"># 返回类或对象的所有成员，注意两者返回是不同的，对象的成员是 self 开始的，由实例化对象时传入的</span></span><br><span class="line">__str__           <span class="comment"># 返回打印对象时的输出，默认没写这个方法的情况下，打印对象返回的就是一个对象</span></span><br><span class="line">__repr__          <span class="comment"># 同上，多用于交互模式的回显，可以看作是 __str__ 方法的替补，两者优先使用  __str__ ，同时对于这两个方法，字符串的返回必须使用 return</span></span><br><span class="line">__new__           <span class="comment"># 构造方法，用来创建一个空的对象，实例化时会先触发这个方法，然后由初始化方法去初始化对象属性</span></span><br><span class="line">__enter__         <span class="comment"># 创建上下文管理器的时候，进入方法</span></span><br><span class="line">__exit__          <span class="comment"># 退出上下文管理器的退出方法</span></span><br><span class="line">__iter__          <span class="comment"># 用于表示当前对象是一个可迭代对象</span></span><br><span class="line">__next__          <span class="comment"># 从可迭代对象的循环，逐一向后获取元素</span></span><br><span class="line">__getitem__       <span class="comment"># 字典中的值获取，由 对象[&#x27;键&#x27;] 来触发</span></span><br><span class="line">__setitem__       <span class="comment"># 字典中的设置键值，由 对象[&#x27;键&#x27;] = &#x27;值&#x27; 来触发</span></span><br><span class="line">__delitem__       <span class="comment"># 字典中的设置删除键，由 del 对象[&#x27;键&#x27;] 来触发</span></span><br><span class="line">__getattr__       <span class="comment"># 当用户视图访问 对象.属性 时会触发</span></span><br><span class="line">__setattr__       <span class="comment"># 定义一个属性被设置时会触发，对象.属性 = 值，和 __setitem__ 类似</span></span><br><span class="line">__getattribute__  <span class="comment"># 当一个属性被访问时会触发</span></span><br></pre></td></tr></table></figure><p>​    <strong>注意 <code>__getattribute__</code> 和 <code>__getattr__</code> 两个方法，前者对所有属性（包括有或没有的）都有效，而后者通常用于不存在的属性，所以类中如果同时设置了这两个方法，<code>__getattribute__</code> 会覆盖掉 <code>__getattr__</code></strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;alex&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__getattr__&#x27;</span>)</span><br><span class="line">        <span class="comment"># return self.d[item]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__getattribute__&#x27;</span>)</span><br><span class="line">        <span class="comment"># return self.d.item</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"><span class="comment"># __getattribute__</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(a.age)</span><br><span class="line"><span class="comment"># __getattribute__</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure><p>​    补充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__name__         <span class="comment"># 这个系统变量显示了当前模块执行过程中的名称，如果当前程序在当前模块（文件）下运行，__name__ 的返回是 __main__，否则会返回模块的名称</span></span><br><span class="line">__main__         <span class="comment"># main 用于作为模块执行的入口</span></span><br></pre></td></tr></table></figure><h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><p>​    在 python 中一切皆对象，所以可以说类本身也是一个对象，而 <strong>类是由 type 类所实例化</strong> 的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(A))   <span class="comment"># &lt;class &#x27;__main__.A&#x27;&gt; &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 对象 a 是 类A 的实例化，而 类A 又是属于 type 这个类</span></span><br></pre></td></tr></table></figure><p>​    所以对于创建类可以有两种方式，一种就是普通的方式编写，另一种就是使用 type 去实例化一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;func&#x27;</span></span><br><span class="line"></span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&#x27;A&#x27;</span>, (<span class="built_in">object</span>,), &#123;<span class="string">&#x27;func&#x27;</span>: func&#125;)</span><br><span class="line"><span class="comment"># type 的第一个参数是 类名，第二个参数是 父类或基类 object，第三个参数是 类的成员</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.func())        <span class="comment"># func</span></span><br></pre></td></tr></table></figure><p>​    <strong>一个仿造 Flask 的 Local，引发的注意点</strong>，简单说明一下 flask 的 local 类，是一个全局容器，flask 的请求上下文和应用上下文都基于它实现，local 的目的是在多线程下让各线程可以拥有自己的一个空间，防止对共同的属性操作造成变量污染或是程序错误，这里例子要说明的是关于 <code>__setattr__</code> 的使用问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> local</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> get_ident</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadStore</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟 flask 的全局 local 对象，store 负责对不同线程各自划分自己的字典，来存储各自信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># store = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.store = &#123;&#125;</span><br><span class="line">        <span class="comment"># object.__setattr__(self, &#x27;store&#x27;, &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self, key, val</span>):</span><br><span class="line">        thread_id = get_ident()</span><br><span class="line">        self.store[thread_id] = &#123;<span class="built_in">str</span>(key): val&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        self.<span class="built_in">set</span>(key, value)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg, store</span>):</span><br><span class="line">    store.<span class="built_in">id</span> = arg</span><br><span class="line">    <span class="comment"># print(store.store)</span></span><br><span class="line">    <span class="comment"># print(store.id)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_store = ThreadStore()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = Thread(target=task, args=(i, thread_store))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>​    上面的代码，运行后会产生异常 <code>AttributeError: &#39;ThreadStore&#39; object has no attribute &#39;store&#39;</code>，错误点在 <code>self.store[thread_id] = &#123;str(key): val&#125;</code></p><p>​    之所以出现异常，提示说 ThreadStore 的对象没有 store 属性，是因为在  <code>__init__</code> 方法中 <code>self.store = &#123;&#125;</code> 会触发类的 <code>__setattr__</code> 方法，而上面 ThreadStore 中写了自定义的 <code>__setattr__</code> 方法，内部去调用了自定义的 <code>set</code> 方法。而在 <code>set</code> 方法中，有一个赋值语句 <code>self.store[thread_id]</code>，这里是想在 self 也就是当前对象上给 store 属性，也就是空字典通过键值对方式赋值，但此时 <code>self.store</code>，这个 self 对象上还没有创建 store 属性，所以会报错显示对象没有 store 属性</p><p>​    和 <code>__setattr__</code> 方法，对应的还有一个 <code>__getattr__</code> 方法，用来通过 <code>.</code> 属性的方式获取值，接下来在 ThreadStore 加上 <code>get</code> 和 <code>__getattr__</code> 两个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">    thread_id = get_ident()</span><br><span class="line">    <span class="keyword">if</span> thread_id <span class="keyword">in</span> self.store:</span><br><span class="line">        <span class="keyword">return</span> self.store[thread_id][<span class="built_in">str</span>(key)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, item</span>):</span><br><span class="line">    <span class="keyword">return</span> self.get(item)</span><br></pre></td></tr></table></figure><p>​    此时，不去修复之前的错误，再次运行代码，会发现程序出现了死循环，最后会达到 Python 的递归深度而返回异常 <code>RecursionError: maximum recursion depth exceeded</code>，问题的触发点在 <code>if thread_id in self.store</code></p><p>​    不过真正的触发点实际是在 <code>set</code> 方法中  <code>self.store[thread_id]</code>，这里的 <code>self.store</code> 其实会去调用对象的 <code>__getattr__</code> 方法，而这个方法最后又是调用了 <code>get</code> 方法，于是就到了 <code>if thread_id in self.store</code> 判断语句，条件 <code>self.store</code> 最后会再次调用 <code>__getattr__</code> 方法，最终形成了死循环的递归调用</p><p>​    这两个问题的出现，根本原因就是因为在初始化方法中没有创建出 store 这个空字典的变量。这个问题有两个解决方法，一种是直接将 store 属性作为类属性，也就是在方法外直接复制 <code>store = &#123;&#125;</code> ，即第 8 行代码，但通常来说类属性不应该被对象去直接访问；还有一种方法就是在初始化方法中，更改 store 属性的创建，因为如果使用自身对象去创建初始化变量，会出现前面两个问题，所以可以通过 object 对象，通过调用它的 <code>__setattr__</code> 方法，将 store 属性加在 ThreadStore 类 object 上，这样一来初始化的赋值就不会走 ThreadStore 类中定义的 set 和 get，就避免了递归寻找的错误</p><h3 id="接口类和抽象类"><a href="#接口类和抽象类" class="headerlink" title="接口类和抽象类"></a>接口类和抽象类</h3><p>​    上面多态的例子中，是在基类中定义了 myfunc 的方法，并且在继承它的子类中也同样实现了这个方法，其实本质上来说，子类可以不创建 myfunc 的方法，用其他的方法也能实现最后的显示结果</p><p>​    这里的 <strong>接口类</strong> 与 <strong>抽象类</strong> 的目的就是为了给继承的子类加上约束，让子类去实现父类指定的方法</p><h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><p>​    在 python 中默认是没有接口类的，如果要实现约束的作用，一种方式是通过 <strong>手动抛出异常 NotImplementedError</strong> 的方式，<strong>当被指定约束的方法被子类调用</strong>，就会通过异常来提示该方法需要在当前的子类中自己实现</p><p>​    接口类不像抽象类，<strong>接口类允许子类在没有实现接口方法时进行实例化</strong>，所以在限制上接口类更关注在子类对方法复写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;myfunc&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_obj = Myclass()</span><br><span class="line">my_obj.myfunc()       <span class="comment"># myfunc</span></span><br><span class="line">my_obj.func()         <span class="comment"># NotImplementedError</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>(<span class="title class_ inherited__">BaseClass</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfunc</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;myfunc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;base.func&quot;</span>)</span><br><span class="line"> </span><br><span class="line">my_obj.func()         <span class="comment"># base.func</span></span><br></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>​    抽象类是一个介于类与接口的一个概念，兼具类和接口的特性，因此可以像接口类一样实现 “归一化”，所谓归一化，指的是不同的类通过继承，去实现其中接口，即使返回的对象无法确定但是都具有相同的方法，这个方法就来自于接口的实现</p><p>​    抽象类除了和接口类一样来对派生类起到约束的作用外，还可以提供抽象方法，这也是一个接口，不同于接口类的接口，该接口可由抽象类自己内部实现来提供派生类调用，或是和接口类中的接口一样要求派生类必须进行实现</p><p>​    抽象类的实现，使用 abc 模块和装饰器来约束接口，特点是 <strong>如果继承的子类没有实现抽象类的接口，是不能创建实例对象的，会直接抛出异常 <code>TypeError: Can&#39;t instantiate abstract class</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span>(metaclass=ABCMeta):   </span><br><span class="line">    <span class="comment"># __metaclass__ = ABCmeta     # 在Python2.6及以上非3的版本都使用这种方式进行定义</span></span><br><span class="line"><span class="meta">@abstractmethod               </span><span class="comment"># 通过 abstractmethod 装饰器来表示抽象方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="类的继承判断"><a href="#类的继承判断" class="headerlink" title="类的继承判断"></a>类的继承判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(obj, cls)       <span class="comment"># 判断 obj 对象是否是 cls 的子孙类</span></span><br><span class="line"><span class="built_in">issubclass</span>(sub, <span class="built_in">super</span>)     <span class="comment"># 判断 sub 是否是 super 的直接子类  ！！注意两个参数都是类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="literal">True</span>, <span class="built_in">int</span>))   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">1</span>, <span class="built_in">int</span>))      <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>))   <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>​    <strong>反射指的是通过 字符串映射 访问对象的属性</strong>，来调用对象的方法；除了实例对象能使用反射，类和模块也可以使用反射，并且写法上是一致的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(obj, name)      <span class="comment"># 判断 obj 对象是否有 name 这个属性或方法（name 的类型是 str），返回 True 或 False</span></span><br><span class="line"><span class="built_in">getattr</span>(obj, name)      <span class="comment"># 获取 obj 的 name 属性值或方法，如果获取不到会抛出异常 AttributeError ，一般情况下 hasattr 和 getattr 都配合使用，判断有属性或方法，就对其取值，其中 name 如果得到的是方法，那返回的则是一个内存地址，所以需要加上 ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_a</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;func_a&#x27;</span></span><br><span class="line"></span><br><span class="line">a = A() </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(a, <span class="string">&#x27;func_a&#x27;</span>))      <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(a, <span class="string">&#x27;func_a&#x27;</span>)())    <span class="comment"># func_a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(a, <span class="string">&#x27;func_b&#x27;</span>)())    <span class="comment"># AttributeError: &#x27;A&#x27; object has no attribute &#x27;func_b&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(a, <span class="string">&#x27;func_b&#x27;</span>, <span class="string">&#x27;default_val&#x27;</span>))    <span class="comment"># default_val</span></span><br><span class="line"><span class="comment"># getattr 的第三个参数是默认值，即如果属性或方法不存在，就以设置的默认值返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setattr</span>(obj, name, val)         <span class="comment"># 给对象的属性赋值，如果属性不存在，会先创建并赋值</span></span><br><span class="line"><span class="built_in">delattr</span>(name)                   <span class="comment"># 删除对象指定的属性 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setattr</span>(a, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;stark&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.__dict__)               <span class="comment"># &#123;&#x27;name&#x27;: &#x27;stark&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a.name)                   <span class="comment"># stark</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delattr</span>(a, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a.name)                   <span class="comment"># AttributeError: &#x27;A&#x27; object has no attribute &#x27;name&#x27;</span></span><br></pre></td></tr></table></figure><p>​    使用反射，利用请求方式去查看返回结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Http</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,url</span>):</span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self,url</span>):</span><br><span class="line">        res = requests.post(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射获取网页返回</span></span><br><span class="line">url = <span class="string">&quot;http://wei-foun.github.io&quot;</span></span><br><span class="line">method = <span class="built_in">input</span>(<span class="string">&quot;请求方法&gt;&gt;&gt;:&quot;</span>)</span><br><span class="line">h = Http()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(h,method):</span><br><span class="line">    func = <span class="built_in">getattr</span>(h,method)</span><br><span class="line">    res = func(url)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你的请求方式有误...&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>​    <strong>类装饰依靠于内部的 <code>__call__</code> 方法和 <code>__init__</code></strong> ，语法糖使用 <code>@类名()</code> ，实际上会去调用 <code>__call__</code> 作为装饰器，由初始化方法类定义内层执行的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有参数形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, s</span>):</span><br><span class="line">self.s = s        <span class="comment"># 用来接收类的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Starting&quot;</span>, func.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;s =&quot;</span>, self.s)            <span class="comment"># 使用类的参数</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Ending&quot;</span>, func.__name__)</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@A(<span class="params"><span class="string">&quot;xxxx&quot;</span></span>)            </span><span class="comment"># hello=A(hello)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"><span class="comment"># Starting hello</span></span><br><span class="line"><span class="comment"># s = xxxx</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># Ending hello</span></span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>​    <strong>singleton pattern 单例模式是一种常用的软件设计模式</strong>，只允许让类能有一个实例化对象。例如数据库的连接等，如果要给每一个用户创建一个连接实例对象，非常占用资源，而使用唯一的实例，让所有请求通过这个实例去进行访问，更加容易管理，且在程序任何位置都可以使用唯一的单例对象</p><p>​    <strong>单例的优点：提供对唯一实例的受控访问；相当于是一个全局的变量，但防止了在命名空间被污染</strong></p><p>​    单例的五种实现：</p><p>​    <strong>1）文件导入模块的形式     2）基于类的单例     3） 基于 <code>__new__</code> 方法的实现     4）基于 metaclass 的实现     5）基于装饰器的形式</strong></p><p>​    1）导入模块</p><p>​    对于 python 来说，<strong>模块是一个天然的单例模式</strong>，导入模块的过程在其第一次被导入时就会生成 .pyc 文件，如果第二次又要导入，则是从文件中加载，而不会执行模块所在的文件的代码。所以，通导入其他文件中的类对象，即得到了一个单例对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">singleton = Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> singleton</span><br><span class="line">a = singleton</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))     <span class="comment"># 1861751801504</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> singleton</span><br><span class="line">b = singleton</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))     <span class="comment"># 1861751801504</span></span><br></pre></td></tr></table></figure><p>​    2）<strong>基于类的方式，通过 类方法 @classmethod 来实现</strong>，并在第一次实例时，创建出自己的对象赋给类方法，后面都使用这个类方法去创建实例对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">cls._instance = cls(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line">obj = Singleton.instance()</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">t = threading.Thread(target=task, args=[i,])</span><br><span class="line">t.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br></pre></td></tr></table></figure><p>​    3） 基于 <code>__new__</code> 方法的实现，也是最常使用的一种，<strong>利用类的实例化会调用 <code>__new__</code> 方法，通过重写该方法来实现单例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">cls._instance = <span class="built_in">object</span>.__new__(cls)  </span><br><span class="line">    <span class="comment"># 这里要传入 cls 给 __new__ 方法，也可以用 super().__new__(cls)</span></span><br><span class="line"><span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Singleton()</span><br><span class="line">obj1 = Singleton()</span><br><span class="line"><span class="built_in">print</span>(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x0000025D60E685F8&gt; &lt;__main__.Singleton object at 0x0000025D60E685F8&gt;</span></span><br></pre></td></tr></table></figure><p>​    4）基于 metaclass 的实现</p><p>​    回顾一下，在之前的整理中，知道类是由 type 所创建的（可以理解为类时 type 的实例），实例对象是由类所创建的</p><p>​    类 + ()，会去触发 type 的 <code>__call__</code> 方法，而这个方法会去调用 <code>__new__</code>  和 <code>__init__</code></p><p>​    对象 + ()，同样会去触发类的 <code>__call__</code>   </p><p>​    metaclass 是元类，用它可以指定当前的类由谁去做实例化的操作，对于继承于 type 的类就属于元类，简单理解就是能够创建出类的就是元类，而创建对象就是类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonType</span>(<span class="title class_ inherited__">type</span>):   <span class="comment"># 注意，这里需要继承 type</span></span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):   <span class="comment"># 并且 call 方法需要的参数是 cls</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line"><span class="keyword">with</span> SingletonType._lock:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">cls._instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=SingletonType):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = A(<span class="string">&#x27;tony&#x27;</span>)</span><br><span class="line">obj1 = A(<span class="string">&#x27;stark&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.A object at 0x00000180898306D8&gt; &lt;__main__.A object at 0x00000180898306D8&gt;</span></span><br></pre></td></tr></table></figure><p>​    5）装饰器的单例实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">cls</span>):</span><br><span class="line">instance = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line"><span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">instance[cls] = cls(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> instance[cls]</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = A(<span class="string">&#x27;tony&#x27;</span>)</span><br><span class="line">obj1 = A(<span class="string">&#x27;stark&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.A object at 0x00000205681E85F8&gt; &lt;__main__.A object at 0x00000205681E85F8&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-二</title>
      <link href="/997618812/"/>
      <url>/997618812/</url>
      
        <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    函数出现目的是为了实现代码的复用，防止相同的操作需要反复编写相同的逻辑，当需要被调用到时，只需要去调用对应的函数就可以得到处理后的结果</p><h4 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(参数1，参数2)：</span><br><span class="line">&#x27;&#x27;&#x27;函数注释&#x27;&#x27;&#x27;</span><br><span class="line">... </span><br><span class="line">函数体</span><br><span class="line">...</span><br><span class="line">return 返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数名(参数1，参数2)      # 调用函数</span><br></pre></td></tr></table></figure><p>​    函数名必须是包含 <strong>字母，数字 或 下划线</strong>，但是 <strong>不能以数字开头</strong>，且函数名最好有可读性，方便通过名字知道函数的功能</p><p>​    <code>return</code> 表示结束函数的执行，并且返回值可以是任何数据类型；如果一个函数有返回值，就需要使用变量去接受这个 <code>return</code> 的值，否则调用执行函数是没有效果的</p><p>​    对于 <code>return</code> 的返回结果，如果函数体最后不写 <code>return</code>，函数执行结束默认返回的是 <code>None</code>；如果函数体最后只写了 <code>return</code>，后面没有写具体返回值，那么也是会返回 <code>None</code></p><p>​    <code>return</code> 要返回多个值，需要用 <code>,</code> 隔开，最后会以元组的形式将其返回，所以对于接收者，可以是一个变量，那就是接收到一个元组，如果是多个变量，那就一一对应接收</p><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><p>​    首先，写在函数定义中的参数都称为 <strong>形参</strong>；而在调用函数的时候，填写的参数称为 <strong>实参</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func(arg):          # arg 就是形参</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">a = func(&#x27;hello&#x27;)       # &#x27;hello&#x27; 就是实参 </span><br></pre></td></tr></table></figure><p>​    函数是可以接收多个参数的传递的，多个参数之间也是使用 <code>,</code> 隔开，但是毕竟这些参数是供函数使用的，因此需要进行划分，来指明参数和参数之间的使用区别，形参的顺序上是：<strong>位置传参，默认值传参，关键字传参 以及 动态传参</strong> ，另外 <strong>函数的参数也可以是函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置传参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="comment"># 1 2    # 位置传参，即实参顺序对应形参顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值传参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b=<span class="number">2</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 2    # 默认值传参，即给形参赋予默认的值，即使实参没有传递对应参数，也不会报错，且函数会使用默认的参数值进行逻辑处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字传参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b=<span class="number">2</span>,c=<span class="number">10</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b,c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">4</span>, b=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 1 5 4   # 关键字传参，即实参传递时就指定好形参的变量进行传递，让对应的形参变量取值</span></span><br></pre></td></tr></table></figure><p>​    <strong>动态传参</strong> 是一个特殊的传参方式，用来处理要传入的参数有很多的情况，<strong>分两种 <code>*args</code> 和 ``</strong>kwargs``** </p><p>​    <strong><code>*args</code></strong> 将多个参数组成 <strong>元组形式 并打散传入给位置参数</strong></p><p>​    <strong>``</strong>kwargs``** 将多个参数组成 <strong>字典形式 并打散传入给关键字参数</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b,c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)                       <span class="comment"># 1 2 3</span></span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])                    <span class="comment"># 1 2 3</span></span><br><span class="line">func(*<span class="string">&#x27;123&#x27;</span>)                      <span class="comment"># 1 2 3</span></span><br><span class="line">func(*&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;)      <span class="comment"># a b c   如果 agrs 是字典的形式， * 打散后只会去其中的 key</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,b,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)                    <span class="comment"># a b</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)                 <span class="comment"># &#123;&#x27;x&#x27;: 2, &#x27;y&#x27;: 3, &#x27;z&#x27;: 4&#125;  参数 a 和 b 之后的关键字参数被组成了一个字典</span></span><br><span class="line">    <span class="built_in">print</span>(*kwargs)                <span class="comment"># x y z</span></span><br><span class="line"></span><br><span class="line">func(<span class="string">&#x27;a&#x27;</span>,b=<span class="string">&#x27;b&#x27;</span>,x=<span class="number">2</span>,y=<span class="number">3</span>,z=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>​    <strong>补充点：强制使用命名参数 <code>*</code></strong></p><p>​    即调用传参的时候，必须要使用变量名赋值的形式，例如 <code>func(a,*,b)</code> ，在 <code>*</code> 号后面的形参 b，就必须在调用传参时，写明 <code>b=</code>，而前面的 a 则可以使用命名也可以不使用，继续按照位置传参也可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a,*,b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)      <span class="comment"># TypeError: func() takes 1 positional argument but 2 were given</span></span><br></pre></td></tr></table></figure><h4 id="命名空间与作用域"><a href="#命名空间与作用域" class="headerlink" title="命名空间与作用域"></a>命名空间与作用域</h4><p>​    <strong>命令空间由外到内：内置命名空间，全局命名空间，局部命名空间</strong></p><p>​    内置命名空间，即 python 解释器自带的内置函数，比如 print，type 等</p><p>​    全局命名空间，即全局范围下创建存储，例如简单的一个变量赋值，这个变量就存在于全局的空间中</p><p>​    局部命名空间，即执行函数时，函数内部创建了新的变量，这些变量会被临时在存放定义函数的局部空间中，供函数使用，一旦函数调用执行完毕，这个空间会被释放</p><p>​    程序运行的加载顺序：</p><p>​    1）程序真正开始执行之前， 会先加载内置的命名空间</p><p>​    2）程序开始由上至下开始执行，定义在其中的变量会被加载到全局空间，此过程中解释到函数的定义时不会去执行，所以函数内部所创建的都不会被加载</p><p>​    3）函数被触发调用执行，回到函数定义的地方进行加载，内部创建的都被加入局部空间</p><p>​    函数 <strong>作用域</strong> ，也就是作用范围，这个词与命名空间是密切相关的，函数被定义调用就会创建自己的作用域，函数的作用域分为：<strong>全局作用域</strong> 和 <strong>局部作用域</strong></p><p>​    <strong>全局作用域：</strong>即在 <strong>全局命名空间和内置命名空间</strong> 所建立的变量都属于全局的作用域，这些变量在执行程序中的任何一个地方都可以被使用</p><p>​    <strong>局部作用域：</strong>即函数所创造的局部命名空间，这其中的 <strong>变量只能在这个函数内部生效，也就是只能作用于当前的局部范围</strong></p><p>​    注意，因为函数是可以嵌套的，所以局部作用域也就会有层级关系，外层与内层之前称为 enclosing，内层中则称为 local</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------</span><br><span class="line">|   build-n  内置作用域                               |</span><br><span class="line">|   ----------------------------------------------   |</span><br><span class="line">|   |   global  全局作用域                        |   |</span><br><span class="line">|   |   ---------------------------------------  |   |</span><br><span class="line">|   |   |    enclosing                        |  |   |</span><br><span class="line">|   |   |    -------------------------------  |  |   |</span><br><span class="line">|   |   |    |   local                     |  |  |   |</span><br><span class="line">|   |   |    |                             |  |  |   |</span><br><span class="line">|   |   |    -------------------------------  |  |   |</span><br><span class="line">|   |   ---------------------------------------  |   |</span><br><span class="line">|   ----------------------------------------------   |</span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure><p>​    函数的取值顺序：</p><p>​    1）如果变量是在自己内部，也就是由当前调用函数内部创建，直接从局部空间取值</p><p>​    2）如果变量无法在局部空间中取到值，就会往外层搜索，也就是去全局的空间找符合当前变量的值</p><p>​    3）如果全局依然没有取到值，就继续到内置的空间去搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">func()   <span class="comment"># 5   来自全局作用域</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = <span class="number">17</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">func()   <span class="comment"># 17  来自局部作用域</span></span><br></pre></td></tr></table></figure><p>​    之所以要分各自的范围，就是防止变量之间出现污染，因为可能会有全局和局部的变量名字一样得到情况，不划分各自范围，变量就会出现覆盖。但是如果函数内部就是想使用全局的变量的话，python 提供了两种方法来引用不是自己局部范围的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">17</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> a,b             <span class="comment"># global + 变量，表示在当前的函数内部引用全局的变量</span></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    b += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line">func()                     <span class="comment"># 6 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_1</span>():</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_2</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a        <span class="comment"># nolocal + 外层变量，表示在当前的嵌套函数内部引用外层函数的变量，如果外层没有，会抛出语法的异常</span></span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> func_2()</span><br><span class="line"></span><br><span class="line">func_1()                  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure><p>​    除了可以引用之外，还可以用 <strong><code>globals()</code> 查看全局声明的变量</strong> 以及 <strong><code>locals()</code> 查看局部声明的变量</strong></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>​    闭包本身也是一种函数，而且上面的例子中其实就是一个闭包的表现。所谓闭包，其实就是 <strong>内层函数引用外层函数的变量，并且外部函数的返回是内部函数</strong></p><p>​    对于  <strong>判断一个函数是否是闭包函数，可以用 <code>__closure__</code> 方法</strong>，内部的这个函数是闭包函数则会返回一个元组，如果不是则会返回 None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_1</span>():</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func_2</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a     <span class="comment"># nolocal 关键字用来根据作用域修改嵌套函数 func_1 的变量 a</span></span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(func_2.__closure__)</span><br><span class="line">    <span class="keyword">return</span> func_2</span><br><span class="line"></span><br><span class="line">ret = func_1()</span><br><span class="line">ret()               <span class="comment"># (&lt;cell at 0x000001DEE01F0A38: int object at 0x00007FFCE67DB3F0&gt;, &lt;cell at 0x000001DEE01F06D8: function object at 0x000001DEDF196400&gt;)</span></span><br></pre></td></tr></table></figure><p>​     <code>__closure__</code>  方法返回的元组中会包含当前函数所有被调用的对象，注意，在 python 中一切皆对象。这个元组的第二个元素是 function object，表示 func_2 是一个闭包函数</p><p>​    <strong>所以闭包的作用是：保护变量不会受执行影响，让变量常驻内存，但是也需要合理使用，因为这会占用资源</strong>，否则会造成一些不是预期返回结果</p><p>​    使用闭包时，尤其需要注意闭包函数对外层函数变量的应用问题，特别是在循环结构中，可能变量会存在相互干扰，以及引用相同的变量在后续的操作中影响所有闭包的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">*args</span>):</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">            <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(func)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = my_func()    <span class="comment"># 三个变量分别接受了函数返回列表的三个元素</span></span><br><span class="line"><span class="built_in">print</span>(f1())    <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(f2())    <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(f3())    <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​    从返回结果可见，和使用列表生成式一样，返回结果都为同一个值，这是由于 python 的闭包参数延迟绑定导致的</p><p>​    也就是说，在 my_func 函数中 for 循环了三次，在列表中分别加入的是三个闭包函数，而每一个闭包函数 func 引用了外层 for 循环定义了的变量 i，就相当于列表生成式里使用了 lambda 匿名函数一样，闭包函数 func 里本身没有定义 i 的变量，所以当返回的结果 f1，f2 以及 f3 调用闭包函数，内层的闭包会去引用 i 变量的值，而此时 for 循环已经结束，最后的 i 的值是 2，那么最后计算 i*i 得到的就是结果 4，也就导致三个闭包函数返回的结果是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">*args</span>):</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">_i=i</span>):</span><br><span class="line">            <span class="keyword">return</span> _i*_i</span><br><span class="line">        fs.append(func)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = my_func()   </span><br><span class="line"><span class="built_in">print</span>(f1())    <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(f2())    <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(f3())    <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​    当在包含函数上使用参数去接受外层函数后，就相当于是说在循环中产生的闭包函数的作用域中存在了一个变量，这个变量接收外部的循环变量，这样一来每一个闭包作用域中的循环变量都是不同的，所以最后闭包函数执行调用后返回的就是预期结果</p><p>​    由此，<strong>在使用闭包函数时，最好不去引用循环产生的变量，或者是在后续的执行中会发生改变的变量</strong></p><p>​    <strong>补充：当闭包函数引用外层函数变量时，对于这个自由变量，python 是将其存放在了 Cell 的对象中</strong></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>​    装饰器是由闭包演进而来，表现上可以说就是一个闭包函数，但是装饰器有它自己的含义。<strong>装饰器旨在不修改原函数以及调用方式的情况下，对原函数进行功能上的扩展，遵循开放封闭原则</strong></p><p>​    从上面闭包的例子可以看出，闭包函数的调用比一般函数多了一步，需要先对外层（原函数）调用，这一步得到的就是内层（闭包函数），需要再次调用这个函数才能得到内层的结果，当然在外部函数中也是可以直接返回内部函数的调用执行的结果的</p><p>​    例如，需要得到调用函数所执行的时间，最简单就是使用 <code>time 模块</code> 在每一个函数的前后加上代码，最后做差计算得到耗时，但是这显然不符合规范</p><p>​    装饰器的内部函数可以通过接受需要执行的函数，并在内部的函数中进行相应的代码就可以做到对传入的函数进行耗时计算，这样提高了复用性，只需要一个装饰器函数就可以给需要的函数加上这个装饰器来得到执行时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(end - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_num</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回指定数字，在斐波那契中对应的位置的数字，该斐波那契数列的第一位是0&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> count_num(n-<span class="number">1</span>) + count_num(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">fib_count = timer(count_num)</span><br></pre></td></tr></table></figure><p>​    上面的代码中，timer 就是一个自定义的装饰器用来计算函数的执行时间，在调用的时候，将要执行的函数传入这个装饰器，并用函数的原名做变量接收，之后再去调用这个变量</p><p>​    注意上面的代码运行会有问题，因为这个斐波那契的函数是使用了递归方式，<strong>递归函数下使用装饰器会抛出异常</strong></p><p>​    装饰器的实现方式 —— “<strong>语法糖</strong>“</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer                             </span><span class="comment"># 语法糖的使用：@ + 装饰器函数名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib_count</span>(<span class="params">n</span>):                  <span class="comment"># 这里之所以创建一个函数将原来函数放在其中执行，是因为这个原函数使用的递归函数，而递归函数如果直接加装饰器会有问题</span></span><br><span class="line">    <span class="keyword">return</span> count_num(n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fib_count(<span class="number">35</span>))</span><br><span class="line"><span class="comment"># 耗时2.9062602519989014s</span></span><br><span class="line"><span class="comment"># 9227465</span></span><br></pre></td></tr></table></figure><h4 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h4><p>​    这个参数是为了提供给这个装饰器函数使用的，给装饰器添加参数，就能由参数来控制装饰器对不同情况进行处理</p><p>​    根据上面装饰器的例子，现在如果对一些简单的函数觉得没有必要知道运行时间，假如这样的函数有很多，一个个处理就很耗时，通过定义变量作为参数给装饰器，让装饰器函数内部去判断就显得方便一些</p><p>​    从代码实现上，带有参数的装饰器，就是一个三层的嵌套函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;整数计时&quot;</span>)</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">                end = time.time()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;耗时&#123;&#125;s&quot;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(end-start)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;小数计时&quot;</span>)</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">                end = time.time()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;耗时&#123;&#125;s&quot;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params">flag=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(<span class="params"><span class="literal">False</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(count_num())</span><br><span class="line"><span class="comment"># 整数计时</span></span><br><span class="line"><span class="comment"># 耗时1s</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="comment"># 小数计时</span></span><br><span class="line"><span class="comment"># 耗时1.0009684562683105s</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><h4 id="多个装饰器修饰一个函数"><a href="#多个装饰器修饰一个函数" class="headerlink" title="多个装饰器修饰一个函数"></a>多个装饰器修饰一个函数</h4><p>​    对于一个已定义好的函数而言，后续可能会有各种原因，需要对原来的函数进行功能上的添加，就有可能会编写很多的装饰器，而对于一个函数而言，是可以支持多个装饰器的，<strong>但要注意的是，各个装饰器的顺序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_a</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;decorator_a&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">innner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;装饰器A开始执行&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;装饰器A结束执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> innner</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_b</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;decorator_b&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">innner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;装饰器B开始执行&quot;</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;装饰器B结束执行&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> innner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_a           </span><span class="comment"># 执行时，会先进入装饰A中，而此时内部的函数是一个含有装饰器B的原函数</span></span><br><span class="line"><span class="meta">@decorator_b           </span><span class="comment"># 装饰器A执行发现了装饰B，就会进入到装饰器B中，这个时候内部就是原函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;to day is gonna be a good day&quot;</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># decorator_b</span></span><br><span class="line"><span class="comment"># decorator_a</span></span><br><span class="line"><span class="comment"># 装饰器A开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B开始执行</span></span><br><span class="line"><span class="comment"># to day is gonna be a good day</span></span><br><span class="line"><span class="comment"># 装饰器B结束执行</span></span><br><span class="line"><span class="comment"># 装饰器A结束执行</span></span><br></pre></td></tr></table></figure><p>​    原函数里使用的是 print 函数，来将原函数执行的内容进行一个打印输入，所以在执行 装饰器B 时，内层函数执行原函数，就会立即将内容打印，所以在最后的结果中，原函数的内容是在中间</p><p>​    通过上面的例子所返回的结果，<strong>可知多个装饰器修饰同一个函数时，返回的顺序是 自下而上，而内部原函数的调用则是按照装饰器的 自上而下 的顺序</strong></p><p><img src="https://wei-foun.github.io/img/%E8%A3%85%E9%A5%B0%E5%99%A8.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;to day is gonna be a good day&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func())</span><br><span class="line"><span class="comment"># 装饰器A开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B结束执行</span></span><br><span class="line"><span class="comment"># 装饰器A结束执行</span></span><br><span class="line"><span class="comment"># to day is gonna be a good day</span></span><br></pre></td></tr></table></figure><p>​    为什么原函数改为 return 就不行了，因为当使用 return 时，两个装饰器 A 和 B 先后执行，装饰器 B 的内层函数执行原函数，这个时候原函数的返回的字符串被 ret 所接收，但是并没有返回，然后就是 装饰器B 开始结束，并将接着 return 将字符串返回（但不是真的就返回输出了，因为 装饰器A 还没有结束），这个时候就回到 装饰器A 中，装饰器A 内层的 ret 所接收的就是来自 装饰器B 所返回的，但是原函数的结果还没有真正的被 return ，这时 装饰器A 结束，开始 return ret，这个时候函数调用的 print 才开始将返回结果进行打印</p><p>​    所以，虽然看似返回的结果中这两个装饰器没有对原函数进行装饰，但是整个执行的过程中，原函数也是在最内部执行的</p><p>​    <strong>补充：</strong>使用装饰器，需要严格准守 “<strong>开放封闭原则</strong>“，即 <strong>对扩展开放，对修改封闭</strong> 。目的就是防止在原基础上修改导致出现程序不能执行或者产生 bug，因此需要尽可能在不改变原调用上，将修改的内容扩展到原来的程序上</p><p>​    另外，使用装饰器时，内部函数实际上会更改原本函数的文档信息和名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># @wraps(func)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(func.__name__)     <span class="comment"># func1</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(func1.__name__)        <span class="comment"># inner</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure><p>​    为了在使用装饰器的情况下，<strong>让原本的函数的名称和文档信息不被改变，可以使用 <code>functools</code> 模块的 <code>wraps</code> 装饰器，来对内层的 inner 做装饰</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(func.__name__)         <span class="comment"># func1</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(func1.__name__)            <span class="comment"># func1</span></span><br><span class="line"></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure><h4 id="类形式的装饰器"><a href="#类形式的装饰器" class="headerlink" title="类形式的装饰器"></a>类形式的装饰器</h4><p>​    基于类的装饰器，主要实现是通过类的 <code>__call__</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decorate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="comment"># print(&quot;类装饰器&quot;)             </span></span><br><span class="line">        <span class="comment"># ret = self.func(*args, **kwargs)</span></span><br><span class="line">        <span class="comment"># return ret                             # 直接执行函数返回的话，语法糖上不需要使用()</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;类装饰器&quot;</span>)</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> _inner                            <span class="comment"># 闭包方式，语法糖必须加上()，创建类的实例对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorate()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">my_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类装饰器</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>​    递归，简而言之就是函数在内部调用自己，装饰器是由嵌套函数在内层中调用其他的函数实现功能添加，递归通过调用自己实现一个循环的操作。因此递归的使用，需要在内部设置一个出口，当递归到了这个出口，就会自动停止</p><p>​    需要注意的是，<strong>递归本身是会不断调用自己的，所以会是一个死循环，但是 python 还是内部加了一个限制，默认情况下递归的程度大概是在 1000 不到的范围</strong>，就会抛出异常 RuntimeError ，不过这个递归的深度是可以手动修改的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10000</span>)   <span class="comment"># 将深度改为 10000</span></span><br></pre></td></tr></table></figure><p>​    递归的应用有很多，比如汉诺塔问题，二分法查找等，但是递归依旧不是完美的，<strong>递归不适用于大规模的数据处理，容易造成变量常驻内存使得占用大量的资源</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, num</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这个数不在列表中&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = <span class="built_in">len</span>(li) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> num == li[mid]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;找到了&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> num &gt; li[mid]:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li[mid + <span class="number">1</span>:], num)</span><br><span class="line">        <span class="keyword">elif</span> num &lt; li[mid]:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li[:mid - <span class="number">1</span>], num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">li.sort()</span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">9</span>))     <span class="comment"># 找到了</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">12</span>))    <span class="comment"># 这个数不在列表中</span></span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    python 中匿名函数也叫 <strong>lambda 表达式</strong> ，用来表达处理相对简单的函数，匿名函数的函数体只有一行（主体是表达式，而不是一般函数中的代码块），匿名函数中多个参数之间使用 <code>,</code> 隔开，参数和返回值之间使用 <code>:</code> 隔开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> x, y: x+y      <span class="comment"># x, y 是匿名函数的参数；x+y 是匿名函数的返回值</span></span><br><span class="line">ret = a(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)     <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: x, y     <span class="comment"># 这里的 y 会 NameError，因为 y 没有声明，所以不会像 return 那样返回元组</span></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: (x, y)   <span class="comment"># lambda 返回元组需要加上括号</span></span><br></pre></td></tr></table></figure><p>​    通常来说匿名函数都配合一些内置函数搭配使用，这样的函数可以减少像一般函数那样使用很多代码行来处理本身就比较简单的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">&#x27;张楚岚&#x27;</span>, <span class="string">&#x27;张之维&#x27;</span>, <span class="string">&#x27;冯宝宝&#x27;</span>, <span class="string">&#x27;徐四&#x27;</span>, <span class="string">&#x27;王也&#x27;</span>]</span><br><span class="line">f = <span class="built_in">filter</span>(<span class="keyword">lambda</span> el: el[<span class="number">0</span>] != <span class="string">&#x27;张&#x27;</span>, li)      <span class="comment"># 筛选第一个字不是 张 的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(f))                                <span class="comment"># [&#x27;冯宝宝&#x27;, &#x27;徐四&#x27;, &#x27;王也&#x27;]</span></span><br><span class="line"><span class="comment"># filter(func, iterable) 会将可迭代对象中每一个元素作为参数放入 func 中执行将结果返回，返回会是一个 filter 对象，这是一个可迭代对象，用 list 转换就可以看到最终结果</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x+<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])       <span class="comment"># 对每一个元素 +1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(a))                       <span class="comment"># [2, 3, 4]</span></span><br><span class="line"><span class="comment"># map(func, itreable) 同样将可迭代对象的每一个元素作为参数放入 func 执行并返回，并且返回的也是一个可迭代的对象 map，可用 list 转换返回最后的结果</span></span><br></pre></td></tr></table></figure><p>​    注意，filter 和 map 看似用法一致，但是结果的返回并不同，filter 函数的主要目的用来做过滤，也就说返回的对象中是原本可迭代对象中的数据；而 map 函数目的将元素代入函数得到返回的结果，所以 map 返回的对象中数据不一定必须是原本可迭代对象的数据，而这取决于 lambda 函数所设置的返回形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">obj = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">1</span>, li)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(obj))    <span class="comment"># [True, False, True, False, True, False, True, False, True]</span></span><br><span class="line"></span><br><span class="line">obj = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*x, li)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(obj))    <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p>​    <strong>重点：</strong></p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multipliers</span>():</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])</span><br></pre></td></tr></table></figure><p>​    <strong>这段代码的最终结果并不是 <code>[0,2,4,6]</code>，而是 <code>[6,6,6,6]</code></strong></p><p>​    这个问题的原因是因为后期绑定导致的，函数中返回的是一个列表生成式，而其中使用的是 匿名函数 lambda ，可以简单的理解成列表生成式中的按照 <code>for i in rang(4)</code> 生成了 4 个匿名函数对象，完成后 i 的值就是最后一次遍历的 3 ，最后 print 函数也是使用的列表生成式，目的从 multipliers 函数返回得到列表中拿取每一个元素，即每一个匿名函数对象，并给其传入参数 2，由于最后 i = 3，所以当调用 m(2) 的时候，相当于 i * x = 3 * 2，也就是说列表中其实是 4 个  3 * 2，即 <code>[6,6,6,6]</code></p><p>​    如果想要得到一开始所预期的结果的话，只需将函数内部的列表生成式改为生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multipliers</span>():</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])    <span class="comment"># [0, 2, 4, 6]</span></span><br></pre></td></tr></table></figure><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>​    <strong>通过参数的类型来实现不同功能的重(zhong)载(zai)</strong>，通过 <strong>functools 模块中的 singledispatch 装饰器实现，装饰器所装饰的函数是泛型函数的入口，然后通过被装饰函数使用 register 方法来装饰泛型函数，传入不同的基本类型，实现不同的逻辑，最终可以实现在同函数名调用下，实现不同功能的泛型化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(a) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">type</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="meta">@mul.register(<span class="params"><span class="built_in">str</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mul(<span class="number">1</span>,<span class="number">2</span>))       <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(mul(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;2&#x27;</span>))   <span class="comment"># 22</span></span><br><span class="line"><span class="built_in">print</span>(mul(<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>))     <span class="comment"># NotImplemented</span></span><br></pre></td></tr></table></figure><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>​    对于 <strong>可迭代对象</strong> ，简单的理解就是可以使用 for 循环遍历的对象，例如：字符串，列表，字典等，都可以进行循环遍历。因为这类对象的类中，<strong>都提供 <code>__iter__</code> 方法</strong>，所以 <strong>可使用 <code>iter()</code> 方法将当前的对象转换为迭代器对象</strong></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    对于可迭代对象来说，只有  <code>__iter__</code> 方法显然是不够的，因为只有这个方法并不能取出这个可迭代对象的元素，所以 <strong>迭代器内部除了 <code>__iter__</code>  方法还有 <code>__next__</code> 方法</strong>，用于依次往后取出元素，但取到最后一个元素的时候，再次使用 <code>__next__</code> 会抛出 StopIteration 的异常，而这个异常在 for 循环中会被自动捕获</p><p>​    所以迭代器的特点就是：<strong>1）节省内存        2）惰性机制        3）只能依次向后取值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment"># print(dir(a))                 # dir 会将字符串包含的所有方法返回，在里面有 __iter__ </span></span><br><span class="line"><span class="built_in">print</span>(a)                        <span class="comment"># 123</span></span><br><span class="line">a = a.__iter__()                <span class="comment"># 也可使用 iter(a)</span></span><br><span class="line"><span class="built_in">print</span>(a)                        <span class="comment"># &lt;str_iterator object at 0x000002177E816898&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.__next__())             <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(a.__next__())             <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(a.__next__())             <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(a.__next__())             <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>​    可迭代对象和迭代器看着很相似，简单理解可迭代对象用于判断一个对象是否具有可以循环遍历的功能，而迭代器提供遍历和取值的功能，python 也提供了方法去判断一个对象是可迭代对象还是迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = <span class="built_in">iter</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a,Iterable))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a,Iterator))  <span class="comment"># True，没有 a = iter(a) 时，返回的是 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isinstance(o,t)   # 用于判断 对象o 是否是 类t 的子孙类 !! 注意：这里是子孙类，不是直接子类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，上面的代码运行是正常的，但是会抛出一个警告</span></span><br><span class="line"><span class="comment"># DeprecationWarning: Using or importing the ABCs from &#x27;collections&#x27; instead of from &#x27;collections.abc&#x27; is deprecated, and in 3.8 it will stop working </span></span><br><span class="line"><span class="comment"># from collections import Iterable, Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从提示可以看出在新的 python 3.8 的版本开始，上面模块的导入就不成效了，只需改为</span></span><br><span class="line"><span class="comment"># from collections.abc import Iterator,Iterable</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：<code>next</code> 函数是可以对可迭代的对象返回设置默认值的，如果 <code>next</code> 到了最后一个元素，按原本的情况在下一次的 <code>next</code> 就会抛出异常，但是可以通过设置默认值避免</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(i,<span class="number">2</span>))    <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(i,<span class="number">2</span>))    <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(i,<span class="number">2</span>))    <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(i,<span class="number">2</span>))    <span class="comment"># 2    这里就返回了 next 中设置的默认值，而前的元素，都不会被这个默认值影响</span></span><br></pre></td></tr></table></figure><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>​    与普通函数很像，但是在返回的形式上不同，普通函数使用的是 return 来返回结果，但是生成器使用的是 yield 来返回结果</p><p>​    yield 语句每一次执行都会返回一个结果，并在返回后记录当前的运行位置并挂起，在下一次调用函数执行到 yield 的时候，会在上一次的位置上返回下一个结果，然后反复如此依次进行执行和返回</p><p>​    看着和迭代器很像，都需要依次往后执行，并且同样是，<strong>生成器函数执行到最后如果没有下一个了，也是会抛出 StopIteration 的异常</strong></p><p>​    <strong>注意：生成器函数的 yield 返回后的结果是无法直接查看到返回的值，因为 yield 返回的结果是一个 generator 的对象，对于这个生成器对象，需要使用 <code>__next__</code> 方法来得到真正的结果值，当然也可以使用 list 进行转化来查看所有的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(func())                 <span class="comment"># &lt;generator object func at 0x000002362EBDB9A8&gt;</span></span><br><span class="line">func = func()</span><br><span class="line"><span class="built_in">print</span>(func.__next__())        <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(func))             <span class="comment"># 2  # next() 和 __next__() 是一致的，前者需要接受函数调用，而后者是直接调用</span></span><br><span class="line"><span class="built_in">print</span>(func.__next__())        <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>​    另外，生成器函数支持向内部传入值，即 <strong><code>send()</code></strong> 方法，并且在 <strong>第一次执行生成器函数</strong> 的时候，只能使用 <strong><code>next</code>或者是 <code>send(None)</code></strong></p><p>​    <strong>注意点：send()  和  next()  是类似的，send 不加参数的情况下得到结果与 next 的值一样，如果传值，则该值会作为下一次 yield 的位置的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="keyword">yield</span> a</span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line"><span class="built_in">print</span>(func.send(<span class="literal">None</span>))      <span class="comment"># 1   先执行 yield a，将 1 返回后，再将 None 赋予了 b，然后挂起</span></span><br><span class="line"><span class="built_in">print</span>(func.__next__())      <span class="comment"># None   从上一次挂起点继续执行，所以将 b 进行 yield   </span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="built_in">print</span>(func.__next__())      <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(func.send(<span class="number">10</span>))        <span class="comment"># 10  上一次挂起点是 yield a，send 方法将值传入，结果被 b 接收，然后到 yield b 执行，将 10 给返回</span></span><br></pre></td></tr></table></figure><p>​    另外，在 Python3.3 中对生成器新增了一个语法：<strong>yield from</strong>，其作用相当于是简化了 for 循环语句，从一个可迭代对象依次返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(func))     <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(func))     <span class="comment"># 2</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(func))     <span class="comment"># [1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(func))     <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(func))     <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h3 id="内置的一些常用函数"><a href="#内置的一些常用函数" class="headerlink" title="内置的一些常用函数"></a>内置的一些常用函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>()          <span class="comment"># 输入函数，会将结果已字符串返回</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="built_in">str</span>)        <span class="comment"># 将字符串转成 python 代码并执行，有返回值</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="built_in">str</span>)        <span class="comment"># 同上，但是没有返回值，但是能执行更复杂的代码，比如 exec(&quot;print (&#x27;runoob.com&#x27;)&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;123&#x27;</span>), <span class="built_in">type</span>(<span class="built_in">eval</span>(<span class="string">&#x27;123&#x27;</span>)))     <span class="comment"># 123 &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">exec</span>(<span class="string">&#x27;123&#x27;</span>), <span class="built_in">type</span>(<span class="built_in">exec</span>(<span class="string">&#x27;123&#x27;</span>)))     <span class="comment"># None &lt;class &#x27;NoneType&#x27;&gt;</span></span><br><span class="line"><span class="built_in">compile</span>()        <span class="comment"># 预编译，可以选择 eval 或 exec 模式，主要目的是为了对重复性较多或较复杂的代码编译入内存，这样在调用时就不用解释编译而是直接使用执行</span></span><br><span class="line"><span class="built_in">print</span>()          <span class="comment"># 输出函数，参数 end=&#x27;&#x27;，表示每次打印不会换行，参数 flush=True，表示是否刷新，为 True 则会将后面的输出覆盖前面的内容</span></span><br><span class="line"><span class="built_in">open</span>()           <span class="comment"># 打开文件，第一个参数是文件路径，第二个参数的处理方式</span></span><br><span class="line">f.close()        <span class="comment"># 通常打开文件赋予变量，并完成处理后，需要将文件关闭，释放占用的空间</span></span><br><span class="line"><span class="built_in">callable</span>(obj)    <span class="comment"># 判断对象是否是可调用的，返回 True 或 False</span></span><br><span class="line"><span class="built_in">dir</span>(obj)         <span class="comment"># 查看一个对象所包含的方法</span></span><br><span class="line"><span class="built_in">divmod</span>(a,b)      <span class="comment"># 返回一个元组，第一个元素是 a/b 的商，第二个元素是余数</span></span><br><span class="line"><span class="built_in">sorted</span>(obj)      <span class="comment"># 对可迭代对象 obj 进行排序并返回新的对象，不会覆盖原来的，list 的 sort 是会覆盖原来的</span></span><br><span class="line"><span class="built_in">reversed</span>()       <span class="comment"># 对 obj 进行反向排序，同样不会覆盖原对象，reverse 会覆盖原来的</span></span><br><span class="line"><span class="built_in">bytes</span>(s, encoding)     <span class="comment"># 将字符串按照指定的编码规则进行编码后返回</span></span><br><span class="line">s.decode(encoding)     <span class="comment"># 将字节码 s ，按照指定编码规则进行解码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">all</span>(obj)         <span class="comment"># 判断可迭代对象 obj 中的所有元素布尔值是否都是 True，全部都是就返回 True，反之有一个不为 True，就返回 False</span></span><br><span class="line"><span class="built_in">any</span>(obj)         <span class="comment"># 同上，但是只要其中有一个元素是 True 就返回 Ture，只有全部都是 False 才返回 False</span></span><br><span class="line"><span class="built_in">filter</span>(func,<span class="built_in">iter</span>)   <span class="comment"># 将可迭代对象的每一个元素放入函数执行，过滤出匹配的结果</span></span><br><span class="line"><span class="built_in">map</span>(func,<span class="built_in">iter</span>)      <span class="comment"># 同上，将每一个元素放入函数执行，最后将结果返回</span></span><br><span class="line"><span class="built_in">enumerate</span>(obj)        <span class="comment"># 枚举，会返回可迭代对象 obj 中每一个元素以及其下标索引，字典的话则是返回下标索引和键</span></span><br><span class="line">li = [<span class="string">&#x27;alexander&#x27;</span>, <span class="string">&#x27;hamilton&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(li):</span><br><span class="line"><span class="built_in">print</span>(i, j)</span><br><span class="line"><span class="comment"># 0 alexander</span></span><br><span class="line"><span class="comment"># 1 hamilton</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-一</title>
      <link href="/3857016810/"/>
      <url>/3857016810/</url>
      
        <content type="html"><![CDATA[<h3 id="Python种类"><a href="#Python种类" class="headerlink" title="Python种类"></a>Python种类</h3><p>​    众做周知，Python 的底层是由 C 实现的，所以常用的也是 Cpython，除此之外还有 Jpython，lronpython 等</p><p>​    Cpython 是官方的版本，在执行时 Cpython 会将 原 (py) 文件 转换成 字节码 (pyc) 文件，然后在 python 虚拟机上执行</p><p>​    Jpython 顾名思义就是由 java 实现，执行时会将代码动态编译成 java 字节码，然后在 jvm 上运行</p><p>​    IronPython 由 C# 实现，同样执行会将代码编译成 C# 字节码，然后在 CLR 运行</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    常用的七个数据类型：字符串，数字，列表，字典，元组，集合，布尔。其中三个是可变，四个是不可变类型，<strong>字符串，数字，元组，布尔</strong> 是 <strong>不可变数据类型 (可哈希)</strong>；<strong>列表，字典，集合</strong> 是 <strong>可变数据类型 (不可哈希)</strong>。同时 python 中的 <strong>布尔类型</strong> 其实是 <strong>继承 int</strong> 的</p><h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">strip()   <span class="comment"># 移除字符串左右两边的字符，该方法有一个参数，表示指定清除的字符，默认清除左右的空格</span></span><br><span class="line">split()   <span class="comment"># 分割，默认会以一个空白符分割字符串，同样可以通过参数指定分割字符，分割后会返回一个 list</span></span><br><span class="line"><span class="built_in">len</span>(<span class="built_in">str</span>)    <span class="comment"># 返回字符串的总长度</span></span><br><span class="line">capitalize()   <span class="comment"># 首字母大写</span></span><br><span class="line">count()   <span class="comment"># 统计某一个字符的出现的个数，通过参数指定要统计的字符</span></span><br><span class="line">startswith()   <span class="comment"># 判断字符串是否以某个字符开头，通过参数指定字符，返回 True or False</span></span><br><span class="line">endswith()     <span class="comment"># 同理，判断是否以某个字符结尾</span></span><br><span class="line">find()     <span class="comment"># 查找字符串的索引位置，如果返回 -1 则表示搜索的内容不在目标字符串中</span></span><br><span class="line">index()    <span class="comment"># 与 find 一样，但是使用 index 方法查找一个不存在的字符，会抛出异常 ValueError</span></span><br><span class="line">replace()  <span class="comment"># 替换，两个必传参数，被替换的字符，要替换成的字符，第三个参数是次数，默认是全部替换</span></span><br><span class="line">upper()    <span class="comment"># 字符全部转为大写</span></span><br><span class="line">lower()    <span class="comment"># 字符全部转为小写</span></span><br><span class="line">swapcase()  <span class="comment"># 字符串的大小写字母翻转</span></span><br><span class="line">join()     <span class="comment"># 连接字符，join 内部的参数是一个可迭代对象，可迭代的每一个元素要是 str，并将指定的字符作为分隔符加入到每两个字符的中间，作为新字符串返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断方法</span></span><br><span class="line">isdigit()    <span class="comment"># 判断字符串是否是 纯数字 组成</span></span><br><span class="line">isalnum()    <span class="comment"># 判断字符串中是否由 数字或字母 组成</span></span><br><span class="line">isalpha()    <span class="comment"># 判断字符串是否是 纯字母 组成</span></span><br><span class="line">isupper()    <span class="comment"># 判断所有字符是否都是大写</span></span><br><span class="line">islower()    <span class="comment"># 判断所有字符是否都是小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化方法</span></span><br><span class="line"><span class="built_in">format</span>()     <span class="comment"># 将字符串的中留空的位置，替换为 format 方法指定的字符串参数，原字符串中留空数要和给定的参数数量一致，否则抛出 IndexError 异常</span></span><br><span class="line"></span><br><span class="line">msg=<span class="string">&#x27;name:&#123;&#125;,age:&#123;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.<span class="built_in">format</span>(<span class="string">&#x27;ham&#x27;</span>,<span class="string">&#x27;21&#x27;</span>))       <span class="comment"># name:ham,age:21</span></span><br><span class="line">msg=<span class="string">&#x27;name:&#123;0&#125;,age:&#123;1&#125;,addr:&#123;0&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.<span class="built_in">format</span>(<span class="string">&#x27;ham&#x27;</span>,<span class="string">&#x27;21&#x27;</span>))       <span class="comment"># name:ham,age:21,addr:ham</span></span><br><span class="line">msg=<span class="string">&#x27;name:&#123;x&#125;,age:&#123;y&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.<span class="built_in">format</span>(x=<span class="string">&#x27;ham&#x27;</span>,y=<span class="string">&#x27;21&#x27;</span>))   <span class="comment"># name:ham,age:21</span></span><br><span class="line"></span><br><span class="line">msg=<span class="string">&#x27;name:%s,age:%s&#x27;</span>                <span class="comment"># %s 表示格式化字符串，%d 表示格式化整数，%f 表示浮点数</span></span><br><span class="line"><span class="built_in">print</span>(msg %(<span class="string">&#x27;ham&#x27;</span>,<span class="string">&#x27;21&#x27;</span>))            <span class="comment"># name:ham,age:21</span></span><br><span class="line">msg=<span class="string">&#x27;name:%s,age:%d&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg %(<span class="string">&#x27;ham&#x27;</span>,<span class="number">21</span>))              <span class="comment"># name:ham,age:21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.6 版本开始引入一个另一个新的方法 f，性能要比前两者更好，也更简洁</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;123<span class="subst">&#123;b&#125;</span>&#x27;</span>)                    <span class="comment"># 1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">[a:b:c]    <span class="comment"># 字符串截取，返回的是原字符串索引为a到b的字符串（前包后不包）；c参数指步长，即a到b的字符中，每c个字符中取一个字符</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>::])        <span class="comment"># 和 [::] 一样，从开始到末尾    123456</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:<span class="number">3</span>])        <span class="comment"># 截取索引 0，1，2             123</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:-<span class="number">1</span>])       <span class="comment"># 截取到索引为 -1 的前一位      12345</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>:-<span class="number">1</span>:<span class="number">2</span>])     <span class="comment"># 135</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>::<span class="number">2</span>])       <span class="comment"># 135</span></span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">4</span>:-<span class="number">1</span>])      <span class="comment"># 345</span></span><br><span class="line"><span class="built_in">print</span>(a[::])         <span class="comment"># 这个方法也是一种拷贝（浅拷贝）原字符串的方法   123456</span></span><br><span class="line"><span class="comment"># ！！注意，使用切片操作，如果执行的下标超出实际的长度，不会抛出异常，而是返回一个空字符，是一个 str 类型，但是长度是 0</span></span><br></pre></td></tr></table></figure><p>​    补充：字符串格式中 %f 的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%05.2f&#x27;</span> % <span class="number">1.1111</span>)   <span class="comment"># 01.11</span></span><br><span class="line"><span class="comment"># %05.2f，其中 . 前面 05 表示的是返回结果的宽度是 5，不满 5 位长度在前面补充 0，其中 . 也算一位</span></span><br><span class="line"><span class="comment"># .2 表示小数点后面的长度是 2 位，并且在第 2 位后是大于等于 5 的数，就按照四舍五入进一位</span></span><br><span class="line"><span class="comment"># 注意，前面 05，是不满足长度下前面补充 0，如果改成 1，那就是在原数字前面补充一个空字符</span></span><br></pre></td></tr></table></figure><h4 id="数字类型常用方法"><a href="#数字类型常用方法" class="headerlink" title="数字类型常用方法"></a>数字类型常用方法</h4><p>​    数字类型包括了：int，float，long，complex 和 bool，因为 bool 其实是继承了 int ，因此可以用 0 表示 False，1 表示 True，<strong>注意点：</strong>在 python 自带的命令行解释器中，对于数字的存储有一个叫 “<strong>小数据池</strong>“ 的东西，用来存储 <strong>-5 到 256</strong> 的数字以及有规律的字符串，例如 ‘s’ * 20（到 21 的话内存地址就不一样了），只有在规定的范围中，所指向的 id 内存地址才是一致的</p><p>​    python 中 int 类型，默认的进制是 10，如果要将一个 16 进制的字符转为 10 进制，则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;FF&#x27;</span>, <span class="number">16</span>))          <span class="comment"># 255</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;0b100&#x27;</span>, base=<span class="number">2</span>))   <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​    但是在 pycharm 中，似乎不会遵守 ‘数据池’ 的规则，相同值的变量，所指向的地址是一致的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line"><span class="built_in">bin</span>()              <span class="comment"># 十转二</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">2</span>))      <span class="comment"># 0b10   0b 表示二进制</span></span><br><span class="line"><span class="built_in">oct</span>()              <span class="comment"># 十转八</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">8</span>))      <span class="comment"># 0o10   0o 表示八进制   0-7 是八进制正常表示范围，之后就是逢八进一</span></span><br><span class="line"><span class="built_in">hex</span>()              <span class="comment"># 十转十六</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">16</span>))     <span class="comment"># 0x10   0x 表示十六进制 0-9 正常显示，10-15 从 a-f，逢十六进一</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用方法</span></span><br><span class="line"><span class="built_in">abs</span>()              <span class="comment"># 返回数字的绝对值</span></span><br><span class="line"><span class="built_in">max</span>()              <span class="comment"># 返回给定参数中最大的数字</span></span><br><span class="line"><span class="built_in">min</span>()              <span class="comment"># 同上，返回最小值</span></span><br><span class="line"><span class="built_in">divmod</span>(a, b)       <span class="comment"># 返回一个元组，第一个元素是 a/b 的商，第二个元素是商的余数</span></span><br><span class="line"><span class="built_in">pow</span>(a,b)           <span class="comment"># 返回 a 的 b 次方，等同于 a**b</span></span><br><span class="line"><span class="built_in">round</span>(a,b)         <span class="comment"># 返回 a 的四舍五入的结果，默认不给参数 b 则返回整数值，参数 b 控制返回的结果中要保留的小数位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算符</span></span><br><span class="line"><span class="comment"># 包括 +，-，*，/，++，--，**，//，+=，-=，*=，/=，%</span></span><br><span class="line">**                 <span class="comment"># 用于幂计算，计算次方数</span></span><br><span class="line">//                 <span class="comment"># 整除，如果包含小数，结果向下取整，如果除数和被除数有一者是 float，结果也会是 float</span></span><br><span class="line">/                  <span class="comment"># 需要注意的是，python3 中的 / 结果是包含小数点的，也就是返回 float；而在 python2 中 / 的结果是整数 int，但是如果有一方是 float，结果也会是 float</span></span><br><span class="line">%                  <span class="comment"># 表示取余数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序整数列表</span></span><br><span class="line"><span class="built_in">range</span>(a,b,c)        <span class="comment"># 生成元素 a-b 的一个列表，c 为步长数，默认为1，range 一般会在循环中使用，来控制循环次数</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)     <span class="comment"># 10 以内的奇数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提一点 range 是不能用 print 直接查看结果的，使用 type 查看类型，会得到 &lt;class &#x27;range&#x27;&gt;，需要进行转换，使用 list(range(0,10)), 才能查看结果</span></span><br></pre></td></tr></table></figure><p>​    random 库，是一个内置库，用来产生随机数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice(<span class="built_in">iter</span>)        <span class="comment"># 从可迭代对象参数中，随机取一个元素，返回结果是包含这个元素的 list</span></span><br><span class="line">random.randrange(a,b,c)    <span class="comment"># 随机从 a-b 中抽取一个数，c 为步长基数，默认是 1</span></span><br><span class="line">random.randint(a,b)        <span class="comment"># 随机生成一个 [a-b] 的整数，包含 a 也包含 b</span></span><br><span class="line">random.random()            <span class="comment"># 随机生成一个 [0-1) 的小数，包含 0 但是不包含 1</span></span><br><span class="line">random.uniform(a,b)        <span class="comment"># 随机生成 a-b 的小数，小数点后有 16 位</span></span><br><span class="line">random.sample(<span class="built_in">iter</span>,num)    <span class="comment"># 从可迭代对象中随机去取 num 个元素，返回类型是 list</span></span><br><span class="line">random.shuffle(<span class="built_in">iter</span>)       <span class="comment"># 将可迭代对象的元素顺序随机打乱</span></span><br></pre></td></tr></table></figure><p>​    补充：decimal 模块支持十进制数的浮点计算，<strong>但是不能接收浮点数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">a = Decimal(<span class="number">100.1</span>)</span><br><span class="line">b = Decimal(<span class="number">100.1</span>)</span><br><span class="line">c = Decimal(<span class="number">200.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a+b)    <span class="comment"># 200.1999999999999886313162278</span></span><br><span class="line"><span class="built_in">print</span>(a+b == c)    <span class="comment"># False</span></span><br></pre></td></tr></table></figure><p>​    补充：字符串和数字之间是允许通过计算符号进行操作的，但是只能是 + 和 *，另外使用 * 时，字符串只能和正整数有效果，之所以 + 和 * 不会出现数字计算是因为 Python 是弱类型的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;123&#x27;</span> + <span class="string">&#x27;12&#x27;</span>)    <span class="comment"># 12312</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;123&#x27;</span> * <span class="number">2</span>)         <span class="comment"># 123123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;123&#x27;</span> * (-<span class="number">2</span>))      <span class="comment"># 返回空</span></span><br></pre></td></tr></table></figure><h4 id="列表的常用方法"><a href="#列表的常用方法" class="headerlink" title="列表的常用方法"></a>列表的常用方法</h4><p>​    列表是一个可迭代对象的数据类型，可以存储包含 字符串，数字，布尔，字典 等其他的数据类型，当然也可以是自己，也就是列表嵌套列表的结构。列表也是可以通过切片操作来获取元素的，列表的元素和字符串一样，下标索引都是从 0 开始依次往后 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">append()                   <span class="comment"># 在列表的最后追加指定元素</span></span><br><span class="line">insert(index,item)         <span class="comment"># 在列表中指定的索引为 index 的位置，插入 item</span></span><br><span class="line">extend(<span class="built_in">iter</span>)               <span class="comment"># 在原列表的最后追加可迭代对象 iter 的每一个元素，效果和 &#x27;+&#x27; 一样 </span></span><br><span class="line">pop(index)                 <span class="comment"># index 默认是 -1，即默认删除列表中最后的一个元素，并将该元素返回</span></span><br><span class="line">remove(item)               <span class="comment"># 从列表中删除指定的元素</span></span><br><span class="line">clear()                    <span class="comment"># 清空当前列表的所有元素</span></span><br><span class="line">copy()                     <span class="comment"># 拷贝当前列表</span></span><br><span class="line">count(item)                <span class="comment"># 统计列表中有指定元素的总个数</span></span><br><span class="line">index(item,start,end)      <span class="comment"># 从列表中匹配找到指定元素并返回其下标索引位，可以指定开始和结束的位置来进行指定范围的匹配，注意如果列表中重复值，会返回第一次出现的索引位置</span></span><br><span class="line">sort()                     <span class="comment"># 对 原列表 排序，默认是升序，参数 reverse 设为 True 表示降序</span></span><br><span class="line">reverse()                  <span class="comment"># 翻转 原列表</span></span><br><span class="line"><span class="built_in">len</span>(<span class="built_in">list</span>)                  <span class="comment"># 返回列表长度</span></span><br></pre></td></tr></table></figure><p>​    <strong>注意：使用切片对列表进行操作时，同样如果 下标 超出 len 的长度，是不会抛出 IndexError 的，而是直接返回一个空的 []</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(li[<span class="number">10</span>:])    <span class="comment"># []</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li = [(<span class="string">&#x27;i&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;love&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;leetcode&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;coding&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">li.sort(key=<span class="keyword">lambda</span> t:(t[<span class="number">1</span>], t[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(li)    <span class="comment"># [(&#x27;coding&#x27;, 1), (&#x27;leetcode&#x27;, 1), (&#x27;i&#x27;, 2), (&#x27;love&#x27;, 2)]</span></span><br></pre></td></tr></table></figure><p>​    字典的简单排序，通常是在 sort 或 sorted 中的参数 key 使用 lambda 匿名函数来操作，一般情况下都是对一个情况去排序使用 <code>lambda x:x</code>，如果像上面的例子中，要对按照元组中的第二个元素排序的同时，还要求按照如果是第一个元素值是一致的情况下，按照元组的第二个元素排序，就可以使用 <code>lambda t:(t[1], t[0])</code>，这里的两个排序都是升序的，如果要降序排列，就在元素前加一个 - 号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]]*<span class="number">2</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;4&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b)     <span class="comment"># [[&#x27;4&#x27;, 2], [&#x27;4&#x27;, 2]]</span></span><br><span class="line"></span><br><span class="line">a = [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)     <span class="comment"># [[&#x27;1&#x27;, &#x27;3&#x27;], [&#x27;1&#x27;, &#x27;2&#x27;]]</span></span><br></pre></td></tr></table></figure><p>​    使用 * 号去赋值数组元素时，数组内部嵌套的元素其实都是相同引用，所以当对嵌套内部的元素进行修改时，会造成相互影响</p><h5 id="列表表达式"><a href="#列表表达式" class="headerlink" title="列表表达式"></a>列表表达式</h5><p>​    也叫 列表推导式，同样用来处理简单的列表类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="元组常用方法"><a href="#元组常用方法" class="headerlink" title="元组常用方法"></a>元组常用方法</h4><p>​    简单来说元组是一个可读不可改的列表，不可改也就说明元组是可哈希的，并且列表能存储的类型，元组也可以存储，元组内部的元素也可以是不可哈希的，同时元组一样可以通过索引来执行切片获取元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(item)                <span class="comment"># 统计元组中指定元素的出现次数</span></span><br><span class="line">index(item,start,end)      <span class="comment"># 获取指定元素在元组的下标位置，同样可以设置一个范围</span></span><br></pre></td></tr></table></figure><p>​    注意 <code>t = 1,(注意这里有一个,)</code> 这个 t 的类型也是一个元组</p><p>​    元素虽然是不可以变的数据结构，但是任然支持了一些操作，例如 +，可以是两个元组元素合并，产生一个新的元组。* ，可以复制元组的元素，同样会生成一个新元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">t1 = (<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(t + t1)       <span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="built_in">print</span>(t*<span class="number">2</span>)          <span class="comment"># (1, 2, 3, 1, 2, 3)</span></span><br></pre></td></tr></table></figure><h4 id="字典常用方法"><a href="#字典常用方法" class="headerlink" title="字典常用方法"></a>字典常用方法</h4><p>​    字典是以 key-value 的形式存储数据，是不可哈希的，但是 <strong>字典对于 key 的要求是必须可哈希（不可变类型）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>[key]           <span class="comment"># 返回对应 key 的 value，如果 key 不存在则抛出 KeyError 的异常</span></span><br><span class="line"><span class="built_in">dict</span>[key]=value     <span class="comment"># 通过赋值可以更改 key 对应的值，如果 key 在字典中不存在，则会在字典中加入这对 key-value</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[key]       <span class="comment"># 删除字典中的 key 和对应的 value</span></span><br><span class="line"><span class="built_in">dict</span>.clear()        <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>            <span class="comment"># 删除整个字典</span></span><br><span class="line"><span class="built_in">dict</span>.copy()         <span class="comment"># 拷贝当前字典</span></span><br><span class="line">get(key, value)     <span class="comment"># get 方法获取 key 对应的值，但是 key 如果不存在不会抛出异常，value 参数用于指定如果 key 获取不到值，就将这个参数的值作为默认值</span></span><br><span class="line">pop(key，value)     <span class="comment"># pop 方法用于删除 key，会返回 key 对应的值，如果 key 不存在会抛出异常 KeyError，设置 value 参数的值，可以作为异常时返回的值</span></span><br><span class="line"><span class="keyword">del</span> <span class="built_in">dict</span>[key]       <span class="comment"># del 的方式也可以删除一个字典的 key</span></span><br><span class="line">popitem()           <span class="comment"># 默认刷出字典中最后一对 key-value</span></span><br><span class="line">keys()              <span class="comment"># 返回一个 dict_keys 的列表，包含该字典中所有的 key</span></span><br><span class="line">values()            <span class="comment"># 返回一个 dict_values 列表，包含所有的值</span></span><br><span class="line">items()             <span class="comment"># 返回一个 dict_items 列表，其中每一个元素是 (key, value) 的元组</span></span><br><span class="line"><span class="built_in">dict</span>.update(&#123;key:value&#125;)   <span class="comment"># 将所给的字典参数的键值更新到当前的字典中，如果 key 存在就替换 value</span></span><br><span class="line"><span class="built_in">dict</span>.fromkeys(sqe,value)   <span class="comment"># 从可迭代的参数 sqe 中将每一个元素作为字典的 key，不设参数 value 时，默认字典会给每个 key 的值赋为 None，设置 value 时，则所有键的值都是这个 value</span></span><br><span class="line"><span class="built_in">dict</span>.setdefault(key,default)    <span class="comment"># 在字典中添加键值，如果字典中存在 key 则不会改动，不存在则加入这个键值</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>], [])</span><br><span class="line">v[<span class="string">&#x27;k1&#x27;</span>].append(<span class="number">666</span>)</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="comment"># &#123;&#x27;k1&#x27;: [666], &#x27;k2&#x27;: [666]&#125;</span></span><br></pre></td></tr></table></figure><p>​    <code>fromkeys</code> 如果给出第二个参数，则会将当前这个字典的所有 value 都指向这个参数，所以当使用一个可变对象，比如使用列表作为第二参数时，如果要用 key 在列表的添加一个值，会导致当前字典所有 value 的字典中都会添加这个值</p><h5 id="字典表达式"><a href="#字典表达式" class="headerlink" title="字典表达式"></a>字典表达式</h5><p>​    同理于 列表表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items()&#125;)</span><br><span class="line"><span class="comment"># &#123;1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h4><p>​    集合是一个无序且数据不能重复的序列，所以可以用来进行去重操作，与字典类似但是没有 value，集合中存储的都是 key，且 key 一样都要是可哈希的</p><p>​    另外，集合虽然看着和数组也很像，但并不支持和数组一样通过下标索引来获取元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">add()               <span class="comment"># 添加一个元素，如果元素存在就不添加，参数不能是 list，dict，tuple</span></span><br><span class="line">update()            <span class="comment"># 可以添加多个元素，参数类型可以是 list，dict，tuple，字典的就直接将 key 加入</span></span><br><span class="line">remove(ele)         <span class="comment"># 移除集合中的指定的元素，如果元素不存会抛出 KeyError 异常</span></span><br><span class="line">discard(ele)        <span class="comment"># 同上，但是不会抛出异常</span></span><br><span class="line">pop()               <span class="comment"># 如果集合是纯数字类型元素，那么 pop 方法会将集合变为有序，然后删除第一个元素；如果集合是有字符串类型的元素，pop 方法会将其无序化，然后随机删除一个元素</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)            <span class="comment"># &#123;1, 2, &#x27;a&#x27;, 6, &#x27;c&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a.pop())      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;asdfg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)            <span class="comment"># &#123;&#x27;a&#x27;, &#x27;d&#x27;, &#x27;f&#x27;, &#x27;s&#x27;, &#x27;g&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(b.pop())      <span class="comment"># a</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)            <span class="comment"># &#123;1, 2, 4, 5, 6, 8, 9&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a.pop())      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> <span class="built_in">set</span>            <span class="comment"># 判断元素 x 是否在集合 set 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合的运算</span></span><br><span class="line">|                   <span class="comment"># 并集（例: print(pythons.union(linuxs))）</span></span><br><span class="line">&amp;                   <span class="comment"># 交集（例: print(pythons.intersection(linuxs))）</span></span><br><span class="line">-                   <span class="comment"># 差集（例: print(pythons.difference(linuxs))）</span></span><br><span class="line">^                   <span class="comment"># 对称差集（例: print(pythons.symmetric_difference(linuxs))）</span></span><br><span class="line">a == b              <span class="comment"># 判断集合 a 和 b 是否一致</span></span><br><span class="line">a &gt; b               <span class="comment"># 判断集合 a 是否包含集合 b 的所有元素，同理还有符号 &#x27;&lt;&#x27;</span></span><br><span class="line">a &gt;= b              <span class="comment"># 判断集合 a 是否包含所有集合 b 的元素或和集合 b 一致，同理还有符号 &#x27;&lt;=&#x27;</span></span><br><span class="line">a.issuperset(b)     <span class="comment"># 判断集合 a 是否是集合 b 的父集，即包含集合 b 的元素</span></span><br><span class="line">a.issuberset(b)     <span class="comment"># 同上，判断 a 是否是 b 的子集</span></span><br></pre></td></tr></table></figure><h5 id="集合表达式"><a href="#集合表达式" class="headerlink" title="集合表达式"></a>集合表达式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,-<span class="number">5</span>,<span class="number">6</span>,-<span class="number">7</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># print(&#123;i**2 for i in s&#125;)</span></span><br><span class="line"><span class="comment"># &#123;1, 4, 36, 49, 25&#125;     # 集合自带去重</span></span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if…else-判断"><a href="#if…else-判断" class="headerlink" title="if…else 判断"></a>if…else 判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:           <span class="comment"># if 判断 condition 为 T 执行 ①</span></span><br><span class="line">①……</span><br><span class="line"><span class="keyword">elif</span> condition:         <span class="comment"># if ① 判断为 F 进入 elif 判断 condition 为 T 执行 ②</span></span><br><span class="line">②……</span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 上面判断都不通过执行 else 的 ③</span></span><br><span class="line">③……</span><br><span class="line"></span><br><span class="line">a = <span class="number">3000</span></span><br><span class="line">b = <span class="number">300</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&gt;b&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> a &lt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&lt;b&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a!=b or a=b&#x27;</span>)</span><br><span class="line"><span class="comment"># a&gt;b</span></span><br></pre></td></tr></table></figure><p>​    对于简单的 if 条件判断语句，比如比较两个大小返回其中一个，可以使用 <strong>三元运算符</strong>，但是也要适当使用，如果判断逻辑相对复杂，使用这样的方式，会对代码的可读性有所降低</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;lg&quot;</span> <span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">3</span> <span class="keyword">else</span> <span class="string">&quot;gl&quot;</span>)   <span class="comment"># lg</span></span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>​    语法： <code>for i in iter:</code> ，从可迭代对象中每一次遍历时，依次向后出去元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​    补充：循环判断中，使用 if 语句判断时，多个条件判断可能会使用 if…if…else，也可能是使用 if…elif…else。两种判断方式执行流程是不同的，if…if…else 的流程是，第一个 if 判断不满足条件，会继续判断下一个 if，最后都不满足再执行 else；if…elif…else 的流程是，当第一个 if 判断不满足，那么 elif 不会被触发，直接走到 else</p><p>​    if…elif… 的判断更像是一个并列的判断语句，所代表的是一个判断的两种条件，而 if…if… 就是多种不同条件的判断</p><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>​    语法：   <code>while condition:</code> ，根据条件 condition 判断是否为 True，为 True 则执行内部代码块。但是 <code>while True:</code> 代表的是无限循环，就是死循环，所以循环体内部需要去修改 condition 来退出循环</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">condition = <span class="literal">True</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">condition = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>​     while 的语法中是有判断的， 所以也可以使用 else </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">11</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;over&#x27;</span>)    <span class="comment"># else 的内部代码只有在循环条件不满足并且循环没有被 break 退出才会执行</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><h4 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h4><p>​    上面里的例子使用了 break 来退出循环语句，来执行后续的代码；还有另一种就是 continue ，与 break 不同的是， continue 的作用是退出当前的循环，进入下一次的循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i)                   <span class="comment"># 0 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)                   <span class="comment"># 0 1 2 3 5，当 i = 4 时，continue 跳到下一次循环开始，i = 5</span></span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>​    有两种方式，一种使用 <code>open()</code> 打开文件进行处理，但是最后需要手动将文件关闭，避免一直占用系统资源；另一种常用的方式是使用 <code>with</code> 创建上下文管理器，这种方式在处理完成后，无需手动去关闭，当文件没有被使用的情况下，上下文管理器会自动关闭掉打开的文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;11.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)      </span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:       <span class="comment"># 如果只是对文件只读操作，需要加上异常捕获</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;文件不存在&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    f.close()                   <span class="comment"># 使用 open 操作文件完成后，需要调用 close 去关闭，避免占用资源</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;12.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:   <span class="comment"># with open 打开的文件需要用 as，来赋予一个变量，作为文件句柄对象</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="with-上下文管理器"><a href="#with-上下文管理器" class="headerlink" title="with 上下文管理器"></a>with 上下文管理器</h4><p>​    <strong>使用 with 操作文件，会自动去触发 with 处理对象的 <code>__enter__</code> 和 <code>__exit__</code> 两个方法，当使用 with 创建上下文管理器后，会进入 <code>__enter__</code>  方法中，之后打开文件和一系列的读写操作才会去执行，如果使用了 as 则会将 <code>__enter__</code> 方法后的结果给到 as 指向的变量，当最后执行完毕后，会进入 <code>__exit__</code> 方法中将文件关闭</strong></p><p>​    <strong><code>__exit__</code> 方法实际有三个参数，如果 with 上下文管理器中的代码执行没有错误，那么 <code>__exit__</code> 的参数值会是三个 None，如果执行出现错误，<code>__exit__</code> 的参数是 exc_type，exc_value，exc_traceback 各自接收异常信息。对于 <code>__exit__</code> 方法，如果返回的是 False，会将收到的异常抛出到上下文管理器之外，通过外部的异常捕获来处理，如果是返回 True 则表示不向外抛出异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;enter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(exc_type)</span><br><span class="line">        <span class="built_in">print</span>(exc_val)</span><br><span class="line">        <span class="built_in">print</span>(exc_tb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample</span>():</span><br><span class="line">    <span class="keyword">return</span> Sample()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sample() <span class="keyword">as</span> sample:</span><br><span class="line">    <span class="built_in">print</span>(sample)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enter</span></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="comment"># exit</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># None </span></span><br></pre></td></tr></table></figure><h4 id="内容读取"><a href="#内容读取" class="headerlink" title="内容读取"></a>内容读取</h4><p>打开文件时，需要给予读写模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;r&#x27;:  默认的模式，表示读取文件，如果文件不存在会抛出异常</span><br><span class="line">&#x27;w&#x27;:  表示对文件进行写入，如果文件不存在则会创建文件，如果文件存在则会进行覆盖</span><br><span class="line">&#x27;a&#x27;:  同上，但是不同是的，这种模式表示追加写入，所以如果文件存在，内容是追加写入，而不是覆盖</span><br><span class="line">&#x27;x&#x27;:  创建文件，如果文件存在则会抛出文件存在的异常 FileExistsError</span><br><span class="line"></span><br><span class="line"># 下面这两个用于和上面的配合</span><br><span class="line">&#x27;b&#x27;: &#x27;rb&#x27;,&#x27;wb&#x27;,&#x27;ab&#x27;，在原本含义功能不变的原则下，&#x27;b&#x27;用来表示对二进制的文件进行处理</span><br><span class="line">&#x27;+&#x27;: 配合这个符号，则表示同时拥有读与写，例如 &#x27;r+&#x27;,&#x27;w+&#x27;,&#x27;a+&#x27;,&#x27;rb+&#x27;,&#x27;wb+&#x27;,&#x27;ab+&#x27;</span><br></pre></td></tr></table></figure><p>​    同时还有一个注意点就是，<strong>读的模式下，文件指针全部在文件的开头，追加的模式下，文件的指针会在文本的末尾</strong></p><p>​    补充：</p><p>​    对文件的操作完成后，要关闭文件的目的，是为了将资源回收</p><p>​    首先，对于 Python 的程序而言，默认会去申请一个空间，当操作文件时，会将文件对象变量存在栈空间，实际的文件对象是存在堆空间的</p><p>​    但是，python 程序内存空间的对象，并不能直接对硬盘上的文件进行操作。所以，这中间实际上还有一个部分，就是操作系统的内存，当 python 的文件对象调用 <code>write()</code> 和 <code>read()</code> 时，操作系统会自己划分一块空间，用来执行这个操作</p><p>​    操作系统划分的内存空间，会将硬盘的文件解码出来放入内存，再由 <code>read</code> 读取返回给 python 程序，写入的流程则是方向相反的方式</p><p>​    所以，当 python 程序完成文件操作后，如果不关闭文件，那么操作系统中的那部分内存就不能被回收，导致内存资源的浪费</p><p><img src="https://img2020.cnblogs.com/blog/1881426/202005/1881426-20200512123218567-334434507.png" alt="img"> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.read(size)           <span class="comment"># 读取指定 size 字节长度的内容</span></span><br><span class="line">f.readline()           <span class="comment"># 只读取一行的内容，最后包括换行符 \n</span></span><br><span class="line">f.readlines()          <span class="comment"># 读取所有的内容，通过换行符将每一行作为一个元素保存在列表返回</span></span><br><span class="line">f.seek(offset, whence)     <span class="comment"># seek 方法是通过游标来读取，第一个是参数是偏移量，第二个参数是偏移位置，whence 默认是 0，即表示从文件开头开始进行 offset 的偏移量</span></span><br></pre></td></tr></table></figure><h4 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.write(p_str)                  <span class="comment"># 将字符串写入到文件中，会返回写入的字符长度</span></span><br><span class="line">f.write(sequence_of_strings)    <span class="comment"># 将一个字符串的序列写入文件，等同于对每个字符串使用 write 方法写入</span></span><br></pre></td></tr></table></figure><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>​    上面的文件处理就使用了异常捕获来对抛出的异常进行处理，使得程序可以正常执行，而不是被异常阻断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整的异常捕获逻辑，通常使用 try... except... 就能够满足异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 可能出现错误的代码块</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:     <span class="comment"># 万能的异常捕获处理，只要抛出异常都会被其捕获</span></span><br><span class="line"><span class="comment"># except 可以根据可能出现的错误类型进行添加，当出现 try 中的代码块出现异常则执行对应错误类型的except的代码块</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># else 的代码只有在 try 中代码执行没有问题的情况下执行，其作用就是防止一些意想不到的问题，并且 except 又没有捕获到</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># finally 的语句是指无论 try 是否出现错误都会执行的代码块</span></span><br></pre></td></tr></table></figure><h4 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h4><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>NameError</td><td>尝试访问一个没有声明的变量等</td></tr><tr><td>SyntaxError</td><td>语法出现错误，可能就是单词错误或是符号问题</td></tr><tr><td>IndexError</td><td>下标索引超出序列的范围，循环遍历时或是按照下标取元素会出现这个问题</td></tr><tr><td>KeyError</td><td>尝试请求一个不存在于字典的主键</td></tr><tr><td>AttributeError</td><td>尝试访问一个未知的对象属性</td></tr><tr><td>ValueError</td><td>传递的参数不正确，传递过多或过少的参数等</td></tr><tr><td>TypeError</td><td>传递的参数类型不被支持进行操作等</td></tr><tr><td>ZeroDivisionError</td><td>当除数为 0 的错误</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>​    <strong>Python 中的异常全部的基类都是继承于 BaseException</strong>，但是根据不同类型还是分成了几类包括：</p><p>​    系统相关的（SystemExit）</p><p>​    按键的输入异常（KeyboardInterrupt）</p><p>​    生成器的（GeneratorExit）</p><p>​    以及最常见的异常（Exception）</p><p>​    大多数程序的异常都是继承于 Exception 的，例如 NameError，OSError，StopIteration 等等很多</p><h4 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h4><p>​    上面使用过 “万能的异常处理”，即 <code>except Exception as e</code> ，但是这样的处理如果被记录到日志中，却不好排查具体的错误原因，所以通常情况下还是去使用规定的异常名去独自处理各自异常捕获</p><p>​    但是有时候程序可能并不会抛出所感知到的异常，因此可以   <strong>手动地抛出异常去进行捕获，即使用 <code>raise</code> 语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;错啦错啦&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)      <span class="comment"># 错啦错啦</span></span><br></pre></td></tr></table></figure><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>​    通过上面表里列出的异常和描述，不难看出其实这些异常可能对应的情况有多种，如果想要精确的捕获一种情况的异常错误，可以使用自定义异常，<strong>自定义异常的类需要继承 Exception</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,msg</span>):</span><br><span class="line">self.msg = msg</span><br><span class="line"><span class="comment"># def __str__(self):   可以不用写这个方法，因为那个 BaseException 父类里面已经实现了</span></span><br><span class="line"><span class="comment">#     return self.msg</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">raise</span> myException(<span class="string">&#x27;错啦&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> myException <span class="keyword">as</span> e:   <span class="comment"># 直接使用 Exception 也可以捕获自定义的异常</span></span><br><span class="line"><span class="built_in">print</span>(e)       <span class="comment"># 错啦</span></span><br></pre></td></tr></table></figure><p>​    <strong>注意点：</strong>在编写自定义的异常时，最好选择继承于 Exception 而不是最终基类的 BaseException</p><p>​    因为捕获父类异常时，继承其的子类的异常也都会被其捕获，所以如果要去捕获 BaseException 的异常，则 KeyboardInterrupt 中的异常同样会被其捕获，那么再去按下 ‘Ctrl + C’ 出来的异常就被自定义的给捕获了，再去使用 ‘Ctrl + C’ 也就没有效果了</p><h4 id="not-and-or"><a href="#not-and-or" class="headerlink" title="not and or"></a>not and or</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">or</span> <span class="number">3</span>)              <span class="comment"># 1    或</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>)             <span class="comment"># 3    与</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">4</span>)   <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span>)       <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="literal">False</span>)          <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="literal">True</span>)           <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>​    对于 <code>x or y</code>，如果 x 为 真，就返回 x ；否则返回 y</p><p>​    对于 <code>x and y</code>，如果 x 为 假，就返回 x ；如果 x 为 真，y 为 假，返回 y；如果 x 为 真，y 为 真，返回 y</p><p>​    另外，包含了 and 和 or 的逻辑中，<strong>and 优先级高于 or</strong></p><p>​    除了之外，not 表示非，not 1 表示为 False，not 0 表示为 True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>)       <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">1</span>)       <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h4 id="python-之禅"><a href="#python-之禅" class="headerlink" title="python 之禅"></a>python 之禅</h4><p>​    直接 <code>import this</code> 就能看到经典的 python 之禅</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#x27;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#x27;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#x27;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#x27;s do more of those!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python之禅 by Tim Peters</span><br><span class="line"> </span><br><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标）</span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span><br><span class="line">可读性很重要（优美的代码是可读的）</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span><br><span class="line">不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span><br><span class="line">当存在多种可能，不要尝试去猜测</span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span><br><span class="line">虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础整理</title>
      <link href="/1520610863/"/>
      <url>/1520610863/</url>
      
        <content type="html"><![CDATA[<h2 id="编程知识简单整理"><a href="#编程知识简单整理" class="headerlink" title="编程知识简单整理"></a>编程知识简单整理</h2><h3 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h3><p>​    这个世界上有非常多的编程语言，他们大部分都可以胜任一个或多个领域的代码编程，但是各自之间的编程方式或执行方式都有些不同。从编程角度上分为三种：机器语言，汇编语言，高级语言</p><p>​    <strong>机器语言：</strong>简单来说就是通过使用计算机底层的二进制码，也就是通过 0 和 1 编写机器指令来执行程序。通常来说，这个要求是非常大的，即不好记忆，也不方便对其进行阅读，但是执行非常快</p><p>​    <strong>汇编语言：</strong>类似与机器语言，但是对其进行了优化，通过将英文缩写来代替代码指令，称为 <strong>“助记符”</strong>，但是依旧通过编写指令来执行</p><p>​    <strong>高级语言：</strong>进一步在汇编的基础上，将相关指令合成单条指令，形成了对指令的封装，让代码编写更简单，偏向人类思维方式，也更方便代码阅读</p><p>​    从执行上来说：机器语言使用二进制码，因此可以被CPU直接解读执行；<strong>汇编语言和高级语言</strong> 的编写会产生一个 <strong>源程序</strong> 文件，<strong>这个文件不能被直接执行</strong>。对于汇编语言，需要汇编程序将源程序进行翻译并生成目标程序来执行。对于高级语言，又分成 <strong>解释型</strong> 或 <strong>编译型</strong> 两种程序进行翻译执行。需要知道的是，机器语言和汇编语言因为编写复杂，难以记忆和阅读，也被称为 “低级语言”</p><h3 id="解释型和编译型"><a href="#解释型和编译型" class="headerlink" title="解释型和编译型"></a>解释型和编译型</h3><p>​    两种类型的执行方式，其实都是需要对代码进行一个机器码的翻译过程，但是两者方式并不同</p><p>​    <strong>编译型</strong>（c，c++ 等）</p><p>​    优点：编译器一般会有预编译的过程对代码进行优化，完成后运行不需要再次编译，所以编译型语言的程序执行效率高，编译后的文件可以脱离开发环境独立运行。需要知道的是，编译器的目的实现代码翻译机器码，并且会有两个步骤分别是编译和链接，链接是为了将模块的机器码和依赖库串连起来</p><p>​    缺点：编译之后，如果要修改代码，那么就需要重新在编译一次。并且编译会根据当前操作系统环境生成机器码，不同的操作系统间移植会有问题，跨平台性相对较差</p><p>​    <strong>解释型</strong>（python，javascript 等）</p><p>​    优点：有良好的平台兼容性，在任何环境中都可以运行，但是前提需要安装解释器 (虚拟机)。因为不是整体编译后才能执行，所以相对更灵活，代码支持动态修改</p><p>​    缺点：由于是边解释编译，边执行，因此执行效率比较低。而且因为没有整体编译后的执行文件，所以执行上就必须依赖于解释器</p><h3 id="动态和静态"><a href="#动态和静态" class="headerlink" title="动态和静态"></a>动态和静态</h3><p>​    通常语言的分类中也会提到动态语言和静态语言，两者主要的区别是：<strong>在运行过程中，是否能够改变代码结构，变量是否需要声明数据类型。</strong></p><p>​    <strong>动态语言</strong> 可以再运行时进行函数，对象等引用，或是删除已有的函数等，能够改变自身结构；同时，动态语言在运行时就会确定数据类型，<strong>变量的类型会按照被赋的值的类型判断</strong>，例如：Python，JavaScript 等</p><p>​    <strong>静态语言</strong> 即不支持结构上的修改，同时变量使用，需要提前声明数据类型</p><p>​    通常情况下解释型语言也是动态类型语言，编译型语言也是静态类型语言</p><h3 id="强类型和弱类型"><a href="#强类型和弱类型" class="headerlink" title="强类型和弱类型"></a>强类型和弱类型</h3><p>​    <strong>强类型</strong> 语言表示一旦变量被制定了数据类型，除非进行了强制转换，否则就一直是原来的类型，并且 <strong>强类型中整型不能和字符串共同处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#3&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +=: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><p>​    <strong>弱类型</strong> 就基本忽略了数据类型，一个变量可以被赋予不同的数据类型的值，并且 <strong>支持整型与字符串的处理</strong>，规则上会将整型强制转换为字符串来操作，得到结果将属于字符串类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a += <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><img src="https://pic2.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg" alt="img"></p><h2 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h2><p>​    常见的有：ASCII，GBK，Unicode，UTF-8，UTF-16 等，需要知道 1 字节（B，byte）= 8 位（bit），二进制表示位就是 0000000，往上是 1KB = 1024 B，1MB = 1024 KB 等等</p><p>​    ASCII：一个英文字母使用一个字节，包含大小写英文字母，0-9， 常规的标点符号和扩展的符号等，范围是 0 - 255</p><p>​    GBK：中国制定的一套自己的编码规则，使用 2 个字节（16位）表示一个中文汉字，对于英文依旧使用 1个字节 = 1字母，还有一套中文编码 GB2312，表示国家标准第 2312 条</p><p>​    Unicode：也叫万国码，包含了全世界所有的字符，但是 unicode 只是一个理论上的编码方式，它有不同的编码实现，32 位的 4 个字节</p><p>​    UTF-8：是可变长度的 unicode ，对于英文依旧使用 1个字节（8位）存储，欧洲其他文字使用 2个字节（16位），中文使用 3个字节（24位）</p><p>​    UTF-16：也是 unicode 的方式之一，但是全部将所有字符全部统一使用 16位 进行存储</p><p>​    另外，python 的发布要比 unicode 的要早，所以这也就是为什么在 python2 的版本中使用的是 ASCII 的编码方式</p><h2 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h2><p>​    python 中数据类型有 str，int，list，tuple，dict，bool，set</p><p>​    其中分为 <strong>可变对象，不可哈希</strong> 的是：<strong>list，dict，set</strong>；分为 <strong>不可变对象，可哈希</strong> 的是：<strong>str，int，tuple</strong></p><h3 id="可哈希，不可变"><a href="#可哈希，不可变" class="headerlink" title="可哈希，不可变"></a>可哈希，不可变</h3><p>​    什么是不可变，就是说不同的值需要使用不同的内存地址，例如对 python 的 str 进行操作，得到结果是使用另一个内存地址，而不是原来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))    <span class="comment"># 2673291651144</span></span><br><span class="line"></span><br><span class="line">a += <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))    <span class="comment"># 2673311883696</span></span><br></pre></td></tr></table></figure><p>​    一个对象可哈希，那么在生存期内必须是不可变的，且这个对象内部需要一个哈希函数，和一个用来比较的方法，用来比较哈希的值。也就是说如果一个对象是可哈希的，它的内部需要有的魔法方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) __eq__() 或者 __cmp__()</span><br><span class="line">2) __hash__()</span><br></pre></td></tr></table></figure><p>​    这里有一个 <strong>注意点</strong>：</p><p>​    python 中一切皆为对象，并且所有的类都有一个共同的继承父类 object，但是 object 类中是有提到的可哈希需要的两个方法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>))</span><br><span class="line">[<span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>,  <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br></pre></td></tr></table></figure><p>​    所以，当使用 dir() 查看 list 或其他可变对象时，也能看到 <code>__eq__</code> 和 <code>__hash__</code> ；并且如果自定义一个类，当调用 hash() 方法时，也可以得到一个 hash值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, color</span>):</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">color</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, self.color)</span><br><span class="line"></span><br><span class="line">car = Car(<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hash</span>(car))     <span class="comment"># 143713058673</span></span><br></pre></td></tr></table></figure><p>​    <strong>补充：Python 的自省</strong></p><p>​    所谓自省，指的是程序运行过程中可以知道对象的类型或者是对象内部结构，Python 中天然支持这个操作，例如上面的 dir 方法，可以快速知道对象内部所有的方法，使用 type 方法也可以知道一个对象的类型</p><h3 id="可变，不可哈希"><a href="#可变，不可哈希" class="headerlink" title="可变，不可哈希"></a>可变，不可哈希</h3><p>​    上面说到内存地址不一致，表明这个对象是不可变的，反之如果一个对象操作后 id 不变，那就是一个可变对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))     <span class="comment"># 2241896735240</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))     <span class="comment"># 2241896735240</span></span><br><span class="line"><span class="built_in">print</span>(a)         <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>​    由此可知，为什么 python 中的字段不能使用 可变数据类型，因为字典的查找会通过 key 找对应的值，如果 key 使用可变类型，就会导致不同的值最后依赖的是相同的 key，这显然是不对的</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2983461467/"/>
      <url>/2983461467/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello~ world : )"></a>Hello~ world : )</h3><p>​    终于，我的博客问世了，可喜可贺。为什么要弄博客呢，最重要的目的其实就是为了做技术积累，和一些生活记录吧，以往总是在学习之后，只是使用 word 或 思维导图去做一些记录，但是怎么看怎么丑，而且查看起来也不是特别的方便，于是就开始了一段博客搭建之旅。</p><p>​    这一说，还有些惭愧了，自己也不是技术能人，只是会些皮毛的小角色。在搭建博客的过程中，一度一拖再拖，仅仅就是弄了框就什么也没弄了，简直 “鸽子王”。好在，这些天终于弄好了，虽然整体上来说弄得有点胡里花哨的，加载也挺慢，图片也不美，但，但是也算是有个完整的了嘛。那接下来的就是，将之前的文本记录整理整理，陆续加入了这个博客中了。</p><p>​    最后，祝愿一切都好！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一行代码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello-world :)&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://wei-foun.github.io/img/h-w.gif" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
