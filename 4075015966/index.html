<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>GO 基础 | </title><meta name="keywords" content="golang"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础整理初始化和依赖管理创建 go 项目目录后，进入目录用go mod init 命令初始化项目生成一个 go.mod 文件 1234567891011121314151617$ go mod init mygin$ cat go.modmodule mygingo 1.20require (  github.com&#x2F;gin-gonic&#x2F;gin v1.9.1  k8s.io&#x2F;apimachiner">
<meta property="og:type" content="article">
<meta property="og:title" content="GO 基础">
<meta property="og:url" content="http://example.com/4075015966/index.html">
<meta property="og:site_name">
<meta property="og:description" content="基础整理初始化和依赖管理创建 go 项目目录后，进入目录用go mod init 命令初始化项目生成一个 go.mod 文件 1234567891011121314151617$ go mod init mygin$ cat go.modmodule mygingo 1.20require (  github.com&#x2F;gin-gonic&#x2F;gin v1.9.1  k8s.io&#x2F;apimachiner">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover45.jpg">
<meta property="article:published_time" content="2025-07-04T16:26:58.000Z">
<meta property="article:modified_time" content="2025-07-12T07:00:59.475Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover45.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/4075015966/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GO 基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-12 15:00:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover45.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GO 基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-04T16:26:58.000Z" title="发表于 2025-07-05 00:26:58">2025-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-12T07:00:59.475Z" title="更新于 2025-07-12 15:00:59">2025-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go-%E8%AF%AD%E6%B3%95/">go 语法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GO 基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="基础整理"><a href="#基础整理" class="headerlink" title="基础整理"></a>基础整理</h3><h4 id="初始化和依赖管理"><a href="#初始化和依赖管理" class="headerlink" title="初始化和依赖管理"></a>初始化和依赖管理</h4><p>创建 go 项目目录后，进入目录用<code>go mod init</code> 命令初始化项目生成一个 go.mod 文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init mygin</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> go.mod</span><br><span class="line">module mygin</span><br><span class="line"></span><br><span class="line">go 1.20</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/gin-gonic/gin v1.9.1</span><br><span class="line">  k8s.io/apimachinery v0.25.2</span><br><span class="line">  k8s.io/client-go v0.25.2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  github.com/PuerkitoBio/purell v1.1.1 // indirect</span><br><span class="line">  ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当项目中要使用到第三方库，可以用 <code>go get</code> 去下载安装，然后就可以在文件中导入。同时目录下的 go.mod 和 go.sum 文件会有对应的修改</p>
<ul>
<li><code>go.mod</code> 文件列出了项目的模块名和它直接依赖的模块及其版本</li>
<li><code>go.sum</code> 文件包含了所有依赖包的校验和，用于确保下载的包没有被篡改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin</span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="comment"># mytest.go</span></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对于 go.mod 中记录的三方包，go 也提供了对应的命令 <code>go mod tidy</code>来进行管理，例如清理未使用依赖，解决有冲突的依赖，更新依赖版本等</p>
<p>如果要清除一个依赖，可以使用 <code>go clean -i 依赖包地址</code></p>
<p>当从 github 上 clone 一个 golang 项目，且包含了 go.mod 文件，可以使用 <code>go mod download</code> 下载依赖包到本地缓存</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go 中变量声明的方式有多种</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">name = <span class="string">&quot;fw&quot;</span></span><br><span class="line"><span class="comment">// var name string = &quot;fw&quot;</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age  <span class="type">uint8</span>     </span><br><span class="line">  <span class="comment">// 无符号的 int8类型，即 2^8，值范围是 0 ~ 255，int8 -128 ~ 127</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;fw&quot;</span></span><br><span class="line"><span class="comment">// go 会给根据声明的值自动判断 name 变量类型</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line">name := <span class="string">&quot;fw&quot;</span></span><br><span class="line"><span class="comment">// := 短赋值方式只能在函数中使用，用来定义局部变量</span></span><br><span class="line"></span><br><span class="line">—————————————————————————————————————————————————————————————————</span><br><span class="line">name := <span class="built_in">new</span>(<span class="type">string</span>)</span><br><span class="line">*name = <span class="string">&quot;stark&quot;</span></span><br><span class="line"><span class="comment">// new 函数声明一个 T 类型的匿名变量，返回的是这个 T 类型变量的指针 *T</span></span><br></pre></td></tr></table></figure>
<p>当使用 var 关键字声明变量后，go 会自动给变量赋值，而这个值被称为零值，不同的数据类型，零值是不同的</p>
<h5 id="基本数据类型和零值"><a href="#基本数据类型和零值" class="headerlink" title="基本数据类型和零值"></a>基本数据类型和零值</h5><ul>
<li>数值类型，就是 0，go 中数值类型有很多种，表示不同的取值范围，根据使用需求使用不同类型可以控制内存占用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr   <span class="comment"># 无符号数值类型取值范围从 0 开始</span></span><br><span class="line">float32 float64</span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure>
<p>这里 int 类型，会根据当前操作系统位数来设定，例如是 64 的机器，var num int，这个 num 的的范围就是 -9223372036854775808 到 9223372036854775807</p>
<ul>
<li>布尔类型，就是 false</li>
<li>字符串类型，就是空字符</li>
<li><strong>接口或应用类型（slice，指针，map，chan，函数），就是 nil</strong></li>
<li>数组或结构体等聚合类型，每个元素或字段是对应类型的零值</li>
</ul>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>Go 中常量使用 const 关键字定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<h5 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h5><p>自定义数据类型可以基于现有的基本数据类型或复合数据类型，为其赋予一个新的类型名称，并可以为其添加方法，从而实现类型的功能扩展</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 类型名称 底层类型</span></span><br><span class="line"><span class="keyword">type</span> Name <span class="type">string</span>              <span class="comment">// 定义底层类型是 string 的数据类型 Name</span></span><br><span class="line"><span class="keyword">const</span> myName Name = <span class="string">&quot;stark&quot;</span>   <span class="comment">// 声明 Name 类型的 myName 常量并赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Name)</span></span> SayName() <span class="type">string</span> &#123;     </span><br><span class="line">  <span class="comment">// 定义 Name 类型的 SayName 方法，接收 Name 类型变量，并返回一个 string 类型的值</span></span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;what&#x27;s your name man!, my name is %s&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name.SayName()</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go 中字符串是 utf-8 存储的，使用 len 函数获取长度时，其实是字符串的 byte 个数，所以如果是中文字符串，直接使用下标截取的话会有误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的 string 操作</span></span><br><span class="line">newString = strings.Replace(<span class="string">&quot;go go&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;hello&quot;</span>, n=<span class="number">-1</span>)  <span class="comment">// 字符串替换，n 为 -1 表示替换所有匹配，1 就表示替换一个匹配</span></span><br><span class="line">stringList := strings.Split(<span class="string">&quot;1 2 3&quot;</span>, <span class="string">&quot; &quot;</span>)    <span class="comment">// [1 2 3]</span></span><br><span class="line">s := strings.TrimSpace(<span class="string">&quot;  123  &quot;</span>)            <span class="comment">// 清除左右空白字符</span></span><br><span class="line">s1 := strings.Trim(<span class="string">&quot; ! 123  &quot;</span>, <span class="string">&quot;! &quot;</span>)         <span class="comment">// 去除左右满足的指定移除字符</span></span><br><span class="line">strings.HasPrefix(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;http&quot;</span>)         <span class="comment">// 是否满足前缀</span></span><br><span class="line">strings.HasSuffix(<span class="string">&quot;filename.go&quot;</span>, <span class="string">&quot;go&quot;</span>)       <span class="comment">// 是否满足后缀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串本质是 byte 切片，go 中字符的存储使用 byte 类型（0-255），go 中 byte 属于整数数据类型</span></span><br><span class="line">s := <span class="string">&quot;123&quot;</span></span><br><span class="line">bs := []<span class="type">byte</span>(s)         <span class="comment">// []byte() 将接收的字符串分割成数组，每个元素字符被转为 ascii 码</span></span><br><span class="line">fmt.Println(bs)         <span class="comment">// [49 50 51]</span></span><br><span class="line">fmt.Print(<span class="type">string</span>(bs))   <span class="comment">// 123%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类型转字符串，Sprintf 格式化字符串，或者用 strconv 模块的方法</span></span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, <span class="number">12</span>)</span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;%f&quot;</span>, <span class="number">12.12</span>)</span><br><span class="line"><span class="comment">// Printf 和 Sprintf 在是使用上是一致的，但是 Sprintf 会有返回格式化的字符串，Printf 只是标准输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转其他类型，可以用 strconv 模块对应 Parse 方法</span></span><br><span class="line">strconv.Itoa(<span class="number">12</span>)                   <span class="comment">// Itoa 只接收 int 类型</span></span><br><span class="line">num := strconv.FormatInt(<span class="number">26</span>, <span class="number">2</span>)    <span class="comment">// FormatInt 只接受 int64 类型，且需要传转换进制数</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T, %v&quot;</span>, num, num)     <span class="comment">// string, 11010</span></span><br><span class="line"></span><br><span class="line">b, err := strconv.ParseBool(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">s, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)      <span class="comment">// strconv 包转 int 类型</span></span><br><span class="line">bytes := []<span class="type">byte</span>(<span class="string">&quot;hello&quot;</span>)           <span class="comment">// 字符串转字节数组，每个元素都是 ASCII 的编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换失败</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int64</span> = <span class="number">11</span></span><br><span class="line">n1, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)    <span class="comment">// 将 s 转为 10 进制的 int64 类型</span></span><br><span class="line">fmt.Println(n1, err)</span><br><span class="line"><span class="comment">// 如果 string 转类型失败，那变量的值会是类型的默认值</span></span><br><span class="line"><span class="comment">// 0  strconv.ParseInt: parsing &quot;hello&quot;: invalid syntax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是要操作一个中文的字符串，例如截取</span></span><br><span class="line"><span class="comment">// 需要转为 []rune 类型，rune 代表的 unicode 码点是固定的 4 个字节长度(等同于 int32)</span></span><br><span class="line">s := <span class="string">&quot;世界和平&quot;</span></span><br><span class="line">s1 := s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(s1 == <span class="string">&quot;世界&quot;</span>)     <span class="comment">// false</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))          <span class="comment">// 12</span></span><br><span class="line">s2 := s[:<span class="number">6</span>]</span><br><span class="line">fmt.Println(<span class="type">string</span>(s2))      <span class="comment">// 世界</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;世界和平&quot;</span></span><br><span class="line">s1 := []<span class="type">rune</span>(s)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1))         <span class="comment">// 4</span></span><br><span class="line">fmt.Println(<span class="type">string</span>(s1[:<span class="number">2</span>]))  <span class="comment">// 世界</span></span><br></pre></td></tr></table></figure>
<p>字符串拼接，除了使用最基础的 += 的方式，如果是需要循环的话，可以使用 <code>string.Builder</code> 类型的 <code>WriteString</code> 方法，这种性能上比 += 要更高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">  str.WriteString(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(str.String())   <span class="comment">// aaaaa</span></span><br></pre></td></tr></table></figure>
<h5 id="string-与-byte"><a href="#string-与-byte" class="headerlink" title="string 与 []byte"></a>string 与 []byte</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 的底层结构体</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="type">uintptr</span></span><br><span class="line">  Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 的底层结构体</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">  Data <span class="type">uintptr</span></span><br><span class="line">  Len  <span class="type">int</span></span><br><span class="line">  Cap  <span class="type">int</span>      <span class="comment">// string 类型只是比 slice 少一个 cap 容量的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 string 的底层结构体和 slice 的底层结构体只有一个 cap 容量属性的差异，string 和 byte 切片可以相互转换，go 中可以把字符串类型看成是一个只读的 <code>[]byte</code> 切片</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJkY2MwNDg1NjYzYzU0MDEyMDc1YjM1ZWVjN2VlYWVfUlFQRjZTVVpMcUNSYnlrRmxWSm9JNVZCZnA3NHN0UkRfVG9rZW46RkxUamJzQlFVb2YzNTN4QjZBSmNNTzlKbmplXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<p>String 转为 byte 切片后就可以通过 index 下标来进行修改，但类型转换是会有性能影响的，字符串越长性能损耗也会越大</p>
<p>因为字符串是不可变类型，任何字符串的操作，都会需要通过 copy 来拷贝到新的内存空间中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 和 []byte 的转换和修改</span></span><br><span class="line">s := <span class="string">&quot;fw&quot;</span></span><br><span class="line">bs := []<span class="type">byte</span>(s)  <span class="comment">// 注意 []byte 切片无法处理中文，中文字更改可以转为 []rune 切片</span></span><br><span class="line">bs[<span class="number">0</span>] = <span class="string">&#x27;w&#x27;</span></span><br><span class="line">s = <span class="type">string</span>(bs)</span><br><span class="line">fmt.Println(s)   <span class="comment">// ww</span></span><br></pre></td></tr></table></figure>
<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>当整数进行类型转换时，大范围类型转为小小范围类型，会按照溢出处理。这个溢出处理，就是将二进制数值的溢出部分进行截断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 <span class="type">int64</span> = <span class="number">999999</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int8</span> = <span class="type">int8</span>(num1)   <span class="comment">// 63</span></span><br><span class="line"><span class="comment">// 999999 - 转二进制 &gt; 11110100001000111111 </span></span><br><span class="line"><span class="comment">// 11110100001000111111 - 按照 int8 存储 8位做截断，得到最后 8 位 &gt; 00111111</span></span><br><span class="line"><span class="comment">// 00111111 - 转十进制 &gt; 63</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n1 <span class="type">int32</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="type">int8</span></span><br><span class="line">n2 = <span class="type">int8</span>(n1) + <span class="number">128</span>     <span class="comment">// 这里会直接报错，因为 128 已经超出了 int8 范围</span></span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一旦初始化数组之后，数组的大小就无法改变了，所以无法后续往数组中增加元素，只允许通过 index 去修改元素</p>
<p>Go 中数组的每一个元素都是同一种类型，但如果是声明时定义为 <strong>interface{} 这种接口，就可以存储不同类型的元素</strong></p>
<p>另外，数组是值传递，当一个数组赋值给另一个变量，两个变量之间没有引用关系，其中一个变量修改某个元素后，另一变量的数组对应元素不会发生改变</p>
<p>长度 len 和 容量 cap，初始化一个数组后，会自动得到长度和容量的值，长度就是数组中元素的个数，但是容量会有点区别，容量的值是数组第一个元素到最后一个元素的个数</p>
<p>比如初始化一个 5 个元素的数组，使用切片 [2:] 获取其中部分元素的数组时，这个新的数组其长度就是 3 个元素，其容量也是 3，因为 3 - 5 是 3 个元素</p>
<p>如果是切片 [:3] 获取部分元素的数组，其长度是 3，容量是 5，因为新切片对应的底层数组上是第一个元素到数组最后一个元素，所以容量是 5</p>
<p>也就是容量，是从截取位置对应到底层数组上后，从截取位置计算到数组最后一个元素的个数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">li := [<span class="number">10</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 长度为 10 的 int 类型数组，此时没有给每个元素赋值，每个 int 类型零值是 0</span></span><br><span class="line"><span class="comment">// [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line">li := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">2</span>&#125;      <span class="comment">// 指定 index 赋值来初始化数组</span></span><br><span class="line"><span class="comment">// [1 0 0 0 2]</span></span><br><span class="line"></span><br><span class="line">li := [<span class="number">5</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// [&lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; &lt;nil&gt;]</span></span><br><span class="line">li := [<span class="number">5</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;</span><br><span class="line"><span class="comment">// [0 1 123 &lt;nil&gt; &lt;nil&gt;]</span></span><br><span class="line"></span><br><span class="line">li := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 初始化大小的同时给每一个元素赋值</span></span><br><span class="line">li := [][]<span class="type">int</span>&#123;[]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;, []<span class="type">int</span>&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 创建一个二维数组，[[1 2 3] [4 5 6] [7 8 9]]</span></span><br><span class="line"></span><br><span class="line">li := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// [...]T 这种数组声明时，go 会自动根据初始化的元素个数推到该数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li [<span class="number">3</span>]<span class="type">int</span>      <span class="comment">// 本机是 64位，所以 int 类型变量占 64 位即 8个字节</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;li pointer: %p \n&quot;</span>, &amp;li)</span><br><span class="line">fmt.Printf(<span class="string">&quot;li[0] pointer: %p \n&quot;</span>, &amp;li[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;li[1] pointer: %p \n&quot;</span>, &amp;li[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// li pointer: 0x824d90 </span></span><br><span class="line"><span class="comment">// li[0] pointer: 0x824d90 </span></span><br><span class="line"><span class="comment">// li[1] pointer: 0x824d98   </span></span><br><span class="line"><span class="comment">// 所以下标位 1 的元素，地址是下标位 0 的地址上自增 8 字节</span></span><br><span class="line"><span class="comment">// 如果是 int8 类型数组，那么最后两个元素地址序号上则是相差为 1，即 8 位 1 字节</span></span><br></pre></td></tr></table></figure>
<h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>golang 的 bool 与 int 不会自动转换，所以在判断上无法使用 0 和 1 来作为 bool 判断</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>Slice 和数组不同的是，slice 是动态的，允许增加元素，且 slice 的底层数组类型是引用了数组，因此将一个数组赋值给另一个 slice 变量，其中一个 slice 的 index 对应元素更改的话，另一个 slice 也会更改</p>
<p>初始化一个空的 slice 切片，其零值是 nil，然后长度和容量都是 0</p>
<p>slice 支持通过 make 构建，当因不确定数组时，无法用切片操作获取切片，就可以使用 make 创建切片</p>
<p>slice 的扩容机制：</p>
<ul>
<li>当长度小于 1024 时，每次发生扩容将按照容量 * 2 来扩容</li>
<li>当长度大于 1024 时，每次发生扩容将以增加 25 % 容量来扩容</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;   </span><br><span class="line"><span class="comment">// 直接声明 slice，这里不用像数组一样在 [] 中设置 bounds 个数</span></span><br><span class="line"></span><br><span class="line">arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice = arr1[:<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 直接在数组上使用切片操作获取切片</span></span><br><span class="line"></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 使用 make 函数构建切片，会同时构建底层数组</span></span><br><span class="line"><span class="comment">// [0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"><span class="comment">// make 函数构建的切片，底层的数组是非可见的，只有切片自己可以使用来修改</span></span><br><span class="line"><span class="comment">// 因此 make 构建的切片，主要是构建一个切片空间，其元素需要一一赋予</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// append 函数可以追加多个元素，也可以追加切片，追加切片需要在后面加 ... 来解构</span></span><br><span class="line">x := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">x = <span class="built_in">append</span>(x, <span class="number">1</span>,<span class="number">2</span>)   <span class="comment">// 将 1 和 2 分别追加到 x 中</span></span><br><span class="line">fmt.Println(x)    <span class="comment">// [1 2]</span></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">append</span>(x, x...)</span><br><span class="line"><span class="comment">// append 函数会自动对切片扩容，然后将元数引用到新的切片后返回</span></span><br><span class="line">fmt.Println(x)    <span class="comment">// [1 2 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.22 版本 slices 库的 Concat 方法同样可以完成多个切片合并，内部其实也是通过 append 方法实现</span></span><br><span class="line">li1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">li2 := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">li3 := slices.Concat(li1, li2)    <span class="comment">//  [1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(slice)      <span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">slice = <span class="built_in">append</span>(slice[:<span class="number">3</span>], slice[<span class="number">4</span>:]...)    <span class="comment">// 使用 append 来删除切片元素</span></span><br><span class="line"><span class="comment">// 这个省略号是用于表示将 a[4:] 中的元素逐个作为参数传递给 append 函数</span></span><br><span class="line"><span class="comment">// 如果不加省略号，那么 append 函数会把 a[4:] 整个子切片当作一个元素追加到 a[:3] 后面</span></span><br><span class="line"><span class="comment">// 而加上省略号后，就会把 a[4:] 中的每个元素分别追加</span></span><br><span class="line">fmt.Println(slice)      <span class="comment">// [1 2 3 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy 函数接收两个切片参数，将第二个参数切片的值，复制给第一个参数目标切片</span></span><br><span class="line"><span class="comment">// 每个元素的 copy 会按照索引逐个覆盖目标切片元素</span></span><br><span class="line"><span class="comment">// !!! 注意这需要看本身 slice 的容量，如果本身 cap 是 1，那么将拷贝到本身的元素就只会拷贝目标被拷贝切片的第一个元素</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">copy</span>(s[<span class="number">2</span>:], s[<span class="number">2</span>+<span class="number">1</span>:]))   <span class="comment">// copy 函数没有返回，是对第一个参数做更改</span></span><br><span class="line">fmt.Println(s)   <span class="comment">// [5 6 8 9 9]</span></span><br></pre></td></tr></table></figure>
<h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicateElement</span><span class="params">(languages []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//针对 string 类型的切片去重</span></span><br><span class="line">    result := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(languages))</span><br><span class="line">    temp := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// 构建一个 map，每个 value 是 struct 类型，go 中空的 struct 不会占用空间</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> languages &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := temp[item]; !ok &#123;</span><br><span class="line">            temp[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            result = <span class="built_in">append</span>(result, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distinct</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(input []T)</span></span> []T &#123;</span><br><span class="line">  <span class="comment">// 泛型去重</span></span><br><span class="line">  set := <span class="built_in">make</span>(<span class="keyword">map</span>[T]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  res := <span class="built_in">make</span>([]T, <span class="number">0</span>, <span class="built_in">len</span>(set))</span><br><span class="line">  <span class="keyword">for</span> _, value := <span class="keyword">range</span> input &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := set[value]; !ok &#123;</span><br><span class="line">      set[value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">      res = <span class="built_in">append</span>(res, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>也就是 hash 表，通过 k-v 结构存储数据，go 中 map 类型的零值是 nil，且 map 是引用类型</p>
<p>注意：如果是声明 map 的变量，需要使用 make 函数来构建，否则声明的 map 不指向任何内存地址是 nil，是不能进行 k-v 写入的</p>
<p>在 go 的 map 中获取一个不存在的 key 操作是安全的，并不会报错，而是返回设定 value 类型的零值，但是 <strong>map 并不是写入安全的，并发写入会有问题</strong></p>
<p>另外 go 的 map 是无序的，如果想要有序的 map，需要将 map 的值保存到切片，进行排序后通过遍历写入到新的 map 中</p>
<p><strong><em>关联补充：</em></strong></p>
<ul>
<li>Go 中 slice 空切片且零值也是 nil，为什么却能用 append 来追加元素。因为 append 方法在底层会为 slice 分配相关数组引用，让 nil 的 slice 从而指向具体内存地址</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">people := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)   <span class="comment">// make(map[string]int) == map[string]int&#123;&#125;</span></span><br><span class="line">people[<span class="string">&quot;stark&quot;</span>] = <span class="number">42</span></span><br><span class="line">people[<span class="string">&quot;alex&quot;</span>] = <span class="number">26</span></span><br><span class="line">fmt.Println(people)              <span class="comment">// map[alex:26 stark:42]</span></span><br><span class="line"></span><br><span class="line">people1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d&quot;</span>, people1)        <span class="comment">// map[]</span></span><br><span class="line">people1[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, people1)        <span class="comment">// map[one:1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">people[<span class="string">&quot;stark&quot;</span>] = <span class="number">42</span></span><br><span class="line">people[<span class="string">&quot;alex&quot;</span>] = <span class="number">26</span></span><br><span class="line">fmt.Println(test1)               <span class="comment">// panic: assignment to entry in nil map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> graph = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>  </span><br><span class="line"><span class="comment">// 表示一个嵌套 map 结构  &#123;&quot;&quot;: &#123; &quot;&quot;: true &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">val, ok := people[<span class="string">&quot;messi&quot;</span>]  </span><br><span class="line"><span class="comment">// key 存在，val 就是对应 map 中存储的值，ok 就是 true</span></span><br><span class="line"><span class="comment">// key 不存在，val 就是 map 定义时 val 的零值，ok 就是 false</span></span><br><span class="line">fmt.Println(val, ok)        </span><br><span class="line"><span class="comment">// 0 false，所以对于 key 是否存在可以判断取值时返回的第二个值是否为 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(people, <span class="string">&quot;alex&quot;</span>)</span><br><span class="line"><span class="comment">// 删除一个 key，使用内置函数 delete(map, key)，这个删除 key 如果 key 不存在也不会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := people[<span class="string">&quot;messi&quot;</span>]; !ok &#123;    <span class="comment">// _, ok := people[&quot;messi&quot;]</span></span><br><span class="line">    people[<span class="string">&quot;messi&quot;</span>] = <span class="number">36</span>              <span class="comment">// if !ok &#123;                                        </span></span><br><span class="line">&#125;                                     <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// !!注意!! 在循环比较两个 map 的键值对时</span></span><br><span class="line"><span class="comment">// 不能单一用 xv != y[key]，因为 y 的 map 中 value 本身可能就是 0 值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mymap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  sum := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=num; i++ &#123;</span><br><span class="line">    sum *= i</span><br><span class="line">  &#125;</span><br><span class="line">  mymap[num] = sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span>; i&lt;=<span class="number">5</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> myfunc(i)    <span class="comment">// fatal error: concurrent map writes</span></span><br><span class="line">  <span class="comment">// 使用协程并发对 map 进行写入操作时，因为 map 非线程安全，所以结果是非预期的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>类比 python 的话，就是 class 类这个类型，但 go 并不是纯粹的面向对象</p>
<p>Go 通过结构体（<code>struct</code>）、方法（<code>method</code>）和接口（<code>interface</code>）实现了类似面向对象编程的功能</p>
<p><strong>Go 的面向对象编程更注重组合（Composition）而非继承（Inheritance），并且是通过接口实现了强大的多态性</strong></p>
<p>一般结构体名称和内部属性都是首字母大写，这样被外部导入时，外部才可以实例化这个结构体，以及访问结构体的属性</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;    </span><br><span class="line">    <span class="comment">// 声明 Employee 类型的结构体</span></span><br><span class="line">    ID  <span class="type">int</span>        <span class="comment">// 结构体的属性名首字母也是大写，才可以在被外部导入后查看属性</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    list []<span class="type">int</span>     <span class="comment">// 结构体中属性是 指针，slice，map 的类型，其默认零值为 nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people Employee</span><br><span class="line">people.ID = <span class="number">1</span></span><br><span class="line">people.Name = <span class="string">&quot;stark&quot;</span></span><br><span class="line"><span class="comment">// people := Employee&#123;ID：1, Name: &quot;stark&quot;&#125;    // 实例化结构体时直接对属性赋值</span></span><br><span class="line"><span class="comment">// people := &amp;Employee&#123;ID：1, Name: &quot;stark&quot;&#125;   // 返回一个结构体指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people *Employee = <span class="built_in">new</span>(Employee)   <span class="comment">// var people *Employee = &amp;Employee&#123;&#125;</span></span><br><span class="line"><span class="comment">// new 函数会创建结构体指针，所以这个 people 是一个 Employee 的指针</span></span><br><span class="line">(*people).Name = <span class="string">&quot;tony&quot;</span>   <span class="comment">// == people.Name = &quot;tony&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，go 是强类型语言，所以两个结构体如果字段不一致的情况，是无法进行转换的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">int</span></span><br><span class="line">  <span class="comment">// Address string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">int</span></span><br><span class="line">  Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p People = People&#123;Name: <span class="string">&quot;alex&quot;</span>, Age: <span class="number">12</span>, Phone: <span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> e Employee = Employee(p)   </span><br><span class="line"><span class="comment">// cannot convert p (variable of type People) to type Employee</span></span><br></pre></td></tr></table></figure>
<p>对于一个 struct 结构体，它的属性值在内存上是连续存储的，但是如果属性类型是指针类型，虽然指针是连续的，但实际指向的内存空间并不连续</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Phone <span class="type">int</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p People = People&#123;Name: <span class="string">&quot;alex&quot;</span>, Age: <span class="number">12</span>, Phone: <span class="number">123</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name: %p, age: %p, phone: %p&quot;</span>, &amp;p.Name, &amp;p.Age, &amp;p.Phone)</span><br><span class="line"><span class="comment">// name: 0xc00005e3c0, age: 0xc00005e3d0, phone: 0xc00005e3d8</span></span><br></pre></td></tr></table></figure>
<p>声明结构体如果没有给名称，那就是匿名结构体，适合在结构体对象只是单次使用，例如下面 UserCouponResponse 中的 Data 字段就是匿名结构体，因为 Data 数组中每一个结构体都是单独一次直接构建初始化，没有其他地方会用到就可以定义成匿名结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserCouponResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">  Code <span class="type">int64</span>  <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">  Msg  <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">  Data []*<span class="keyword">struct</span> &#123;</span><br><span class="line">    CouponId           <span class="type">int</span>    <span class="string">`json:&quot;couponId&quot;`</span></span><br><span class="line">    ProdCode           <span class="type">string</span> <span class="string">`json:&quot;prodCode&quot;`</span></span><br><span class="line">    UserId             <span class="type">int64</span>  <span class="string">`json:&quot;userId&quot;`</span></span><br><span class="line">    CouponStatus       <span class="type">int</span>    <span class="string">`json:&quot;couponStatus&quot;`</span></span><br><span class="line">    DiscountPercentage <span class="type">int</span>    <span class="string">`json:&quot;discount&quot;`</span></span><br><span class="line">  &#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的匿名结构体的每一个字段后都带有一个 json 的 tag，这个标识的作用是实现 json 数据和结构体字段的自动映射转换，因为通常 json 传递的数据字段都是小写的，所以结构体的 json tag 内的字段相当于是结构体在 json 数据格式中的别名</p>
<p>对于上面的代码，其实也是嵌套结构体，data 字段是一个匿名结构体的嵌入，通常嵌套结构体可以实现代码的复用和继承</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  Person       <span class="comment">// Person 作为匿名成员嵌入到 Employee 结构体中</span></span><br><span class="line">  EmployeeID   <span class="type">int</span></span><br><span class="line">  Department   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  emp := Employee&#123;</span><br><span class="line">    Person: Person&#123;</span><br><span class="line">      Name: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">      Age:  <span class="number">30</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    EmployeeID: <span class="number">12345</span>,</span><br><span class="line">    Department: <span class="string">&quot;Engineering&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体嵌入无疑会增加对字段赋值和访问的复杂性，例如上面的嵌套结构体，想修改 emp 的 Name 属性，就需要 <code>emp.Person.Name = &quot;alex&quot;</code> 的方式，所以 go 进行了简化，可以通过 <code>emp.Name</code> 来进行匿名访问</p>
<p><strong>需要注意，如果结构体的属性与匿名嵌入结构体的属性存在重复时，比如上面 Employee 结构体也有 Name 字段时，并不会报错，因为两者所在作用域不一致，因此匿名访问时是按照就近原则去访问</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  Person</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  EmployeeID   <span class="type">int</span></span><br><span class="line">  Department   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  emp := Employee&#123;</span><br><span class="line">    Person: Person&#123;</span><br><span class="line">      Name: <span class="string">&quot;fw&quot;</span>,</span><br><span class="line">      Age:  <span class="number">30</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    EmployeeID: <span class="number">12345</span>,</span><br><span class="line">    Department: <span class="string">&quot;Engineering&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(emp.Name)            <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">  fmt.Println(emp.Person.Name)     <span class="comment">// fw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>结构体的方法和 go 函数的声明很相似，只是多了一个接收器，这个接收器还支持指针类型，所以能在一个结构体上看到有普通值类型的接收器声明的方法，以及指针类型接收器的方法</p>
<p><code>func (接收器名称  结构体类型) 方法名(形参)  (返回值列表，多个值需要使用例如：(a int, b int)) &#123;&#125;</code>，方法如果没有 return，则不需要定义返回值列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(people Employee)</span></span> getInfo() &#123;</span><br><span class="line">  <span class="comment">// 注意这里的 people 变量，它是结构体实例的值拷贝</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;ID:%d ; Name:%s&quot;</span>, people.ID, people.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于普通的值接收器方法来说，如果修改了结构体的属性，这个操作只在该方法内局部空间生效</p>
<p>而如果是指针接收器的方法，在方法内修改结构体属性，将会产生全局修改。另外 <strong>如果结构体属性是引用类型，例如 slice 切片，那么普通方法访问修改的话，也会影响到全局上</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> method1() &#123;</span><br><span class="line">  t.name = <span class="string">&quot;new name1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> method2() &#123;</span><br><span class="line">  t.name = <span class="string">&quot;new name2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  t := T&#123;<span class="string">&quot;old name&quot;</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;method1 调用前 &quot;</span>, t.name)</span><br><span class="line">  t.method1()</span><br><span class="line">  fmt.Println(<span class="string">&quot;method1 调用后 &quot;</span>, t.name)</span><br><span class="line">  fmt.Println(<span class="string">&quot;method2 调用前 &quot;</span>, t.name)</span><br><span class="line">  t.method2()</span><br><span class="line">  fmt.Println(<span class="string">&quot;method2 调用后 &quot;</span>, t.name)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// method1 调用前  old name</span></span><br><span class="line"><span class="comment">// method1 调用后  old name </span></span><br><span class="line"><span class="comment">// method2 调用前  old name </span></span><br><span class="line"><span class="comment">// method2 调用后  new name2</span></span><br></pre></td></tr></table></figure>
<p>注意，go 中结构体实例的两种方式，一种就是直接实例化，例如上面的 t := T{“old name”}，还有一种先通过 new 函数在内存中创建 T 结构体的实例，然后逐个属性赋值，当然可以是 t1 := &amp;T{“old name”}</p>
<p>如果是直接实例化方式，这种结构体值（对象）是无法使用指针来访问属性，而通过 new 和指针实例的结构体指针，则可以通过指针访问属性，例如 (*t).name</p>
<p>另外，使用结构体指针访问属性 t.name 时，其实 go 内部最后也是通过 (*t).name 去进行访问，只是前者的书写会更简便一些</p>
<p>关于结构体方法的接收器，可以理解成 python class 类的方法的 self 参数，在 go 中这个接收器是一个值拷贝，即使定义的结构体方式是指针类型的接收器，在调用时这个接收器传递的是指针地址的值拷贝</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针也是一个变量，它存储的不是变量的值，而是值的内存地址，比如类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针，其零值为 <code>nil</code></p>
<p>因为 go 函数默认都是值传递，也就是说函数的形参变量，其值是拷贝了执行的参数的值，但并非是引用关系，所以在函数中修改了变量的值后，函数外部调用函数传入的变量却不会有任何修改</p>
<p>当使用指针时，在函数内部对指针变量修改后，外部的全局变量将会一样被修改，对于结构体变量很常用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;value: %v, pointer: %v&quot;</span>, num, &amp;num)      <span class="comment">// 使用 &amp; 可以访问一个变量的内存地址</span></span><br><span class="line"><span class="comment">// value: 10, pointer: 0xc00001a098</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>     <span class="comment">// 变量 p 是一个 int 类型的指针</span></span><br><span class="line"></span><br><span class="line">age := <span class="number">20</span></span><br><span class="line">p = &amp;age       </span><br><span class="line"><span class="built_in">println</span>(p)     <span class="comment">// 0xc00007df40</span></span><br><span class="line">*p = <span class="number">22</span>        <span class="comment">// *p 将 p 指针的值修改为 22</span></span><br><span class="line"><span class="built_in">println</span>(age)   <span class="comment">// 22，因 p = &amp;age 将 p 指向了 age 的内存地址，*p 修改了指针的值，也就修改了 age</span></span><br></pre></td></tr></table></figure>
<p>Golang 指针的三个限制：</p>
<ul>
<li>指针不能参与计算</li>
<li>不同类型的指针不能相互转换</li>
<li>不同类型的指针不能进行比较和赋值</li>
</ul>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数切片排序</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">sort.Ints(nums)</span><br><span class="line">fmt.Println(nums)           <span class="comment">// [1 2 5 5 6 9]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串切片排序</span></span><br><span class="line">strings := []<span class="type">string</span>&#123;<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>&#125;</span><br><span class="line">sort.Strings(strings)</span><br><span class="line">fmt.Println(strings)        <span class="comment">// [apple banana cherry date]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型排序</span></span><br><span class="line"><span class="comment">// 需要实现 sort.Interface 接口的 Len()、Less(i, j int) bool 和 Swap(i, j int) 三个方法</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i].Age &lt; a[j].Age &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByAge)</span></span> Swap(i, j <span class="type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;</span><br><span class="line"></span><br><span class="line">people := []Person&#123;&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">31</span>&#125;,&#123;<span class="string">&quot;John&quot;</span>, <span class="number">42</span>&#125;,&#123;<span class="string">&quot;Michael&quot;</span>, <span class="number">17</span>&#125;,&#123;<span class="string">&quot;Jenny&quot;</span>, <span class="number">26</span>&#125;,&#125;</span><br><span class="line">sort.Sort(ByAge(people))</span><br><span class="line">fmt.Println(people)         <span class="comment">// [&#123;Michael 17&#125; &#123;Jenny 26&#125; &#123;Bob 31&#125; &#123;John 42&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// go 1.18 sort 提供了 sort.Slice 方法，通过内部自定义 Less 的匿名函数来排序 </span></span><br><span class="line">sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> people[i].Age &lt; people[j].Age</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(people)         <span class="comment">// [&#123;Michael 17&#125; &#123;Jenny 26&#125; &#123;Bob 31&#125; &#123;John 42&#125;]</span></span><br></pre></td></tr></table></figure>
<p>补充：sort.Ints 内部其实调用的是 Sort(IntSlice(x)) ，IntSlice 接口就是实现了 len，less，swap 三个方法，同时还另外实现了一个 sort 方法来直接链式操作，这个 sort 方法也是调用的 sort.Sort 方法，所以 sort.IntSlice 和 sort.Ints 本身都是对 int 切片进行原地排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intslice := sort.IntSlice&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;</span><br><span class="line">sort.Sort(intslice)</span><br><span class="line">fmt.Println(intslice)      <span class="comment">// [1 2 3 5 6]</span></span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>补充：init 函数，<strong>go 中每个源文件都可以有一个 init 函数，该函数会在 main 函数执行前被执行</strong> 当一个包被引入时，会执行该包的 init 函数，这个 init 优先于引入程序的 init</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(a, b <span class="type">int</span>)</span></span> (sum, sub <span class="type">int</span>) &#123;  </span><br><span class="line">  <span class="comment">// go 支持返回值命名，在函数体内可以无需声明或是使用 := ，且最后只需写 return</span></span><br><span class="line">  sum = a + b</span><br><span class="line">  sub = a - b</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printParams</span><span class="params">(args ...<span class="type">int</span>)</span></span> &#123;    </span><br><span class="line">  <span class="comment">// 可变形参，使用 ...T 表示（用于接收 0 或到 n 个参数）</span></span><br><span class="line">  <span class="comment">// 类似 python 的 *agrs</span></span><br><span class="line">  <span class="comment">// go 没有 python 中的关键字参数 kwargs，可以使用 strcut 结构体来传入</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">  <span class="comment">// go 中使用 ...int 的形参，是一个 slice 切片，可以进行遍历</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">printParams(params...)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变参数接收不同类型的参数可以使用空接口: ...interface&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorf</span><span class="params">(lineNum <span class="type">int</span>, formart <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 上面这个形参表示就是函数需要接受至少 2 或到 n 个参数</span></span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数同样可以接受指针类型参数，依次实现对全局外部变量进行修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">        a, b = b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">10</span></span><br><span class="line">y := <span class="number">20</span></span><br><span class="line">swap(x, y)</span><br><span class="line">fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">fmt.Println(y)  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递，使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x := <span class="number">10</span></span><br><span class="line">y := <span class="number">20</span></span><br><span class="line">swap(&amp;x, &amp;y)</span><br><span class="line">fmt.Println(x)  <span class="comment">// 20</span></span><br><span class="line">fmt.Println(y)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>函数本身也可以作为参数，go 中函数的零值是 nil，函数值是不可进行比较的，所以也无法作为 map 中的 key，有了函数值就可以通过行为的方式调用函数，例如下面的 strings.Map 会将第二个参数的每个字符给 add1 函数调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">rune</span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;HAL-9000&quot;</span>)) <span class="comment">// &quot;IBM.:111&quot;</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;VMS&quot;</span>))      <span class="comment">// &quot;WNT&quot;</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">&quot;Admix&quot;</span>))    <span class="comment">// &quot;Benjy&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;    </span><br><span class="line">  <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;    <span class="comment">// 匿名函数</span></span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := squares            <span class="comment">// 函数值赋值，但是这里 squares 函数内部 x 不会被保留</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, f())   <span class="comment">// func() int%</span></span><br><span class="line">fmt.Println(f)          <span class="comment">// 0x4804c0</span></span><br><span class="line">fmt.Println(f())        <span class="comment">// 0x480660</span></span><br><span class="line">fmt.Println(f()())      <span class="comment">// 1</span></span><br><span class="line">fmt.Println(f()())      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">f := squares()          <span class="comment">// 函数结果赋值，f 变量中的匿名函数 x 引用了 squares 的变量</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T&quot;</span>, f())   <span class="comment">// int%</span></span><br><span class="line">fmt.Println(f())        <span class="comment">// 1  squares 函数中的 x 变量会常驻内存，且作用域是在 squares 内，所以不会对全局造成污染</span></span><br><span class="line">fmt.Println(f())        <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码需要在 1.22 版本之前才会复现  https://antonz.org/go-1-22/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">  values := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;foo5 val = %v\n&quot;</span>, val)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo5()</span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"><span class="comment">// foo5 val = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 range 遍历来说，每次得到的 val 变量是同一个地址，并不是 slice 里每个元素的引用</span></span><br><span class="line"><span class="comment">// 由于闭包的延迟绑定，这里 go func()() 会开启 routine</span></span><br><span class="line"><span class="comment">// 这会使得这个匿名函数的真正执行要晚于 for 循环，所以当这个匿名函数执行时</span></span><br><span class="line"><span class="comment">// for 循环的 val 由于被闭包引用，所以延长了生命周期，但是 for 已经完成了</span></span><br><span class="line"><span class="comment">// 所以 val 最后的值就是 5，只会得到 for 结束后 val 存储的值</span></span><br></pre></td></tr></table></figure>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>defer 关键字可以产生延迟执行，defer 的函数会在 return 语句更新返回值后再执行，这使得 defer 函数可以访问到返回值</p>
<p>defer 通常用来在主函数结束之前对资源进行释放，如关闭文件句柄、断开连接、释放锁等。有了 defer 语句就可以轻松地的在函数中统一处理释放，和省去重复的判断逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="type">int</span>, n2 <span class="type">int</span>)</span></span>(res <span class="type">int</span>)&#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1 n1=&quot;</span>, n1)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;ok1 n2=&quot;</span>, n2)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;res =&quot;</span>, res)</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;fmt.Println(<span class="string">&quot;res =&quot;</span>, res)&#125;()</span><br><span class="line">  res = n1 + n2</span><br><span class="line">  fmt.Println(<span class="string">&quot;ok1 res=&quot;</span>, res)</span><br><span class="line">  <span class="comment">// 注意 defer 函数不受 panic 的影响，假设在这行手动抛出 panic，这个 sum 函数中 defer 也会运行</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// ok1 res= 30</span></span><br><span class="line"><span class="comment">// res = 30</span></span><br><span class="line"><span class="comment">// res = 0</span></span><br><span class="line"><span class="comment">// ok1 n2= 20</span></span><br><span class="line"><span class="comment">// ok1 n1= 10</span></span><br></pre></td></tr></table></figure>
<p>需要注意 defer 执行机制，在 defer 关键字执行时，会立即拷贝 defer 函数所引用的外部变量，并不是在 defer 函数执行的时候才去获取，所以上面的 <code>defer func () &#123;fmt.Println(&quot;res =&quot;, res)&#125;()</code> 在 defer 关键字后使用了一个匿名函数，这样匿名函数被延后执行时，res 已经完成计算，所以返回的计算后的值，如果没有使用匿名函数，而是直接 fmt 打印 res，则 defer 关键字执行时，就已经获取了 res 的值，但此时 res 还没有计算，所以会打印默认零值，也就是 0</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 defer 计算函数执行时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  startedAt := time.Now()</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; fmt.Println(time.Since(startedAt)) &#125;()</span><br><span class="line">    </span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：defer 数据结构是一个链表，每当有一个新 defer 函数都会被追加到 defer 链表的最前端，在 go 运行时执行时这个延时调用链的时候，会从前向后执行 defer</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=OTczNDMzMDljNDhhM2Y1NmVkNzU1Yjk1MDc0YWZiMzJfYzlOU0FUczc3TVlGanVNdlF5eERNaTF4SEJLanRWeDJfVG9rZW46RlAzRmJlWnJXb09SbDd4V0JFNGM1THhjblFJXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<h5 id="panic-与-recover"><a href="#panic-与-recover" class="headerlink" title="panic 与 recover"></a>panic 与 recover</h5><p>Panic 可以改变程序控制流，调用 panic 会立即停止执行当前函数，并在当前 goroutine 递归执行调用方的 defer</p>
<p>Recover 则可以用终止 panic 造成的程序崩溃，需要在 defer 中去使用来捕获 panic </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;run f1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;   <span class="comment">// recover 的捕获需要结合 defer 函数来得到捕获到的错误</span></span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;detect error:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;oops! f2 error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  f1()</span><br><span class="line">  f2()</span><br><span class="line">  fmt.Println(<span class="string">&quot;run main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// run f1</span></span><br><span class="line"><span class="comment">// detect error: oops! f2 error   // 注意 defer 执行时会在 f2 堆栈释放前</span></span><br><span class="line"><span class="comment">// run main</span></span><br></pre></td></tr></table></figure>
<h5 id="Time-模块基本使用"><a href="#Time-模块基本使用" class="headerlink" title="Time 模块基本使用"></a>Time 模块基本使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  now := time.Now()</span><br><span class="line">  fmt.Println(<span class="string">&quot;Current time:&quot;</span>, now)  </span><br><span class="line">  <span class="comment">// Current time: 2025-07-09 14:18:02.28202441 +0800 CST m=+0.000029936</span></span><br><span class="line"></span><br><span class="line">  timeStr := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">  <span class="comment">// go 中将时间对象转为字符串时间的格式化格式，很奇特使用特定数字表示</span></span><br><span class="line">  <span class="comment">// 上面这个 format 是固定的，表示将当前时间对象转为 年-月-日 时:分:秒 的格式</span></span><br><span class="line">  <span class="comment">// 15 表示的是 24 小时值的 hour，03 表示 12 小时制的 hour</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Formatted time:&quot;</span>, timeStr)  </span><br><span class="line">  <span class="comment">// Formatted time: 2025-07-09 14:18:02</span></span><br><span class="line"></span><br><span class="line">  timeStamp := now.Unix()</span><br><span class="line">  <span class="comment">// Unix 时间戳是从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的秒数</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Unix timestamp:&quot;</span>, timeStamp) </span><br><span class="line">  <span class="comment">// Unix timestamp: 1720501082</span></span><br><span class="line"></span><br><span class="line">  timeObj := time.Unix(timeStamp, <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 将 Unix 时间戳转换为 time.Time 对象</span></span><br><span class="line">  <span class="comment">// Unix 接受两个参数，第一个 秒 单位的时间戳，第二个 纳秒 单位的时间戳</span></span><br><span class="line">  <span class="comment">// 将 秒 单位时间戳转为时间对象，第二个参数就是 0，反之亦然</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Time object from timestamp:&quot;</span>, timeObj)  </span><br><span class="line">  <span class="comment">// Time object from timestamp: 2025-07-09 14:18:02 +0800 CST</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;Time object Formatted time:&quot;</span>, timeObj.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))  </span><br><span class="line">  <span class="comment">// Time object Formatted time: 2025-07-09 14:18:02</span></span><br><span class="line"></span><br><span class="line">  timeObj, err := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, timeStr, time.Local)</span><br><span class="line">  <span class="comment">// ParseInLocation 用于将字符串时间解析为 time.Time 对象，会返回 time 对象和 error</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error parsing time:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Parsed time object:&quot;</span>, timeObj)  </span><br><span class="line">  <span class="comment">// Parsed time object: 2025-07-09 14:18:02 +0800 CST</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Interface 接口类型具体描述了一系列方法的集合，所以<strong>接口中不需要定义方法体以及变量，在 go 中都是隐式实现接口，只要结构体实现了接口中所有的方法就表示为实现了接口</strong></p>
<p><strong>interface 可以理解为是 struct 的更高级抽象，可以实现多态和解耦</strong></p>
<p>io.Writer 类型是用得最广泛的接口之一，因为它提供了所有类型的写入 bytes 的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Requests <span class="keyword">interface</span>&#123;</span><br><span class="line">  <span class="comment">// 自定义类型需要实现接口中所有的方法，才能算是实现了接口方法</span></span><br><span class="line">  <span class="comment">// 如果少一个没实现，那么对接口赋值时会报错说没有实现是接口中的方法</span></span><br><span class="line">  SendRequest()</span><br><span class="line">  GetResponse()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接口中也可以嵌套其他接口，但同样在最后给接口赋值时都需要将内部所有接口方法实现</span></span><br><span class="line">  <span class="comment">// 注意，嵌套的其他接口中，不能有重名的接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc Computer)</span></span> SendRequest() &#123;</span><br><span class="line">  <span class="comment">// 表示 Computer 类型实现了 Requests 接口的 SendRequest 方法</span></span><br><span class="line">  <span class="comment">// go 中没有 implements 关键字，所以不需要显式声明接口实现</span></span><br><span class="line">  <span class="comment">// 隐式声明的方式让 go 可以更加符合高内聚低耦合</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;pc send request&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc Computer)</span></span> GetResponse() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;pc get response&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> myrequests Requests</span><br><span class="line">  <span class="keyword">var</span> pc Computer = Computer&#123;&#125;</span><br><span class="line"></span><br><span class="line">  myrequests = pc             <span class="comment">// 表示 pc 这个结构体实现了 Requests 这个接口</span></span><br><span class="line">  myrequests.GetResponse()    <span class="comment">// pc get response</span></span><br><span class="line">  myrequests.SendRequest()    <span class="comment">// pc send request</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 表示一个空接口，空接口允许接受任何类型的值</span></span><br><span class="line">  <span class="comment">// 所以有些函数的形参可以看到会是一个空接口类型，这样函数调用时就可以传入任何类型的值</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%v&quot;</span>, i2)</span><br><span class="line">  <span class="comment">// 接口是属于引用类型，所以接口底层值是 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和结构体很相似，接口同样可以设定接收者, 例如下面的 Cat 和 <em>Cat 两种类型的 Quack 方法，他们都实现了接口中的方法，但是在 *</em>go 接口中不允许同时存在，值接收者和指针接受者只能二选一**</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">  Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Quack() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span></span> Quack() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口同样可以作为值传递或返回，接口值的内部可以看做是一个元素（底层类型，底层值），接口的零值是 nil，但需要非常注意，一个包含 nil 指针的接口和 nil 接口是不同的两种东西</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If out is non-nil, output will be written to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...do something...</span></span><br><span class="line">    <span class="keyword">if</span> out != <span class="literal">nil</span> &#123;</span><br><span class="line">        out.Write([]<span class="type">byte</span>(<span class="string">&quot;done!\n&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        buf = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// enable collection of output</span></span><br><span class="line">    &#125;</span><br><span class="line">    f(buf) <span class="comment">// <span class="doctag">NOTE:</span> subtly incorrect!</span></span><br><span class="line">    <span class="keyword">if</span> debug &#123;</span><br><span class="line">        <span class="comment">// ...use buf...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 debug 为 false 是，buf 的类型是一个 nil 的指针，这个 nil 指针在 f 中调用 Write 很显然会报错，但这个 out 接口本身并不是一个 nil 接口，它的底层类型是 <em>bytes.Buffer，而值为 nil 指针。所以 *</em>要避免将空指针值的给到一个非空接口**，上面的 buf 变量一开始就应该定义为 io.Writer 类型</p>
<p><strong>空接口通常可以用来保存任何类型的值，可以用在函数形参上以表示接收任何类型的参数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>练习：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IPAddr [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 为 IPAddr 添加一个 &quot;String() string&quot; 方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IPAddr)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d.%d.%d.%d&quot;</span>, ip[<span class="number">0</span>], ip[<span class="number">1</span>], ip[<span class="number">2</span>], ip[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  hosts := <span class="keyword">map</span>[<span class="type">string</span>]IPAddr&#123;</span><br><span class="line">    <span class="string">&quot;loopback&quot;</span>:  &#123;<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">&quot;googleDNS&quot;</span>: &#123;<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> name, ip := <span class="keyword">range</span> hosts &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, name, ip)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loopback: 127.0.0.1</span></span><br><span class="line"><span class="comment">// googleDNS: 8.8.8.8</span></span><br></pre></td></tr></table></figure>
<h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>类型断言提供对接口类型底层数据类型的访问，例如 i 这个空接口，可以接受任何类型 假设有一个多态数组，其类型是空接口，当进行遍历调用接口时，就需要使用断言，和 map 获取 key 一样，<code>i.(T)</code> 去断言 i 的类型时会返回一个变量表示断言是否成功，这样可以避免因为 i 不是 T 类型时引发的 panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)          <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)      <span class="comment">// hello true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型选择，和 switch 语法很像，用于支持多种类型的判断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;二倍的 %v 是 %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%q 长度为 %v 字节\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;我不知道类型 %T!\n&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  do(<span class="number">21</span>)</span><br><span class="line">  do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">  do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>Go 中通过 error 接口类型的值表示错误，这个 error 接口中定义了一个返回字符串的 Error 方法，所以如果要自定义错误，需要实现 error 接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="type">float64</span>    <span class="comment">// 定义一个负数平方根的错误类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="comment">// 实现负数平方根的 Error 方法</span></span><br><span class="line">  <span class="keyword">return</span> fmt.Sprint(<span class="string">&quot;cannot Sqrt negative number: &quot;</span>, <span class="type">float64</span>(e))</span><br><span class="line">  <span class="comment">// 注意这里的 e 需要通过 float64 进行转换，</span></span><br><span class="line">  <span class="comment">// 否则 Sprintf 函数会调用 e 的 Error 方法得到格式化字符串</span></span><br><span class="line">  <span class="comment">// 而当前这个 e 的 Error 方法中又调用了 Sprintf，这就变成死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, ErrNegativeSqrt(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> math.Sqrt(x), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))    <span class="comment">// 0 cannot Sqrt negative number: -2</span></span><br></pre></td></tr></table></figure>
<p>关于错误的处理，如果直接使用打印或是 log 记录 error ，当 error 传递时，就会出现重复信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  _, err := w.Write(buf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;unable to write:&quot;</span>, err) <span class="comment">// annotated error goes to log file</span></span><br><span class="line">    <span class="keyword">return</span> err                           <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  err := WriteConfig(f, &amp;conf)</span><br><span class="line">  fmt.Println(err) <span class="comment">// io.EOF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unable to write: io.EOF</span></span><br><span class="line"><span class="comment">// could not write config: io.EOF</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>所以可以给错误加上一些上下文信息，并将错误直接返回给上层，由上层判断处理，通过 <code>fmt.Errorf</code> 可以给错误加上上下文信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然如果想要获取错误更多信息，可以使用 <code>github.com/pkg/errors</code> 这个包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只附加新的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只附加调用堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同时附加堆栈和信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err <span class="type">error</span>, message <span class="type">string</span>)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归解包得到原始错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cause</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;open failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  buf, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;read failed&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  home := os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">  config, err := ReadFile(filepath.Join(home, <span class="string">&quot;.settings.xml&quot;</span>))</span><br><span class="line">  <span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">&quot;could not read config&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _, err := ReadConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;original error: %T %v\n&quot;</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;stack trace:\n%+v\n&quot;</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="make-与-new"><a href="#make-与-new" class="headerlink" title="make 与 new"></a>make 与 new</h4><p>Go 中在对类型初始化时，通常会使用到这两个函数，但两者还是有些区别的</p>
<p><strong>new：</strong></p>
<ul>
<li><strong>用途</strong>：<strong><code>new</code></strong> <strong>用于分配内存</strong>，为变量分配零值（<code>zero value</code>）</li>
<li><strong>返回值</strong>：<strong><code>new</code></strong> <strong>返回一个指向分配内存的指针</strong></li>
<li><strong>语法</strong>：<code>new(Type)</code>，其中 <code>Type</code> 是要分配内存的类型</li>
<li><strong>行为</strong>：<ul>
<li><code>new</code> 分配的内存大小由类型决定</li>
<li>分配的内存会被初始化为该类型的零值（例如，<code>int</code> 的零值是 <code>0</code>，<code>string</code> 的零值是 <code>&quot;&quot;</code>，<code>struct</code> 的零值是所有字段为零值的实例）</li>
<li><code>new</code> 返回的是一个指针，指向分配的内存</li>
</ul>
</li>
</ul>
<p>make：</p>
<ul>
<li><strong>用途</strong>：<code>make</code> 用于初始化内置的引用类型（如 <code>slice</code>、<code>map</code> 和 <code>channel</code>）</li>
<li><strong>返回值</strong>：<strong><code>make</code></strong> <strong>返回一个初始化后的引用类型的值，而不是指针</strong></li>
<li><strong>语法</strong>：<code>make(Type, size)</code> 或 <code>make(Type, size1, size2)</code>，其中：<ul>
<li><code>Type</code> 是要初始化的类型（必须是 <code>slice</code>、<code>map</code> 或 <code>channel</code>）</li>
<li><code>size</code> 是初始化的大小</li>
<li><code>size1</code> 和 <code>size2</code> 用于 <code>slice</code> 的长度和容量</li>
</ul>
</li>
<li><strong>行为</strong>：<ul>
<li><strong><code>make</code></strong> <strong>只能用于初始化内置的引用类型</strong>，不能用于普通类型（如 <code>int</code>、<code>struct</code> 等）</li>
<li>初始化后的类型已经准备好使用，且内部数据结构被正确初始化</li>
<li>对于 <code>slice</code>，<code>make</code> 返回一个指向底层数组的切片</li>
<li>对于 <code>map</code>，<code>make</code> 返回一个空的哈希表</li>
<li>对于 <code>channel</code>，<code>make</code> 返回一个通道</li>
</ul>
</li>
</ul>
<h4 id="循环与分支"><a href="#循环与分支" class="headerlink" title="循环与分支"></a>循环与分支</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本的循环写法</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用条件的循环，代替了 while，golang 里没有 while 循环</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i&lt;<span class="number">10</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环，使用 break 退出，或 return 退出函数</span></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for range 可以用来遍历数组，或是 map，也可是是 strings</span></span><br><span class="line">names := []<span class="type">string</span>&#123;<span class="string">&quot;messi&quot;</span>, <span class="string">&quot;stark&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> names &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，go 的字符串 string，是由一系列 rune 组成，每个 rune 都是一个 unicode 码</span></span><br><span class="line"><span class="comment">// 所以遍历字符串时，打印每一个字符，得到的是一个数字，可以通过fmt.Printf(&quot;%c\n&quot;,v)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// go 的 if 判断表达式前，允许增加一个语句用来声明判断变量</span></span><br><span class="line">mymap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;age&quot;</span>: <span class="string">&quot;fw&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> val, ok := mymap[<span class="string">&quot;name&quot;</span>]; ok &#123;</span><br><span class="line">  fmt.Println(val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fmt.Print(<span class="string">&quot;no name key in mymap&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// go 也支持 switch</span></span><br><span class="line"><span class="comment">// switch &lt;表达式，可以是变量，指针，函数&gt; &#123;</span></span><br><span class="line"><span class="comment">//  case 表达式1，表达式2，... :       // 注意每个 case 最后都要有 :  </span></span><br><span class="line"><span class="comment">//     block1                        // 如果 case 代码块里没有 break，则会继续往后执行 case</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//  case 表达式3，表达式4，... :</span></span><br><span class="line"><span class="comment">//     block2</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//  default:</span></span><br><span class="line"><span class="comment">//     block3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;macOS.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;                  <span class="comment">// switch 也支持无表达式的</span></span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;早上好！&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;下午好！&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">&quot;晚上好！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：</p>
<p>switch 穿透，如果想要一个满足的 case 被执行后，可以将下一个 case 的代码块执行，可以使用 falllthrough 关键字，但需要谨慎使用 一个 fallthrough 只允许继续做一次 case 穿透</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射允许在程序运行期间动态获取变量或结构体的信息，并支持修改</p>
<p>Go 通过自带的 reflect 包实现了运行时的反射能力，来让程序操作不同类型的对象，其中主要的两个函数是：</p>
<ul>
<li><code>reflect.TypeOf</code> 能获取类型信息，就是反射后变量的底层类型，返回的是 <code>reflect.Type</code>，</li>
<li><code>reflect.ValueOf</code> 能获取数据的运行时表示，就是反射后变量的底层值，通过返回 <code>reflect.Value</code> 表示</li>
</ul>
<p>reflect.Type 是一个接口类型，而 reflect.Value 则被定义为 struct，这两个反射对象都可以用 Name 方法查看类型名，Kind 方法查看底层类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  i := <span class="number">1</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;i)</span><br><span class="line">  </span><br><span class="line">  v := reflect.ValueOf(&amp;i)  <span class="comment">// 获取 i 指针的反射对象</span></span><br><span class="line">  fmt.Println(v.Type())     <span class="comment">// 查看反射对象的类型</span></span><br><span class="line">  fmt.Println(v.Elem().Addr())    <span class="comment">// Elem 可以得到指针指向的对象</span></span><br><span class="line">  fmt.Println(v.Pointer())  <span class="comment">// 查看反射对象指针的值</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;v)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// v.SetInt(10)           // 反射对象不能直接修改值，因为 go 的函数调用是值传递，这个 v 和 i 并没有直接关系</span></span><br><span class="line">  v.Elem().SetInt(<span class="number">10</span>)       <span class="comment">// 通过反射更新值</span></span><br><span class="line">  fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0xc00001a098</span></span><br><span class="line"><span class="comment">// *int</span></span><br><span class="line"><span class="comment">// 0xc00001a098</span></span><br><span class="line"><span class="comment">// 0xc000008078</span></span><br><span class="line"><span class="comment">// 824633827480</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>反射的特性在处理结构体时非常有用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">  </span><br><span class="line">  t := reflect.TypeOf(p)</span><br><span class="line">  v := reflect.ValueOf(p)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历结构体字段</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">    f := v.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d: %s %s = %v\n&quot;</span>, i, t.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0: Name string = Alice</span></span><br><span class="line"><span class="comment">// 1: Age int = 25</span></span><br></pre></td></tr></table></figure>
<p>大多数应用和服务一般不太会过多使用反射，因为反射会一定程度降低代码可读性，主要是一些框架中会使用反射来简化代码</p>
<p>通常 ORM 框架，序列化和反序列化等会使用反射特性</p>
<p>反射也可以对方法进行调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">  A <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MyStruct)</span></span> Add(b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> m.A + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  m := &amp;MyStruct&#123;A: <span class="number">10</span>&#125;</span><br><span class="line">  </span><br><span class="line">  v := reflect.ValueOf(m)</span><br><span class="line">  method := v.MethodByName(<span class="string">&quot;Add&quot;</span>)   <span class="comment">// MethodByName 可以名字得到结构体反射的方法</span></span><br><span class="line">  </span><br><span class="line">  args := []reflect.Value&#123;reflect.ValueOf(<span class="number">5</span>)&#125;</span><br><span class="line">  result := method.Call(args)       <span class="comment">// 反射的方法需要使用 Call 来调用，参数 []reflect.Value 切片</span></span><br><span class="line">  </span><br><span class="line">  fmt.Println(result[<span class="number">0</span>].Int())      <span class="comment">// 输出 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三法则"><a href="#三法则" class="headerlink" title="三法则"></a>三法则</h4><p>Go 反射的三个法则是：</p>
<ul>
<li>从接口值可以反射出反射对象</li>
<li>从反射对象可以反射接口值</li>
<li>要求改反射对象，其值必须可设置</li>
</ul>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>go 最大的优势特点就是通过 goroutine 进行并发编程，goroutine 可以理解为 golang 的协程，是并发执行的工作单元</p>
<p>goroutine 非常轻量级，运行一个协程只需要 4-5 kb，所以 go 中可以非常容易地创建上万个协程实现并发。对于 goroutine 的调度全部由 go 的运行时来管理，而不是通过操作系统，go 的运行时会在用户态进行调度，避免了上下文切换需要的消耗</p>
<p>当一个程序开始运行，主函数会在一个叫 main routine 中运行，其中要开启一个 go 协程，只需在函数调用前加上关键字 go ，即 <code>go func()</code> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)    <span class="comment">// 开启 spinner 函数的协程</span></span><br><span class="line">  <span class="keyword">const</span> n = <span class="number">45</span></span><br><span class="line">  fibN := fib(n)       <span class="comment">// fib 函数会一直计算直到 return 结果，此时 spinner 也在一起执行</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)</span><br><span class="line">  <span class="comment">// 主函数上最后 Printf 结束时，内部 spinner 协程会被终止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;\r%c&quot;</span>, r)</span><br><span class="line">          time.Sleep(delay)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x &lt; <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fib(x<span class="number">-1</span>) + fib(x<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 goroutine 中想要手动终止执行，可以使用 runtime 包中的 <code>runtime.Goexit()</code>，<strong>goroutine 被终止时，调度器会确保已经注册 defer 被延时执行</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">      <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">      runtime.Goexit()</span><br><span class="line">      fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B.defer</span></span><br><span class="line"><span class="comment">// A.defer</span></span><br></pre></td></tr></table></figure>
<h4 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h4><p>go 语言调度器通过 GMP 模型来实现并发执行和管理，GMP模型由三个核心组件组成：G（Goroutine）、M（Machine）、P（Processor）</p>
<p>G：Goroutine 代表一个独立的执行单元，Goroutine 的调度由 Go 运行时在用户态进行</p>
<p>M：Machine 代表操作系统的线程，一个 M 可以执行多个 Goroutine，但同一时间只能执行一个 Goroutine。M 与操作系统的线程直接对应，Go 运行时通过 M 来利用多核 CPU 的并行计算能力，</p>
<p>P：Processor 被看做运行在线程上的本地调度器，它可以维持一个容纳最多 256 个 G 的队列，是 M 与 G 的中间层，为线程 M 提供上下文，通过 GOMAXPROCS 可以设置最大的活跃线程数，默认这个值是当前机器的核数</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=MWNjMWEzOTQ1OGI4ZGVmOTQ2ZmJiOWYzZDVkMjJmZGZfekJ2aGtWMDlUbFhpRjJJUHJSeWE1VFBUZm9NUTQyS0JfVG9rZW46Q1RaT2JHcnVPb1ZhM0Z4UU8ybGMxNmU3bjJlXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<p>Go 调度器的设计：</p>
<ul>
<li><strong>复用线程的两个策略</strong>：<ul>
<li><strong>Work Stealing 机制</strong>：当本线程没有可执行的 G，会从全局 G 队列中获取。如果全局队列中没有，则尝试从其他 P 的队列中偷取 G</li>
<li><strong>Hand Off 机制</strong>：当本线程因 G 进行系统调用等阻塞时，线程会释放绑定的P，把 P 转移给其他空闲的 M 执行</li>
</ul>
</li>
<li><strong>抢占式调度</strong>：Goroutine 是协作式的，一个协程只有让出 CPU 才能让下一个协程执行，而 Goroutine 执行超过 10ms 就会强制让出 CPU，防止其他协程饿死</li>
<li><strong>G0 和 M0</strong>：<ul>
<li><strong>G0</strong>：每次启动一个 M 都会创建的第一个 Goroutine，仅用于调度，不指向任何可执行的函数。每个 M 都有一个 G0，在调度或系统调用时使用 G0 的栈空间</li>
<li><strong>M0</strong>：启动程序后的第一个主线程，负责执行初始化操作和启动第一个Goroutine，此后与其他 M 一样</li>
</ul>
</li>
</ul>
<p>Goroutine 的生命周期，大致可以分为：</p>
<ul>
<li><p>创建（Creation），即通过 go 关键期启动函数，此时 goroutine 会初始化，加入到运行时的调度队列中</p>
</li>
<li><p>运行（Running），goroutine 调度到内核态 M 线程上执行</p>
</li>
<li><p>阻塞（Bolcking）, goroutine 执行过程遇到 IO ，channel 或同步操作，调度器 P 会挂起它，执行下一个 goroutine</p>
</li>
<li><p>就绪（Runable），goroutine 阻塞解除后，会进入就绪状态等待重新调度</p>
</li>
<li><p>完成（Finished），goroutine 执行结束，go 运行时会清理 goroutine 的资源</p>
<p>整个生命周期，包含了以下一些状态：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_Gidle</td>
<td>刚刚被分配并且还没有被初始化</td>
</tr>
<tr>
<td>_Grunnable</td>
<td>没有执行代码，没有栈的所有权，存储在运行队列中</td>
</tr>
<tr>
<td>_Grunning</td>
<td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td>
</tr>
<tr>
<td>_Gsyscall</td>
<td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td>
</tr>
<tr>
<td>_Gwaiting</td>
<td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td>
</tr>
<tr>
<td>_Gdead</td>
<td>没有被使用，没有执行代码，可能有分配的栈</td>
</tr>
<tr>
<td>_Gcopystack</td>
<td>栈正在被拷贝，没有执行代码，不在运行队列上</td>
</tr>
<tr>
<td>_Gpreempted</td>
<td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td>
</tr>
<tr>
<td>_Gscan</td>
<td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td>
</tr>
</tbody></table>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>虽然 goroutine 是共享内存空间的，但在 go 中推荐<strong>使用 channel 来实现 goroutine 的通信，而不是使用共享内存来通信</strong></p>
<p>Channel 管道就是 FIFO 的先进先出队列，使用 make 函数来构建管道类型，以及设置管道的容量，<strong>如果管道已满再写入，或管道为空再读取，都会引发 deadlock 错误</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> Type)             <span class="comment">// 等价于 make(chan Type, 0)</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)     <span class="comment">// 创建一个存储 int 类型的管道，管道容量为 5</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>                     <span class="comment">// 写入数据到管道</span></span><br><span class="line">x := &lt;-channel              <span class="comment">// 从管道读取</span></span><br><span class="line">x, ok := &lt;-channel          <span class="comment">// 功能同上，同时检查通道是否已关闭或者是否为空</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)                <span class="comment">// 关闭 channel</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;     <span class="comment">// range 可以代替 for 或 while 来逐个从 channel 中持续读取数据</span></span><br><span class="line">    fmt.Println(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 channel 没有设置 capacity 容量，就是无缓冲阻塞读写的，也就是写入一个元素到 channel 中后，必须要有 goroutine 去读取这个值，否则 channel 就会阻止其他 goroutine 的数据写入，所以使用无缓冲管道时需要发送和接收方同时都准备好通信，不然就会导致两边的通信等待</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=NzAxYTRiYjNmNGM2MGE0M2JiMDBiODY0YmQ4YTAyYjhfV0lnR0hvbmFCWTZ1VkxKQ1NwUEhCQ3dTaDFnemNEcVRfVG9rZW46RHk1cmJXT0d5b2J6bEd4UHhjMGNqZ0liblFoXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<p>有设置 capacity 则表示有缓冲非阻塞的管道，允许将管道写入多个数据，直到容量已满为止无法写入，也允许从管道获取多个数据，直到没有数据继续等待 channel 的数据</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU0N2QxMTdkZmRiN2FjZDVjNGRiOTUwMTZmNzg4ZTJfb2dXYWp1azZJREZDS1NaRktKQ1JOem5GanhlZ1JUVzZfVG9rZW46TUd6UGI0TFRBb2dDSGR4cmY1WWMwSmVSbjhxXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>在 go 中还提供了一个 select 关键字来对多个 channel 进行监听，select 的编写和 switch 几乎一样，只是 <strong>select 的 case 必须都是 channel 的收发操作</strong></p>
<p>使用 select 可以实现 channel 的非阻塞收发，当 select 中没有任何匹配的 channel 操作 case，会执行其中 default 语句，而当 select 里有多个满足的 case 时，会随机选择一个进行执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非阻塞收发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> i := &lt;-ch:</span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// default</span></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机 case 执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> time.Tick(<span class="number">1</span> * time.Second) &#123;</span><br><span class="line">      <span class="comment">//  time.TicK 会返回一个定时的通道，这个通道会按照设定间隔时间，发送一个时间值</span></span><br><span class="line">      ch &lt;- <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;case1&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">&quot;case2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="comment">// case2</span></span><br></pre></td></tr></table></figure>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁是一种并发编程中的同步原语（Synchronization Primitives），它能保证多个 Goroutine 在访问同一片内存时不会出现竞争条件（Race condition）等问题</p>
<p>Go 语言在 <code>sync</code> 包中提供了用于同步的一些基本原语，包括常见的 <code>sync.Mutex</code>、<code>sync.RWMutex</code>、<code>sync.WaitGroup</code>、<code>sync.Once</code> 和 <code>sync.Cond</code>，这些基本原语提供了相对原始的同步机制</p>
<h5 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SafeCounter 是并发安全的</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex        <span class="comment">// Mutex 是互斥锁</span></span><br><span class="line">  v  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 对给定键的计数加一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="comment">// Lock 和 Unlock 一定是成对出现，否则会引发死锁</span></span><br><span class="line">  <span class="comment">// 锁定使得一次只有一个 Go 协程可以访问映射 c.v。</span></span><br><span class="line">  c.v[key]++</span><br><span class="line">  c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定键的计数的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="comment">// 锁定使得一次只有一个 Go 协程可以访问映射 c.v。</span></span><br><span class="line">  <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sync.Mutex</code> 是互斥锁，互斥锁有正常模式和饥饿模式：</p>
<ul>
<li>正常模式，锁的等待者按照 FIFO 顺序等待获取锁，这会导致刚被唤起的 goroutine 在和新创建的 goroutine 竞争时，可能就会无法得到锁，导致延迟增加</li>
<li>饥饿模式，锁会优先给等待队列中最前面的获取锁，新创建的 goroutine 不会竞争锁，也不会进入自旋</li>
</ul>
<p>Go 会自动在互斥锁的这两种模式下进行转换以保证性能。正常模式下，新的 goroutine 超过 1ms 没有得到锁，互斥锁就会转为饥饿模式；饥饿模式下，一个在队列尾部的 goroutine 得到锁时，或者是得到锁的等待时间小于 1 ms ，则会转为正常模式</p>
<p>互斥锁的数据结构如下，整体空间只有 8 个字节</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  state <span class="type">int32</span>    <span class="comment">// 当前互斥锁的状态</span></span><br><span class="line">  sema  <span class="type">uint32</span>   <span class="comment">// 用于控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>互斥锁 Metux 的使用需要注意：</em></strong></p>
<ul>
<li>Lock 和 Unlock 一定需要成对使用</li>
<li>如果函数调用传递了互斥锁，函数参数应该为指针，否则函数的值传递特性，函数内再次进行加锁解锁，将会导致死锁</li>
</ul>
<h5 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h5><p><code>sync.RWMutex</code> 是读写互斥锁，是从互斥锁上演变的，颗粒度更新的锁，即允许并发读操作，但是不允许并发读写，并发写写操作，因此 <strong>RWMetux 更加适合读多写少的场景使用</strong></p>
<p>RWMutex 结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  w           Mutex       <span class="comment">// 复用互斥锁提供的能力</span></span><br><span class="line">  writerSem   <span class="type">uint32</span>      <span class="comment">// 写等待读</span></span><br><span class="line">  readerSem   <span class="type">uint32</span>      <span class="comment">// 读等待写</span></span><br><span class="line">  readerCount <span class="type">int32</span>       <span class="comment">// 存储了当前正在执行的读操作数量</span></span><br><span class="line">  readerWait  <span class="type">int32</span>       <span class="comment">// 当写操作被阻塞时等待的读操作个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h5><p><code>sync.WaitGroup</code> 可以等待一组 Goroutine 的返回，比较常见的使用场景是批量发出 RPC 或者 HTTP 请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">requests := []*Request&#123;...&#125;</span><br><span class="line"></span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="built_in">len</span>(requests))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, request := <span class="keyword">range</span> requests &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(r *Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// res, err := service.call(r)</span></span><br><span class="line">  &#125;(request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group 检查点，检查所有 goroutine 是否全部完成</span></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>WaitGroup 提供了三个方法 Add，Done，Wait：</p>
<ul>
<li><p>Add，用来设置 WaitGroup 的计数值</p>
</li>
<li><p>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)</p>
</li>
<li><p>Wait，调用这个方法后会一直阻塞，直到 WaitGroup 的计数值变为 0</p>
<p>注意事项：</p>
</li>
<li><p>Waitgroup 的所有 Add 都都必须在 Wait 之前设置</p>
</li>
<li><p>虽然 Add 可以传负数来将计数器做减法，但还是要用 Done 来处理完成</p>
</li>
<li><p>不同于 Add 和 Wait，Done 方法需要在每一个 goroutine 中使用，否则会死锁</p>
</li>
</ul>
<h6 id="ErrorGroup"><a href="#ErrorGroup" class="headerlink" title="ErrorGroup"></a>ErrorGroup</h6><p>Waitgroup 的协同等待在并发原语中使用频率非常高，但是 waitgroup 无法传播这一批 goroutine 中发生错误后的消息，和上下文取消的功能</p>
<p>所以 go 的扩展库 <code>golang.org/x/sync/errgroup</code> 提供了 ErrorGroup 这个原语，可以看做是 waitgroup 的增强版，适用于需要有错误处理需求的协同场景</p>
<p>ErrorGroup 会将执行的 goroutine 遇到的第一个错误返回，并在出现错误时会自动调用 context 的 cancel 方法取消同步信号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  eg, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    i := i</span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">      time.Sleep(<span class="number">2</span> * time.Second) </span><br><span class="line"></span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 监听 context 信号</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;Canceled:&quot;</span>, i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">90</span> &#123;</span><br><span class="line">          fmt.Println(<span class="string">&quot;Error:&quot;</span>, i)</span><br><span class="line">          <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Error: %d&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;End:&quot;</span>, i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := eg.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h5><p><code>sync.Once</code>可以保证在 Go 程序运行期间的某段代码只会执行一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  o := &amp;sync.Once&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      o.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          fmt.Println(<span class="string">&quot;only once&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h5><p><code>sync.Cond</code>可以让一组的 Goroutine 都在满足特定条件时被唤醒，<strong>每一个</strong> <strong><code>sync.Cond</code></strong> <strong>结构体在初始化时都需要传入一个互斥锁</strong></p>
<p>Cond 条件锁提供的方法：</p>
<ul>
<li><code>sync.Cond.Wait</code> 在调用之前一定要使用获取互斥锁，否则会触发程序崩溃</li>
<li><code>sync.Cond.Signal</code> 唤醒的 Goroutine 都是队列最前面、等待最久的 Goroutine</li>
<li><code>sync.Cond.Broadcast</code> 会按照一定顺序广播通知等待的全部 Goroutine</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status <span class="type">int64</span>     <span class="comment">// 创建一个条件判断变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)     <span class="comment">// 通过互斥锁创建一个 cond 条件锁</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> listen(c)                       <span class="comment">// 开启 10 个协程，每个都执行 listen 方法监听条件变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)          <span class="comment">// 延迟 1 秒后，启动 broadcast 协程</span></span><br><span class="line">  <span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)        <span class="comment">// 创建一个系统信号的通道</span></span><br><span class="line">  signal.Notify(ch, os.Interrupt)      <span class="comment">// 通知系统将 os.Interrupt 信号（通常是 Ctrl+C）发送到这个通道</span></span><br><span class="line">  &lt;-ch                                 <span class="comment">// 没有 Ctrl+C 时，主 goroutine 会阻塞在这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">  c.L.Lock()                           <span class="comment">// 锁定条件互斥锁，使 broadcast 是线程安全</span></span><br><span class="line">  atomic.StoreInt64(&amp;status, <span class="number">1</span>)        <span class="comment">// 通过原子操作，设置 status 条件变量的值为 1</span></span><br><span class="line">  c.Broadcast()                        <span class="comment">// 条件锁发送广播信号，唤醒所有等待条件的 goroutine</span></span><br><span class="line">  c.L.Unlock()                         <span class="comment">// 释放条件互斥锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">  c.L.Lock()                           <span class="comment">// 锁定条件互斥锁，使 listen 是线程安全</span></span><br><span class="line">  <span class="keyword">for</span> atomic.LoadInt64(&amp;status) != <span class="number">1</span> &#123; <span class="comment">// 原子操作，读取 status 变量值</span></span><br><span class="line">    c.Wait()                           <span class="comment">// status 不等于 1，则继续等待</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;listen&quot;</span>)                <span class="comment">// status 条件变量确认通过，10 个 goroutine 执行打印</span></span><br><span class="line">  c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h3><p>应用程序运行会有堆（Heap）和栈（Stack）两种内存，GC 的作用是回收堆内存，栈内存则用于存储函数中局部变量和调用栈，这些内存使用完就可以被释放，所以由编译器通过指令自动清理</p>
<p>在 py 中垃圾回收机制是引用计数，标记-清除，分代回收三种。在 go 中主要是三色标记清除算法</p>
<h4 id="三色标记清除"><a href="#三色标记清除" class="headerlink" title="三色标记清除"></a>三色标记清除</h4><p><strong>标记-清除算法有个非常明显的问题，就是需要 STW（stop the world）暂停所有线程来实现安全地标记和清除。且每次 STW 期间，需要完整遍历 heap 来得到不可达的需清理垃圾，每次清理后还会造成一定的碎片</strong></p>
<p>Go 经过历代优化，在 1.5 版本开始使用三色标记清除来并发处理垃圾回收，三色标记是将程序中的对象分为白色，黑色和灰色</p>
<p><strong>白色：潜在垃圾</strong></p>
<p><strong>黑色：活跃对象，从根节点可达，以及没有其他引用指针的对象</strong></p>
<p><strong>灰色：活跃对象，存在对白色对象的引用</strong></p>
<p>初始阶段，所有对象都会被标记为白色。然后会从根节点遍历所有对象，将从根节点直接可达的对象标记成灰色，加入到灰色对象集合，接着遍历灰色对象集合，将其中一个灰色对象放置到黑色对象集合中，同时将该黑色对象所指向的对象加入到灰色对象集合，然后就是重复此步骤直到没有灰色对象</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgyODcxM2EyMGFmNzRmN2QyZmFkYzYxYzFkN2ExYTFfTjZlOWwza0xOOHBBZ2s1aTF4TVpUSk1peGt0RUVzWk1fVG9rZW46SUdoOGJPUlEzb1BCMGp4N3RmemNETDVXbjVkXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<p>然后垃圾回收器就会对白色的垃圾对象进行回收，因为这些对象程序没有引用，程序不存在依赖可以被回收，例如下图的 D 对象</p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E1NGU1YzA4NTFkYWU2NWY1NzFlMTJhOGUzOTdlYWNfQ2tpVDlTVkFla2VMWHppdlFMRVpHRmRsRGRrUjVubzJfVG9rZW46TFJwSWJsYU1kb2kwUGp4dkJ0RmMzTUl0bnhiXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<p>但是三色标记清除本身并不能并发执行，需要依赖 STW 来确保安全，因为假设程序在垃圾回收处理过程中，并发处理将 A 对象指向 D 对象，此时三色标记中已经没有灰色对象，这个 D 对象就会被错误回收</p>
<p>因此 go 在三色标记清除基础上增加屏障技术，来实行并发和增量的标记对象，要达到这个需要达成强三色不变性或弱三色不变性</p>
<p><strong>强三色不变性：黑色对象不能指向白色对象，只能指向灰色或黑色对象</strong></p>
<p><strong>弱三色不变性：黑色对象所指向的白色对象，必须要包含一个灰色对象经过的（多个）白色对象的路径</strong></p>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=YjliMTE0ZWYwZDg1NWMxMjMxMWRlNGQ4M2EwNTNkZjZfcXFUSEdrYXhSNGM3OFNMSlllTEVDNmtPbXVxZWMyT2lfVG9rZW46R2NLQWI3WTBZb0ZpRXV4SXdRamNTbkdQbmNlXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<p><strong>Go 分被引入了插入写屏障和删除写屏障两种技术来大大缩短 STW 的时间</strong></p>
<h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h4><ul>
<li>插入写屏障，简单来说就是在并发过程中，对象指向发生改变后，依然确保能将原先的对象保留，例如下图的 B 对象，在 A 将指向触发写屏障指到 C 上后，C 对象按照强三色逻辑会被标记灰色，而 B 对象按照三色标记逻辑遍历 B 对象后将 B 变为黑色<ul>
<li>插入写屏障，只作用在堆空间，如果是函数调用栈，最会需要再次通过 STW 暂停保护，对栈空间进行三色标记清楚逻辑的遍历，依次来确保栈空间下对象不会被错误回收</li>
</ul>
</li>
</ul>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJhNWE2MDc5MTUyNmU4MTYwNjE5MzJkNmRiZDdlYThfcHBtZWZkYVE3SUlsU1huTTVkS2hXdzF1ZlNxbzk3Y25fVG9rZW46VVQzcWJBbmlFb2NJRnF4SzZYNmMwUWVubnlkXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h4><ul>
<li>删除写屏障，能够保留住对象避免并发下被错误回收，例如下图 B 到 C 的指向被删除，A 将指针指向了 C，B 为删除对象则 B 会被标记为灰色，C 对象得到 A 指向被标会灰色，进行下一轮遍历 C 对象变为黑色，B 对象没有下游，但 B 是灰色所以按照逻辑被保留并标记为黑色，在进入到下一轮后会重新按照三色逻辑将 B 回收</li>
</ul>
<p><img src="https://h7xe2vtda6.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FkYmIyOTcyMTE4ZDc2MTg4NzNjZDYyNmM2NGJmZGVfME1qQVdEREYxQlNlZFlobVhRVFp5elpOYmxtaVJ4SjRfVG9rZW46VDhpZGJHVlhWb051TjR4M2VJQ2MxQlFlbnhjXzE3NTIzMDI3OTM6MTc1MjMwNjM5M19WNA" alt="img"></p>
<h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><p>由于插入和删除写屏障都有各自的一些问题，在 1.8 版本 go 的 GC 改为三色标记清除 + 混合写屏障。混合写屏障结合了插入和删除写屏障：</p>
<ul>
<li>GC 开始时，优先将栈空间上所有可达对象标记黑色（避免栈的二次遍历）</li>
<li>GC 过程中，栈上新创建的对象同样会标记为黑色</li>
<li>被删除的对象会被标记为灰色</li>
<li>被添加的对象会被标记为灰色</li>
</ul>
<h3 id="Gin-框架"><a href="#Gin-框架" class="headerlink" title="Gin 框架"></a>Gin 框架</h3><h4 id="初始化服务"><a href="#初始化服务" class="headerlink" title="初始化服务"></a>初始化服务</h4><p>通常创建一个 gin 的 server，都是使用 gin.Default() 去构建默认的 gin 服务，这其中会调用 New 方法创建，然后会再使用 Use 方法去加上  Logger 和 Recovery 这两个 middleware</p>
<p>所以其实也可以直接使用 New 去出初始化，不过一般都是使用 Default</p>
<h4 id="请求结构体绑定"><a href="#请求结构体绑定" class="headerlink" title="请求结构体绑定"></a>请求结构体绑定</h4><p>以常见 json 数据格式为例，gin 中 gin.Context 提供的请求体序列化的方法是 ShouldBind 和 ShouldBindBodyWith 两个方法</p>
<p><strong>ShouldBind 方法只允许 context 调用一次进行结构体绑定，第二次调用该方法则会得到 EOF</strong></p>
<p>ShouldBindBodyWith 方法会都多一个参数来指定序列化请求体的格式，例如：binding.JSON，不同于 ShouldBind 方法的是 bindbodywith 允许在请求处理函数中多次调用，来实现将请求中的数据序列化到不同的结构体中</p>
<p>补充：除了 Shouldbind，还有 Bind，对应的是 MustBind 方法，和 should 的区别是 must 的绑定方法，如果出现字段无法匹配绑定则会直接中断处理请求，返回 400 的错误响应</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ShouldBind（手动处理错误）</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.JSON(<span class="number">400</span>, gin.H&#123;<span class="string">&quot;code&quot;</span>: <span class="number">1001</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Invalid input&quot;</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Bind（自动处理错误）</span></span><br><span class="line"><span class="keyword">if</span> err := c.BindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 自动返回 400 + 默认错误格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：请求的 json 数据中包含的时间类型的话，结构体中可以指定时间值的格式，例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  Birthday time.Time <span class="string">`form:&quot;birthday&quot; time_format:&quot;20060102&quot; time_utc:&quot;1&quot;`</span>  </span><br><span class="line">  <span class="comment">// time_utc:&quot;1&quot; 表示将 Birthday 的值转为 utc 事件，不设置这个 tag 就是本地时间</span></span><br><span class="line">  <span class="comment">// 注意，如果前端请求参数的格式不是 20060102，在使用 bind 方法时是会报错的</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：对于动态路由的参数，可以使用 context 的 Param 方法去获取路由上动态参数的值，也可以使用 ShouldBindUri 的方法将路由上的动态参数直接绑定到结构体上</p>
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Person <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ID   <span class="type">string</span> `uri:<span class="string">&quot;id&quot;</span> binding:<span class="string">&quot;required,uuid&quot;</span>`</span><br><span class="line">  Name <span class="type">string</span> `uri:<span class="string">&quot;name&quot;</span> binding:<span class="string">&quot;required&quot;</span>`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件的设置位置可以有三种，他们的作用范围是逐个减少的：</p>
<ul>
<li><p>全局中间件</p>
</li>
<li><p>路由组中间件</p>
</li>
<li><p>路由中间件</p>
<p>全局中间件，就是在服务入口初始化后，可以通过 Use 去设置，和使用 Default 创建 gin 里的默认的两个中间件一样</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e := gin.Default()</span><br><span class="line"></span><br><span class="line">e.Use(middlewares.RequestMiddleware())  <span class="comment">// 全局中间件</span></span><br><span class="line"></span><br><span class="line">e.GET(<span class="string">&quot;/health&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;server is health&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>路由组中间件的设置其实也是一样的，但还有另一种写法，就是在 Group 方法的第二参数开始就是中间件的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRouterMiddleware1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;in AdminRouterMiddleware1&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;out AdminRouterMiddleware1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRouterMiddleware2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;in AdminRouterMiddleware2&quot;</span>)</span><br><span class="line">  c.Next()</span><br><span class="line">  fmt.Println(<span class="string">&quot;out AdminRouterMiddleware2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRouterInit</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">  AdminRouters := e.Group(<span class="string">&quot;/admin&quot;</span>, AdminRouterMiddleware1)</span><br><span class="line">  AdminController := &amp;controllers.AdminController&#123;&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    AdminRouters.GET(<span class="string">&quot;/users&quot;</span>, AdminRouterMiddleware2, AdminController.GetUsers)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，在中间件的函数中，可以使用 context 的 Set 设置可以在其他中间件或路由 controller 函数内使用的全局变量，通过 context 的 Get 方法可以读取，这个方法会返回两个值，第一个是要获取的值，第二个值是 key 是否存在</p>
<p><strong>补充：中间件函数中如果需要使用 go routine 的话，这个协程内需要使用 context 的副本，也就是需要先进行 context 的 Copy 方法来拷贝副本</strong></p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>调用 context 的 SetCookie 方法可以设置 cookie，分别有以下这些参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetCookie(</span><br><span class="line">  name, </span><br><span class="line">  value <span class="type">string</span>, </span><br><span class="line">  maxAge <span class="type">int</span>,        <span class="comment">// 如果要删除一个 cookie，需要通过 setcookie 将过期时间设置为负数</span></span><br><span class="line">  path,              <span class="comment">// 表示 cookie 生效路径，一般都是 &quot;/&quot; 表示全站有效，也可以是某一个路由路径</span></span><br><span class="line">  domain <span class="type">string</span>,     <span class="comment">// 表示 cookie 生效域名，默认是当前域名，设为 .example.com 时，所有子域名（如 api.example.com）均可访问</span></span><br><span class="line">  secure,            <span class="comment">// 设置为 true 时，表示只有 https 请求才会携带此 cookie</span></span><br><span class="line">  httpOnly <span class="type">bool</span>) &#123;   <span class="comment">// 设置为 true 时，表示允许 js 去操作该 cookie</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>非常流程的应该是 logrus 和 zap，后者是非常适合高并发的项目，在性能上要比 logrus 高出几倍，而 logrus 虽然性能不及 zap，但简单易用，只是目前此项目已经不再维护</p>
<p>搭配 lumberjack 可以实现日志轮转</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccessLogger</span><span class="params">()</span></span> *logrus.Logger &#123;</span><br><span class="line">  accessLogger := logrus.New()</span><br><span class="line">  accessLogger.SetOutput(&amp;lumberjack.Logger&#123;</span><br><span class="line">    Filename:   <span class="string">&quot;logs/access.log&quot;</span>, <span class="comment">// 日志文件路径</span></span><br><span class="line">    MaxSize:    <span class="number">100</span>,               <span class="comment">// 每个日志文件的最大大小（MB）</span></span><br><span class="line">    MaxBackups: <span class="number">5</span>,                 <span class="comment">// 保留旧日志文件的最大数量</span></span><br><span class="line">    MaxAge:     <span class="number">5</span>,                 <span class="comment">// 保留旧日志文件的最大天数（优先于 MaxBackups）</span></span><br><span class="line">    Compress:   <span class="literal">true</span>,              <span class="comment">// 是否压缩旧日志文件</span></span><br><span class="line">    LocalTime:  <span class="literal">true</span>,              <span class="comment">// 使用本地时间命名日志文件</span></span><br><span class="line">  &#125;)</span><br><span class="line">  accessLogger.SetFormatter(&amp;logrus.JSONFormatter&#123;</span><br><span class="line">    TimestampFormat: <span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="comment">// 设置时间格式</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accessLogger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>浏览器的同源策略是禁止进行 A 向 B 跨域请求的，同源策略包含：</p>
<ul>
<li>A 和 B 的域名不同，不允许跨源</li>
<li>A 和 B 的服务端口不同，不允许跨源</li>
<li>A 和 B 的协议不同，一个是 http ，一个是 https，同样不允许跨源</li>
</ul>
<p>测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以浏览器访问百度，然后在控制台中使用以下 js 发起请求</span></span><br><span class="line"><span class="keyword">var</span> jq = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">jq.<span class="property">src</span> = <span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(jq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $=jQuery.<span class="title function_">noConflict</span>();</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8080/api&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Gin 中没有设置 CORS 的情况下，会得到这样的错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span> to <span class="title class_">XMLHttpRequest</span> at <span class="string">&#x27;http://127.0.0.1:8080/api&#x27;</span> <span class="keyword">from</span> origin <span class="string">&#x27;https://www.baidu.com&#x27;</span> has been blocked by <span class="variable constant_">CORS</span> <span class="attr">policy</span>: <span class="title class_">No</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> header is present on the requested resource.</span><br></pre></td></tr></table></figure>
<p>所以实际情况下，这个功能是需要在服务端开启 CORS 来允许跨域资源共享，这其中又分为简单请求和非简单请求</p>
<p>简单请求：即 GET，POST，HEAD，且请求头不包含自定义头部标签，那服务端只需在响应头设置 Access-Control-Allow-Origin 为 *，来表示允许互联网任何域名访问</p>
<p>非简单请求：例如 PUT，DELETE，请求头包含自定义标签，请求中 Content-Type 是 application/json 这类情况，那么客户端请求服务端时，会先发送一个 OPTIONS 的预检请求，来获取服务端允许哪些请求方法，哪些请求源，以及哪些请求头</p>
<p>Gin 中开启 CORS，是通过 <code>github.com/gin-contrib/cors</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-contrib/cors&quot;</span></span><br><span class="line">  <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  e := gin.Default()</span><br><span class="line">  e.Use(cors.New(cors.Config&#123;</span><br><span class="line">    AllowOrigins:     []<span class="type">string</span>&#123;<span class="string">&quot;*&quot;</span>&#125;, <span class="comment">// 明确允许访问的域名</span></span><br><span class="line">    AllowMethods:     []<span class="type">string</span>&#123;<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;PATCH&quot;</span>&#125;,    <span class="comment">// 允许的http方法</span></span><br><span class="line">    AllowHeaders:     []<span class="type">string</span>&#123;<span class="string">&quot;Origin&quot;</span>&#125;,          <span class="comment">// 允许客户端在请求中携带的头部字段</span></span><br><span class="line">    ExposeHeaders:    []<span class="type">string</span>&#123;<span class="string">&quot;Content-Length&quot;</span>&#125;,  <span class="comment">// 允许客户端访问的额外响应头（默认只能访问简单头，如 Cache-Control、Content-Language 等）</span></span><br><span class="line">    AllowCredentials: <span class="literal">true</span>,                        <span class="comment">// 允许跨域请求携带凭据</span></span><br><span class="line">    MaxAge: <span class="number">12</span> * time.Hour,                        <span class="comment">// 预检请求（OPTIONS）的缓存时间</span></span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 是一种进程间<strong>通信协议</strong>。它允许程序调用另一台机器（或同一台机器的其他进程）上的 <strong>函数/过程</strong>，实现像在调用本地函数一样，隐藏了网络通信的细节</p>
<p><strong>核心思想：</strong></p>
<ul>
<li>调用者像调用本地函数一样调用远程函数</li>
<li>底层通过序列化（编码）请求、网络传输、远程反序列化得到请求参数并调用执行，再将结果返回</li>
</ul>
<h4 id="用-go-写一个-rpc-服务-demo"><a href="#用-go-写一个-rpc-服务-demo" class="headerlink" title="用 go 写一个 rpc 服务 demo"></a>用 go 写一个 rpc 服务 demo</h4><p>服务端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net&quot;</span></span><br><span class="line">  <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明远程调用的函数，一般都是放在结构体中</span></span><br><span class="line"><span class="keyword">type</span> Users <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 rpc 服务的请求和响应的结构体   注意，这个结构体在客户端和服务端都需要定义</span></span><br><span class="line"><span class="keyword">type</span> UserReq <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id  <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRes <span class="keyword">struct</span> &#123;</span><br><span class="line">  Success <span class="type">bool</span></span><br><span class="line">  Data []UserReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Users)</span></span> ListUsers (req UserReq, res *UserRes) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 模拟查询用户列表</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;查询用户列表&quot;</span>, req)   <span class="comment">// 查询用户列表 &#123;0 李四 0 &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟数据库数据</span></span><br><span class="line">  userData := []UserReq&#123;</span><br><span class="line">    &#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;张三&quot;</span>, Age: <span class="number">18</span>, Phone: <span class="string">&quot;12345678901&quot;</span>&#125;,</span><br><span class="line">    &#123;Id: <span class="number">2</span>, Name: <span class="string">&quot;李四&quot;</span>, Age: <span class="number">20</span>, Phone: <span class="string">&quot;12345678902&quot;</span>&#125;,</span><br><span class="line">    &#123;Id: <span class="number">3</span>, Name: <span class="string">&quot;王五&quot;</span>, Age: <span class="number">22</span>, Phone: <span class="string">&quot;12345678903&quot;</span>&#125;,</span><br><span class="line">    &#123;Id: <span class="number">4</span>, Name: <span class="string">&quot;李六&quot;</span>, Age: <span class="number">22</span>, Phone: <span class="string">&quot;12345678904&quot;</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 声明 rpc 服务的响应数据</span></span><br><span class="line">  userList := []UserReq&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟查询条件</span></span><br><span class="line">  <span class="keyword">if</span> req.Id &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入了 Id，则只返回该用户</span></span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> userData &#123;</span><br><span class="line">      <span class="keyword">if</span> user.Id == req.Id &#123;</span><br><span class="line">        userList = <span class="built_in">append</span>(userList, user)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入了 Name，则返回所有匹配的用户</span></span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> userData &#123;</span><br><span class="line">      <span class="keyword">if</span> user.Name == req.Name &#123;</span><br><span class="line">        userList = <span class="built_in">append</span>(userList, user)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有传入查询条件，则返回所有用户</span></span><br><span class="line">    userList = userData</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *res = UserRes&#123;</span><br><span class="line">    Success: <span class="literal">true</span>,</span><br><span class="line">    Data: userList,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 注册 rpc 服务</span></span><br><span class="line">  err := rpc.RegisterName(<span class="string">&quot;Users&quot;</span>, <span class="built_in">new</span>(Users))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;rpc 注册 User 失败&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动 rpc 服务</span></span><br><span class="line">  listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8081&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;rpc 启动失败&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;rpc 服务启动成功，监听端口：8081&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> listener.Close() <span class="comment">// 确保在程序结束时关闭监听器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 等待客户端连接</span></span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;rpc 连接失败&quot;</span>, err)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> rpc.ServeConn(conn) <span class="comment">// 启动一个协程处理连接</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserReq <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id  <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Age <span class="type">int</span></span><br><span class="line">  Phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRes <span class="keyword">struct</span> &#123;</span><br><span class="line">  Success <span class="type">bool</span></span><br><span class="line">  Data []UserReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 Dial 方法链接 rpc 服务端</span></span><br><span class="line">  conn, err1 := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8081&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;连接 rpc 服务失败&quot;</span>, err1)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close() <span class="comment">// 确保在程序结束时关闭连接</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> res UserRes</span><br><span class="line">  <span class="comment">// 调用远程方法 ListUsers</span></span><br><span class="line">  conn.Call(<span class="string">&quot;Users.ListUsers&quot;</span>, UserReq&#123;Name: <span class="string">&quot;李四&quot;</span>&#125;, &amp;res)</span><br><span class="line">  err2 := conn.Call(<span class="string">&quot;Users.ListUsers&quot;</span>, UserReq&#123;Name: <span class="string">&quot;李四&quot;</span>&#125;, &amp;res)</span><br><span class="line">  <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;调用 rpc 服务失败&quot;</span>, err2)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;调用 rpc 服务成功&quot;</span>, res)   <span class="comment">// 调用 rpc 服务成功 &#123;true [&#123;2 李四 20 12345678902&#125;]&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="gPRC"><a href="#gPRC" class="headerlink" title="gPRC"></a>gPRC</h4><p><strong>gRPC</strong> 是 Google 开源的高性能、通用的 <strong>RPC 框架</strong>，且支持多种语言，用来在分布式系统中进行服务间通信，基于：</p>
<ul>
<li><strong>HTTP/2</strong>（高效双向流传输，支持多路复用、头部压缩、流控）</li>
<li><strong>Protocol Buffers（protobuf）</strong>（高效序列化）</li>
</ul>
<p>在 gRPC 中会使用 .proto 这个文件，需要在这个文件中定义接口，然后根据使用的开发语言去生成客户端与服务端使用请求响应包</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/4075015966/">http://example.com/4075015966/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover45.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2133446919/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover46.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 基础</div></div></a></div><div class="next-post pull-right"><a href="/4209932858/"><img class="next-cover" src="https://wei-foun.github.io/img/cover44.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker 容器网络</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">基础整理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">初始化和依赖管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9B%B6%E5%80%BC"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本数据类型和零值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">自定义数据类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string-%E4%B8%8E-byte"><span class="toc-number">1.3.1.</span> <span class="toc-text">string 与 []byte</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC"><span class="toc-number">1.4.</span> <span class="toc-text">数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94"><span class="toc-number">1.6.</span> <span class="toc-text">布尔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">1.7.</span> <span class="toc-text">切片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">去重</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">1.8.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.9.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.10.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">闭包函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defer"><span class="toc-number">1.12.2.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#panic-%E4%B8%8E-recover"><span class="toc-number">1.12.3.</span> <span class="toc-text">panic 与 recover</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Time-%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.4.</span> <span class="toc-text">Time 模块基本使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.13.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">1.13.1.</span> <span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">1.14.</span> <span class="toc-text">错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#make-%E4%B8%8E-new"><span class="toc-number">1.15.</span> <span class="toc-text">make 与 new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8E%E5%88%86%E6%94%AF"><span class="toc-number">1.16.</span> <span class="toc-text">循环与分支</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">2.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%B3%95%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">三法则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GMP"><span class="toc-number">3.1.</span> <span class="toc-text">GMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">3.2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#select"><span class="toc-number">3.2.1.</span> <span class="toc-text">select</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">3.3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mutex"><span class="toc-number">3.3.1.</span> <span class="toc-text">Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RWMutex"><span class="toc-number">3.3.2.</span> <span class="toc-text">RWMutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WaitGroup"><span class="toc-number">3.3.3.</span> <span class="toc-text">WaitGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ErrorGroup"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">ErrorGroup</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Once"><span class="toc-number">3.3.4.</span> <span class="toc-text">Once</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cond"><span class="toc-number">3.3.5.</span> <span class="toc-text">Cond</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%EF%BC%88Garbage-Collection%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">GC（Garbage Collection）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">4.1.</span> <span class="toc-text">三色标记清除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.2.</span> <span class="toc-text">插入写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.3.</span> <span class="toc-text">删除写屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.4.</span> <span class="toc-text">混合写屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gin-%E6%A1%86%E6%9E%B6"><span class="toc-number">5.</span> <span class="toc-text">Gin 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">初始化服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%91%E5%AE%9A"><span class="toc-number">5.2.</span> <span class="toc-text">请求结构体绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text">中间件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie"><span class="toc-number">5.4.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">5.5.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">5.6.</span> <span class="toc-text">CORS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC"><span class="toc-number">6.</span> <span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-go-%E5%86%99%E4%B8%80%E4%B8%AA-rpc-%E6%9C%8D%E5%8A%A1-demo"><span class="toc-number">6.1.</span> <span class="toc-text">用 go 写一个 rpc 服务 demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gPRC"><span class="toc-number">6.2.</span> <span class="toc-text">gPRC</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2938300177/" title="k8s-pod发布部署"><img src="https://wei-foun.github.io/img/cover50.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s-pod发布部署"/></a><div class="content"><a class="title" href="/2938300177/" title="k8s-pod发布部署">k8s-pod发布部署</a><time datetime="2025-08-02T16:35:03.000Z" title="发表于 2025-08-03 00:35:03">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1213981086/" title="k8s-调度"><img src="https://wei-foun.github.io/img/cover49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s-调度"/></a><div class="content"><a class="title" href="/1213981086/" title="k8s-调度">k8s-调度</a><time datetime="2025-08-02T07:25:30.000Z" title="发表于 2025-08-02 15:25:30">2025-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/558590641/" title="k8s整理"><img src="https://wei-foun.github.io/img/cover48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s整理"/></a><div class="content"><a class="title" href="/558590641/" title="k8s整理">k8s整理</a><time datetime="2025-07-31T07:24:29.000Z" title="发表于 2025-07-31 15:24:29">2025-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/466764255/" title="airflow整理"><img src="https://wei-foun.github.io/img/cover47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="airflow整理"/></a><div class="content"><a class="title" href="/466764255/" title="airflow整理">airflow整理</a><time datetime="2025-07-12T07:04:30.000Z" title="发表于 2025-07-12 15:04:30">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux 基础"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 基础"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux 基础">Linux 基础</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover45.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>