<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>常见算法 | </title><meta name="keywords" content="python,算法"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常见排序算法   排序算法 最差时间分析 平均时间复杂度 稳定性 空间复杂度    冒泡排序 O(n²) O(n²) 稳定 O(1)   选择排序 O(n²) O(n²) 不稳定 O(1)   插入排序 O(n²) O(n²) 稳定 O(1)   快速排序 O(n²) O(nlogn) 不稳定 O(logn)   堆排序 O(nlogn) O(nlogn) 不稳定 O(1)   归并排序 O(nl">
<meta property="og:type" content="article">
<meta property="og:title" content="常见算法">
<meta property="og:url" content="http://example.com/3963924866/index.html">
<meta property="og:site_name">
<meta property="og:description" content="常见排序算法   排序算法 最差时间分析 平均时间复杂度 稳定性 空间复杂度    冒泡排序 O(n²) O(n²) 稳定 O(1)   选择排序 O(n²) O(n²) 不稳定 O(1)   插入排序 O(n²) O(n²) 稳定 O(1)   快速排序 O(n²) O(nlogn) 不稳定 O(logn)   堆排序 O(nlogn) O(nlogn) 不稳定 O(1)   归并排序 O(nl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover35.jpg">
<meta property="article:published_time" content="2022-08-21T15:39:45.000Z">
<meta property="article:modified_time" content="2025-04-01T17:58:07.096Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="python">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover35.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/3963924866/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常见算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-02 01:58:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover35.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常见算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-21T15:39:45.000Z" title="发表于 2022-08-21 23:39:45">2022-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-01T17:58:07.096Z" title="更新于 2025-04-02 01:58:07">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常见算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th>最差时间分析</th>
<th>平均时间复杂度</th>
<th>稳定性</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n²)</td>
<td>O(nlogn)</td>
<td>不稳定</td>
<td>O(logn)</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>稳定</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>​    简单来说就是用来衡量算法运行的时间，例如最简单的 range(n) 的 for 循环来说，最后遍历的元素是 n-1 个，整个时间复杂度上可以看成如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">时间复杂度 = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + .... + (n-<span class="number">4</span>) + (n-<span class="number">3</span>) + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)</span><br><span class="line">          = Cn   (C是一个常数) </span><br><span class="line">          = n</span><br><span class="line">          = O(n）</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">              </span><br><span class="line">时间复杂度 = <span class="number">1</span> * [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)] + <span class="number">2</span> * [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)] + ...</span><br><span class="line">          = [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)] * [<span class="number">1</span> + <span class="number">2</span> .... + (n-<span class="number">2</span>) + (n-<span class="number">1</span>)]</span><br><span class="line">          = n * n</span><br><span class="line">          = O(n²)</span><br></pre></td></tr></table></figure>
<p>​    所以，可以简单理解 <strong>一次循环</strong> 的执行，时间复杂度上就是 <strong>O(n)</strong>；一般来说，时间复杂度高的算法会比时间复杂度低的算法要慢；并且如果算法在循环中，每一次循环会少遍历原来的一半的话，时间复杂度上可以简单看作是 O(logn)</p>
<p>​    常见的时间复杂度的高低比较：<strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n²logn) &lt; O(n³)</strong> </p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>​    和时间复杂度一样，用来评估算法在空间上内存的占用大小，如果算法执行不涉及需要申请空间的话，就可以看作是 O(1) 的，一般来说算法的效率都是 <strong>“空间换时间”</strong></p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>​    <strong>最简单的理解：</strong>每一轮遍历，都是将当轮循环的最大值一层层往 “上”（往数组最后）抛出</p>
<p>​    简单说明：一个数组 [5,1,7,2] 进行冒泡排序，会有两个指针，第一个指针 i 表示轮数，第二 j 的则是元素的下标索引指针</p>
<p>​    i = 0 的遍历：i 指向 5，先将数组的第 0 和 1 位（即 j 与 j+1）进行比较，即比较 5 和 1，因为 5 &gt; 1，所以交换两者的位置后得到 [1,5,7,2]，完成后将指针 j + 1，继续遍历数组，同样的方法比较 5 和 7，因为 5 &lt; 7，所以数组不变依然是 [1,5,7,2]，依次类推，继续遍历，最后第一轮完成返回的数组是 [1,5,2,7]</p>
<p>​    i = 1 的遍历：第一轮完成后，可见数组并不是有序的，所以第二轮遍历依然是将这一轮的最大值抛出，不过此时数组需要分成两部分，非有序和有序，有序的部分就是在第一轮中最末尾的元素，非有序就是末尾元素前的经过第一轮后的数组，所以对于第二轮来说，要遍历的就是 [1,5,2]，最后将这一次的最大值加入到有序数组中的第一个位置上</p>
<p>​    关于 i 的循环语句 <code>range(len(li) - 1)</code>，这个语句可以直接是 <code>range(len(li))</code>，但是 <code>-1</code> 是因为真正的排序其实由 j 的循环去操作，而 j 在第一轮就会冒出最大值到列表最后，<code>-1</code> 就省去了最后当排序完成后，i 还要去判断列表最后一个元素</p>
<p>​    关于 j 的循环语句 <code>range(len(li) - i - 1)</code>，同样可以直接是 <code>range(len(li) - 1)</code>，之所以是 <code>-i - 1</code> 同样是一种优化，因为 j 的每一轮会冒出最大值，到最后的有序数组部分，也就是说 i 完成一轮，数组最后的有序部分就会多一个值，<code>-i - 1</code> 就为为了减少对有序部分的再次比较，也就说第一次 j 冒出最大值 9 到有序部分后，下一次 j 的循环中比较只用比较无序部分</p>
<p>​    可见，对于冒泡排序来说，需要 n 轮的循环，所以对于无序的数组来说，一般的时间复杂度是 O(n²) </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"><span class="built_in">print</span>(li)                   <span class="comment"># [9, 2, 8, 6, 0, 5, 7, 3, 1, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bubble_sort(li))      <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>优化：</strong></p>
<p>​    上面的代码处理了大部分正常的情况，也说了一般的时间复杂度是 O(n²) ，但是如果对于一个数组来说，它看似是一个有序的，只是有一个元素穿插在了其他的位置上，例如 [1,4,2,6,8]，这里面 2 之后都是有序的，也就是这一轮只需要交换 4 和 2 就可以了，所以上面的代码还可以优化，加上一个标记，防止第一轮完成后去继续遍历，这个优化只是限于只用一轮遍历交换两个数的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> exchange:</span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>
<p>​    这样一来，对于类似 [1,4,2,6,8] 的数组，时间复杂度就是 O(n) 了</p>
<p>​    所有的循环都是可以用递归来实现的，所以上面的冒泡排序也可以用递归实现，但是使用递归方式在效率上会有所影响</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">li</span>):</span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; li[i+<span class="number">1</span>]:</span><br><span class="line">            li[i], li[i+<span class="number">1</span>] = li[i+<span class="number">1</span>], li[i]</span><br><span class="line">            exchange = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> exchange:</span><br><span class="line">        bubble_sort(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)                 <span class="comment"># [6, 1, 0, 8, 2, 5, 3, 9, 7, 4]</span></span><br><span class="line"><span class="built_in">print</span>(bubble_sort(ll))    <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>​    <strong>最简单的理解：</strong>每一轮遍历，都将数组中的最小值放到最前面</p>
<p>​    简单说明：对 [2,4,6,0,1] 进行选择排序，与冒泡一样会分成有序和无序两个部分，同样会有两个指针，指针 i 作为最小值的索引，指针 j 用来对数组遍历</p>
<p>​    i = 0 的遍历：首先，将数组索引 0 的元素作为最小值，使用 min_pos = i 标记最小值的索引，那么接下去的遍历就是从数组的第二个元素比较开始。如果数组的第二个元素大于第一个元素，就需要更改 min_pos 这个最小索引标记，将 min_pos 改为 j，然后指针 j 继续往后遍历和比较，只要比较出最小的值，就修改 min_pos 为 j。所以在第一轮结束，得到的数组是 [0,4,6,2,1]</p>
<p>​    i = 1 的遍历：首先，这一次 min_pos 的 i 值从 0 改为了 1，即这次开始分为了有序部分和无序部分，有序部分即 0，后面的 [4,6,2,1] 是无序部分，也就是这一轮需要遍历出其中的最小值，然后这个最小值成为这个数组的索引为 0 的第一位，即最后得到的数组是 [0, 1, 6, 2, 4]</p>
<p>​    之后的遍历，也是同样的思路，在 i = n 的位置开始，找到后面数组中的最小值后，两者的位置进行互换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li) - <span class="number">1</span>):</span><br><span class="line">        min_pos = i      <span class="comment"># 每一轮，都假设当前位置是最小的值</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(li)):    <span class="comment"># 从当前位置之后开始遍历比较</span></span><br><span class="line">            <span class="keyword">if</span> li[min_pos] &gt; li[j]:        <span class="comment"># 如果最小位置大于遍历位置，所以当前位置不是实际最小位置</span></span><br><span class="line">                min_pos = j                <span class="comment"># 重新赋值最小位置为当前判断得到的位置</span></span><br><span class="line">        li[i], li[min_pos] = li[min_pos], li[i]    <span class="comment"># 比较循环结束，将得到实际最小位置和当前以为最小位置互换</span></span><br><span class="line">    <span class="keyword">return</span> li </span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(len(li)):</span></span><br><span class="line">    <span class="comment">#    for j in range(i+1, len(li)):</span></span><br><span class="line">    <span class="comment">#        if li[i] &gt; li[j]:</span></span><br><span class="line">    <span class="comment">#            li[i], li[j] = li[j], li[i]</span></span><br><span class="line">    <span class="comment"># return li</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li)                     <span class="comment"># [4, 3, 1, 7, 2, 0, 9, 5, 8, 6]</span></span><br><span class="line"><span class="built_in">print</span>(select_sort(li))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>​    <strong>最简单的理解：</strong>就像按照点数整理纸牌一样，从无序区中拿取第一张牌依次和前面的比较大小</p>
<p>​    简单说明：对 [2,4,6,0,1] 进行插入排序，每一轮把无序区的第一个元素抽出，与前面的元素进行比较，前面的元素如果大于抽出的元素，则往后移动，一直到没有元素大于抽出的元素，就将其放到那个位置上</p>
<p>​    遍历流程：首先，依然是两个指针，指针 i 作为数组元素的整个遍历，指针 j 作为抽出元素与其前面位置的元素的比较。将抽取的数的元素（即 li[i]）赋值一个变量保存，然后指针 j 为当前 i 前一位（即 j = i -1），在 while 循环中一直遍历这个指针到 0 的位置，且将抽出的元素与其前面的元素比较，如果这些元素大于抽出的元素，就需要将抽出的位置重新赋值给大于其的元素，如此一来，可以实现将前面所有大于抽出元素的元素实现位置后移。到最后，循环条件不满足了，即 j - 1 = -1 了，就需要 +1 来让索引回到 0 的位置，并且将抽出的元素最后赋值给 0 的位置（注意：这里指的是最后的时候，其中如果遍历时，如果 j -1 后的元素不大于抽出的元素，就说明 j + 1 的位置就是抽出元素应该存在的位置）</p>
<p>​    也就是说，在 i = 3 时，即抽出元素是 0 的遍历中，数组的流程是：</p>
<p>​    [2,4,6,0,1]  &gt; [2,4,6,6,1] &gt; [2,4,4,6,1] &gt; [2,2,4,6,1] &gt; [0,2,4,6,1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:    <span class="comment"># li[j] 是当前位置前一位  # li[j] &gt; tmp 升序  li[j] &lt; tmp 降序</span></span><br><span class="line">            li[j + <span class="number">1</span>] = li[j]            <span class="comment"># li[j+1] 是当前位置</span></span><br><span class="line">            j -= <span class="number">1</span>                       <span class="comment"># 将遍历位置前移一位</span></span><br><span class="line">        li[j + <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li)                    <span class="comment"># [8, 5, 6, 1, 2, 7, 0, 4, 3, 9]</span></span><br><span class="line"><span class="built_in">print</span>(insert_sort(li))       <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>​    最重要的思路就是：<strong>分治法（divide and conquer）</strong>，整体来说快速排序分三个步骤</p>
<p>​    1）partition：选择基准分割数，将数组分割成两部分，基准数左边全部是小于基准数的数组，右边则都是大于的</p>
<p>​    2）对两个数组分别递归调用快排</p>
<p>​    3）整理最后的数组，将排序后的左边 + 基准数 + 右边</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    pivot = li[<span class="number">0</span>]</span><br><span class="line">    left_part = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">    right_part = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">    left_part = quick_sort(left_part)</span><br><span class="line">    right_part = quick_sort(right_part)</span><br><span class="line">    <span class="keyword">return</span> left_part + [pivot] + right_part</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(li)                    <span class="comment"># [2, 3, 5, 6, 8, 0, 4, 9, 7, 1]</span></span><br><span class="line"><span class="built_in">print</span>(quick_sort(li))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>​    需要知道的是，在上面的代码的中由于对左右两个部分是利用列表生成式去实现的，所以在空间复杂度上是 O(n) 的，但是这种方式和一般空间复杂度 O(logn) 的在执行上差别不会太大</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空间复杂度 O(logn) 的实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">li,left,right</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="string">    快速排序是不稳定的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    快速排序存在最坏情况，最坏情况下，时间复杂度为 O(n²)</span></span><br><span class="line"><span class="string">    即如果一个列表是倒叙的排列，这种情况下每次递归只少一个数</span></span><br><span class="line"><span class="string">    而如果是随机的数列，每次递归给分成一半</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(li,left,right)</span><br><span class="line">        quick_sort(li,left,mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(li, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">li,left,right</span>):</span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]</span><br><span class="line">    li[left] = tmp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">li = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(quick_sort(li,<span class="number">0</span>,<span class="built_in">len</span>(li)-<span class="number">1</span>))    <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>​    注意，虽然快排在理论上时间复杂度是 O(nlogn)，但实际上快排会受到实际数组排序而被影响，如果数据原本就是接近有序，那么利用基准数作为左右分解再去排序的时间复杂度则会退化到 O(n²)，主要的原因就是因为基准数的选择上有问题</p>
<p>​    简单实现上，在数据排序相对均匀的情况下，利用第一个或最后一个作为基准数作为分界点都可以达到平均的时间复杂度，但这种方式没有考虑到数据本身的特点，那么想要防止算法的退化，简单的一点的做法可以是通过三个数字来进行取中，或者是随机法</p>
<p>​    三数取中法，就是在数组区间中取出第一个，中间，最后一个数，然后对比这三个数，最后选择一个中间值作为基准数从而当做分界点，这样的做法相对来说每一次递归中数据的间隔相对固定，要比单纯直接利用一个数来分界会均匀一些，但是这也随数据大小而定，如果数据量很大，取中法的选择可能就需要由三个数变为五个数或是十个数</p>
<p>​    随机法，顾名思义就是在每次递归的区间中，随机选择一个随机值作为分界点，这样的做法也可以使最后的排序能在平均时间复杂度上，避免极端情况导致退化</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>​    先从简单的思路理解：假设一个数组可以分为两段，也就是两个有序的数组，通过整理最后合为一个有序数组，整个一次的步骤称为 “归并”</p>
<p>​    假设现在有两个有序数组：[1,2,5]，[0,3,4,8]；需要循环遍历两个数组，并进行大小比较，即需要分别取出两个数组的索引下标，也就是需要两个参数作为指针，在每一次比较后，将小的元素从其所在数组移除加入到新的数组中，并对其所在数组的指针 +1，如此反复进行比较以及指针后移；最后，如果两个数组的长度不相等，势必会出现到最后无法继续比较的情况，就需要将还有多余元素的数组直接在新的数组后追加即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并两个有序数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_li</span>(<span class="params">li_a, li_b</span>):</span><br><span class="line">    len_a, len_b = <span class="built_in">len</span>(li_a), <span class="built_in">len</span>(li_b)</span><br><span class="line">    a = b = <span class="number">0</span></span><br><span class="line">    new_li = []</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> a &lt; len_a <span class="keyword">and</span> b &lt; len_b:</span><br><span class="line">        <span class="keyword">if</span> li_a[a] &lt; li_b[b]:</span><br><span class="line">            new_li.append(li_a[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_li.append(li_b[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> a &lt; len_a:</span><br><span class="line">        new_li.extend(li_a[a:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_li.extend(li_b[b:])</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">return</span> new_li</span><br><span class="line"></span><br><span class="line">li_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">li_2 = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(merge_sort(li_1,li_2))    <span class="comment"># [0, 1, 2, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure>
<p>​    上面的代码实现了对两个有序数组的最后排序，那么对于归并排序就可以直接借此实现了，只需要将打乱的数组交给函数，函数内部去计算得到一个中间数，分别得到左右两部分，然后递归调用，对左右两个数组继续拆分，到最后拆到左右两个数组都是一直有一个元素，去调用归并来实现合并</p>
<p><img src="https://wei-foun.github.io/img/%E5%BD%92%E5%B9%B6.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接着上面的归并，来实现归并排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">li</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(li) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = <span class="built_in">int</span>(<span class="built_in">len</span>(li) / <span class="number">2</span>)</span><br><span class="line">        merge_left = merge_sort(li[:mid])</span><br><span class="line">        merge_right = merge_sort(li[mid:])</span><br><span class="line">        <span class="keyword">return</span> merge_li(merge_left, merge_right)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)                  <span class="comment"># [8, 7, 6, 2, 1, 4, 5, 0, 3, 9]</span></span><br><span class="line"><span class="built_in">print</span>(merge_sort(ll))      <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>​    最后，从分析和 diamante 实现可知，归并排序每一次循环都会减少一半的循环对象，所以时间复杂度上是 O(nlogn) ，给归并的方法中由于创建了一个新的列表去进行 append 的操作，所以空间复杂度上是 O(n) 的</p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>​    计数排序适用于数据范围不大的场景，其特点就是计数和范围。在计数之前，需要确定出数据的范围，注意这个范围并不是指数组的长度，而是数组中的最大值。然后利用这个值作为新的数组的长度值，同时将新数组的每一个索引对应的元素赋值为 0，这么做的目的就是为了后面循环时进行累计计数的操作，注意这里新的数组长度需要在最大值上 + 1，</p>
<p>​    简单来说，就是确定出最大值后，按照这个最大值划分出一个个桶，有点类似桶排序的操作，但是在桶内不是存放实际数据，而是通过遍历操作进行累加。例如，数组是 [2,6,3,3,5]，得到最大值是 6 后创建出 [0,0,0,0,0,0,0] 的数组，然后将新的数组的下标当做是原数组的值，新数组的值则是对应原数据的出现次数，那么经过遍历后就得到了 [0,0,1,2,0,1,1]</p>
<p>​    接下来就是计数的操作，这里会在前面的新数组上再次遍历，将小于等于的元素做累加计数，也就是数组的索引对应的元素的前一位元素的和</p>
<p>​    注意这个计数操作的遍历，需要从索引 1 开始，因为按照范围创建的数组长度的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原数组 = [2, 6, 3, 3, 5]</span><br><span class="line">范围遍历后的数组 = [0, 0, 1, 2, 0, 1, 1]   对应原数组数据的计数</span><br><span class="line">				 0  1  2  3  4  5  6    这里索引 index 同时也是原数组的数据元素</span><br><span class="line">小于等于的计数数组 = [0, 0, 1, 3, 3, 4, 5]   对应数据的小于等于的计数</span><br><span class="line">				   0  1  2  3  4  5  6    索引 index 同时也是原数组的数据元素</span><br></pre></td></tr></table></figure>
<p>​    然后就是计数排序的关键部分，需要将原数组反向遍历，将得到的数组作为索引去找到计数数组对应的元素，例如 5 对应的计数数组中的元素是 4，那么经过计数排序后，这个 5 应该出现的位置是 4 - 1，也就是索引 3 的位置，同时对应的 计数数组的元素 4 也需要减去 1，将其值变为 3。简单理解就是说将计数数组中小于等于元素 4 的一个数从计数中排除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">原数组 = [2, 6, 3, 3, 5]</span><br><span class="line">计数排序数组 = [0, 0, 0, 0, 0, 0, 0]      计数数组 = [0, 0, 1, 3, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">1）原数组倒数第一位开始遍历，得到 5，得到计数数组的元素 4，4 - 1 = 3，计数排序数组[3] = 5</span><br><span class="line">计数排序数组 = [0, 0, 0, 5, 0, 0, 0]      计数数组 = [0, 0, 1, 3, 3, 3, 5]</span><br><span class="line"></span><br><span class="line">2）原数组倒数第二位开始遍历，得到 3，得到计数数组的元素 3，3 - 1 = 2，计数排序数组[2] = 3，计数数组[3] = 2</span><br><span class="line">计数排序数组 = [0, 0, 3, 5, 0, 0, 0]      计数数组 = [0, 0, 1, 2, 3, 3, 5]</span><br><span class="line"></span><br><span class="line">3）原数组倒数第三位开始遍历，得到 3，得到计数数组的元素 3，2 - 1 = 1，计数排序数组[1] = 3，计数数组[3] = 1</span><br><span class="line">计数排序数组 = [0, 3, 3, 5, 0, 0, 0]      计数数组 = [0, 0, 1, 1, 3, 3, 5]</span><br><span class="line"></span><br><span class="line">4）原数组倒数第四位开始遍历，得到 6，得到计数数组的元素 5，5 - 1 = 4，计数排序数组[4] = 6</span><br><span class="line">计数排序数组 = [0, 3, 3, 5, 6, 0, 0]      计数数组 = [0, 0, 1, 1, 3, 3, 4]</span><br><span class="line"></span><br><span class="line">5）原数组倒数第五位开始遍历，得到 2，得到计数数组的元素 1，1 - 1 = 0，计数排序数组[0] = 2</span><br><span class="line">计数排序数组 = [2, 3, 3, 5, 6, 0, 0]      计数数组 = [0, 0, 0, 1, 3, 3, 4]</span><br></pre></td></tr></table></figure>
<p>​    由此可见，最后计数排序得到数组就完成了对原数组的排序，但是为了实现原地排序操作，可以对原数组在做一次遍历，每一个索引对应的新的元素就是计数排序后的数组索引对应的元素，从而将值进行替换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">li, n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">max</span> = li[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span> &lt; li[i]:</span><br><span class="line">            <span class="built_in">max</span> = li[i]</span><br><span class="line"></span><br><span class="line">    a = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>+<span class="number">1</span>)]</span><br><span class="line">    b = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        a[li[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">max</span>+<span class="number">1</span>):</span><br><span class="line">        a[i] = a[i-<span class="number">1</span>] + a[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        index = a[li[i]] - <span class="number">1</span></span><br><span class="line">        b[index] = li[i]</span><br><span class="line">        a[li[i]] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        li[i] = b[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">li = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(count_sort(li, <span class="built_in">len</span>(li)))     <span class="comment"># [1, 2, 3, 3, 5, 5, 6, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>​    堆（heap），其实可以看作是一个完全二叉树，通常又分大根堆和小根堆，两者的区别是，<strong>大根堆中任意一个节点都要大于它的孩子节点，小根堆则正好相反</strong></p>
<p>​    <strong>堆排序的时间复杂度是 O(nlogn)，并且是原地排序算法</strong>，因为堆排序不借助其余数组，而是在原数组上进行排序</p>
<p><img src="https://wei-foun.github.io/img/%E5%A0%86.jpg" alt="img"></p>
<p>​    堆排序的过程：</p>
<p>​    1）构建堆，以大根堆为例</p>
<p>​    2）得到堆顶的元素为最大元素</p>
<p>​    3）去掉堆顶元素，将堆最后一个元素移至堆顶，通过调整再次得到有序的大根堆</p>
<p>​    4）移除堆顶元素，即作为第二大的元素</p>
<p>​    5）重复开始步骤 3），直到堆为空</p>
<p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_6_0.gif" alt="排序（6）：堆排序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift</span>(<span class="params">li,low,high</span>):</span><br><span class="line">    <span class="comment"># 对树进行向下调整，li 表示树，low 表示当前树的根节点位置，high 表示树最后的节点位置</span></span><br><span class="line">    tmp = li[low]</span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="comment"># while 判断左右子节点是否小于 high，如果 j 超出 hight，表示指针 i 所在位置已经是堆中最后的节点</span></span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># j + 1 表示右子节点，判断是否该节点是否存在，且左小于右</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 条件通过，j 就 +1，将 j 指向右节点位置</span></span><br><span class="line">        <span class="keyword">elif</span> li[j] &gt; tmp:</span><br><span class="line">            <span class="comment"># 判断 li[j] 表示的左节点或右节点是否大于他们父节点</span></span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            <span class="comment"># 条件通过，表示子节点中的值是大于当前的父节点，将父节点的位置的值变为子节点的值</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="comment"># 同时，为了向后继续遍历，将父节点的 i 指针指向子节点的 j 指针，来遍历后一个子树的父子节点</span></span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 并重新计算 j 指针指向的子树结构的左节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果上面都不满足，说明 i 指针的父节点大于 j 指向的子节点，不需要调整指针，直接退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line">    <span class="comment"># 循环结束，说明当前堆结构调整完成，将 i 指针位置的父节点还原</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">li</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(li)</span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):    <span class="comment"># 任何一个子节点找父节点都是 len(li) // 2 - 1</span></span><br><span class="line">        <span class="comment"># 构建堆，是自下而上操作，时间复杂度是 O(logn)</span></span><br><span class="line">        sift(li, low, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 依次出数，是自上而下操作，时间复杂度是 O(logn)</span></span><br><span class="line">        li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">        sift(li, <span class="number">0</span>, high-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)                   <span class="comment"># [0, 7, 4, 5, 3, 6, 9, 1, 2, 8]</span></span><br><span class="line"><span class="built_in">print</span>(heap_sort(ll))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p>​    堆的概念和之前的几个排序相比理解上复杂很多，但是堆也是一个很实用的数据结构，对于 top-k 的问题，使用堆排序可以快速方便的得到结果</p>
<p>​    首先，在 sift 的函数中接收三个参数，分别是 树，树的根节点位置，最后节点的位置；同时，函数内部用了三个变量来做递进，tmp 表示当前树根的根节点元素（注意：不会一直是堆顶的那个根元素，在遍历中是会产生改变的），i 被赋予参数 low 的值，表示父节点的位置，j 则就是左子节点的位置 2 * i + 1；从动态的演示图中，可以知道构建大根堆的调整是从最后的父子节点开始的，所以循环的条件就是 j（左子节点的位置）最后一定是要小于等于树最后的节点的位置（就是小于或等于列表的长度），因为左子节点一定是小于右子节点的，是右子节点位置 -1 的，j &gt; high 就说明 i 的位置已经是叶子节点了，也就是说 i 代表的父节点已经是列表最后一位，没有后续的子节点了，即此时堆的调整应该结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> j &lt;= high:</span><br><span class="line">	<span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">	    j += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​    接着是循环内的第一个判断，j 表示为左节点位置，+1 就表示右节点位置，和循环条件一样，右节点必须是小于等于最后的节点的位置，= 表示当前调整的树是整个堆最后的一个子树，&lt; 则表示前面或者上一层的子树，但是这个条件并不足以判断是否调整父子节点位置，另外还需要比较的是左节点和右节点的大小，<code>li[j] &lt; li[j+1]</code> 表示左边小于右边，那么就将 j + 1，也就是指向其中大的那个节点。所以这个判断表示的意思是判断是否存在右节点，并且判断大小，如果右边的大，j 指向右边，这一步的目的是为了从子节点中选出大的那个子节点，将 j 的指针指向该节点，在后续操作中，调整 i 和 j，即将父节点替换为比它大的子节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> li[j] &gt; tmp:</span><br><span class="line">   	li[i] = li[j]</span><br><span class="line">   	i = j</span><br><span class="line">   	j = <span class="number">2</span> * i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​    这个判断语句，首先是  <code>li[j] &gt; tmp</code> 表示，左节点或者是上面的 if 判断通过后的右节点，与他们的父节点进行大小比较，如果大于则表示，这个子树是要进行调整的，将 <code>li[i] = li[j]</code> ，表示将原本父节点的位置替换为子节点，完成后将 i 重新赋值为 j，j 重新改为 2 * i + 1，作为下一次递进后的左节点</p>
<p>​    最后一个 else 的判断的语句中直接 break 退出循环了，所表示的是当前的左或者右两个节点的值都小于父节点，也就是说不需要进行子树调整</p>
<p>​    函数的最后还有一个 <code>li[i] = tmp</code>， 表示的是将原来的父节点赋值给叶子节点，这里的 i 之所以是叶子节点，是因为经过 while 循环后 i = j ，这个 i 成为了上次调整后的左或右的节点，而最后的左和右就是上一次的叶子节点；也就是说，将原本小于左右的父节点赋值给其中的子节点</p>
<p>​    这里其实可以再优化一下，因为 tmp 变量的目的最后其实就是为了将父子交换，所以上面的代码可以省去 <code>tmp = li[low]</code> 这行，并将循环判断中的父子判断改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> j &lt;= high:</span><br><span class="line">    <span class="keyword">if</span> j+<span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> li[i] &lt; li[j]:</span><br><span class="line">        li[i], li[j] = li[j], li[i]</span><br><span class="line">        i = j</span><br><span class="line">        j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>​    那么，上面的整个 sift 的函数其实就是实现了堆的调整，然后就是 heap_sort 函数了，这其中涉及了递归调用，去将列表初始化为堆，并且完成调整后，挨个进行出去并同时调整返回最后需要的有序的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    sift(li, low, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>​    函数里的第一个循环就是用来构造堆的，这里的 n 表示的是给的数组的长度，也就是堆的节点数，上面也说了从动态演示中，对于堆的调整是从数组右后往前的，所以在构造堆时，要确定传入的 low 和 high 的值，依然是从后开始，那么 high 的参数可以设为 <code>len(li)-1</code>，就是代码中的 n-1，因为将 high 的值设为最后一个节点位置，不会影响堆递进的调整，因为不管是堆中那一个部分需要进行调整，都不会超过最后一个位置的范围，而且 sift 函数都是对各自的子树去调整，最终都是调整父与左右两个子节点的关系，所以不会影响到堆的调整</p>
<p>​    然后就是 low 的值了，堆的调整都是父节点和左右子节点比较出大的然后调整，所以 low 参数可以设为父节点的位置，因为 n - 1 是最后的节点，那么对应父节点就是式子：</p>
<p>​    <code>( i - 1 ) // 2 = ( n - 1 - 1 ) // 2 = ( n - 2 ) // 2 = n // 2 - 1</code></p>
<p>​    那么最后的父节点在堆中的位置就是 len(li) // 2 - 1，最后通过循环，设一个步长为 -1 的 range(n//2-1, -1, -1)，就可以依次去调整每一个父节点的子树，也就是完成了堆的构造</p>
<p>​    构造堆之后，就是排序的步骤了，在 sift 函数中会去对堆去调整，再加上调整后的堆是大根堆，接下来的排序只需要将堆顶取出和最后的节点交换即可，每交换一次便会从新调整一次得到一个新的大根堆</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">    sift(li, <span class="number">0</span>, high-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>​    在这个循环中，high 的值是从最后一个节点的位置开始，以 -1 步长向前取值，然后交换 <code>li[0], li[high]</code>，实现将堆顶的最大元素和队尾进行交换，同时再去使用 sift 去调整重新构造的新的大根堆，注意这里 high 的参数是：遍历出来的 high - 1，也就是将刚才已经放到队尾的最大值排除，防止再次被交换调整，这样递进上去，就可以实现对堆的排序了</p>
<p>​    对于 堆 这个结构，python 还提供了 <strong>heapq</strong> 这个模块来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">li</span>):</span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> li:</span><br><span class="line">        heapq.heappush(h, value)</span><br><span class="line">    <span class="keyword">return</span> [heapq.heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(li))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ll)              <span class="comment"># [4, 5, 9, 2, 0, 1, 8, 3, 6, 7]</span></span><br><span class="line"><span class="built_in">print</span>(heap_sort(ll))   <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># 可以看到使用 heapq 模块也能实现堆排序，类似 sorted 方法，但是与 sorted 的排序不同的是，heapq 模块实现的堆排序不是稳定的</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># heapq 模块常见的函数</span></span><br><span class="line">heapq.heappush(head, itrm)    <span class="comment"># 将 item 将入到堆中，且保持堆的不变性</span></span><br><span class="line">heapq.heappop(head)           <span class="comment"># 弹出并返回 heap 的最小元素，且保持堆的不变性，如果堆为空，抛出 IndexError，使用 head[0] 只能访问最小元素但是不会进行弹出</span></span><br><span class="line">heapq.heappushpop(head, item)     <span class="comment"># 相当于是 push 和 pop 的整合，先将 item 将入堆，并弹出返回最小元素，heappushpop 要比上面的两个方法执行起来更有效率</span></span><br><span class="line">heapq.heapify(x)              <span class="comment"># 将 列表x 原地转换为 堆 的结构，是一个 小根堆 结构</span></span><br><span class="line">heapq.heapreplace(head, item)     <span class="comment"># 和 heappushpop 相反，是先将最小项弹出返回后，将新的 item 将入到堆中，保持堆不变性，同样比联合使用 push 和 pop 在单步操作上更有效率，并且如果堆为空，也会抛出 IndexError </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># headpreplace 方法有一个问题，因为毕竟是先进行弹出，再去添加，就会导致可能这个方法返回的值会比添加的 item 值要大，不过不希望如此，可以使用 heappushpop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，heappush 方法也可以去传入元组，这样形式适用于例如任务优先级与跟踪主记录赋值的场景</span></span><br><span class="line">h = []</span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>, <span class="string">&#x27;write code&#x27;</span>))    <span class="comment"># 元素的第一个值代表优先级</span></span><br><span class="line">heapq.heappush(h, (<span class="number">7</span>, <span class="string">&#x27;release product&#x27;</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>, <span class="string">&#x27;write spec&#x27;</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">3</span>, <span class="string">&#x27;create tests&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(heapq.heappop(h))     <span class="comment"># (1, &#x27;write spec&#x27;)</span></span><br></pre></td></tr></table></figure>
<h5 id="Top-k-问题"><a href="#Top-k-问题" class="headerlink" title="Top-k 问题"></a>Top-k 问题</h5><p>​    top-k 是堆结构的典型使用场景，但不说其他的方式就不能实现。比如时间复杂度都为 O(n²) 的冒泡排序，选择排序，插入排序，可以用这三个任何一个对数组进行整体的排序，但是只需要遍历 k 次就可以获取最大的 k 个元素，也就是说最多就需要遍历 k 次就够了，所以对于 top-k 问题，使用这三个算法排序后，就不再是对列表中 n 个元素去进行二次遍历，最后的时间复杂度就是 O(kn)</p>
<p>​    也可以使用理论上时间复杂度都是 O(nlogn) 的快速排序，归并排序，然后通过切片操作，再去获取到最大的 k 个，那整体上来说，切片只是遍历了 k 次，那最后时间复杂度是 O(nlogn+k)</p>
<p>​    如果使用堆排序，相对上面的方法，在时间复杂度上会更优。<strong>整体思路，先将列表前面 k 个元素，构建一个小根堆的结构，那对于 k 个元素的堆构建，这个时间复杂度上是 O(klogk)。然后，将列表在 k 位置之后的元素遍历，与前面小根堆的根节点比较大小</strong>，如果元素大于根节点的值，就替换这个根节点，如果结构不满足小根堆，那就是说需要进行一次堆调整，调整后将最小节点作为根节点，那这一步的操作，时间复杂度首先是 n-k 个元素的遍历，然后就是堆调整的 logk，因为每一次遍历都可能需要调整，所以就是 (n-k)(logk)，即 O(nlogk - klogk)，<strong>最后的时间复杂度就是 O(klogk) + O(nlogk - klogk)，即 O(nlogk)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sift</span>(<span class="params">li, low, high</span>):</span><br><span class="line">    <span class="comment"># 构建小根堆</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[i] &gt; li[j]:</span><br><span class="line">            li[i], li[j] = li[j], li[i]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">top_k</span>(<span class="params">li, k</span>):</span><br><span class="line">    heap = li[:k]</span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> <span class="built_in">range</span>(k//<span class="number">2</span>-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        sift(heap, low, k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift(heap, <span class="number">0</span>, k-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[high] = heap[high], heap[<span class="number">0</span>]</span><br><span class="line">        sift(heap, <span class="number">0</span>, high-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h4><p>​    二分法查找是非常常见的一个查找的算法，相比起线性查找来说，时间复杂度上从 O(n) 变成了 O(logn)，这种提升就是因为二分法每一次都会省去一半的数量，即 n，n/2，n/4，n/8，n/2^k，那么当 n/2^k = 1 时，即 2^k = n，即 k = log₂n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性查找       O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_search</span>(<span class="params">data_set, value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">range</span>(data_set)):</span><br><span class="line">        <span class="keyword">if</span> data_set[i] == value:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 二分法查找     O(logn)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, num</span>):</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; num:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">li.sort()</span><br><span class="line"><span class="built_in">print</span>(li)                       <span class="comment"># [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 12]</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">10</span>))       <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">6</span>))        <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<p>​    二分法查找，从字面理解就是将原列表拆分进行查找，也就是以列表的中间元素为断点拆分两个列表，然后判断这个中间元素与要查找元素的大小，大于就表示要查找的元素是在右边的列表中，反之，小于则表示被查元素是在左边的列表中；<strong>注意：使用 二分法 的前提是 可迭代元素 是 有序的</strong></p>
<p>​    <strong>另外，需要注意的是，对于 mid 的计算   <code>mid = (low + high) // 2</code> 实际上是会有问题的，因为 low 和 high 的值如果很大则有可能造成溢出，所以可优化成 <code>mid = low + (high - low) // 2</code>。那么对于除法的优化，则是可以用位置来计算，可以优化成 <code>mid = low + ((high - low) &gt;&gt; 1)</code></strong></p>
<p>​    经过第一次二分，就将要搜索的范围减少了一半，后续的操作就是循环地去对被查元素所在的列表进行二分，直到最后中间元素等于被查元素，就表示找到了，这个中间元素的下标索引就是被查元素在原列表的中索引位置，如果二分到最后列表只有两个元素，那么计算后得到的中间下标索引就是 0 ，也就是第一个元素和被查元素不相等，需要作出一个返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版本的二分法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, num, low, high</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; num:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li, num, low, mid - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li, num, mid + <span class="number">1</span>, high)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">li.sort()</span><br><span class="line"><span class="built_in">print</span>(li)                              <span class="comment"># [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 12]</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">len</span>(li)))  <span class="comment"># -1</span></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">6</span>, <span class="number">0</span>, <span class="built_in">len</span>(li)))   <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<p>​    使用 二分法 去查找的时候，不一定得到就是完全正确的目标索引位置，因为如果列表的元素是允许有重复的，且要查找的元素正好能在 mid 的位置上，那么如果 mid 前面的元素和目标值是一致的，那么就不能返回目标值在列表中第一次出现的位置</p>
<h4 id="二分法查找（元素第一次出现的位置）"><a href="#二分法查找（元素第一次出现的位置）" class="headerlink" title="二分法查找（元素第一次出现的位置）"></a>二分法查找（元素第一次出现的位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">nums, target</span>):</span><br><span class="line">    l, h = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = (l + h) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">while</span> mid != <span class="number">0</span> <span class="keyword">and</span> nums[mid-<span class="number">1</span>] == nums[mid]:</span><br><span class="line">                <span class="comment"># 从 mid 位置向前遍历，判断值是否一致，一致就将 mid - 1，同时 mid 不能为 0</span></span><br><span class="line">                mid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">       	<span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            r = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​    上面的思路其实很容易理解，就是在通过二分法确定了查找的元素后，在该元素的位置往前遍历，因为实现二分法的前提是数据是有序排列的，所以通过向前遍历判断从而得到元素第一次实现的位置</p>
<p>​    除了上面的这种判断外，当 nums[mid] == target，还可以通过一下代码实现判断</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">    <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> nums[mid - <span class="number">1</span>] != target: <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">else</span>: high = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>​    两段判断代码的思路其实大体来说是一致的，不同之处是前者是 and 判断，后者是用 or。后者的一个注意点是 high 这个变量，如果 mid 不为 0 或者是 nums[mid - 1] = target 了，其实就是说明要么 mid 已经到最低位了，即表示 mid 就是查询元素的第一次出现的位置了，要么就是 mid 不在最低位，而 nums[mid - 1] 又不等于 target，也就是说 mid 已经是第一次出现的位置。当两个条件都不满足时，就表示需要调整范围，也就是调整 high 这个变量，因为 mid 的区间总是 low 到 high 位，所以两个条件都不满足，high 则等于 mid - 1</p>
<h4 id="二分法查找（大于等于查找元素的第一次出现位置）"><a href="#二分法查找（大于等于查找元素的第一次出现位置）" class="headerlink" title="二分法查找（大于等于查找元素的第一次出现位置）"></a>二分法查找（大于等于查找元素的第一次出现位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, h = <span class="number">0</span>, <span class="built_in">len</span>(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = (l + (h - l) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> li[mid] &gt;= t:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> li[mid - <span class="number">1</span>] &lt; t:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">7</span>))    <span class="comment"># 5   li[5] = 8</span></span><br></pre></td></tr></table></figure>
<p>​    同样是二分法的变题，但相对而言代码上则简单一些，因为查找大于等于目标值的第一次位置，实际上目标值的区间就会是在 mid + 1 到 high 的区间内，所以 mid 的值小于目标值，只要更改 low 的位置为 mid +1 即可，而大于等于则是同样的逻辑，所以可以少了 if 的判断</p>
<p>​    当 mid 的值大于等于目标值，一旦 mid 最后计算后是 0 就是查找结束了，mid 的值就可以返回。或者是 mid - 1 的值小于了目标值，也是表示 mid 位置的值是大于等于目标值的第一个位置，也可以直接返回。而两个条件都不满足，则就更改 high 的位置，让 high 为 mid - 1 这样就可以排除后面大于目标值的一个元素</p>
<h4 id="二分法查找（元素出现的最后位置）"><a href="#二分法查找（元素出现的最后位置）" class="headerlink" title="二分法查找（元素出现的最后位置）"></a>二分法查找（元素出现的最后位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, n, = <span class="number">0</span>, <span class="built_in">len</span>(li)</span><br><span class="line">    h = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = l + (h - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] &lt; t:</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; t:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == n - <span class="number">1</span> <span class="keyword">or</span> li[mid + <span class="number">1</span>] != t:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">5</span>))    <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>​    查找元素最后的出现的位置，大体上和查找第一次出现位置是类似的，不同之处是就是在等于查找元素时，内部的判断逻辑上，查找的区间是在 mid + 1 到 high。当 mid 指向的值和目标值一致，就要从 mid 开始往后查找，但同样是有两个条件，如果 mid 是数组的最后的一个元素，那必然就是最后的位置，如果 mid + 1 指向的值不等于目标值，也就是说 mid 所在位置的目标值就是最后出现的位置。如果两个条件都不满足，就要将区间头部 + 1，也就是 mid + 1</p>
<p>​    另外，要注意的是上面除了 low 和 high 两个变量外，还有一个变量 n，所表示的就是数组的最后一位</p>
<h4 id="二分法查找（小于等于查询元素的最后出现位置）"><a href="#二分法查找（小于等于查询元素的最后出现位置）" class="headerlink" title="二分法查找（小于等于查询元素的最后出现位置）"></a>二分法查找（小于等于查询元素的最后出现位置）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bin_search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, n = <span class="number">0</span>, <span class="built_in">len</span>(li)</span><br><span class="line">    h = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = l + (h - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] &gt; t:</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == n - <span class="number">1</span> <span class="keyword">or</span> li[mid + <span class="number">1</span>] &gt; t:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bin_search(li, <span class="number">7</span>))   <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<p>​    思路同理于查找大于等于的第一次出现位置，只是实现上正好相反。由于是查找最后的位置，所以同样需要 n 这个变量来记录数组最后的索引。查找小于等于的最后位置，那么实际的查找区间就是 low 到 mid - 1，所以当 mid 指向的值大于目标值，high 就要在 mid 上减 1</p>
<p>​    当 mid 指向的值小于等于目标值时，就需要判断 mid，如果 mid 是数组最后的一位，那就是小于等于的最后位置，如果 mid + 1 的值大于了目标值，表示 mid 的位置就是小于等于目标值的最后位置。如果两个条件都不满足，就需要改变区间，因为是查找最后位置，所以 low 就是 mid + 1</p>
<h4 id="旋转排序数组查找"><a href="#旋转排序数组查找" class="headerlink" title="旋转排序数组查找"></a>旋转排序数组查找</h4><p>​    该数组不同正常排序的数组，是在某一个位置进行拆分，将拆分的两个数组位置互换，然后在这个数组中查询指定的元素索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">li, t</span>):</span><br><span class="line">    l, n = <span class="number">0</span>, <span class="built_in">len</span>(li)</span><br><span class="line">    h = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h:</span><br><span class="line">        mid = l + (h - l) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == t:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[<span class="number">0</span>] &lt;= li[mid]:</span><br><span class="line">            <span class="keyword">if</span> li[<span class="number">0</span>] &lt;= t &lt; li[mid]:</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> li[mid] &lt; t &lt;= li[n-<span class="number">1</span>]:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(search(li, <span class="number">1</span>))    <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<p>​    本题简单的思路是可以找到数组的旋转位置，这样就能得到左右两边都是有序的数组，再判断目标值与两个数组的第一个元素，以此确定目标值所在的数组，再利用二分法进行查找。这种方式实现要简单一些，但是会多一些判断逻辑</p>
<p>​    然后就是上面代码的方式，整体上和普通二分法类似，区别同样是逻辑判断的处理上。首先的一个判断就是 mid 的位置元素是目标值，这样就直接把 mid 返回，如果不等于目标值，就相当于利用这个 mid 将数组分割成左右两部分，两个部分中至少有一个数组是有序的</p>
<p>​    假设左边是有序的，即区间范围是 [ low, mid )，即 0 的位置元素是小于等于 mid 指向的元素，接下来需要再次进行判断，从而修改 low 或 high 指向的位置。如果目标值大于等于 0 位置的元素，且小于 mid 指向元素，表明目标值在这个有序范围内，那么就要控制 high 的指向，变为当前 mid -1 的位置，从而缩减不必要的部分。反之，则表明目标值不在 0 到 mid 这个范围内，那么 low 的位置就需要改为 mid + 1，舍去掉 0 到 mid 有序的部分</p>
<p>​    如果一开始 mid 位置的元素要小于 0 位置的元素，那么则表明 mid 之后是有序的，同样需要进行后续的判断更改 low 或 high。如果目标值大于 mid，且小于等于原数组最后一个元素，说明目标值在该范围内，就需要将 low 改为 mid + 1，反之就是更改 high 为 mid - 1</p>
<p>​    </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/3963924866/">http://example.com/3963924866/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover35.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/557344215/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover36.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx-整理</div></div></a></div><div class="next-post pull-right"><a href="/685301591/"><img class="next-cover" src="https://wei-foun.github.io/img/cover34.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Rest_Framework-整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/4125439603/" title="python2 与 python3 的区别"><img class="cover" src="https://wei-foun.github.io/img/cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-19</div><div class="title">python2 与 python3 的区别</div></div></a></div><div><a href="/864857163/" title="python基础语法-五"><img class="cover" src="https://wei-foun.github.io/img/cover19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-25</div><div class="title">python基础语法-五</div></div></a></div><div><a href="/3857016810/" title="python 基础语法-一"><img class="cover" src="https://wei-foun.github.io/img/singstreet.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-27</div><div class="title">python 基础语法-一</div></div></a></div><div><a href="/3391672429/" title="数据结构和算法"><img class="cover" src="https://wei-foun.github.io/img/cover11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-23</div><div class="title">数据结构和算法</div></div></a></div><div><a href="/997618812/" title="python 基础语法-二"><img class="cover" src="https://wei-foun.github.io/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-30</div><div class="title">python 基础语法-二</div></div></a></div><div><a href="/1656529424/" title="python 基础语法-三"><img class="cover" src="https://wei-foun.github.io/img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">python 基础语法-三</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">常见排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Top-k-%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.1.</span> <span class="toc-text">Top-k 问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.</span> <span class="toc-text">二分法查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%88%E5%85%83%E7%B4%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">二分法查找（元素第一次出现的位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%88%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">二分法查找（大于等于查找元素的第一次出现位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%88%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%80%E5%90%8E%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">二分法查找（元素出现的最后位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%88%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%90%8E%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">二分法查找（小于等于查询元素的最后出现位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.6.</span> <span class="toc-text">旋转排序数组查找</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux再学习"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux再学习"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux再学习">Linux再学习</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4075015966/" title="GO 基础"><img src="https://wei-foun.github.io/img/cover45.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO 基础"/></a><div class="content"><a class="title" href="/4075015966/" title="GO 基础">GO 基础</a><time datetime="2025-07-04T16:26:58.000Z" title="发表于 2025-07-05 00:26:58">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4209932858/" title="容器网络"><img src="https://wei-foun.github.io/img/cover44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容器网络"/></a><div class="content"><a class="title" href="/4209932858/" title="容器网络">容器网络</a><time datetime="2023-07-04T16:26:58.000Z" title="发表于 2023-07-05 00:26:58">2023-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4253636491/" title="kubernetes-搭建"><img src="https://wei-foun.github.io/img/cover43.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kubernetes-搭建"/></a><div class="content"><a class="title" href="/4253636491/" title="kubernetes-搭建">kubernetes-搭建</a><time datetime="2023-03-19T10:39:02.000Z" title="发表于 2023-03-19 18:39:02">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/undefined/" title="wsl docker 卸载"><img src="https://wei-foun.github.io/img/cover42.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="wsl docker 卸载"/></a><div class="content"><a class="title" href="/undefined/" title="wsl docker 卸载">wsl docker 卸载</a><time datetime="2023-03-05T08:50:50.000Z" title="发表于 2023-03-05 16:50:50">2023-03-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover35.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>