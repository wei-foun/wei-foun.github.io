<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Rest_Framework-整理 | </title><meta name="keywords" content="Rest_Framework"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="序列化 Serializerdjango 的 serializers​    django 本身自带了序列化的组件 serializers（djang.core.serializers），这个序列化器使用 serialize 方法来进行对象的序列化，该方法接收两个参数，format 表示要序列化的格式，通常就是 json，第二个是 instance，要对模型类的对象序列化传给前端就可以使用这个方法">
<meta property="og:type" content="article">
<meta property="og:title" content="Rest_Framework-整理">
<meta property="og:url" content="http://example.com/685301591/index.html">
<meta property="og:site_name">
<meta property="og:description" content="序列化 Serializerdjango 的 serializers​    django 本身自带了序列化的组件 serializers（djang.core.serializers），这个序列化器使用 serialize 方法来进行对象的序列化，该方法接收两个参数，format 表示要序列化的格式，通常就是 json，第二个是 instance，要对模型类的对象序列化传给前端就可以使用这个方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover34.jpg">
<meta property="article:published_time" content="2021-06-09T14:43:56.000Z">
<meta property="article:modified_time" content="2025-04-01T17:58:07.105Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="Rest_Framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover34.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/685301591/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Rest_Framework-整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-02 01:58:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover34.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Rest_Framework-整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-09T14:43:56.000Z" title="发表于 2021-06-09 22:43:56">2021-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-01T17:58:07.105Z" title="更新于 2025-04-02 01:58:07">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python-web%E6%A1%86%E6%9E%B6/">python web框架</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python-web%E6%A1%86%E6%9E%B6/Django/">Django</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python-web%E6%A1%86%E6%9E%B6/Django/Rest-Framework/">Rest_Framework</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Rest_Framework-整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="序列化-Serializer"><a href="#序列化-Serializer" class="headerlink" title="序列化 Serializer"></a>序列化 Serializer</h3><h4 id="django-的-serializers"><a href="#django-的-serializers" class="headerlink" title="django 的 serializers"></a>django 的 serializers</h4><p>​    django 本身自带了序列化的组件 serializers（djang.core.serializers），这个序列化器使用 serialize 方法来进行对象的序列化，该方法接收两个参数，format 表示要序列化的格式，通常就是 json，第二个是 instance，要对模型类的对象序列化传给前端就可以使用这个方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> course.models <span class="keyword">import</span> Course</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line">s = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, Course.objects.<span class="built_in">all</span>())</span><br><span class="line"><span class="comment"># 返回的 s 就是一个 json 字符串，模型类的所有记录都会被序列化，</span></span><br><span class="line"></span><br><span class="line">s = serializers.serialize(<span class="string">&#x27;json&#x27;</span>, Course.objects.<span class="built_in">all</span>(), fields=(<span class="string">&quot;course_name&quot;</span>, <span class="string">&quot;course_detail&quot;</span>))</span><br><span class="line"><span class="comment"># 如果针对只需要几个字段序列化，可以使用 fields 去指定</span></span><br></pre></td></tr></table></figure>
<p>​    注意，django 组件中 serializers 的序列化器，对模型类的实例做序列化时，如果一个模型类中有外键关联字段，那么使用 serialize 方法序列化后，并不能直接得到外键关联的对象，而是只能得到外键关联到的字段的值，如果一个 foreign key 关联的是用户表的用户主键，那么最后的 json 数据里序列化的结果就是用户表中的主键 id</p>
<p>​    另外，django core 中的 serializers 序列化支持的功能有限，如果要在前后端分离的项目中使用，这个序列化器首先不能对前端的数据做校验，数据校验需要自己提取 request.data 里的数据做校验处理。同时，后端对模型类中的实例序列化时，也不能加入自定义的数据，而且序列化多个对象还需要自己处理分页等功能。此外，如果序列化的数据出现异常，要返回给前端的结果，也需要自己再去做对应的处理</p>
<h4 id="drf-的-serializers"><a href="#drf-的-serializers" class="headerlink" title="drf 的 serializers"></a>drf 的 serializers</h4><p>​    drf 的序列化器，需要从 rest_framework 中导入 serializers，用法和 django 的 orm 非常类似，根据 models 中的模型类定义对应的 serializer</p>
<p>​    <strong>补充：字段的参数</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>max_length</strong></td>
<td>最大长度</td>
</tr>
<tr>
<td><strong>min_lenght</strong></td>
<td>最小长度</td>
</tr>
<tr>
<td><strong>allow_blank</strong></td>
<td>是否允许为空</td>
</tr>
<tr>
<td><strong>read_only</strong></td>
<td>表明该字段仅用于序列化输出，默认False</td>
</tr>
<tr>
<td><strong>write_only</strong></td>
<td>表明该字段仅用于反序列化输入，默认False</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td>表明该字段在反序列化时必须输入，默认True</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>反序列化时使用的默认值</td>
</tr>
<tr>
<td><strong>error_messages</strong></td>
<td>包含错误编号与错误信息的字典</td>
</tr>
<tr>
<td><strong>label</strong></td>
<td>用于HTML展示API页面时，显示的字段名称</td>
</tr>
<tr>
<td><strong>help_text</strong></td>
<td>用于HTML展示API页面时，显示的字段帮助提示信息</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>, verbose_name=<span class="string">&quot;课程名称&quot;</span>, help_text=<span class="string">&quot;课程名称&quot;</span>, null=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    introduction = models.TextField(verbose_name=<span class="string">&quot;课程介绍&quot;</span>, help_text=<span class="string">&quot;课程介绍&quot;</span>)</span><br><span class="line">    teacher = models.ForeignKey(settings.AUTH_USER_MODEL,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                verbose_name=<span class="string">&quot;讲师&quot;</span>,</span><br><span class="line">                                help_text=<span class="string">&quot;讲师&quot;</span>,</span><br><span class="line">                                )</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>,</span><br><span class="line">                                help_text=<span class="string">&quot;课程价格&quot;</span>,</span><br><span class="line">                                verbose_name=<span class="string">&quot;课程价格&quot;</span>)</span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>, verbose_name=<span class="string">&quot;创建日期&quot;</span>)</span><br><span class="line">    updated_at = models.DateTimeField(auto_now=<span class="literal">True</span>, verbose_name=<span class="string">&quot;更新日期&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        verbose_name = <span class="string">&quot;课程表&quot;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        ordering = (<span class="string">&#x27;price&#x27;</span>, )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line"><span class="comment"># ------- serializers.py -----------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseSerializer</span>(serializers.Serializer):</span><br><span class="line">    name = serializers.CharField()</span><br><span class="line">    introduction = serializers.CharField()</span><br><span class="line">    price = serializers.CharField()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>​    然后在视图中，只需导入整个 CourseSerializer 就可以使用了，比如前端通过 course_list 的 api 请求课程的资源，就要实例化 CourseSerializer 对象，并传入查询集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; get，从模型类获取对象，序列化返回给前端&quot;&quot;&quot;</span></span><br><span class="line">    objs = CourseSerializer(instance=Course.objects.<span class="built_in">all</span>(), many=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 因为 ORM 的 all 获取到的是多个对象，所以序列化需要 many=True 这个参数，表示对多个实例做序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response(data=objs.data, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure>
<p>​    <strong>补充：如果只是模型中普通字段的展示，使用例如 serializers.CharField() 就可以了，但对于一些外键关联的字段，例如一对多，或多对多，且又可能还需要做一些逻辑处理，则需要使用 serializers.SerializerMethodField()</strong></p>
<p>​    <strong>当一个序列化字段使用 SerializerMethodField 来做展示时，则需要对应在序列化类中定义 <code>get_字段名</code> 的方法，且需要接受一个参数 obj，表示传递进来的查询集对象</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">recommend_courses = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_recommend_courses</span>(<span class="params">self, obj</span>):</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: item.pk,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: item.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> obj.recommend_courses.<span class="built_in">all</span>()</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>​    当前端通过 api 要创建一个课程时，会将对应的键值数据传递给后端，只需将数据给到序列器，就能实现对数据的创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; post，从前端接收到序列化的数据，进行反序列化，并校验数据，通过则保存，否则就返回异常&quot;&quot;&quot;</span></span><br><span class="line">    data = CourseSerializer(data=request.data, partial=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># partial=True，表示 data 中数据不需要满足 models 中所有字段，只有部分字段，也可以更新和创建</span></span><br><span class="line">    <span class="comment"># ！！但是如果 models 中设定了字段的约束，比如不能为空，那么 data 中必须有这个数据，否则校验就不通过</span></span><br><span class="line"></span><br><span class="line">    data.teacher = request.user</span><br><span class="line">    <span class="keyword">if</span> data.is_valid():</span><br><span class="line">        <span class="comment"># data.save(teacher=request.user)</span></span><br><span class="line">        data.save()</span><br><span class="line">        <span class="keyword">return</span> Response(data=data.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="comment"># ！！注意，Response 中的 data，要是 Serializer 序列化后对象的 data，而不能直接将 Serializer 对象给 Response</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(data.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>​    <code>data = CourseSerializer(data=request.data, partial=True)</code> 会创建出 serializer 对象</p>
<p>​    注意，上面对 data 的 teacher 属性的赋值，这个值是 request.user，其实就是当前登录用户对象，也就是对应的用户表的实例，因为在 Course 表中 teacher 是外键，关联到用户表，而前端在提交数据时，无需给到后端 teacher_id 这个表字段的 id，因为创建 Course 默认用当前登录用户，所以在使用 save 时，需要给已经将前端数据序列化后的 data 对象，加上 teacher 字段的值</p>
<p>​    如果是前端的数据给到后端，CourseSerializer 的实例化中需要使用 data 参数，值就是 request.data，因为基本前端过来的格式是 json 数据，都会放在请求对象的 data 中</p>
<p>​    <strong>前端到后端，即反向序列化，序列化类在实例化时，参数使用 data，值是 request 中的 data</strong></p>
<p>​    <strong>后端到前端，即正向序列化，序列化类在实例化时，使用 instance 参数，值就是 orm 查询的查询集对象</strong></p>
<p>​    <strong>另外，如果前端执行的更新操作，那么在序列化时，需要同时使用 instance 和 data 两个参数，instance 表示的是要更新的那条记录的实例，data 就是前端提交的要更新的键值数据</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">&quot;PUT&quot;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">		course = Course.objects.get(<span class="built_in">id</span>=course_id)</span><br><span class="line"> <span class="keyword">except</span> Course.DoesNotExist:</span><br><span class="line">		<span class="keyword">return</span> Response(data=&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;没有该课程&quot;</span>&#125;, status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">    obj = CourseSerializer(instance=course, data=request.data)</span><br><span class="line">    <span class="keyword">if</span> obj.is_valid():</span><br><span class="line">        obj.save()</span><br><span class="line">        <span class="comment"># 这里不需要在设置 teacher 的字段，因为更新操作的请求 data 中包含了这个字段</span></span><br><span class="line">        <span class="keyword">return</span> Response(data=obj.data, status=status.HTTP_201_CREATED)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(data=obj.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>​    <strong>补充：</strong> 实例化序列化对象的过程中，<strong>如果要额外加入自定义的数据，可以使用 context 的参数</strong>，将键值数据给到字典，传递给 context</p>
<p>​    <strong>前端的数据序列化完成后，得到序列化对象，需要先调用 is_valid 方法进行数据校验，验证通过返回 True，否则就是 False</strong>，不通过时，序列化器对象的 errors 的属性会包含错误信息，这和 django 的 form 组件的流程是一致的，通过验证的数据，可以从 validated_date 中获取。另外 is_valid 的方法可以设置 raise_exception=True 来设置当数据验证不通过抛出 serializers.ValidationError 时，直接给前端返回 HTTP 400 Bad Request 的响应</p>
<p>​    通过校验后，就是保存数据，使用序列化器对象的 save 方法，就可以实现创建或更新。<strong>save 方法内部会判断创建这个序列化对象时，会判断 self.instance 是不是空（即实例化序列化时是否传入了 instance 参数），没有的话就调用模型类的 create 方法创建记录，如果有传递 instance 就表示是更新操作，就会调用 update 方法</strong></p>
<h4 id="serializers-的钩子"><a href="#serializers-的钩子" class="headerlink" title="serializers 的钩子"></a>serializers 的钩子</h4><p>​    drf 中 serializers 的功能与 django 的 form 组件相似，除了能做序列化外，也有 form 组件一样的功能去校验字段的数据，form 有局部和全局钩子，drf 的 serializers 也一样支持钩子函数来对字段做额外的校验</p>
<p>​    <strong>局部钩子 validate_字段</strong>，对单个字段做自定义的校验，可接受一个参数 value，即规则通过将 value 返回，如果逻辑处理不通过，可以 raise 抛出 serializers.ValidationError 的错误，ValidationError 中 detail 属性是错误的描述，code 属性可以是处理字段名称</p>
<p>​    <strong>全局钩子 validate</strong>，对多个字段做自定义的校验，可接受一个参数 attrs，大概是 querydict 字典，可以 get 到属性拿到对应的值，如果校验通过需要将 attrs 返回</p>
<p>​    如果某个字段需要做多个校验，那么局部钩子就不能实现了，所以 drf 给 serializers 类提供了一个参数 validators 属性，该属性可以接受多个用来校验该字段的钩子函数</p>
<h4 id="ModelSerializer"><a href="#ModelSerializer" class="headerlink" title="ModelSerializer"></a>ModelSerializer</h4><p>​    是 serializers 的子类，和 django 的 modelform 类似，也是直接基于模型类来定义序列化类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CourseSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="comment"># price = serializers.CharField()    ModelSerializer 也可以额外定义序列化字段</span></span><br><span class="line">    teacher = serializers.ReadOnlyField(source=<span class="string">&quot;teacher.username&quot;</span>)</span><br><span class="line">    <span class="comment"># ReadOnlyField 表示当前字段是 只读 字段，也就说前端不需要对该字段的数据提交，source 表示从 teacher.username 到关联表取出 username</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Course</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;introduction&#x27;</span>, <span class="string">&#x27;teacher&#x27;</span>, <span class="string">&#x27;price&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​    注意，这里的 teacher 属性中的 source，这个 teacher 实际上的是一个 instance 的实例，在 models 里 Course 模型类的 teacher 字段是 ForeignKey 做的外键，关联到了 django 默认的 settings.AUTH_USER_MODEL，AUTH_USER_MODEL = ‘auth.User’</p>
<p>​    因此上面序列化类的 teacher 就是从 User 中得到一个实例，并且返回了这个实例的 username 字段。所以，返回的 json 中 teacher 的值，是一个字符串而不是一个对象</p>
<p>​    正常情况下，根据 Course 表来说，序列化中的外键字段是 teacher_id，<strong>django 会在迁移时在数据库的表中，自动对模型中外键字段加上 _id 的后缀</strong>，所以默认序列化的 fields 中的 teacher 其实是表中 teacher_id 的字段，但是在 drf 中并不需要自己手动加上 _id 后缀，目的就是使字段和模型定义统一</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机导论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;introduction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;包含内容有，计算机网络，计算机硬件，计算机历史发展，计算机基础知识等等&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;teacher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;33.30&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>​    如果在 CourseSerializer 这个 ModelSerializer 中，需要通过外键获取 User 中的多个字段，可以是一个个在 CourseSerializer 中添加自定义的字段，再用 source 去指向得到一个字符串</p>
<p>​    也可以在 CourseSerializer 中嵌套 UserSerializer 这个自定义的序列化类，其中这个 UserSerializer 中 class Meta 的 fields 属性就可以指定其他序列化类查询时需要返回的字段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">&quot;username&quot;</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseSerializer</span>(serializers.ModelSerializer):</span><br><span class="line">    teacher = UserSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Course</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;introduction&#x27;</span>, <span class="string">&#x27;teacher&#x27;</span>, <span class="string">&#x27;price&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>​    这样一来，由于没有了 source 的字段属性去单独获取指定的值，CourseSerializer 的 teacher 就会返回一个 instance ，也就是说在返回的 json 中，teacher 这个字段的值不再是字符串，而是对应的一个对象，其中会包括了在 UserSerializer 中 fields 属性设置的字段</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机导论&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;introduction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;包含内容有，计算机网络，计算机硬件，计算机历史发展，计算机基础知识等等&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;teacher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>      </span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;33.30&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h3 id="drf-视图与路由"><a href="#drf-视图与路由" class="headerlink" title="drf 视图与路由"></a>drf 视图与路由</h3><h4 id="FBV"><a href="#FBV" class="headerlink" title="FBV"></a>FBV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(<span class="params">[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">course_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用 django 原生的请求处理方式，也就是自己构建 json 数据，再将 json 数据给到 response 返回&#x27;&#x27;&#x27;</span></span><br><span class="line">    course_dict = &#123;....&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(course_dict)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        course = json.loads(request.body.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># 原生 django 获取 post 的 json 数据，需要从 request.body 中获取，且得到是字节类型</span></span><br><span class="line">        <span class="keyword">return</span> HttpReposne(json.dumps(course), content_type=<span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Course</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> CourseSerializer</span><br><span class="line"><span class="keyword">from</span> django.views.decorators <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">course_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;使用 drf 序列化组件的方式&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        objs = CourseSerializer(instance=Course.objects.<span class="built_in">all</span>(), many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(data=objs.data, status=status.HTTP_200_OK)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        data = CourseSerializer(data=request.data, partial=<span class="literal">True</span>)</span><br><span class="line">	    <span class="comment"># drf 可以从 request.data 中获取 post 的 json 数据 </span></span><br><span class="line">        <span class="keyword">if</span> data.is_valid():</span><br><span class="line">            data.save(teacher=request.user)</span><br><span class="line">            <span class="keyword">return</span> Response(data=data.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">return</span> Response(data.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>​    注意，在没使用 drf 的认证组件的情况下，会受到 django 的 csrfmiddleware 中间件的影响，需要提供 token 才能去测试，而 <strong>django 提供了一个装饰器来绕开 csrfmiddleware，csrf_exempt 装饰器</strong>（from django.views.decorators.csrf import csrf_exempt）</p>
<p>​    使用 FBV 方式开发 drf 的路由设置，和 django 原本的 url 设置是一致的，所以 urls.py 的编写都是一样的</p>
<h4 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># APIView</span></span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">csrf_exempt, <span class="string">&quot;dispatch&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CourseList</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>):</span><br><span class="line">        queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">        s = CourseSerializer(instance=queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(s.data, status=status.HTTP_200_OK)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        s = CourseSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> s.is_valid():</span><br><span class="line">            s.save(teacher=request.user)</span><br><span class="line">            <span class="keyword">return</span> Response(s.data, status=status.HTTP_200_OK)</span><br><span class="line">        <span class="keyword">return</span> Response(s.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>​    drf 对 django CBV 的 View 做了进一步封装得到 APIView，其中最主要的就是 dispatch 方法，<strong>drf 的 APIView 在 dispatch 方法中做了一些类组件的初始化和调用，包括认证组件，权限组件，频率组件</strong></p>
<p>​    CBV 中避免出现 csrf 的问题，是使用 method_decorator 装饰器，其中参数是 csrf_exempt，name 参数是 dispatch，因为类视图的调用是通过 as_view 方法，然后到 dispatch 中做分发，所以类视图的请求处理的位置是在 dispatch 的方法这，当然也可以直接对 post 的请求直接装饰 csrf_exempt</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GenericAPIView</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle,)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perform_create</span>(<span class="params">self, serializer</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重写 ListCreateAPIView 中的 mixins.CreateModelMixin 类的创建方法&quot;&quot;&quot;</span></span><br><span class="line">        serializer.save(teacher=self.request.user)</span><br><span class="line">        <span class="comment"># 默认 CreateModelMixin 使用 create 方法去生成数据对象（实际内部会去调用 perform_create 方法，通过 serializer 参数的 save 去创建），但是 teacher 字段并不由前端输入来创建的，是通过登录对象作为 teacher，所以要重写 perform_create 方法，</span></span><br><span class="line">        <span class="comment"># Generic 的 View，要获取 request，需要通过 self.request 来获取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseDetail</span>(generics.RetrieveUpdateDestroyAPIView):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    generics.RetrieveUpdateDestroyAPIView 表示支持 获取，更新，删除的一个 APIView，相当于是：</span></span><br><span class="line"><span class="string">    mixins.RetrieveModelMixin,</span></span><br><span class="line"><span class="string">    mixins.UpdateModelMixin,</span></span><br><span class="line"><span class="string">    mixins.DestroyModelMixin,</span></span><br><span class="line"><span class="string">    GenericAPIView</span></span><br><span class="line"><span class="string">    这是个单独功能类的封装，RetrieveUpdateDestroyAPIView 本身也是继承了这几个 mixin 的类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    permission_classes = (IsOwnerorReadOnly,)</span><br><span class="line">    throttle_classes = (IPThrottle,)</span><br></pre></td></tr></table></figure>
<p>​    GCBV 是在 CBV 的 APIView 上的又一次封装得到 GenericAPIView，并且结合 mixins，创建了针对不同请求方法的通用类视图</p>
<table>
<thead>
<tr>
<th>通用类视图</th>
<th>处理的请求方法</th>
<th>继承父类</th>
</tr>
</thead>
<tbody><tr>
<td>CreateAPIView</td>
<td>post</td>
<td>mixins.CreateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>ListAPIView</td>
<td>get（获取所有）</td>
<td>mixins.ListModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveAPIView</td>
<td>get（获取指定记录）</td>
<td>mixins.RetrieveModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>DestroyAPIView</td>
<td>delete</td>
<td>mixins.DestroyModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>UpdateAPIView</td>
<td>put 和 patch</td>
<td>mixins.UpdateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>ListCreateAPIView</td>
<td>get 和 post</td>
<td>mixins.ListModelMixin，mixins.CreateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveUpdateAPIView</td>
<td>get（指定记录），put，patch</td>
<td>mixins.RetrieveModelMixin，mixins.UpdateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveDestroyAPIView</td>
<td>get（指定记录），delete</td>
<td>mixins.RetrieveModelMixin，mixins.DestroyModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveUpdateDestroyAPIView</td>
<td>get（指定记录），put，patch，delete</td>
<td>mixins.RetrieveModelMixin，mixins.UpdateModelMixin，               mixins.DestroyModelMixin，GenericAPIView</td>
</tr>
</tbody></table>
<p>​    ListModelMixin 提供一个 list 方法，其中会调用 get_queryset 获取设定的查询集，并将查询集给 paginate_queryset 做分页，最后使用 get_serializer 方法获取设置的序列化器将查询集进行序列化，将序列化器对象的 data 数据给到 Response 返回，返回状态码是 200</p>
<p>​    所以，使用到 ListAPIView 时，需要在通用类视图中，设置 queryset 属性，即要序列化的查询集，同时还需要设置 serializer_class 属性，值就是自定义的序列化类</p>
<p>​    CreateModelMixin 提供了一个 create 的方法， 其中会调用 get_serializer 方法，将 request.data 数据给到设置的序列化类，然后就是序列化类的一套操作，is_valid 做校验，数据通过校验后会调用 <strong>perform_create</strong> 方法并传入序列化器对象，该方法实际上会调用序列化器的 save 方法去创建</p>
<p>​    所以，使用 CreateAPIView，也要定义 serializer_class，如果数据创建成功，会返回 201 状态码的响应，否则会返回 400 状态码，如果创建记录前要更改序列化器中的数据，需要重写 perform_create 方法</p>
<p>​    RetrieveModelMixin 提供了一个 retrieve 方法，<strong>内部会调用 self.get_object 方法，实际上是调用了 GenericAPIView 中的 get_object 方法</strong>，内部 <strong>filter_kwargs 字典会去查看 lookup_field 和 lookup_url_kwarg</strong> 两个属性，前者是 pk，后者默认是 None，然后以 pk 作为 key，值就是从 self.kwargs 即从 url 上获取 self.lookup_url_kwarg 或 self.lookup_field 的值作为 url 参数的 key 来获取到具体的请求资源，也就说默认情况下，是从 url 上拿到 pk 关键字的值，<strong>再到模型类中获取，获取的方法会去调用 get_object_or_404 方法</strong>，如果实例不存在就返回 404。得到实例后，会再去 get_serializer 获取序列化类，然后序列化返回 data 中的数据</p>
<p>​    所以，使用 RetrieveModelMixin 时，如果要明确 api 用什么 key 去数据库中查询，如果不是 pk 字段，就需要定义一个 lookup_url_kwarg 这个属性，然后是要设置 queryset 属性，同时设置上序列化类 serializer_class</p>
<p>​    UpdateModelMixin 提供了 update 方法来实现更新操作，<strong>首先会去 kwargs 上用 pop 获取是否有 partial 参数，没有就是 False，否则 partial 的值就是 True。然后就是调用 get_object 获取 instance 和 get_serializer 获取序列化类，用 is_valid 校验后，会使用 perform_update 来更新，实际上也是调用序列化的 save 方法</strong></p>
<p>​    DestroyModelMixin 提供了 destroy 方法，主要就是 <strong>通过 get_object 得到具体的 instance，再去使用 perform_destroy 方法，去调用 instance 的 delete 方法删除</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ViewSet</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookInfoViewSet</span>(viewsets.ViewSet):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):</span><br><span class="line">        books = BookInfo.objects.<span class="built_in">all</span>()</span><br><span class="line">        serializer = BookInfoSerializer(books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">retrieve</span>(<span class="params">self, request, pk=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            books = BookInfo.objects.get(<span class="built_in">id</span>=pk)</span><br><span class="line">        <span class="keyword">except</span> BookInfo.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">        serializer = BookInfoSerializer(books)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p>​    ViewSet 是 APIView 的更深一步的封装，ViewSet 继承了 ViewSetMixin 和原本的 APIView，ViewSetMixin 重写 as_view 的方法，要求了在 urls 的路由配置中，http 的请求动词要和对应处理的 ViewSet 视图集类中的方法进行映射，即 <code>MyViewSet.as_view(&#123;&#39;get&#39;: &#39;list&#39;, &#39;post&#39;: &#39;create&#39;&#125;)</code></p>
<p>​    get 请求对应的方法名会有两种，一种是获取所有查询集的 list，另一种是获取指定实例的 retrieve</p>
<p>​    更新的请求中，put 对应 update 用作完整的更新，patch 对应 partial_update 用作部分字段传递的局部更新</p>
<p>​    在 ViewSet 上，还有更进一步的封装 ModelViewSet，ModelViewSet 将所有的处理方法都集合到了一起</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelViewSet</span>(mixins.CreateModelMixin,</span><br><span class="line">                   mixins.RetrieveModelMixin,</span><br><span class="line">                   mixins.UpdateModelMixin,</span><br><span class="line">                   mixins.DestroyModelMixin,</span><br><span class="line">                   mixins.ListModelMixin,</span><br><span class="line">                   GenericViewSet):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A viewset that provides default `create()`, `retrieve()`, `update()`,</span></span><br><span class="line"><span class="string">    `partial_update()`, `destroy()` and `list()` actions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>​    使用 viewsets 的 ModelViewSet 时，路由的配置和 ViewSet 是一样的，在 as_view 中都需要配置请求动词和对应方法的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">&#x27;view_set/course/&#x27;</span>, views.CourseViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>: <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;post&#x27;</span>: <span class="string">&#x27;create&#x27;</span>&#125;), name=<span class="string">&quot;vs_course&quot;</span>),</span><br><span class="line"></span><br><span class="line">path(<span class="string">&#x27;view_set/course/&lt;int:pk&gt;/&#x27;</span>, views.CourseViewSet.as_view(&#123;<span class="string">&#x27;get&#x27;</span>: <span class="string">&#x27;retrieve&#x27;</span>, <span class="string">&#x27;put&#x27;</span>: <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>: <span class="string">&#x27;partial_update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>: <span class="string">&#x27;destroy&#x27;</span>&#125;), name=<span class="string">&quot;vs_course_detail&quot;</span>),</span><br></pre></td></tr></table></figure>
<p>​    注意，因为 GET 请求获取的资源可能是一个集合，也可能是具体的对象资源，所以在使用 viewsets 的时候，是需要创建两个 url 的，但是所要执行的视图函数都是一样的，区别就在于 as_view 中，请求动词和视图集中提供的方法</p>
<h3 id="drf-认证组件-——-authentication"><a href="#drf-认证组件-——-authentication" class="headerlink" title="drf 认证组件 —— authentication"></a>drf 认证组件 —— authentication</h3><p>​    <strong>关于 drf 的组件，可以通过两种方式来使用，一种是全局 settings 中配置，另一种是在视图类中设置</strong></p>
<p>​    <strong>认证组件的执行要先于其他的功能组件</strong>，因为 <strong>dispatch 中调用 initialize_request 对 request 封装时，会使用 get_authenticators 方法获取认证类，会去遍历视图类中设置的 authentication_classes 属性</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_request</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns the initial request object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>​    如果没有设置，就会去全局配置文件中查找 DEFAULT_AUTHENTICATION_CLASSES 的配置项</p>
<p>​    <strong>全局配置，需要在 settings 中配置一个 REST_FRAMEWORK 的字典，认证组件需要配置 DEFAULT_AUTHENTICATION_CLASSES</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">        <span class="comment"># 默认认证组件, 认证组件会在视图最开始处理时执行，并且也先于权限，认证组件的优先级是最高的</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,</span><br><span class="line">        <span class="comment"># 最基本的 http 用户名，密码认证方式，通过后 request.user 是登录用户对象，request.auth 是 None</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,</span><br><span class="line">        <span class="comment"># Session 方式根据后端的会话认证，前端可以通过 ajax 来发送认证，但是 post 和 put 请求都需要携带 csrf_token，认证通过后，request.auth 也是返回 None</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.TokenAuthentication&#x27;</span>,</span><br><span class="line">        <span class="comment"># 多个认证组件，由上至下进行，认证通过后，返回 request.user, request.auth</span></span><br><span class="line">        <span class="comment"># 不通过，则向下进行其他类型的认证，一旦通过，那么后面的认证模块就不会再去执行</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>drf 中认证组件有 BasicAuthentication，SessionAuthentication 和 TokenAuthentication</strong>。initialize_request 中完成对 Request 的封装后得到 request 实例，会执行 <strong>initial 方法，内部会去执行 perform_authentication(request) 方法，该方法会去调用 request.user</strong></p>
<p>​    <strong>然后会去调用 _authenticate 方法，该方法会循环 self.authenticators</strong>，这个 authenticators 就是在 initialize_request 封装 Request 时，循环遍历设置的 authentication_classes 得到的认证类的列表。然后会去调用 <strong>每个认证类的 authenticate 方法，认证通过会返回 user_auth_tuple</strong>，这个元组有两个元素，第一个就是 user 的实例，第二个是 auth 值就是 None </p>
<p>​    使用 BasicAuthentication 认证时，postman 在请求头的字段字段会添加一个 Authorization 字段，值是 Basic + 一个空格 + 用户名和密码在 base64 字后的密文。由于请求头信息中包含了用户敏感信息，虽然是编码后的值，但是这个密文是可以回推从而得到明文信息的，所以 BasicAuthentication 并不是一种绝对安全的方式，通常情况下在使用 postman 做接口测试时，会使用这个认证。<strong>如果认证失败了，在响应头会多一个 WWW-Authenticate 的字段</strong></p>
<p>​    SessionAuthentication 认证使用的是 django 框架的 Session 框架做认证，所以 SessionAuthentication 是需要请求中要携带 csrf_token 的。认证通过了 user 属性也是用户实例，auth 也是 None，但是认证不通过，不会在响应头中添加字段</p>
<p>​    TokenAuthentication 是 drf 基于 token 令牌的一种认证方式，<strong>使用 TokenAuthentication 的话，需要在 installed-app 中加上 ‘rest_framework.authtoken’，同时需要进行数据迁移同步数据库，会生成一张 authtoken_token 的表</strong>，包含三个字段 key，也就是 token 令牌；created 表示创建时间；user_id 表示用户 id</p>
<p>​    如果使用的 django 自己的 AUTH_USER_MODEL 作为用户模型类，在创建用户时不会主动去给对应用户创建 token，所以需要使用信号机制来触发 TokenAuthentication 的 Token 模型类，来生成一个 token 令牌</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> django.db.model.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment"># from django.contrib.auth.models import User</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @receiver(post_save, sender=User)</span></span><br><span class="line"><span class="meta">@receiver(<span class="params">post_save, sender=settings.AUTH_USER_MODEL</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_token</span>(<span class="params">sender, instance=<span class="literal">None</span>, created=<span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建用户时，触发信号，函数接收信号和用户对象，在 token 表中创建该用户的 Token&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> created:</span><br><span class="line">        <span class="comment"># 用户创建后触发信号，created 会是 True</span></span><br><span class="line">        Token.objects.create(user=instance)  </span><br><span class="line">        <span class="comment"># 创建 token 时，user 字段就是刚才创建好的用户实例 instance</span></span><br></pre></td></tr></table></figure>
<p>​    rest_framework.authtoken 也提供了一个视图 obtain_auth_token 接口用来返回用户的 token 信息，在 postman 上通过设置的路由，访问 obtain_auth_toekn 这个接口时，还是需要使用用户名和密码登录的，然后才能获取到自己的 token</p>
<p>​    TokenAuthentication 认证成功后，user 会被赋值为用户的实例，auth 则被赋值为 Token 的实例，得到对应的 token 令牌。认证失败的话，响应头中也会有 WWW-Authenticate 字段</p>
<p>​    得到用户的 token 后，在后面的请求可以在 postman 的 Auth 认证栏中选择 API key 的方式，key 就是 Authorzation 字段，value 就是 Token + 空格 + token 的值</p>
<p>​    <strong>补充：</strong>drf 的组件设置因为可以全局，也可以在局部设置，两者的优先级是局部要优先</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> authentication_classes, permission_classes, throttle_classes</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BasicAuthentication, SessionAuthentication, TokenAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_classes(<span class="params">(<span class="params">TokenAuthentication,</span>)</span>)</span></span><br><span class="line"><span class="meta">@permission_classes(<span class="params">(<span class="params">IsAuthenticated,</span>)</span>)</span></span><br><span class="line"><span class="meta">@throttle_classes(<span class="params">...</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">course_list</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>​    在 FBV 和 CBV 中局部设置认证，权限，频率组件，需要使用 rest_framework 中 decorators 装饰器中的 authentication_classes, permission_classes, throttle_classes 来做装饰，注意组件的执行顺序</p>
<p>​    而在 GCBV 之后，组件的设置可以直接通过属性方式设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br></pre></td></tr></table></figure>
<h3 id="drf-权限组件-——-permissions"><a href="#drf-权限组件-——-permissions" class="headerlink" title="drf 权限组件 —— permissions"></a>drf 权限组件 —— permissions</h3><p>​    权限组件同样可以进行全局配置，或是在视图类中通过 permission_classes 属性来设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">	<span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (</span><br><span class="line">    	<span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,   <span class="comment"># 认证是否通过</span></span><br><span class="line">	),</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br></pre></td></tr></table></figure>
<p>​    drf 的 permissions 组件提供多种权限校验，<strong>AllowAny 允许所有，也就是不校验权限；IsAuthenticated 检查是否通过认证，认证通过的用户才能访问；IsAdminuser 只有管理员权限的角色可以访问；IsAuthenticatedOrReadOnly，表示认证通过的可以访问和操作，而认证未通过的匿名用户只能使用 get 请求</strong></p>
<p>​    drf 的权限组件的执行流程是，在 <strong>dispatch 的 initial 方法中调用 self.check_permissions(request)，该方法会去调用 get_permissions 方法会循环遍历得到权限组件的列表</strong>，然后遍历这个列表得到每一个权限校验类，去 <strong>调用 has_permission 方法</strong>，这个方法会返回 True 或 False 来表示是否有权限</p>
<p>​    所以自定义权限检查类时，需要定义一个 <strong>has_permission 方法，该方法用于检查是否有权限访问视图，如果是模型类的权限，可以定义 has_object_permission</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IsOwnerorReadOnly</span>(permissions.BasePermission):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义权限，只允许对象的所有者才能编辑&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_object_permission</span>(<span class="params">self, request, view, obj</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        所有的 request 请求都有读权限，GET，HEAD，OPTION</span></span><br><span class="line"><span class="string">        :param request: drf 自己的 request</span></span><br><span class="line"><span class="string">        :param view: view 表示当前视图</span></span><br><span class="line"><span class="string">        :param obj: obj 表示 instance</span></span><br><span class="line"><span class="string">        :return: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:   <span class="comment"># (&quot;GET&quot;,&quot;HEAD&quot;,&quot;OPTION&quot;)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> request.user == obj.teacher</span><br></pre></td></tr></table></figure>
<h3 id="drf-频率组件-——-throttling"><a href="#drf-频率组件-——-throttling" class="headerlink" title="drf 频率组件 —— throttling"></a>drf 频率组件 —— throttling</h3><p>​    同样支持两种配置方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">	<span class="string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.AnonRateThrottle&#x27;</span>,   <span class="comment"># 对匿名用户做频率显示</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.throttling.UserRateThrottle&#x27;</span>,   <span class="comment"># 对请求用户做频率限制</span></span><br><span class="line">    ],</span><br><span class="line">	<span class="string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment"># THROTTLE_RATES 支持 second，minute，hour，day</span></span><br><span class="line">        <span class="string">&#x27;anon&#x27;</span>: <span class="string">&#x27;100/day&#x27;</span>,     <span class="comment"># 匿名用户每天只能访问 100 次</span></span><br><span class="line">        <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;2/minute&#x27;</span>,    <span class="comment"># 限制用户每分钟只能访问 2 次</span></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCourseList</span>(generics.ListCreateAPIView):</span><br><span class="line">    queryset = Course.objects.<span class="built_in">all</span>()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br></pre></td></tr></table></figure>
<p>​    频率组件的执行流程和权限组件是一样的，<strong>initial 中去调用 self.check_throttles(request)</strong>，会去遍历设置的频率类，调用 <strong>allow_request</strong> 方法判断结果是 True 还是 False，如果 allow_request  返回 False 了，会接着调用频率类的 <strong>wait</strong> 方法，这个方法返回的就是需要等待的时间</p>
<p>​    同时，check_throttles 中还会创建一个列表，会将 wait 返回的时间添加进去，并且会去遍历取出一个最大值</p>
<p>​    drf 中 <strong>匿名用户频率限制 AnonRateThrottle 类</strong>，主要使用 ip 地址来进行区分限制；<strong>登录用户 UserRateThrottle 类</strong>，使用的是 user_id 来区分做限制；<strong>ScopedRateThrottle 类是对每个视图做访问限制</strong>，使用 ip 或 user_id 来区分</p>
<p>​    如果要 <strong>自定义频率限制类，需要实现两个基本方法，allow_request 和 wait</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> throttling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPThrottle</span>(throttling.BaseThrottle):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;每个 ip 一分钟内只能访问 3 次&#x27;&#x27;&#x27;</span></span><br><span class="line">    ip_pool = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.history_list = []</span><br><span class="line">        self.cur_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allow_request</span>(<span class="params">self, request, view</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.history_list)</span><br><span class="line">        ip = request.META.get(<span class="string">&#x27;REMOTE_ADDR&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> ip <span class="keyword">not</span> <span class="keyword">in</span> self.ip_pool:</span><br><span class="line">            self.ip_pool[ip] = [self.cur_time]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        self.history_list = self.ip_pool[ip]</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     if self.cur_time - self.history_list[-1] &gt; 60:</span></span><br><span class="line">        <span class="comment">#         self.ip_pool[ip].pop(-1)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line">        <span class="keyword">while</span> self.history_list <span class="keyword">and</span> self.cur_time - self.history_list[-<span class="number">1</span>] &gt; <span class="number">60</span>:</span><br><span class="line">            self.history_list.pop(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.history_list) &lt; <span class="number">3</span>:</span><br><span class="line">            self.history_list.append(self.cur_time)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span> - (self.cur_time - self.history_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h3 id="drf-分页组件-——-pagination"><a href="#drf-分页组件-——-pagination" class="headerlink" title="drf 分页组件 —— pagination"></a>drf 分页组件 —— pagination</h3><p>​    全局的配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>:  <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">100</span>,      <span class="comment"># 每页数目</span></span><br><span class="line">    <span class="string">&#x27;MAX_PAGE_SIZE&#x27;</span>: <span class="number">10</span>,   <span class="comment"># 显示的页数最多是 10 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    自定义按照页数参数的分页器，需要继承 PageNumberPagination。注意下面所使用的类视图都是通用类视图，因为通用类视图中有 pagination_class 的属性可以设置自定义的分页器类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagintation.PageNumberPagination</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LargeResultsSetPagination</span>(<span class="title class_ inherited__">PageNumberPagination</span>):</span><br><span class="line">    page_size = <span class="number">1000</span>    <span class="comment"># page_size 和全局的 PAGE_SIZE 一样，表示每一页的数据条数</span></span><br><span class="line">    page_size_query_param = <span class="string">&#x27;page_size&#x27;</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BillingRecordsView</span>(generics.ListAPIView):</span><br><span class="line">    queryset = Billing.objects.<span class="built_in">all</span>()</span><br><span class="line">    pagination_class = LargeResultsSetPagination</span><br></pre></td></tr></table></figure>
<p>​    这里 page_size_query_param 的属性，这个属性的作用是允许动态获取指定的数据条数。默认情况下，设置 page_size 来控制每一页的数据条数，在 url 上使用通过参数 ?page=1 来获取不同页上 page_size 设定的数目，因为默认分页器的 page_query_param 属性的值就是 “page”，这个 page 就是代表 api 的 url 上的获取指定页的参数 page</p>
<p>​    设置 page_size_query_param 的值为 “page_size”，就表示前端通过的 api 上 url 的参数中允许使用 page_size 来指定要获取的数据条数，但是如果设置了 page_size 属性的值是 10，那么即使 api 上使用 ?page_size=100，也只能获得 10 条记录</p>
<p>​    除了 PageNumberPagination 使用 page 参数来做分页，drf 还有 LimitOffsetPagination 支持通过偏移量获取不同的数据记录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> LimitOffsetPagination</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BillingRecordsView</span>(generics.ListAPIView):</span><br><span class="line">    queryset = Billing.objects.<span class="built_in">all</span>()</span><br><span class="line">    pagination_class = LimitOffsetPagination</span><br></pre></td></tr></table></figure>
<p>​    <strong>LimitOffsetPagination 的属性有 default_limit 作用和 page_size 一样，表示每一页的数量，还有  limit_query_param 属性表示 url 上的参数，默认就是 limit，还有 offset_query_param 属性，也是指向参数 offset</strong></p>
<p>​    所以使用 LimitOffsetPagination 做分页器，api 的 url 使用的参数就是 ?limit=100&amp;offset=400，表示的就是从 400 开始取出 100 条记录</p>
<p>​    <strong>非通用类视图的 APIView 视图中，可以在 list 的方法内，手动实例化分页器对象，然后调用对象的 paginate_queryset 方法，这个方法要接收的参数第一个是查询集对象，第二个是 request</strong></p>
<p>​    分页器类中还实现了 get_paginated_response 来构建返回的 response，在页数分页类 PageNumberPagination 中，get_paginated_response 需要接受处理好分页后的查询对象数组，会自动将上下页的路由处理好并放在响应中，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_paginated_response</span>(<span class="params">self, data</span>):</span><br><span class="line">    <span class="keyword">return</span> Response(OrderedDict([</span><br><span class="line">        (<span class="string">&#x27;count&#x27;</span>, self.page.paginator.count),   <span class="comment"># count 不是总页数，而是分页对象接收的查询集的长度，也就是每页的数据条数</span></span><br><span class="line">        (<span class="string">&#x27;next&#x27;</span>, self.get_next_link()),</span><br><span class="line">        (<span class="string">&#x27;previous&#x27;</span>, self.get_previous_link()),</span><br><span class="line">        (<span class="string">&#x27;results&#x27;</span>, data)</span><br><span class="line">    ]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pagination</span>(<span class="title class_ inherited__">PageNumberPagination</span>):</span><br><span class="line">    page_size = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GASListViewSet</span>(viewsets.ViewSet):    <span class="comment"># ViewSet 继承了 APIView 和 ViewSetMixin</span></span><br><span class="line">    authentication_classes = [MyJWTAuthentication]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">list</span>(<span class="params">self, request</span>):</span><br><span class="line">        gases = Goods_And_Services.objects\</span><br><span class="line">            .<span class="built_in">filter</span>(deleted_at=<span class="literal">None</span>, creator_id_id=request.user_obj.get(<span class="string">&#x27;user_id&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        paginator = Pagination()</span><br><span class="line">        gases = paginator.paginate_queryset(gases, request)</span><br><span class="line"></span><br><span class="line">        serializer = GASSerializer(instance=gases, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> paginator.get_paginated_response(serializer.data)</span><br><span class="line">        <span class="comment"># return Response(data=serializer.data)</span></span><br></pre></td></tr></table></figure>
<h3 id="drf-解析组件-——-parsers"><a href="#drf-解析组件-——-parsers" class="headerlink" title="drf 解析组件 —— parsers"></a>drf 解析组件 —— parsers</h3><p>​    解析器的作用就是从前端中根据 content_type 字段的类型，来对前端发送的数据做解析。<strong>在 drf 中 parsers 解析器默认提供了三种解析器，包括 JSONParser，FormParser 和 MultiPartParser，分别对应处理 json 数据，表单数据，以及复杂的表单数据解析，比如表单中提交的数据会有文件的上传的话就可以使用 MultiPartParser</strong>，全局配置需要设置 DEFAULT_PARSER_CLASSES</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_PARSER_CLASSES&#x27;</span>:[</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.JSONParser&#x27;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.FormParser&#x27;</span></span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.MultiPartParser&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    如果在类视图函数中做针对性的数据解析，需要使用 parser_classes 的属性指定</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    parser_classes = [JSONParser, ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>​    JSONParser 会根据 application/json 的类型做解析，从 request.data 中解析前端的 json 数据并返回一个 dict 字典</p>
<p>​    FormParser 会根据 application/x-www-form-urlencoded 类型解析，同样在 request.data 中取出键值数据，但最后返回的是一个 QueryDict 对象</p>
<p>​    MultiPartParser 会根据 multipart/form-data 类型做解析，为了完全支持前端的表单数据解析，通常会与 FormParser  一起使用，所以和 FormParser 一样都是返回 QueryDict  对象</p>
<p>​    <strong>FileUploadParser 是专门用来处理前端文件上传的解析类，要获取解析数据通过 file 这个字段，即 request.data[‘file’]</strong></p>
<p>​    如果要自定义解析类，需要继承 BaseParser，并对 parse 方法进行实现，parse 的方法接收三个参数。stream 表示前端的 request 的数据流对象，media_type 表示就是前端中对应 Content_Type 字段的数据类型，parser_context 表示解析数据的上下文，这个参数必须是字典类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlainTextParser</span>(<span class="title class_ inherited__">BaseParser</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Plain text parser.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    media_type = <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, stream, media_type=<span class="literal">None</span>, parser_context=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Simply return a string representing the body of the request.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> stream.read()</span><br></pre></td></tr></table></figure>
<p>​    media_type 和 parser_context 不是必要参数，因为这个两个参数默认是 None，所以在 parse 方法主要完成的就是 request 数据对象的读取</p>
<p>​    解析类的执行流程，在 dispatch 中执行 request 的初始化方法 initialize_request，这个方法会调用 get_parser_context 方法从参数 request 中得到 parser_context，然后返回 Request 类的实例，这里实例第一个参数就是 django 自身的 request，然后包括调用 get_parsers 方法从设置的 parser_classes 中遍历解析类，或是从全局中获取默认的解析类列表，然后还包括前面提到的 get_authenticators 方法得到认证类，get_content_negotiator 方法得到分页类，同时会将 parser_context 传入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_request</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns the initial request object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>​    在 Request 这个类中，有一个 data 的属性，在函数视图中的 request.data 就会从这个属性获取数据，该属性会去调用 _load_data_and_files 方法，会去调用 _parse 方法，这个私有方法的内部实际就是调用了解析类的 parse 方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parsed = parser.parse(stream, media_type, self.parser_context)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="comment"># If we get an exception during parsing, fill in empty data and</span></span><br><span class="line">    <span class="comment"># re-raise.  Ensures we don&#x27;t simply repeat the error when</span></span><br><span class="line">    <span class="comment"># attempting to render the browsable renderer response, or when</span></span><br><span class="line">    <span class="comment"># logging the request or similar.</span></span><br><span class="line">    self._data = QueryDict(<span class="string">&#x27;&#x27;</span>, encoding=self._request._encoding)</span><br><span class="line">    self._files = MultiValueDict()</span><br><span class="line">    self._full_data = self._data</span><br></pre></td></tr></table></figure>
<p>​    同时将 Querydict 的数据赋给 _data 变量，文件的数据则是给 _files 变量，最后 _parse 会返回一个元组包含解析后的 (data, files)</p>
<h3 id="drf-渲染组件-——-renderers"><a href="#drf-渲染组件-——-renderers" class="headerlink" title="drf 渲染组件 —— renderers"></a>drf 渲染组件 —— renderers</h3><p>​    渲染组件和解析组件其实是一个道理，只是方向不同，渲染类的作用是后端的数据通过渲染类转变为前端能够处理的数据类型，drf 默认使用了两个 JSONRenderer，BrowsableAPIRenderer 两个渲染类，全局中配置通过 DEFAULT_RENDERER_CLASSES 设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;DEFAULT_RENDERER_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.JSONRenderer&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    类视图中使用，则可以直接通过 renderer_classes 属性设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestView</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    renderer_classes = [JSONRenderer, ]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure>
<p>​    当视图返回 response 的时候，在 Response 的类中有一个 rendered_content 的属性方法，内部最终是通过 getattr 得到 renderer 设置的渲染类，通过调用 renderer 的 render 方法的得到 ret 并返回</p>
<h3 id="drf-异常处理"><a href="#drf-异常处理" class="headerlink" title="drf 异常处理"></a>drf 异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_exception_handler</span>(<span class="params">exc, context</span>):</span><br><span class="line">    <span class="comment"># 先调用 REST framework 默认的异常处理方法获得标准错误响应对象</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在此处补充自定义的异常处理</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">&#x27;status_code&#x27;</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>
<p>​    在全局配置中，如果没有定义自定义的异常处理函数，默认会去使用 drf 自己的视图异常处理方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="string">&#x27;rest_framework.views.exception_handler&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    drf 中常见的异常有：</p>
<p>​    AuthenticationFailed 表示认证失败</p>
<p>​    NotAuthenticated 表示没有进行认证</p>
<p>​    PermissionDenied 表示权限拒绝</p>
<p>​    MethodNotAllowed 表示请求方法不支持，CBV 通过 api_view （from rest_framework.decorators import api_view）的装饰器，可以指定允许的请求方式，@api_view([“GET”, “POST”])，表示只允许 get 和 post</p>
<p>​    Throttled 表示超出频率限制</p>
<p>​    ValidationError 表示数据校验有错误</p>
<h3 id="drf-的全局配置"><a href="#drf-的全局配置" class="headerlink" title="drf 的全局配置"></a>drf 的全局配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DRF的全局配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 设置分页</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>: <span class="string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PAGE_SIZE&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment"># 设置日期格式化</span></span><br><span class="line">    <span class="string">&#x27;DATETIME_FORMAT&#x27;</span>: <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>,</span><br><span class="line">    <span class="comment"># 当 DRF 返回 response 对象时，要使用的 rander 类</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_RENDER_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.renders.JSONRenderer&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.renders.BrowsableAPIRenderer&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 解析器，如何解析 request 请求中的 request.data</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PARSER_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.JSONParser&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.FormParser&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.parsers.MultiPartParser&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 权限以及认证相关的配置</span></span><br><span class="line">    <span class="string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.permissions.IsAuthenticated&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.BasicAuthentication&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.SessionAuthentication&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;rest_framework.authentication.TokenAuthentication&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/685301591/">http://example.com/685301591/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rest-Framework/">Rest_Framework</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover34.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/3963924866/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover35.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常见算法</div></div></a></div><div class="next-post pull-right"><a href="/2201923992/"><img class="next-cover" src="https://wei-foun.github.io/img/cover33.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Celery-整理</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-Serializer"><span class="toc-number">1.</span> <span class="toc-text">序列化 Serializer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#django-%E7%9A%84-serializers"><span class="toc-number">1.1.</span> <span class="toc-text">django 的 serializers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#drf-%E7%9A%84-serializers"><span class="toc-number">1.2.</span> <span class="toc-text">drf 的 serializers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serializers-%E7%9A%84%E9%92%A9%E5%AD%90"><span class="toc-number">1.3.</span> <span class="toc-text">serializers 的钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ModelSerializer"><span class="toc-number">1.4.</span> <span class="toc-text">ModelSerializer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%B7%AF%E7%94%B1"><span class="toc-number">2.</span> <span class="toc-text">drf 视图与路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FBV"><span class="toc-number">2.1.</span> <span class="toc-text">FBV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CBV"><span class="toc-number">2.2.</span> <span class="toc-text">CBV</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6-%E2%80%94%E2%80%94-authentication"><span class="toc-number">3.</span> <span class="toc-text">drf 认证组件 —— authentication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E6%9D%83%E9%99%90%E7%BB%84%E4%BB%B6-%E2%80%94%E2%80%94-permissions"><span class="toc-number">4.</span> <span class="toc-text">drf 权限组件 —— permissions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E9%A2%91%E7%8E%87%E7%BB%84%E4%BB%B6-%E2%80%94%E2%80%94-throttling"><span class="toc-number">5.</span> <span class="toc-text">drf 频率组件 —— throttling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B6-%E2%80%94%E2%80%94-pagination"><span class="toc-number">6.</span> <span class="toc-text">drf 分页组件 —— pagination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E8%A7%A3%E6%9E%90%E7%BB%84%E4%BB%B6-%E2%80%94%E2%80%94-parsers"><span class="toc-number">7.</span> <span class="toc-text">drf 解析组件 —— parsers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6-%E2%80%94%E2%80%94-renderers"><span class="toc-number">8.</span> <span class="toc-text">drf 渲染组件 —— renderers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">drf 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-%E7%9A%84%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="toc-number">10.</span> <span class="toc-text">drf 的全局配置</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/1213981086/" title="k8s-调度"><img src="https://wei-foun.github.io/img/cover49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s-调度"/></a><div class="content"><a class="title" href="/1213981086/" title="k8s-调度">k8s-调度</a><time datetime="2025-08-02T07:25:30.000Z" title="发表于 2025-08-02 15:25:30">2025-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/558590641/" title="k8s整理"><img src="https://wei-foun.github.io/img/cover48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s整理"/></a><div class="content"><a class="title" href="/558590641/" title="k8s整理">k8s整理</a><time datetime="2025-07-31T07:24:29.000Z" title="发表于 2025-07-31 15:24:29">2025-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/466764255/" title="airflow整理"><img src="https://wei-foun.github.io/img/cover47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="airflow整理"/></a><div class="content"><a class="title" href="/466764255/" title="airflow整理">airflow整理</a><time datetime="2025-07-12T07:04:30.000Z" title="发表于 2025-07-12 15:04:30">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux再学习"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux再学习"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux再学习">Linux再学习</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4075015966/" title="GO 基础"><img src="https://wei-foun.github.io/img/cover45.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO 基础"/></a><div class="content"><a class="title" href="/4075015966/" title="GO 基础">GO 基础</a><time datetime="2025-07-04T16:26:58.000Z" title="发表于 2025-07-05 00:26:58">2025-07-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover34.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>