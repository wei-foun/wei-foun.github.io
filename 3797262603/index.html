<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>计算机网络 | </title><meta name="keywords" content="计算机网络"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一条 url 所经历的过程​    大致的简单流程是： ​    DNS 查询 -&gt; TCP 三次握手 -&gt; HTTP 请求 -&gt; Nginx 服务器 -&gt; uWSGI 服务器 -&gt; web 应用程序响应 -&gt; TCP 四次挥手 ​    当浏览器中输入一个 url 时，首先会在本地的 dns 缓存上进行查询，如果浏览器内部没有，会再去本地系统的 hosts 文">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/3797262603/index.html">
<meta property="og:site_name">
<meta property="og:description" content="一条 url 所经历的过程​    大致的简单流程是： ​    DNS 查询 -&gt; TCP 三次握手 -&gt; HTTP 请求 -&gt; Nginx 服务器 -&gt; uWSGI 服务器 -&gt; web 应用程序响应 -&gt; TCP 四次挥手 ​    当浏览器中输入一个 url 时，首先会在本地的 dns 缓存上进行查询，如果浏览器内部没有，会再去本地系统的 hosts 文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover23.jpg">
<meta property="article:published_time" content="2020-11-03T13:45:50.000Z">
<meta property="article:modified_time" content="2025-07-25T06:40:24.078Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover23.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/3797262603/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-25 14:40:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover23.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-03T13:45:50.000Z" title="发表于 2020-11-03 21:45:50">2020-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-25T06:40:24.078Z" title="更新于 2025-07-25 14:40:24">2025-07-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一条-url-所经历的过程"><a href="#一条-url-所经历的过程" class="headerlink" title="一条 url 所经历的过程"></a>一条 url 所经历的过程</h3><p>​    大致的简单流程是：</p>
<p>​    <strong>DNS 查询</strong> -&gt; <strong>TCP 三次握手</strong> -&gt; <strong>HTTP 请求</strong> -&gt; <strong>Nginx 服务器</strong> -&gt; <strong>uWSGI 服务器</strong> -&gt; <strong>web 应用程序响应</strong> -&gt; <strong>TCP 四次挥手</strong></p>
<p>​    当浏览器中输入一个 url 时，首先会在本地的 dns 缓存上进行查询，如果浏览器内部没有，会再去本地系统的 hosts 文件查询。如果依然没有，再往上层去查询，比如查询路由器缓存，没有就往上去查询 dns 服务器</p>
<p>​    当查询得到目标的 ip 地址之后，就需要通过 tcp 协议去建立连接，即常说的 “三次握手”，建立好连接就下去就是开始通信</p>
<p>​    请求来到应用层上，通过 http 协议向目标地址发起请求，但是这个请求通常不会直接直接进入到 web 应用程序中进行处理，请求可能进过一系列的路由跳转，会先到达一个 “中转站”，像是 Nginx 服务器上，来对大量请求做负载均衡，或是反向代理</p>
<p>​    经过 Nginx 的分发，请求来到 uWSGI 服务器上，因为应用程序可能是利用各个不同的开发语言和程序框架去开发的，比如 python 的 django，flask 或 tornado 等等，http 协议请求进入到他们内部不方便被处理来获取需要的信息，所以需要通过 uWSGI 服务器的 uwsgi 协议（是一种线路协议，而不是通信协议）将请求变为各个框架可以处理的形式。简单来说，uWSGI 服务器其实是 Nginx 服务器 和 web 应用程序服务器的中间桥梁，提供了两者能交流的一个统一接口进行适配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         uwsgi             WSGI</span><br><span class="line">Nginx &lt;---------&gt; uWSGI &lt;---------&gt; django</span><br></pre></td></tr></table></figure>
<p>​    最后，请求终于跋山涉水来到了 web 应用程序服务器上，开始进行业务逻辑上的处理，同时将最后返回的响应按照之前过来的步骤再返回到浏览器上，并在请求响应结束后，通过 tcp 协议的 “四次挥手” 断开连接</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>​     OSI（Open System Interconnect），即 <strong>开放式系统互联</strong>，是 ISO（国际标准化组织）组织研究的网络互连模型。 ISO 为了更好的使网络应用更为普及，推出了 OSI 参考模型，其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，在同一套标准下进行相互沟通。简而言之，OSI 就像是现实生活的中语言体系，比如英语作为全世界的一套通用语言一样，OSI 参考模型就是为了建立友好的交流方式而制定的一套标准协议</p>
<p>​    OSI 定义了网络互连的七层框架（自下而上）：<strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</strong>。每一层都分工明确，拥有自己标准和任务</p>
<p><img src="https://wei-foun.github.io/img/osi-7.jpg" alt="img"> </p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​    应用层是最接近实际用户的一层，为计算机用户提供应用接口以及网络服务。在应该层中常见的标准协议有：HTTP（超文本传输协议），HTTPS（超文本传输安全协议），FTP（文本传输协议），DNS（域名解析），SMTP（简单的邮件传输协议），POP3（邮局协议版本3）等等</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>​    提供各种用于应用层数据的编码和转化功能，确保数据的安全性和可被其他应用层识别，比如，对数据的加密与解密，图片的编码与解码，以及压缩和解压</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>​    负责建立，管理和终止表示层实体之间的通信会话。可以把会话层想象是以前战争时期的电话接线员，当中央司令向战区指挥官下达指令，拨打电话后，会先接到接线员的地方，这个地方会有大量的线路通向各个战区，接线员知道目标战区后，将电话线转接到战区线路上，当指令下达完成挂断后，接线员负责断开中央线路和该战区线路的通话，那接线员就相当于是一个会话层，管理着发送与接收方之间的会话</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>​    是这七层中尤为重要的一层，同样在上面的例子里，电话接线员所在的转接室就相当于传输层，由它负责端到端的连接与传输。传输层的作用是通过匹配进程和端口，为上层协议提供端到端可靠和透明的传输服务，处理差错问题或是流量控制等问题</p>
<p>​    在传输层中，<strong>数据的传输形式被称为 段，即 数据段（segment）</strong></p>
<p>​    在传输层上，最常见的协议就是：<strong>TCP（传输控制协议），UDP（用户数据报协议）</strong></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>​    同样也是非常重要的一层，依旧是上面的例子，接线员是会话，转接室是负责连接传输，网络层就相当于中央线路和战区线路的线路连接，比如要是连接偏远战区可能就需要先转到附近的转接室，然后再去选择，这其中可能会需要连接多个转接室才能到达目的战区。也就是通过 ip 地址进行节点的连接，同时网络层需要根据需要选择最优路由和交换节点，确保数据可以传输到目的的 ip 地址</p>
<p>​    在网络层中，<strong>数据的形式被称为 包，或是分组（packet）</strong></p>
<p>​    网络层最常见的协议就是 IP（互联网协议），常见的网络设备像是路由器，交换机等</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>​    <strong>将来自 物理层 的数据组成 字节，再由字节组合成 数据帧（frame），或将来自 网络层 的数据拆分为 帧。</strong>数据链路层主要是在不可靠的物理介质上提供可靠的传输，包括，物理地址寻址、流量控制，数据检错或重发</p>
<p>​    数据链路层中 <strong>主要的设备包括二层交换机，网桥等，</strong>包含的协议有 SDLC，HDLC，PPP，STP，帧中继等</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​    规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接，用来传输实际的信号</p>
<p>​    <strong>数据在物理层中的表现形式称为 比特（bit）</strong>，主要的设备包括同轴电缆，双绞线，集线器，中继器，调制解调器等</p>
<h4 id="发送与接收"><a href="#发送与接收" class="headerlink" title="发送与接收"></a>发送与接收</h4><p>​    数据在 OSI 七层模型中的发送和接收，其实就是一次打包和拆包的操作，因为各层会分别在整合的数据上进行头部的添加，用来进行校验</p>
<p>​    <img src="https://wei-foun.github.io/img/osi-s-r.jpg" alt="img"> </p>
<p>​    数据在 <strong>传输层 的 TCP 协议上会加上一个头部，包含 源端口 和 目标端口</strong></p>
<p>​    数据封装后在 <strong>网络层 的 IP 协议上又会加一个头部，包含 源 ip 和 目标 ip</strong></p>
<p>​    在 <strong>数据链路层上添加的头部信息，会包含 源 mac 地址 和 目标 mac 地址</strong></p>
<h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>​    和 OSI 七层模型 是一致的，只是将高层进行整合，合并为了应用层，除此之外，还有四层模型，本质上都是对 OSI 七层的整合，四层模型是将 物理层 和 数据链路层 合并为了一层</p>
<p><img src="https://wei-foun.github.io/img/tcp-ip.jpg" alt="img"></p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>​    <strong>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong></p>
<p>​    面向字节流指的是，<strong>TCP 协议的 socket 会给连接双方留有一个固定大小的缓冲区，且应用程序会将数据块分成合适大小的 字节放入缓冲区</strong>，由缓冲区进行 TCP 报文段的发送以及将接受的 TCP 报文段放入到缓冲区，防止连接中一方发送过快，另一方接收和处理很慢的情况下，导致 TCP 报文段 在接收方出现读取无序情况，或是因为读取处理慢造成缓冲区的字节数据溢出而丢失 TCP 报文。基于字节流的传输，从意识上理解就相当于， TCP 发送报文段的字节数据在接收方来说都是有序的且没有丢失的，发送与接收没有中断产生</p>
<p>​    <strong>优点：</strong>可靠，稳定</p>
<p>​    <strong>缺点：</strong>效率低，慢</p>
<h4 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><img src="https://wei-foun.github.io/img/tcp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<p>​    之前的七层模型中说到，每一层都会对数据进行封装并加上各自可以用来识别的头部信息，传输层的 TCP 协议会给头部信息中加上 源端口 和 目标端口，但除此之外还有很多其他的参数信息</p>
<p>​    序列号（seq）：序列号的值是随机生成的，通信时是顺序递增，来确保数据传输的有序的</p>
<p>​    确认号（ack）：服务端收到客户端序列号，进行响应时，通过客户端发送的序列号 +1 表示确认收到数据包</p>
<p>​    数据偏移：长度是 4 位，即 32 个字节。TCP首部长度在不包含选项的话，是 20 个字节，20 / 4 = 5，也就是说这个报头长度（数据偏移）是 5，那最大就是 40 个字节，因此对于整个 TCP 封装的首部长度最大就是 20 + 40 = 60 个字节，对于这个字段最大可设置的值是 60 / 4 = 15</p>
<p>​    保留位：用来作为以后的扩展使用，整个长度是 6 位，一般设置是 0</p>
<p>​    标志位：总长是 6 位，从左到右依次是 URG，ACK，PSH，RST，SYN，FIN</p>
<p>​        URG：紧急指针是否有效，值为 1 时，表示某一位需要优先处理</p>
<p>​        ACK：确认号是否有效，一般值为 1</p>
<p>​        PSH：值为 1 时，提示接收端程序立即从 TCP 缓冲区把数据读走</p>
<p>​        RST：值为 1 时，表示对方要求重新建立连接，或复位</p>
<p>​        SYN：值为 1 时，表示请求建立连接，并在其序列号的字段进行序列号的初始值设定</p>
<p>​        FIN：值为 1 时，表示断开连接</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>​    <strong>意识理解：</strong>所谓三次握手，指的是客户端与服务端需要通过三次之间的联系才确保两者之间达成有效连接。第一次握手，由客户端向服务端发起连接请求，等待服务器响应。第二次握手，由服务端回应客户端的连接请求，即响应客户端已经收到连接请求并允许进行连接，等待客户端收到消息和回应。第三次握手，即客户端收到服务端的连接请求许可，并响应服务端，建立与服务端的连接</p>
<p>​    这就是基于概念上最简单的理解，就好像是现实中两个人握手一样，通常两人见面伸手并握手后，都习惯性地上下晃动两三下一样</p>
<p>​    <strong>概念理解：</strong>上面的说明只是为了简单描述三次握手是怎样的三次握手，具体的 TCP 协议连接的三次握手中，其实包含了很多参数来表示状态</p>
<p><img src="https://wei-foun.github.io/img/tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="img">  </p>
<p>​    从图可知，客户端与服务端的连接过程中，共发送了 3 个数据包，这分别表示三次握手过程</p>
<p>​    <strong>第一次握手</strong>，客户端处于主动状态，请求连接服务端，发送给服务端的 tcp 数据包中设置了标志位 SYN 的值，该值被设置为 1，来表示请求进行连接，并且会生成一个随机值 （X）作为 序列号（seq） 在这个 tcp 包的头部信息中，请求发送后客户端会进入到发送等待状态，即 SYN_SENT</p>
<p><img src="https://wei-foun.github.io/img/tcp-1.jpg" alt="img"></p>
<p>​    <strong>第二次握手</strong>，服务端从监听状态中，发现连接请求，为了确认客户端身份和是否确认连接，所以发送自己的响应给客户端。首先，在回应的 tcp 的头部信息中，将 ACK 设置为 1，表示确认并允许客户端的连接请求，且 SYN 的值不进行改变，并将接收到的 tcp 头部信息中的序列号进行 + 1（X+1）作为确认序列号，同时会另外自己生成随机值（Y）作为这次响应的序列号。完成后，服务端进入 SYN_RCVD 状态等待客户端对这次响应的确认</p>
<p><img src="https://wei-foun.github.io/img/tcp-2.jpg" alt="img"></p>
<p>​    <strong>第三次握手</strong>，就是最后一步的确认请求，客户端收到服务端允许连接的响应后，需要再次发送一个请求来表示自己确认收到允许连接的响应，因此在这次的 tcp 头部信息中，会将响应的 序列号 +1 作为这次的 确认序列号，而这次包的序列号则是在第一次的 X 上 +1 表示是自己后续的发送包，且一样还是将 ACK 的值设为 1 表示确认。然后将这次请求发送刚给服务端，并进入 ESTABLISHED 状态，服务端收到确认请求后也会进入 ESTABLISHED 状态来表示 tcp 请求连接成功，最后这样就完成了由客户端到服务端的三次握手过程</p>
<p><img src="https://wei-foun.github.io/img/tcp-3.jpg" alt="img"></p>
<p>​    <strong>一个常见的问题：为什么必须是三次握手，两次不行吗？</strong></p>
<p>​    通过上面的解释知道了三次握手中后两次的其实都是用来做确认了，假设现在将三次握手合并为两次，一个问题就是如何在第二次握手完成客户端与服务端对连接请求的确认，当客户端一开始请求连接发送了一个 SYN 包后，服务端允许连接并同样需要回一个数据包，同时服务端为了确认客户端收到，会等待客户端再给自己一个响应来确认对方。如果只有两次，服务端发送响应后就结束了，这样一直无法知道客户端是否收到自己允许客户端连接的响应</p>
<p>​    其次，如果服务端响应的允许连接的数据包发出后被拦截掉，客户端没有收到响应会一直发送 SYN 数据包来请求连接，假设服务端的响应的 SYN+ACK 的响应数据包一直被拦截，而客户端会不断发送 SYN 来请求，从而导致服务端可能会出现崩溃，因为服务端会维持住一个没有确认回复的半连接状态的连接，如果没有回应会进行重试，并维持这样的半连接大概 30s - 2m 才会丢弃这样的半连接，在一直无法收到服务端的响应的话，且又不断有大量的连接请求过来，导致服务端需要维护这些大量没有意义的半连接，到最后无法承受而挂掉，这就是常说的 “<strong>SYN 洪水攻击</strong>“</p>
<p>​    并且，因为如果只有两次握手来建立连接，假设服务端的响应被客户端收到了，但是对于服务端而言，它永远不知道对方是否有收到，依然会维持半连接或是重试来浪费无端的开销。所以，三次握手中的每一次握手都是必不可少的</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>​    <strong>意识理解：</strong> 在数据传输过程中，客户端想要与服务端断开连接，所以发送一个断开连接的请求给服务端，这是第一次挥手。服务端收到后，进行响应表示自己收到请求并允许断开，这是第二次挥手。紧接着，服务端会立刻看之前通信的数据是否传输完成，如果数据都发给服务端了，服务端会再次发送一个响应表示自己已经连接断开，这是第三次挥手。客户端在收到允许断开的响应，以及服务端断开连接的响应后，会回复一个响应，来通知服务端自己收到了服务端发送的响应，并最后彻底断开连接，这是第四次挥手</p>
<p>​    简单一个例子，你去银行取钱，要取 50w，坐到柜台对面说 “老子要取 50w”，然后柜台服务员忙忙碌碌开始取钱，并一万一万封装给你，这是一个双发的数据通信过程。然后，你发现今天交易所今天有个新基发售，要到结束时间了，你赶着去做韭菜，然后对柜台人员说，”哎呀！还没好吗，算了，我先取 25w 吧”，即第一次挥手，柜台服务员心想，你个土包子，买基直接网上交易不就可以了，还来去现金，祝你早日被割韭菜，嘴上说 “好的”，即第二次挥手。然后柜台服务员将 25w 里最后的 1w 给到你，还在问你还有其他需要帮助的，没有了就会说 “请对本次服务评分，谢谢”，即第三次挥手。赶着当韭菜的你说，”没了没了”，然后不情愿的在评分机器上给了一个 “炸鸡棒” 的评价就离开了，即第四次挥手</p>
<p>​    <strong>概念理解：</strong>在说三次握手的时候，已经知道了 tcp 的数据头部中是含有参数和标志来表示请求类型的，同时对于双方而言也会有状态上的变化</p>
<p><img src="https://wei-foun.github.io/img/tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="img">  </p>
<p>​    <strong>第一次挥手</strong>，客户端会发送一个 FIN 的数据包来表示请求断开，和三次握手一样，除了本次请求的标志位是 FIN 之外，也会生成一个随机值作为 seq 的序列号，然后进入到 FIN_WAIT1 等待状态，等待服务端的响应</p>
<p>​    <strong>第二次挥手</strong>，服务端收到客户端的 FIN 后，需要发送响应表示收到断开连接的请求，即会回复一个 ACK 的确认包，且数据包的确认序列号是请求的 FIN 包里的 seq 序列号 + 1，并且进入到等待断开的状态 CLOSE_WAIT，且客户端收到 ACK 后，会进入 FIN_WAIT2 等待状态</p>
<p>​    <strong>第三次挥手</strong>，服务端会确认自己的数据是否有在传输的，有的话需要等待传输完成，这相当于在用百度限速盘和迅雷在下载一个任务一样，数据在下载过程中选择关闭程序后，会有提示说 “当前仍有任务在下载”，确认了之后，后台的下载进程其实并没有立即关闭程序，而是在等待最后的数据包传输。当没有数据传输了，服务端会发送一个 FIN 的包给客户端，对于服务端的状态而言则是进入 LAST_ACK 最后确认状态，也就是说第二次挥手和第三次挥手都是由服务端发送的，且此时客户端会进入 TIME_WAIT 状态</p>
<p>​    <strong>第四次挥手</strong>，客户端在等待连接关闭的整个状态中，接收到服务端的 FIN 后处在 TIME_WAIT 状态中，会需要对 FIN 包回复一个 ACK 表示确认，如果服务端没收到会进行重试，或是等待 2MSL 的时间，然后进入到 CLOSED 状态，表示连接断开</p>
<p>​    客户端进收到服务端最后的 FIN 后发送 ACK 确认，之所以没有直接断开连接，而是进入到 TIME_WAIT 的状态并等待 2MSL，也是出于可能的网络不稳定的因素。因为，假设客户端最后的 ACK 丢失，导致服务端始终无法收到最后的 ACK，服务端会以为自己的 FIN 没有被收到，会进行重发。并且对于客户端而言，如果在 2MSL 的时间中再次收到服务端的 FIN，那么当前的连接就不能断开，客户端会再次发送 FIN，并在 TIME_WAIT 状态下再去等待 2MSL，如果指定时间内，没再收到服务端的 last_ack 的 FIN，才会进入到 ClOSE 状态断开连接</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>​    上面提到了，在 TCP 的收发时，可能存在发送方发送的速度过快，接收方来不及接收的情况，这样会导致数据的丢失，所以在 TCP 连接双方的缓冲区中，<strong>接收方可以通过 滑动窗口 的机制来限制 TCP 通信时，对数据流量的控制</strong></p>
<p>​    在双方通信时，<strong>接收方可以在 数据接收窗口 rwnd 中设置自己能够接受的数据大小</strong>，这样发送方在数据发送时，一旦发出的数据达到了 rwnd 的限制，就无法继续发送</p>
<p><img src="https://wei-foun.github.io/img/tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" alt="img"></p>
<p>​    图中，一开始接收方 B 设置了接收窗口 rwnd=400 做限制，所以发送方 A 第一次发送和第二次分别发送的 100 个字节的数据，都会被 B 接收，而此时 B 根据 rwnd 的限制，还能接收 200 的字节数据，即 rwnd=200</p>
<p>​    接着 A 开始发送 201 开始的第 3 个 100 字节数据，假设出现网络不稳定，B 没有接收到这次的数据，而此时 B 发送新的响应，并对 rwnd 重新修改了限制，设置为 rwnd=300。A 收到后继续往后发送数据，即 301 和 401 开始的 200 个字节的数据，此时 rwnd=100，且由于之前 201 的数据没有收到接收响应，A 会对 201 的数据进行重试，再次发送。完成后，根据 B 设置的窗口限制，此时的 <strong>rwnd=0，A 无法继续在向 B 发送新的数据</strong></p>
<p>​    B 在处理数据后，再次发送响应将 窗口大小 设为 100，表示还能接受一次数据发送，A 收到后继续往后发送 501 的数据，当 B 收到后又将 rwnd 改为 0，表示让 A 停止发送，不再接收新的数据了</p>
<p>​    另外，<strong>在 TCP 通讯时，每个连接都会持有一个 持续计时器（persistence timer），当其中一方收到另一方发送的 rwnd=0 的滑动窗口通知时，会启动这个计时器，当计时器内部设置的时间到期，会主动发送一个零窗口控测报文段（携带 1 个字节数据），如果不被接收则会重置这个计时器</strong></p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>​    上面提到，当数据从发送方被发出，可能会因为各种网络问题导致丢包，或者是延迟很高，而导致接收方会认为某一段数据没有被收到。比如，客户端发送了 6，7，8，9 四个数据段，而服务端按顺序正常接收后，<strong>发现 7 没有收到，而直接收到了 8，此时就会认为 7 这个数据段丢失了，会要求客户端进行重传，假设 9 也被成功收到，那么就会发送三个重复的数据段 6 的 ack 确认，客户端接收后到三个重复的 ack，就会立即在将对应需要的数据段进行快速重传，而不是去等待 ack 超时再去将缺失的数据段重发</strong></p>
<h4 id="累计-ACK"><a href="#累计-ACK" class="headerlink" title="累计 ACK"></a>累计 ACK</h4><p>​    累计确认机制，实际上为了对响应 ack 的优化。在规定的传输通信中，每一次发送，都对应一次 ack 的响应，但是在不稳定的网络环境中，延时和数据包的丢失是不可避免的，再根据 tcp 的快速重传机制，如果丢失数据段，会连发三次 ack 来要求重发数据，这就是的 ack 的响应可能会非常频繁和冗余，导致占用网络带宽</p>
<p>​    <strong>累计 ack 确认机制允许了接收方能用一个 ack 包回复多个连续的数据的成功接收</strong>。这样的目的就使得 ack 的回复可以降低</p>
<p>​    比如，客户端连续发送 6，7，8，9 四个数据段给服务端，服务端的接收中可能会丢失 7 号数据段，但却受到了后面的 8 和 9，如果服务端在发送 三次冗余 ack 前，第 7 号的数据段到达了服务端，那么此时服务端就成功接收了滑动窗口的所有数据，就会直接回复一个 ack 10。客户端收到 ack 10 的响应包，就表示自己发送的数据全部都被成功接收</p>
<p>​    因此，累计确认机制就可以省去服务端对于 8 的单独 ack 回应，以及对 7 号数据段可能的三次冗余 ack</p>
<p>​    <strong>累计确认机制的实现，就是在 ack 的响应上做了延迟，主要的目的是为了等待后续的数据段的到达，来接收成功收到的数据段并缓存住，如果丢失的段能在这个延迟内被就接收，就只需要用最后一次的 ack 来响应，替代所接收的每一次数据段的 ack 确认</strong></p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>​    上面的 TCP 的 滑动窗口，是接收方对通信可能问题的一种控制机制，而 <strong>拥塞控制，则是由发送方去设置的，发送方会根据设置的 cwnd（congestion windows）控制数据的发送</strong>，拥塞窗口的大小取决于网络的拥塞程度，并以此进行动态的调整</p>
<p>​    <strong>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大，以便把更多的分组发送出去，一旦网络出现拥塞，拥塞窗口就减小一些，减少加入到网络中的分组数</strong></p>
<p>​    所以，发送方对于 <strong>拥塞窗口 的控制会有两个状态：正常发送状态下，使用 慢算法 逐步增大发送量；拥塞状态下，利用 拥塞避免，减缓发送量</strong></p>
<p>​    慢启动的通信开始时，发送方会对网络状况做一个探测，并设置一个最大报文数 MSS，当发送的数据收到确认响应后，会将拥塞窗口的 MSS +1，这样就能实现逐步增加发送的 cwnd，提升发送的效率</p>
<p>​    并且，每经历一个发送和响应的轮次，发送方就会将 cwnd  * 2（注意：一个轮次必须要是数据段是连续发出，并都接收到确认响应）</p>
<p>​    为了避免 慢开始 中 cwnd 指数级增加得过快，导致短时间就引起拥塞情况，还需要设置一个 ssthresh 作为慢启动最后的阈值，一旦 cwnd &gt; ssthresh 就会进入到拥塞避免的状态下</p>
<p>​    拥塞避免，即在 cwnd 到达 ssthresh 的阈值，为了避免继续的指数级增加发送量，触发的一种机制，数据通信过程进入到该状态下，会取消每一个请求响应后轮次的倍数增加，让发送量变成线性递增的形式，而一旦最后网络出现了阻塞，发送方会重新修改 cwnd</p>
<p><img src="https://wei-foun.github.io/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="img"></p>
<p><img src="https://wei-foun.github.io/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B62.jpg" alt="img"></p>
<h4 id="长连接-与-短连接"><a href="#长连接-与-短连接" class="headerlink" title="长连接 与 短连接"></a>长连接 与 短连接</h4><p>​    短连接：即在通过 tcp 三次握手后，发送 http 请求，得到了服务端的响应，便会立刻进行四次挥手，断开 tcp 连接。也就是说每一次需要请求资源前，都需要进行一次 tcp 连接</p>
<p>​    长连接：简单来说，就是在第一次请求建立好 tcp 连接，在得到响应资源后不会立刻进行断开，这样做可以大大节省请求资源浪费在连接上的开销。对于长连接的设置，也很简单，就是 <strong>在 http 的头部中添加 <code>Connection:keep-alive</code></strong></p>
<p>​    需要注意的是长连接并不是意味着一开始的请求建立的 tcp 连接是永久连接，可以通过在头部中添加 <code>Keep-alive:timeout=20</code>，来设置一个长连接的最大维持时间是 20 秒，防止一致维持长连接造成浪费</p>
<p>​    另外，对于 <strong>http 1.1 版本开始，默认都是使用的是长连接</strong></p>
<h4 id="长轮询-与-短轮询"><a href="#长轮询-与-短轮询" class="headerlink" title="长轮询 与 短轮询"></a>长轮询 与 短轮询</h4><p>​    长短轮询在实际的操作上都是一致的，两者都是通过进行一个循环，来对内容进行请求，通常可以通过 js 来设定一个定时器，通过固定时间来发送请求，从而获取新的资源</p>
<p>​    <strong>短轮询：更加偏向设定的轮询时间，一旦到时间，不管请求到的数据是否会有变化都会立即发出请求</strong></p>
<p>​    <strong>长轮询：更加关注数据内容，如果到达设置时间，数据发生了改变才会立即将新结果返回，如果数据没有变动，则是保持原本的数据。同时长轮询会有一个超时时间，数据没有改动，会继续维持长轮询，直到最后超出设定的超时时间，期间如果数据发生改动，会立即返回并开启下一个长轮询，如果依然没有，则会关闭当前的长轮询，重新再开一个</strong></p>
<p>​    轮询所设置的时间，可以某种程度上减少来自客户端的快速频繁请求，但是同样也会带来问题，对于客户端数目非常庞大的网站，如果同一时刻有非常多的长轮询，也就意味着服务端的压力就会很大</p>
<p>​    所以 <strong>长短连接 是对于 tcp 连接角度来做的设置，长短轮询 则是通过编程方式来实现</strong></p>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>​    <strong>用户数据报协议（UDP User Datagram Protocol），是传输层中一种面向无连接的协议</strong>，它主要用于不要求分组顺序到达的传输，分组传输顺序的检查与排序由应用层完成 ，用在对质量要求不高，要求速度接收的场景，像是视频通话服务等</p>
<p>​    与 TCP 基于字节流不同，UDP 数据包在传输前，应用层的数据不会进入到一个缓冲区中，而是在传输层中加上 UDP 的头部直接交给下一层处理然后发送，所以对于接受方而言，接收的 UDP 数据报不会像 TCP 那样是有序的，也会有丢失的情况</p>
<h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>​    不像 TCP 传输前必须要经历三次握手来进行确认，UDP 面向无连接的方式，不需要去关注那些确认序列号和标识符，简单来说就是只管发不管收，就传输效率上来说要比 TCP 高</p>
<h4 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h4><p>​    与 TCP 就像是混沌的两面一样，UDP 简化了数据传输通信前的效率，带来的是自己的不可靠性，因为没有连接双方的确认，使得数据报在网络中以任何路径去发往目的地，且由于可能的网络不稳定，因此不关注是否最后数据报到达了目的地，也就会产生丢包的现象，但是 UDP 适用的场景而言，像是视频通话等，丢失几帧的画面或是一小段声音都不会产生太大的影响</p>
<h4 id="数据包结构-1"><a href="#数据包结构-1" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><img src="https://wei-foun.github.io/img/udp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="img"></p>
<p>​    伪首部：和 TCP 一样是 12 个字节，目的是为了来进行校验，判断数据包是否是发给本机的，但对于 UDP 面向无连接的特性，伪首部的内容并不是实际有效的部分，只是一个虚拟的数据结构</p>
<p>​    校验和：在 UDP 中是一个可选项，通过判断接收到的数据包的 校验和 的 值是否为全 1，来判断是否丢弃收到的该数据包</p>
<p>​    UDP 长度：则是包含了 UDP 首部 和 数据 的字节长度</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>​    <strong>超文本传输协议（Hyper Text Transfer Protocol）</strong>，是 w3c 组织 的对网络通信的一种基于 tcp 协议传输层上的应用层协议，也可以说是一套通信标准，规定了客户端与服务器之间的通信格式，http 协议的 <strong>默认端口是 80</strong></p>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>​    http 协议本身不会对请求和响应之间的通信状态进行保存，简单来说每次 http 请求都不存储着上次所得到响应内容的参数信息，即每一次请求都是独立的。但是随着 web 不断发展，无状态的 http 请求对于业务来说存在很多问题，所以在 <strong>HTTP/1.1 中有引入了 Cookie 来存储一些认证信息，维持用户对于网站的登录状态</strong></p>
<h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>​    指的是 htttp 协议对处理的限制，要求每一次建立的 tcp 连接上只能处理一个请求，当响应了请求后，随即断开连接，以此来节省传输时间，提供并发性能。但在 HTTP/1.1 开始就不是直接立刻断开连接，而是通过参数 <code>Connection:keep-alive</code> 维持一个长连接，又或是再通过 <code>keep-alive:timeout=num</code> 来设置一个最大等待时长，目的是如果一个客户端在得到响应后可能会立刻再次请求获取新的内容，那么就可以依然使用同一个连接来进行数据的传输，减少大量反复建立连接的开销</p>
<p>​    那如果使用了长连接，且发送很多不同该请求，需要怎么区分开呢？可以有两种方式一种就是，一种是在头部信息中加上 <code>Content-Length</code> 字段来告知发送数据有多长，服务端根据长度判断，比如接收文件时，当请求的 <code>Content-Length</code> 为 0 那么就代表客户端的文件上传结束了。但是会有两个问题，如果值设置小于传输的数据大小，会造成数据被截断，如果设置的值小于文件大小，会使接收一致存在处于 Padding 挂起状态</p>
<p>​    那对于动态的数据无法得知长度时，使用 <code>Transfer-Encoding：chunked</code> 表示对数据进行分块编码，对于每一个分块而言，会包含一个 16 进制的数据长度值，且这个数据长度独占一行，通过 ‘\r\n’ 与真实数据隔开，当最后数据长度值为 0 表示当前请求的内容数据传输结束</p>
<h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>​    http 协议上的数据全是明文方式进行传输的，这也使得数据在传输过程中是不安全的</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>​    包含三部分：<strong>请求行，请求头，请求体</strong></p>
<p><img src="https://wei-foun.github.io/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="img"></p>
<p><img src="https://wei-foun.github.io/img/get%E8%AF%B7%E6%B1%82.jpg" alt="img/md5.jpg"></p>
<p>​    通过直接在浏览器中，也可以看到关于请求头的信息，不过请求行的部分不会直接显示，只需要点击一下请求头旁边的 view source 就可以看到请求行。另外一般对于 GET 请求来说，都是为了获取数据，所以一般没有请求体的内容，但是不代表 GET 请求就完全没有请求体</p>
<h5 id="常见的请求头首部字段"><a href="#常见的请求头首部字段" class="headerlink" title="常见的请求头首部字段"></a>常见的请求头首部字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept：可接受的媒体类型（*/*表示支持所有text/html,application/xhtml+xml,application/xml 等）</span><br><span class="line">Accept-Encoding：内容的编码类型（gizp，br，deflate）</span><br><span class="line">Authorization：用户认证信息</span><br><span class="line">Host：请求资源所在服务器</span><br><span class="line">User-Agent：http 客户端程序信息（使用什么设备，浏览器版本等等）</span><br><span class="line">Cookie：每次请求会携带这个值做状态检查</span><br></pre></td></tr></table></figure>
<p>​    媒体类型的形式是，”/“ 前面是顶级媒体类型，描述通用的类型信息和处理规则，有：application，image，text和multipart； “/“ 后面是子类型，表示一个具体数据格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text/html: HTML格式的文本文档</span><br><span class="line">text/plain: 普通的ASCII文本文档</span><br><span class="line">text/xml: XML格</span><br><span class="line">image/png、image/jpeg、image/gif：图片类型</span><br><span class="line">application/xml: XML数据格式 </span><br><span class="line">application/json: JSON数据格式 </span><br><span class="line">application/x-www-form-urlencoded: form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</span><br><span class="line">multipart/form-data: 表单中进行文件上传时，需要使用该格式</span><br></pre></td></tr></table></figure>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>​    包含三部分：<strong>响应行，响应头，响应体</strong></p>
<p><img src="https://wei-foun.github.io/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="img"></p>
<h5 id="常见的响应头首部字段"><a href="#常见的响应头首部字段" class="headerlink" title="常见的响应头首部字段"></a>常见的响应头首部字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges：是否接受字节范围请求</span><br><span class="line">Age：推算资源创建经过的时间</span><br><span class="line">Location：令客户端重定向到指定的url（通常300状态的时候会出现）</span><br><span class="line">Server：http服务器的信息</span><br></pre></td></tr></table></figure>
<h4 id="请求和响应头中通用的首部字段"><a href="#请求和响应头中通用的首部字段" class="headerlink" title="请求和响应头中通用的首部字段"></a>请求和响应头中通用的首部字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control：控制缓存行为</span><br><span class="line">Date：创建报文的日期时间</span><br><span class="line">Pragma：报文指令</span><br><span class="line">Transfer-Encoding：指定报文主体的传输编码方式</span><br></pre></td></tr></table></figure>
<h4 id="请求和响应头中的实体首部字段"><a href="#请求和响应头中的实体首部字段" class="headerlink" title="请求和响应头中的实体首部字段"></a>请求和响应头中的实体首部字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Allow：支持的http的方法</span><br><span class="line">Content-Encoding：主体使用的编码方式</span><br><span class="line">Content-Length：实体内容的长度，单位是字节</span><br><span class="line">Content-Type：主体的媒体类型（json，form，jpeg等等）</span><br><span class="line">Connection：设置持久连接（keep-alive）</span><br></pre></td></tr></table></figure>
<p>​    content_type 通常是服务器告诉客户端，这次数据的类型，accept 通常是表示客户端请求资源时，自己支持哪些类型</p>
<p>​    常见的 Content-Type 类型有：</p>
<p>​    <strong>application/x-www-form-urlencoded</strong>：表示浏览器原生的 form 表单提交，数据格式是按照 key1=val1&amp;key2=val2，且对 key 和 val 都会进行 url 编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 </span><br></pre></td></tr></table></figure>
<p>​    <strong>multipart/form-data</strong>：常见的 post 数据提交方法，在提交文件的时候，需要在 form 表单标签中的设置 <code>enctype=&quot;multipart/form-data&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; name=&quot;description&quot; value=&quot;some text&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;myFile&quot;&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>​    <strong>application/json</strong>：表示消息的主体是经过序列化后的 json 字符串，这种方式可以很方便提交结构复杂的结构化数据，也因此很适合 RESTful 的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/json;charset=utf-8 </span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>text/xml</strong>：是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范，结构上相似与 html，但是相对使用 json 序列化后的结构话数据来说，这样方式会更占用空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST [http://www.example.com](http://www.example.com) HTTP/1.1 </span><br><span class="line">Content-Type: text/xml </span><br><span class="line">&lt;!--?xml version=&quot;1.0&quot;?--&gt; </span><br><span class="line">&lt;methodcall&gt; </span><br><span class="line">    &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; </span><br><span class="line">    &lt;params&gt; </span><br><span class="line">        &lt;param&gt; </span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; </span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt; </span><br><span class="line">&lt;/methodcall&gt; </span><br></pre></td></tr></table></figure>
<h4 id="HTTP-的发展"><a href="#HTTP-的发展" class="headerlink" title="HTTP 的发展"></a>HTTP 的发展</h4><p>​    0.9 版本：91 年发布，只有 GET，返回 html 内容</p>
<p>​    1.0 版本：96 年 5 月发布，增加 POST，HEAD，格式内容不再限于 html，报文中规定了字符集，状态码，编码等</p>
<p>​    <strong>1.1 版本：</strong>97 年 1 月，增加了 PUT，PATCH，DELETE 等，加入了新的机制有：<strong>持久连接（keep-alive），管道机制（pipelining）</strong>，Host 字段</p>
<p>​    <strong>管道机制（pipelining）</strong>，正是因为 1.1 版本实现了长连接，使得产生了管道传输的机制。简单来说，管道机制实现了请求和相应的连续性，因为相比原本的通信方式，一个请求只有收到响应后，才能继续发送下一个请求，而 <strong>管道机制允许了请求发送后，可以不用等待该请求的响应返回，从而继续发送后续的请求</strong>，也就说从原本的单向发送阻塞的通信，变成了双向非阻塞的通信传递</p>
<p>​    不过，虽然发送方的请求允许了不等待响应，非阻塞的发送后续请求，但是对于服务端来说，响应的返回依然是与顺序的，严格按照请求的顺序一一进行响应的返回，如果第一个请求的响应比较耗时，<strong>会导致造成队头阻塞的问题</strong></p>
<p>​    <strong>2.0 版本：</strong>15 年，在 09 年 SPDY 草案版本上做了修改来提升效率，加入了：</p>
<p>​    <strong>二进制协议，</strong>1.1 中头信息是文本格式，数据体可以是文本或二进制，在 <strong>2.0 的版本中头部信息以及数据体一律都是二进制，并统称为 “帧”，叫头信息帧和数据帧</strong></p>
<p>​    <strong>多路复用，</strong>复用 TCP 实现双向实时通信，双发都可以发送多个请求和响应，如果服务器收到两个请求，第一个处理上较慢，会先响应第一个，并同时去响应第二个，然后回过头来继续响应第一个请求还没回复的数据</p>
<p>​    由此可见，2.0 的 多工传输 和 1.1 的 管道机制的不同之处，1.1 的 pipelining 的通信当原本的单发，改成了多发来提升效率，但是对于响应接收依旧是顺序的，会出现队头阻塞问题；<strong>2.0 的 多路复用</strong> 则对该问题的进行一步优化，<strong>允许了响应的返回不按照接收请求的顺序</strong>，达到了一个类似异步的效果</p>
<p>​    但是，<strong>多路复用本质上解决了 http 层面上出现的队头阻塞，但是对于 TCP 连接而言，依然存在队头阻塞问题</strong>，因为数据包的抵达可能是无序的，TCP 需要对接收数据报文校验和排序整合之后在传给上层，<strong>如果某个报文丢失，需要等待这个报文重传，因此 TCP 的连接通信会阻塞</strong></p>
<p>​    <strong>头信息压缩，</strong>使用 gzip 等算法压缩头信息，且双方维护一张头信息表，从而提高速度，比如对头部信息中占用较多且重复的 <code>Cookie</code> 和 <code>User Agent</code> 将这些信息压缩到各自的表里，通过检查索引号，来减少一样信息的发送</p>
<p>​    <strong>数据流，</strong>由于多工传输实现的双方可以发送和响应多个数据，所以在 2 的版本中数据包的接收就是没有顺序的，比如同一个连接中，发起的多个请求可能属于多个不同的响应，<strong>在 2 的版本中将每个请求或回应的所有数据包，称为一个 数据流，用一个唯一编号来标识进行区分，且客户端可以对数据流设置优先级</strong></p>
<p><img src="https://wei-foun.github.io/img/http1.jpg" alt="img"> </p>
<h4 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>用于获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>用于提交数据</td>
</tr>
<tr>
<td>PUT</td>
<td>用于提交新内容，实现数据更新</td>
</tr>
<tr>
<td>DELETE</td>
<td>用于删除指定数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>用于获取报文首部</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>用于询问服务器支持的请求方法</td>
</tr>
<tr>
<td>TRACK</td>
<td>用于测试或debug，将服务端收到请求返回给客户端</td>
</tr>
<tr>
<td>PATCH</td>
<td>用于对数据进行局部更新</td>
</tr>
</tbody></table>
<p>​    对于 GET 请求来说，请求特定资源时，资源的关键字是直接跟在请求的 url 之后，指定资源与 url 部分使用 ‘?’ 进行隔开，如果有多个指定参数则是以 ‘&amp;’ 进行连接；而对于 POST 来说，比如表单内容，都是放在 POST 的请求体的进行提交，前提是表单提交的类型是 form-data</p>
<p>​    除此之外，GET 请求的 url 是有长度限制的，POST 因为数据放在请求体里，所以没有长度限制，但这只是理论上的，如果真的不做限制，对服务端而言处理也是个麻烦</p>
<p>​    POST，PUT，两者也有相似的地方，都可以用来进行数据创建或是进行更新，但要符合 RESTful 规范的要求，还是利用 POST 来做数据创建操作，PUT 用来对数据进行更新</p>
<p>​    另外，PUT 已经是更新了，但是为什么还有个 PATCH ？因为 <strong>PUT 更新接收的是修改后的完整对象</strong>，<strong>PATCH 是局部的更新，</strong>即通过 <strong>接收指定的修改信息对该对象的这个信息进行更新操作</strong></p>
<p>​    也就是说如果只修改一个用户的一个手机号，使用 PUT 必须将这个用户对象的所有信息（修改过手机号后）传入，最后在结果上看的就是一个局部的更新效果，但因此会浪费带宽。而如果使用 PUT 只传入要修改字段的信息，那么该用户的其他字段数据会被清空，只留下修改的字段数据</p>
<h5 id="幂等性（idempotent）"><a href="#幂等性（idempotent）" class="headerlink" title="幂等性（idempotent）"></a>幂等性（idempotent）</h5><p>​    指的是系统的接口对外的一种承诺，也就是说当外部调用接口成功后，<strong>无论之后外部调用几次这个接口，给系统带来的影响都是一样的，这样这个接口就是幂等性的</strong>。也就是说，如果一个客户端调用接口，将数据进行修改，成功后有反复去发送相同操作请求，那么这个结果无论执行多少次，也只有第一次的修改是生效的，之后的相同操作对系统而言结果都是一致，那么这个操作称为是幂等性操作，反之就称为是非幂等性操作</p>
<p>​    <strong>GET</strong>：目的是为了获取资源，比如：<a target="_blank" rel="noopener" href="http://www.alexander/news">http://www.alexander/news</a> 。所以不论执行多少次，对于服务端的数据来说不会有任何副作用，所以自然是一个 <strong>幂等性操作</strong></p>
<p>​    <strong>POST</strong>：用来创建资源，本身而言每一次执行，都会去生成一个新的资源，比如：<a target="_blank" rel="noopener" href="http://www.alexander/article，即使每一次使用">http://www.alexander/article，即使每一次使用</a> POST 提交的数据是完全一致的，但是各自的 URI 并不相同，也就是说对服务器来说 POST 请求提交的数据是有副作用的，所以POST 是一个 <strong>非幂等性操作</strong>。对于非幂等性操作而言，提交的数据需要在服务端进行校验处理</p>
<p>​    <strong>PUT</strong>：其实也可以用来作为数据创建，但是和 POST 的区别在于，POST 针对的是像一个资源的集合体，比如上面创建一篇文章的 url 是 <a target="_blank" rel="noopener" href="http://www.alexander/article，而">http://www.alexander/article，而</a> PUT 则是针对每一个单独个体，目的是进行个体的数据更新操作，url 是 <a target="_blank" rel="noopener" href="http://www.alexander/article/1。所以对于">http://www.alexander/article/1。所以对于</a> PUT 来说，反复进行一个资源的修改对于服务器而言也没有副作用，是一个<strong>幂等性操作</strong></p>
<p>​    <strong>DELETE</strong>：和 PUT 一样，使用 DELETE 去反复对一个资源进行删除，其实最后成效的次数只有一次，对服务器没有副作用，自然是一个 <strong>幂等性操作</strong></p>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p><img src="https://wei-foun.github.io/img/http2.jpg" alt="img"> </p>
<p>​    常见的一些状态码：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>201</td>
<td>创建或修改数据成功</td>
</tr>
<tr>
<td>204</td>
<td>删除数据成功</td>
</tr>
<tr>
<td>301</td>
<td>永久重定向，资源已被永久转移至其他 url 并转到新 url</td>
</tr>
<tr>
<td>302</td>
<td>暂时重定向，资源位置临时改变</td>
</tr>
<tr>
<td>304</td>
<td>自上次请求后，缓存资源没有变化，继续使用缓存资源</td>
</tr>
<tr>
<td>401</td>
<td>没有授权，表示要求验证身份</td>
</tr>
<tr>
<td>403</td>
<td>服务端接受请求，但拒绝执行，缺少 token 或 token 不匹配</td>
</tr>
<tr>
<td>404</td>
<td>页面资源丢失，无法得到指定资源</td>
</tr>
<tr>
<td>405</td>
<td>请求方法被禁用</td>
</tr>
<tr>
<td>501</td>
<td>请求方法对服务器不支持，无法完成资源响应</td>
</tr>
<tr>
<td>502</td>
<td>服务器作为网关或代理服务尝试执行请求时，从上游的服务器收到无效响应</td>
</tr>
<tr>
<td>503</td>
<td>服务器目前无法使用，比如暂时停机维护等</td>
</tr>
<tr>
<td>504</td>
<td>服务器作为网关或代理服务器，没有及时收到上游服务器响应，超时</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持请求中使用的 HTTP 协议版本</td>
</tr>
</tbody></table>
<p>​    301 永久重定向，常用与比如网站域名发生变更，当访问旧域名时就会跳转到新域名下，对于搜索引擎来说，会将原本旧域名下的原有外部链接转移到新域名下，不会损失网站对于搜索引擎的权重</p>
<p>​    302 临时重定向，通常就是临时做跳转，比如匿名用户点击用户中心，跳转登录页面，发生的跳转就是临时跳转，一般在这种情况下搜索引擎不会传递页面权重，但有些情况下 302 的临时重定向也可能会被计入新网址的网站下，这就导致网站域名的流量可能被链接数量分摊，使得网站在搜索引擎的排名降低</p>
<h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><p>​    <strong>安全超文本传输协议（Hypertext Transfer Protocol Secure，HTTPS），基于 HTTP 协议，通过 SSL (Secure Socket Layer，安全套接字协议) / TLS (Transport Layer Security，传输层安全)  提供 加密处理数据、验证对方身份 以及 数据完整性保护，即加密 (Encryption)、认证 (Verification)、鉴定 (Identification) 三种功能</strong></p>
<p><img src="https://wei-foun.github.io/img/https1.jpg" alt="img"></p>
<h4 id="对称加密技术（symmetrical-encryption）"><a href="#对称加密技术（symmetrical-encryption）" class="headerlink" title="对称加密技术（symmetrical encryption）"></a>对称加密技术（symmetrical encryption）</h4><p>​    <strong>加密和解密使用的是同一个密钥</strong>，那么这就是 “对称密钥加解密”，<strong>SSL 在传输阶段对数据进行加密使用的就是对称加密。</strong>对称加密并不安全，一旦唯一的密钥会获取，那个对于加密的数据其实就和明文传输没什么区别了</p>
<p><img src="https://wei-foun.github.io/img/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" alt="img">  </p>
<p>​    对称加密的优点是，它的加密算法计算量要小，使得加密与解密过程更快，但缺点就是因为发送时，密钥会和加密数据一同发给接收方，导致任何一个人拦截了数据，就能获得密钥进行解密</p>
<h4 id="非对称加密技术（asymmetrical-encryption）"><a href="#非对称加密技术（asymmetrical-encryption）" class="headerlink" title="非对称加密技术（asymmetrical encryption）"></a>非对称加密技术（asymmetrical encryption）</h4><p>​    <strong>加密和解密使用的是两个不同的密钥</strong>，那么这就是 “非对称密钥加解密”，对于这两密钥来说，<strong>公钥 与 私钥</strong> 都是由服务器向 CA 认证中心申请的数字证书中所以包含的，服务器会将 公钥 发送给客户端，将 私钥 进行保存，并对接收到数据用自己的 私钥 进行解密，所以在 <strong>SSL 的握手阶段使用的就是 非对称加密</strong></p>
<p><img src="https://wei-foun.github.io/img/%E9%9D%9E%E5%AF%B9%E7%A7%B0.jpg" alt="img"></p>
<p>​    补充：密钥的生成可以通过 openssl 去创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建私钥</span></span><br><span class="line">$ openssl genrsa -out server.key 1024   <span class="comment"># 生成服务端的 rsa 私钥文件</span></span><br><span class="line">$ openssl genrsa -out client.key 1024   <span class="comment"># 生成客户端的 rsa 私钥文件</span></span><br><span class="line"><span class="comment"># 创建公钥</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> server.key -pubout -out server.pem  </span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> client.key -pubout -out client.pem</span><br></pre></td></tr></table></figure>
<p>​    非对称加密，同样也不是绝对安全的，如果中间人进行抓取，扮演双向角色，对服务端假装自己是客户端，在客户端面向假装自己是服务端，就可以在真正的服务端与客户端交换公钥的时候获取到双方的公钥。然后中间人将自己的公钥发给服务端和客户端，这样客户端无法知道公钥是否是真正的服务端公钥，而导致加密数据其实被中间人通过自己的私钥解开</p>
<h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>​    <strong>即结合 非对称加密 和 对称加密 技术</strong>，对于服务端而言，需要将自己的公钥发送给客户端，客户端使用随机数和对称算法得到会话密钥，并用服务端公钥加密，所以在握手阶段时，主要目的是交换密钥（会话密钥），服务端先用自己的私钥解开第一层，获取到客户端制定的通信用的会话密钥。而在数据通信阶段，则使用会话密钥进行双方的数据通信</p>
<p>​    由此，<strong>混合加密中，非对称加密的第一阶段，密钥交换的目的是为了保证密钥的安全性，而第二阶段的对称加密，使得双方可以在加密与解密更加高效</strong></p>
<p>​    混合加密 也不意味着一定安全，一旦中间人攻击，密钥仍然会泄露，那中间人就能获取到数据并解密得到会话密钥，利用这个会话密钥与服务端通信。所以 <strong>https 中出现了数字证书，服务端的公钥需要在权威的 CA 认证机构（Certificate Authority ）申请获取，由此解决公钥的信任问题</strong></p>
<h4 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h4><p>​    通过 <strong>单向（即不可回推出原文）hash 函数对原文进行哈希</strong>，将需加密的明文 “摘要” 成一串固定长度 (如128 bit) 的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且为了提升 hash 的强度，密码学的 “加盐” 策略允许使用随机数据，对原数据做附加输入，来增强算法</p>
<h4 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h4><p>​    数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥 加密技术（非对称加密）和 数字摘要 结合起来，形成了实用的 数字签名技术</p>
<p>​    在 https 中通过 CA（Certificate Authority）数字认证中心来为站点颁发证书，这个证书中具有 CA 自己的公私钥实现的密钥签名，还会包含颁发机构的信息，公钥，公司信息，域名，指纹等等，为了防止中间人攻击，客户端会去验证证书的合法性，包括：验证域名，有效期；判断证书来源是否合法；与 CA 服务器校验判断证书是否被篡改等</p>
<p>​    为了获取 CA 证书，服务端还需通过自己的私钥去生成一个 CSR（Certificate Signing Request）证书签名请求文件。不过要从 CA 机构获取证书是付费的，所以对于中小企业，通常会是使用自签名证书，就是自己拟作为 CA 机构给自己的服务器颁发证书</p>
<p>​    自签名证书同样需要生成私钥，以及 CSR 文件，通过这两个再去生成证书</p>
<p><img src="https://wei-foun.github.io/img/%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6.jpg" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsas -out ca.key 1024</span><br><span class="line">$ openssl req -new -key ca.key -out ca.csr</span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure>
<p>​    完成后，对于服务器来说，就需要去向自己模拟的 CA 申请证书，再此之前需要服务器先生成自己的 CSR 文件 <code>openssl req -new -key server.key -out server.csr</code>，需要注意在这个过程中 Common name 要匹配服务器的域名</p>
<p>​    所以，在 SSL 握手阶段，客户端会收到服务器发送的证书来做校验。即使因为证书中公钥是公开的，中间人虽然获取到证书，但是不能得到服务器自己的私钥，就算进行伪装修改证书，在客户端向服务端验证时，也会去验证请求域名等，如果中间人换回了合法的证书，会因为证书域名和请求域名不一致，而认为不通过</p>
<p><img src="https://wei-foun.github.io/img/ca%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.jpg" alt="img"></p>
<h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>​    https 实现了数据通信的加密，使得常规状态下利用抓包工具所抓取到的内容都是密文状态，但是对于浏览器来说，当发现证书存在问题后，只是提示会有安全风险，如果用户授权了是可以继续访问网站的</p>
<p>​    通常对于 https 的抓包工具都会去生成一个证书，用户手动安装这个证书到本地客户端中，那么之后浏览器发出的请求就不直接是与服务端之间通信，而是像走了一个代理，直接使用生成的证书与抓包工具进行数据通信，抓包工具会将请求转发到服务器，这样一来服务端的返回都会经过抓包工具在返回到浏览器</p>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><p>​    <img src="https://wei-foun.github.io/img/http3.jpg" alt="img">  </p>
<p>​    从图中明显可知，在 http 3.0 使用的就不再是 TCP 协议，而是使用 UDP，并且在基于 UDP 之上，使用了 QUIC，并使用 TLS 1.3 的版本</p>
<p>​    google 选择使用 UDP，也不是没有原因的。即使是在 2.0 下，基于 TCP 的通信依旧是会有建立连接时间较长，以及可能的队头阻塞问题等，而要对 TCP 进行改造并不容易，因为 TCP 协议栈时 linux 内部重要组成部分，导致修改和升级所要的成本代价太大</p>
<p>​    相对，<strong>UDP 本身是无连接的，没有建立和关闭连接的过程，并且数据报文的传输不会有队头阻塞问题，也使得对 UDP 的改造会更加方便，所要付出的成本要小</strong></p>
<h5 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h5><p>​    QUIC 其实是 <strong>Quick UDP Internet Connections</strong> 的缩写，即 <strong>快速 UDP 互联网连接</strong>。<strong>简单来说 QUIC 集成了 拥塞控制，多路复用，安全加密 与一身，基于 UDP 的快速连接</strong></p>
<p><img src="https://wei-foun.github.io/img/quic.jpg" alt="img"></p>
<p>​    QUIC 基于 UDP 实现了 <strong>允许一条连接上可以有多个流，流与流之间不会相互影响</strong>，这样就解决了原本使用 TCP 层面上会遇到的队头阻塞问题</p>
<p>​    另外，以 UDP 为基础，天然的达到了允许在第一次通信时，就可以发送应用数据。相对比 TCP，https 的下需要建立 TCP 握手，以及 TLS 加密握手，至少需要 2-3 个 RRT（轮次），http 下也要至少 1 个 RRT，而 UDP 能做实现 0 RRT</p>
<p>​    RRT （Round-Trip Time）是衡量网络连接的指标，表示数据包一次来回的耗时，包括三部分：往返传播时间，网络设备内部排队时间，应用程序数据处理时间</p>
<p><img src="https://wei-foun.github.io/img/quic2.gif" alt="img"></p>
<p>​    虽然，QUIC 协议下可以做都 0 RRT，但是有前提条件的，因为要保证密文和密钥安全，就不得不需要 1 个 RRT来实现密钥交换，为数据通信阶段的加密做准备（即首次连接）。但是 QUIC 中，密钥交换时，在客户端会将服务端发送的 config 包保存，也就说如果客户端有服务端发送的 config，那么就可以直接进行数据传递（非首次连接）</p>
<p>​    另外，客户端对 config 信息的保存也是有时效性的，一旦过期就需要再次进行首次连接，重新交换会话密钥</p>
<h3 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h3><p>​    <strong>websocket 是一种全双工的通信协议</strong>，也就是允许了服务端能够进行主动的响应，相比于 http 或者是 ajax 的轮询方式做请求和响应，websocket 的开销要小得多，因为不会存在频繁的 tcp 的握手和挥手，所以 websocket 适用于实时通信，协同编辑等场景</p>
<p><img src="https://wei-foun.github.io/img/websocket%E9%80%9A%E4%BF%A1.jpg" alt="img"></p>
<p>​    websocket 的实现是基于 http 去实现的，<strong>websocket 最开始依然是需要通过 tcp 的三次握手来建立 http 进行协议升级，可以当做是 websocket 的握手阶段，握手完成后则通过 websocket 的数据帧协议进行数据通信</strong></p>
<p>​    <strong>在 http 协议升级的请求头中会有两个字段，分别是 Connection 和 Upgrade，其中 Upgrade 字段的值就是 websocket，也就是表示要从 http 协议升级为 websocket 协议，Connection 的值是 Upgrade</strong>，除了这两个字段外，<strong>请求头还有一种重要的字段就是 sec-websocket-key 这个字段，它的值是一串 base64 的编码值</strong></p>
<p>​    <strong>服务端接收到 http 请求头的 key 后，会将这个 key 和 websocket 的一个固定的 uuid 做拼接，通过 sha1 计算后在利用base64 编码，然后给到响应字段 sec-websocket-accept</strong>，表示接收客户端的 http 的升级，并且响应的状态码是101，表示升级成功</p>
<p>​    <strong>补充：因为 websocket 是基于 http 实现的，所以 ws 的端口和 http 是一致的</strong></p>
<h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>​    属于七层模型中的网络层协议，IP 协议在网络层的主要作用，<strong>是实现主机与主机之间的通信，即点对点通信</strong>。最常见的 ip 版本就是 IPv4，后来为了对全球可分配的 ip 进行扩充，出现了 IPv6 的版本</p>
<h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>​    网际协议第4版（Internet Protocol version4，IPv4），是一个用点分隔开的四组十进制数的一个主机网络地址标识，每一组的范围是 0 - 255，所以最大位 255，换成二进制是 8 个 1</p>
<p>​    且 IPv4 又分了 5 大类，每一类中的第一组都有各自范围，整个 <strong>ip 地址又有两部分组成，即 网络地址 和 主机地址</strong>，网络地址用来识别设备所在的网络，主机地址用于设备该网络中的设备。IPv4 分出的 5 类，每一类范围都不同即能标识最大主机数也不同，用于不同级别的大，中，小型网络</p>
<p>​    其中，网络地址在数据发送时，会根据路由器和主机的各自的路由控制表进行转发</p>
<p><img src="https://wei-foun.github.io/img/ip.jpg" alt="img">  </p>
<p>​    <strong>ip 地址的分类：</strong></p>
<p>​    <strong>A类：</strong>1 - 127 开头，换成二进制的首位就是 0 [0000001]，默认的掩码是 255.0.0.0 / 8</p>
<p>​    <strong>B类：</strong>128 - 191 开头，换成二进制首位是 10 [000000]，默认的掩码是 255.255.0.0 / 16</p>
<p>​    <strong>C类：</strong>192 - 223 开头，二进制首位是 110 [00000]，默认的掩码是 255.255.255.0 / 24</p>
<p>​    D类：224 - 239 开头，二进制首位是 1110 [0000]，<strong>组播地址</strong>，代表一组特定的主机。组播地址 只能做为 IP 报文的目的地址，所以不会被分配给任意主机，通常用于多点广播或视频会议等场景</p>
<p>​    E类：240 - 255 开头，二进制首位是 1111 [0000]，作为保留地址用来以后使用</p>
<p><img src="https://wei-foun.github.io/img/ip%E5%88%92%E5%88%86.jpg" alt="img"></p>
<p>​    同时 A，B，C 三类 ip 中还分有私有的 ip 地址，一般向家庭局域网，公司办公以及学校网络，都是使用私有 ip 地址，而公有 ip 地址则是由专门机构分配的，需要申请购买</p>
<p><img src="https://wei-foun.github.io/img/ip2.jpg" alt="img">  </p>
<p>​    <strong>特殊的地址：</strong></p>
<p>​    0.0.0.0 本身其实是一个无效地址，但是在服务器上，可以用来指服务器上的所有地址，如果一个服务器有多个地址，且有一个服务监听的是 0.0.0.0，那么任何地址都能访问服务</p>
<p>​    其中 127 开头的都作为 回送地址，也叫 <strong>回环地址</strong>，最常见的就是 127.0.0.1 ，数据不会被发送到网络上，而是直接返回给主机，通常用于进行测试连通性</p>
<p>​    <strong>广播地址</strong>，其中 ip 地址中 <strong>主机号 部分全为 1 的地址，称为 直接广播地址</strong>，<strong>所有部分全为 1 称为 有限广播地址 或 本地网广播地址</strong>。广播地址同样不会被分配给任意主机</p>
<p>​    一台主机使用 直接广播地址，可以像任意指定的网络广播它的数据报；本地网广播地址 则是主机用于向所在网络的其他主机发送广播数据表</p>
<p><img src="https://wei-foun.github.io/img/%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80.jpg" alt="img"> </p>
<p><img src="https://wei-foun.github.io/img/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" alt="img"> </p>
<p>​    <strong>子网掩码：</strong></p>
<p>​    <strong>子网掩码 (subnet mask) 又叫网络掩码，它的作用就是用来分开 ip 地址的网络地址和主机地址</strong>，对于 A，B，C 三类的 ip 地址，默认的子网掩码位分别是 8，16，24 位</p>
<p>​    <strong>练习 &amp; 计算：</strong></p>
<p>​    如果 ip 为 193.6.7.0 / 24，网络前缀（位）是 24，子网掩码是 255.255.255.0</p>
<p>​    如果网络位是 26，子网掩码是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">24 位  255.255.255.0    即 11111111.11111111.11111111.00000000</span><br><span class="line">26 位  255.255.255.192  即 11111111.11111111.11111111.11000000</span><br><span class="line"></span><br><span class="line">11000000 是 8 位，下标从左到右是 7 - 0</span><br><span class="line">所以 192 = 2^7 + 2^6 </span><br><span class="line">		= 128 + 64</span><br><span class="line">子网地址为 255.255.255.192</span><br></pre></td></tr></table></figure>
<p>​    该地址的默认网关地址是？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的网关地址是指 主机位 中除了最后一位是 0，其余全是 1 得到的</span><br><span class="line">193.6.7.0 / 24，主机位 是 8 位，即 11111110</span><br><span class="line">  2^7 + 2^6 + 2^5 +2^4 + 2^3 + 2^2 + 2^1 + 0</span><br><span class="line">= 128 + 64 + 32 + 16 + 8 + 4 + 2 + 0</span><br><span class="line">= 254</span><br><span class="line">所以 ip 193.6.7.0 / 24，默认网关地址是，193.6.7.254 / 24</span><br></pre></td></tr></table></figure>
<p>​    如果还是 26 位的网络位，默认网关又是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">193.6.7.0 / 26，主机位 是 6（32-26） 位，最后一部分即 11 | 111110</span><br><span class="line">  2^5 +2^4 + 2^3 + 2^2 + 2^1 + 0</span><br><span class="line">= 32 + 16 + 8 + 4 + 2 + 0</span><br><span class="line">= 62</span><br><span class="line">所以 ip 193.6.7.0 / 26，默认网关地址是，193.6.7.62 / 24</span><br></pre></td></tr></table></figure>
<p>​    如果要将该 ip 划分 4 个子网，每一个范围是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设 2^N ≥ 4，即 N = 2，那掩码也就默认 24 位上 + 2 位 = 26 位，那主机位就是 6</span><br><span class="line">每一子网段中主机数 = 2^6 = 64，所以分 4 个子网的范围是：</span><br><span class="line">193.6.7.0   - 193.6.7.63</span><br><span class="line">193.6.7.64  - 193.6.7.127</span><br><span class="line">193.6.7.128 - 193.6.7.191</span><br><span class="line">193.6.7.192 - 193.6.7.255</span><br></pre></td></tr></table></figure>
<p>​    ip 为 203.123.1.135，子网掩码是：255.255.255.192，子网地址是什么？广播地址是什么？该地址的 ip 范围是多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子网地址 = ip 地址 与 子网掩码 进行 与 运算</span><br><span class="line"></span><br><span class="line">135：10000111  </span><br><span class="line">192：11000000</span><br><span class="line">---------------</span><br><span class="line">     10000000 = 128</span><br><span class="line"></span><br><span class="line">C类 默认网络位 24，192：11000000，所以该 ip 的真正网络位是 24 + 2 = 26</span><br><span class="line"></span><br><span class="line">ip 为 203.123.1.135，子网掩码是：255.255.255.192 的子网地址是：</span><br><span class="line">203.123.1.128 / 26</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">广播地址 = 网络地址 与 子网掩码取反 进行 或 运算</span><br><span class="line"></span><br><span class="line">子网掩码最后一组是 192，即 11000000，取反可得 00111111</span><br><span class="line">128：10000000</span><br><span class="line">192: 00111111</span><br><span class="line">---------------</span><br><span class="line">     10111111 = 191</span><br><span class="line"></span><br><span class="line">所以该 ip 的广播地址是：203.123.1.191</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">通过子网掩码最后一组是 192，即 256 - 192 = 64，即每一个可分组可以有 64 个 ip，但是实际可分配的地址是 64 - 2 = 62 个，因为要去掉 全为1 和 全为0 的两个主机号的地址，所以分组的范围是：</span><br><span class="line">203.123.1.0   - 203.123.1.63</span><br><span class="line">203.123.1.64  - 203.123.1.127</span><br><span class="line">203.123.1.128 - 203.123.1.191    203.123.1.135 在这个范围内</span><br><span class="line">203.123.1.192 - 203.123.1.255</span><br><span class="line"></span><br><span class="line">所以 203.123.1.135 所在的可分配范围是 203.123.1.129 - 203.123.1.190</span><br></pre></td></tr></table></figure>
<pre><code>**掩码位数，ip 总数，子网掩码对照表**</code></pre><table>
<thead>
<tr>
<th>掩码位数</th>
<th>IP总数</th>
<th>子网掩码</th>
</tr>
</thead>
<tbody><tr>
<td>30</td>
<td>4</td>
<td>255.255.255.252</td>
</tr>
<tr>
<td>29</td>
<td>8</td>
<td>255.255.255.248</td>
</tr>
<tr>
<td>28</td>
<td>16</td>
<td>255.255.255.240</td>
</tr>
<tr>
<td>27</td>
<td>32</td>
<td>255.255.255.224</td>
</tr>
<tr>
<td>26</td>
<td>64</td>
<td>255.255.255.192</td>
</tr>
<tr>
<td>25</td>
<td>128</td>
<td>255.255.255.127</td>
</tr>
<tr>
<td>24</td>
<td>256</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<h5 id="IPv4-数据报"><a href="#IPv4-数据报" class="headerlink" title="IPv4 数据报"></a>IPv4 数据报</h5><p><img src="https://wei-foun.github.io/img/ipv4.jpg" alt="img"></p>
<p>​    版本号：占 4 位，通信双方在通信前必须要保证 ip 协议版本一致，IPv4 的版本就是 4</p>
<p>​    首部长度：占 4 位，即 4 bit，最大值为 1111（15），也就是说最大可以是 60 个字节</p>
<p>​    总长度：占 16 位，是 首部 和 数据 的综合长度，也就是最大可以是 2^16 - 1 = 65535 个字节，如果超出就会进行分片</p>
<p>​    标识：占 16 位，就是用来标识数据报，ip 会在存储器中维持一个计数器，每次产生一个 ip 数据报时，对计数器 + 1 赋值给这个标识字段。当数据报过大被分片时，这个标识会被复制，然后给被分片的数据包，接收方在按照标识判断重组数据报即可</p>
<p>​    标志：占 3 位，其中 最低位 叫 MF，值为 1 标识有若干个数据报，值为 0 标识当前是最后一个数据报，中间位 叫 DF，DF 表示的是不能进行分片，值为 0 时表示可以进行分片</p>
<p>​    片偏移：占 13 位，用于表示数据报在分片后，在原分组中的相对位置</p>
<p>​    生存时间：占 8 位，表示数据报在网络中存在的寿命，该字段的值是数据报在转发过程中的跳数，经过一个路由器，计数值就会 - 1，最大的跳数是 255</p>
<p>​    协议：占 8 位，用来之命名数据报携带的协议</p>
<p>​    首部检验和：占 16 位，用来校验数据报的首段，值为 0 则保留数据报，否则就丢弃</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>​    Internet Protocol Version 6（互联网协议第6版）， 用于替代 IPv4 的下一代 IP 协议。随着科技水平和网络世界的迅速发展，空前的变化使得 IPv4 的编制设计在可用的网络地址和主机地址上的数目开始无法满足需求，虽然出现 地址转换技术（NAT）来缓解这个问题，但是同样造成其他方面的问题</p>
<p>​    IPv6 在最大的区别点就是相比 IPv4 的 32 位地址而言，<strong>直接扩大到了 128 位</strong>，使得理论上的地址空间扩大了 2^96 倍，并且解决了 IPv4 在实际场景中的诸多问题。<strong>使用 8 个 16 位的无符号整数，每个整数用 4 个十六进制表示，数与数之间用冒号隔开</strong>，例如：3ffe:3201:1401:1:280:c8ff:fe4d:db39</p>
<p>​    不过也会有 ip 地址中间会有很多 0，例如：1080:0000:0000:0000:0008:0800:200C:417A，0000:0000:0000:0000:0000:0000:0A00:0001。为了简化，在不影响数值表示情况下，可对每一段的多个 0 简写为 1 个 0，也可以将数字前面的 0 省去，当中间有多个连续的 0 的分段，可以将多个如 :0:0:0 称为 ::，即 1080::8:800:200C:417A，::A00:1。对于网络地址位数表示则是和 IPv4 一样使用 “/“ 隔开，然后表示网络位的位数，例如，0020:0250:f002::/48 </p>
<p>​    与 IPv4 的 A，B，C 三类网络类似，IPv6 也定义三种地址类型：</p>
<p>​    <strong>单播地址：用来唯一标识一个接口，实现一对一通讯</strong>，其中 <strong>回环地址是 ::1/123</strong>。同时对于单播地址，根据场景范围又分为 3 类，链路本地单播地址：在同一链路单播通信，不用经过路由器；唯一本地地址：在内网实现单播通信，类似 IPv4 的私有地址；全局单播地址：用于互联网通信，类似 IPv4 的公有地址</p>
<p><img src="https://wei-foun.github.io/img/%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" alt="img">  </p>
<p>​    <strong>组播地址：用来指定到一群不同的接口，实现一对多通讯</strong>，组播地址起始字节为 FF00::/8 </p>
<p>​    <strong>任（意）播地址：用来表示一组接口，用于对最近的节点进行通讯，最近的节点通过路由协议来指定</strong></p>
<p><img src="https://wei-foun.github.io/img/ipv6.jpg" alt="img">  </p>
<h5 id="IPv6-数据报"><a href="#IPv6-数据报" class="headerlink" title="IPv6 数据报"></a>IPv6 数据报</h5><p>​    对比 IPv4 的协议报，IPv6 做了很多调整</p>
<p><img src="https://wei-foun.github.io/img/ipv4-6.jpg" alt="img">   </p>
<p>​    取消了首部长度，因为整个首部的长度是固定 40 个字节</p>
<p>​    取消了服务类型，而利用流标签和优先级结合的方式来实现</p>
<p>​    取消了总长度字段，改为使用有效载荷长度</p>
<p>​    取消了标识，标志 和 片偏移，将这些实现放在了扩展首部中</p>
<p>​    取消了协议字段，改为下一个首部</p>
<p>​    取消生存时间，改为跳数限制</p>
<p>​    取消首部检验和，将数据报的校验放在了数据链路层和传输层上</p>
<p>​    取消了选项字段，将其归并到扩展首部里</p>
<h3 id="URI-，URL，URN"><a href="#URI-，URL，URN" class="headerlink" title="URI ，URL，URN"></a>URI ，URL，URN</h3><p>​    <strong>URI</strong> uniform resource identifier，<strong>统一资源标识符，用来唯一的标识一个资源</strong>，比如一张纸，一本书，一份文件</p>
<p>​    <strong>URL</strong> uniform resource locator，<strong>统一资源定位器，它是一种具体的 URI</strong>，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源，它的目的是告诉你如何访问到指定的资源。如果把 uri 比作一本字典，url 可以看作是每一个字的页码</p>
<p>​    <strong>URN</strong> uniform resource name，<strong>统一资源命名，是通过名字来标识资源</strong>，如果 uri 是字典，urn  可以看作是开始的目录 </p>
<p><img src="https://wei-foun.github.io/img/url-uri-urn.jpg" alt="img">   </p>
<p>​    从图中可知，所有的 url 都可以是 uri，但并不是所有的 uri 都可以作为 url</p>
<h3 id="WSGI，uwsgi，uWSGI"><a href="#WSGI，uwsgi，uWSGI" class="headerlink" title="WSGI，uwsgi，uWSGI"></a>WSGI，uwsgi，uWSGI</h3><p>​    <strong>WSGI：web service getaway interface，web 服务器网关接口</strong>，是一个 web 服务器与应用服务器通信的一种规范协议，WSGI 是 web服务器 与 web 应用程序或应用框架之间的一种的接口</p>
<p>​    <strong>uwsgi：用于在 uWSGI 服务器与其他网络服务器的数据通信</strong></p>
<p>​    <strong>uWSGI：是一个 web 服务器，实现了 WSGI，uwsgi，http 协议</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx &lt;--- uwsgi ---&gt; uWSGI 服务器 &lt;--- WSGI ---&gt; web 应用程序</span><br></pre></td></tr></table></figure>
<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>​    Representational State Transfer，即 “表现层状态转化”，而这个 “表现层” 指的就是一个具体的资源。对于互联网的任何一个实体或信息，都是有唯一标识的，也就是可以通过 URI 指向这个资源</p>
<p>​    但是表现层如果只是为了表示资源，显然还不够。因为互联网上的信息是多样的，不同的资源表现的形式也不同，比如图片、网页、音乐等等，图片会有 jpg 等不同格式表现，网页使用 html 展现，音乐也会有 mp3 格式等等</p>
<p>​    所以，表现层需要将资源通过各自的形式去表示出来，这样一来对于 URI 就不能做到了，URI 只能标识出一个资源，对于资源的表现需要通过 http 协议在头部信息中加入 accept 和 content-type 字段去指定格式，而这个两个字段就是对资源的表现描述</p>
<p>​    而互联网中，客户端和服务端进行通信，就必然涉及到对资源状态的变更，这就是 “状态变化”。http 协议中定义了基本的 4 个动词（GET，POST，PUT，DELETE），客户端通过这些动词与服务端互动</p>
<p>​    因此一个 RESTful 架构，需要有：</p>
<p>​    1）通过 URL 表示资源</p>
<p>​    2）客户端和服务端可以在表现层上传递这种资源</p>
<p>​    3）客户端通过 http 的 4 个基本动词能够对服务端的资源去操作，实现状态变化</p>
<p>​    简答来说，RESTful 是一种前后端分离下的一种设计架构，RESTful 的关注点在于资源，将服务器上的任何数据都作为资源，利用 http 协议的动词来定义设计接口，将接口作为访问资源的钥匙。通过 RESTful 架构可以很好的将前后端分离，前端无需关注后端的返回的模板，只需要按照设计的接口做资源的处理，而后端就将重点放在资源的获取和业务处理，将资源按照定义的接口进行设计，前后端的交流就可以利用 ajax 通过设计好的 RESTful 接口进行资源获取传递 </p>
<h4 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h4><p>​    <strong>域名：</strong>应该尽可能部署在专用域名下，但如果 api 很简单，不会涉及后续的扩展，可以放在主域名下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com      # 专用域名会更加规范，但是严格必须遵守</span><br><span class="line"></span><br><span class="line">https://example.org/api/</span><br></pre></td></tr></table></figure>
<p>​    <strong>版本：</strong>一个 api 接口的版本可以在 URL 上，也可以放在 http 头部信息中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/</span><br></pre></td></tr></table></figure>
<p>​    <strong>路径：</strong>通过一个 URL 获取一个资源，对于这个 URL 来说不能出现动词，只能使用名词。同时请求的资源通常对于数据库来说，都会是一个集合形式，所以 URL 的名词可以使用复数的形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api.example.com/v1/zoos</span><br><span class="line">https://api.example.com/v1/animals</span><br><span class="line">https://api.example.com/v1/employees</span><br></pre></td></tr></table></figure>
<p>​    <strong>HTTP 动词：</strong>最基本和常见的 4 个动词与数据库的记录操作是对应的，获取资源时，根据需求做指定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br><span class="line"></span><br><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园</span><br><span class="line">GET /zoos/ID：获取某个指定动物园的信息</span><br><span class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE /zoos/ID：删除某个动物园</span><br><span class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>API name</th>
<th>非 RESTful</th>
<th>RESTful</th>
</tr>
</thead>
<tbody><tr>
<td>获取dog</td>
<td><code>/dogs/query/&#123;dogid&#125;</code></td>
<td>GET： <code>/dogs/&#123;dogid</code>}</td>
</tr>
<tr>
<td>插入dog</td>
<td><code>/dogs/add</code></td>
<td>POST： <code>/dogs</code></td>
</tr>
<tr>
<td>更新dog</td>
<td><code>/dogs/update/&#123;dogid&#125;</code></td>
<td>PUT：<code>/dogs/&#123;dogid&#125;</code></td>
</tr>
<tr>
<td>删除dog</td>
<td><code>/dods/delete/&#123;dogid&#125;</code></td>
<td>DELETE：<code>/dogs/&#123;dogid&#125;</code></td>
</tr>
</tbody></table>
<p>​    restful api 的 url 中希望是不使用动词来表述操作的，但是实际开发的 api 设计并不是要严格遵循这样的要求</p>
<p>​    使用 RESTful 来设计 api 是很好的规范，但是 REST 是一种设计风格，而是强制性的约束和规则，通常情况下 http 的请求操作可能会比较繁琐，在不使用动词区分的情况下，完全按照 RESTful 风格设计的 api 可能不利于团队的理解和设计，而且复杂的操作也可能无法单纯的使用 http 的动词来描述</p>
<p>​    <strong>过滤信息：</strong>对于大量的数据库的记录，并不会一次全部返回显示给用户，所以 api 上通过参数过滤结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit=10：指定返回记录的数量</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id=1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>​    <strong>状态码：</strong> http 协议对于动词的返回，都设置有对于不同情况下的状态标识。但是 api 设计并不一定是需要依照原来的状态码，自定义的状态码需要规划和设计</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/3797262603/">http://example.com/3797262603/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover23.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/1649325139/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover25.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Scrapy 整理</div></div></a></div><div class="next-post pull-right"><a href="/2491919310/"><img class="next-cover" src="https://wei-foun.github.io/img/cover22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">web 安全</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1-url-%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">一条 url 所经历的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">OSI 七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">表示层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">会话层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">2.5.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">2.6.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">2.7.</span> <span class="toc-text">物理层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6"><span class="toc-number">2.8.</span> <span class="toc-text">发送与接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">TCP&#x2F;IP 五层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">数据包结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.2.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.3.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.4.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">4.5.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E8%AE%A1-ACK"><span class="toc-number">4.6.</span> <span class="toc-text">累计 ACK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5-%E4%B8%8E-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.8.</span> <span class="toc-text">长连接 与 短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2-%E4%B8%8E-%E7%9F%AD%E8%BD%AE%E8%AF%A2"><span class="toc-number">4.9.</span> <span class="toc-text">长轮询 与 短轮询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.</span> <span class="toc-text">UDP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">无连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%9D%A0"><span class="toc-number">5.2.</span> <span class="toc-text">不可靠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84-1"><span class="toc-number">5.3.</span> <span class="toc-text">数据包结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.</span> <span class="toc-text">HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">6.1.</span> <span class="toc-text">无状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.2.</span> <span class="toc-text">短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%8E%E6%96%87%E4%BC%A0%E8%BE%93"><span class="toc-number">6.3.</span> <span class="toc-text">明文传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">6.4.</span> <span class="toc-text">请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">6.4.1.</span> <span class="toc-text">常见的请求头首部字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">6.5.</span> <span class="toc-text">响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">6.5.1.</span> <span class="toc-text">常见的响应头首部字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%E4%B8%AD%E9%80%9A%E7%94%A8%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">6.6.</span> <span class="toc-text">请求和响应头中通用的首部字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">6.7.</span> <span class="toc-text">请求和响应头中的实体首部字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">6.8.</span> <span class="toc-text">HTTP 的发展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">6.9.</span> <span class="toc-text">HTTP 请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88idempotent%EF%BC%89"><span class="toc-number">6.9.1.</span> <span class="toc-text">幂等性（idempotent）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">6.10.</span> <span class="toc-text">HTTP 状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.</span> <span class="toc-text">HTTPS 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%EF%BC%88symmetrical-encryption%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">对称加密技术（symmetrical encryption）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%EF%BC%88asymmetrical-encryption%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">非对称加密技术（asymmetrical encryption）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86"><span class="toc-number">7.3.</span> <span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%91%98%E8%A6%81"><span class="toc-number">7.4.</span> <span class="toc-text">数字摘要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E6%8A%80%E6%9C%AF"><span class="toc-number">7.5.</span> <span class="toc-text">数字签名技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%93%E5%8C%85"><span class="toc-number">7.6.</span> <span class="toc-text">抓包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3"><span class="toc-number">8.</span> <span class="toc-text">HTTP 3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#QUIC"><span class="toc-number">8.0.1.</span> <span class="toc-text">QUIC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket-%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.</span> <span class="toc-text">websocket 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">10.</span> <span class="toc-text">IP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv4"><span class="toc-number">10.1.</span> <span class="toc-text">IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IPv4-%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">10.1.1.</span> <span class="toc-text">IPv4 数据报</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPv6"><span class="toc-number">10.2.</span> <span class="toc-text">IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IPv6-%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">10.2.1.</span> <span class="toc-text">IPv6 数据报</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI-%EF%BC%8CURL%EF%BC%8CURN"><span class="toc-number">11.</span> <span class="toc-text">URI ，URL，URN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSGI%EF%BC%8Cuwsgi%EF%BC%8CuWSGI"><span class="toc-number">12.</span> <span class="toc-text">WSGI，uwsgi，uWSGI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful"><span class="toc-number">13.</span> <span class="toc-text">RESTful</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">13.1.</span> <span class="toc-text">设计规范</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2938300177/" title="k8s-pod发布部署"><img src="https://wei-foun.github.io/img/cover50.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s-pod发布部署"/></a><div class="content"><a class="title" href="/2938300177/" title="k8s-pod发布部署">k8s-pod发布部署</a><time datetime="2025-08-02T16:35:03.000Z" title="发表于 2025-08-03 00:35:03">2025-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/1213981086/" title="k8s-调度"><img src="https://wei-foun.github.io/img/cover49.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s-调度"/></a><div class="content"><a class="title" href="/1213981086/" title="k8s-调度">k8s-调度</a><time datetime="2025-08-02T07:25:30.000Z" title="发表于 2025-08-02 15:25:30">2025-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/558590641/" title="k8s整理"><img src="https://wei-foun.github.io/img/cover48.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="k8s整理"/></a><div class="content"><a class="title" href="/558590641/" title="k8s整理">k8s整理</a><time datetime="2025-07-31T07:24:29.000Z" title="发表于 2025-07-31 15:24:29">2025-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/466764255/" title="airflow整理"><img src="https://wei-foun.github.io/img/cover47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="airflow整理"/></a><div class="content"><a class="title" href="/466764255/" title="airflow整理">airflow整理</a><time datetime="2025-07-12T07:04:30.000Z" title="发表于 2025-07-12 15:04:30">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux 基础"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 基础"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux 基础">Linux 基础</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover23.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>