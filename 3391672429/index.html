<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构和算法 | </title><meta name="keywords" content="python,数据结构和算法"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常用的内置数据结构和算法   数据结构&#x2F;算法 内置数据结构 内置库    线性结构 list、tuple arry(数组，不常用)、collecitons.namedtuple   链式结构  collections.deque(双端队列)   字典结构 dict collections.Counter(计数器)、OrderedDict(有序字典)   集合结构 set、frozenset(不可变">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法">
<meta property="og:url" content="http://example.com/3391672429/index.html">
<meta property="og:site_name">
<meta property="og:description" content="常用的内置数据结构和算法   数据结构&#x2F;算法 内置数据结构 内置库    线性结构 list、tuple arry(数组，不常用)、collecitons.namedtuple   链式结构  collections.deque(双端队列)   字典结构 dict collections.Counter(计数器)、OrderedDict(有序字典)   集合结构 set、frozenset(不可变">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover11.jpg">
<meta property="article:published_time" content="2020-06-23T05:33:49.000Z">
<meta property="article:modified_time" content="2025-04-01T17:58:07.096Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="python">
<meta property="article:tag" content="数据结构和算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover11.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/3391672429/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构和算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-02 01:58:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover11.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构和算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-23T05:33:49.000Z" title="发表于 2020-06-23 13:33:49">2020-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-01T17:58:07.096Z" title="更新于 2025-04-02 01:58:07">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构和算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="常用的内置数据结构和算法"><a href="#常用的内置数据结构和算法" class="headerlink" title="常用的内置数据结构和算法"></a>常用的内置数据结构和算法</h3><table>
<thead>
<tr>
<th>数据结构/算法</th>
<th>内置数据结构</th>
<th>内置库</th>
</tr>
</thead>
<tbody><tr>
<td>线性结构</td>
<td>list、tuple</td>
<td>arry(数组，不常用)、collecitons.namedtuple</td>
</tr>
<tr>
<td>链式结构</td>
<td></td>
<td>collections.deque(双端队列)</td>
</tr>
<tr>
<td>字典结构</td>
<td>dict</td>
<td>collections.Counter(计数器)、OrderedDict(有序字典)</td>
</tr>
<tr>
<td>集合结构</td>
<td>set、frozenset(不可变集合)</td>
<td></td>
</tr>
<tr>
<td>排序算法</td>
<td>sorted</td>
<td></td>
</tr>
<tr>
<td>二分算法</td>
<td></td>
<td>bisect 模块</td>
</tr>
<tr>
<td>堆算法</td>
<td></td>
<td>heapq 模块</td>
</tr>
<tr>
<td>缓存算法</td>
<td></td>
<td>functions.lru_cache(Least Recent Used，python3)</td>
</tr>
</tbody></table>
<h3 id="线性结构和链式结构"><a href="#线性结构和链式结构" class="headerlink" title="线性结构和链式结构"></a>线性结构和链式结构</h3><p>​    <strong>线性顺序：</strong>用一组地址连续的存储单元依次存储各个元素</p>
<p>​    <strong>线性链式：</strong>将元素节点分为两个部分，数据区存储真正的值，指针区所存储的是下一个元素节点的地址</p>
<p>​    <strong>优缺点：</strong></p>
<p>​    线性存储在读写的速度上相对要快，但是存储的结构在创建时，是有限制的（定长）的空间，即如果元素装满了，就需要重新申请一个更大的空间，再将原来的数据再次写入进去；空间的扩充是在原地址上重新申请更大的存储空间</p>
<p>​    链式存储不是顺序的，所以可以确定的一点是不需要担心空间的问题，但也因此相比线性顺序存储在读写的速度上要慢，并且每一个元素的节点中的指针要存储后面一个元素节点的地址，相比线性存储在存储的空间上要更大一些</p>
<p>​    简单来说，顺序存储例如列表（数组）在查找的时间复杂度上通过索引是 O(1)，链式存储则是 O(n)。但顺序存储在插入或删除的操作复杂度就是 O(n)，因为数据需要向后或向前移动调整，而链式存储在插入和删除的时间复杂度就是 O(1)</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>​    跳表的数据结构实际上是基于链式存储的一种变形，跳表对链表查询时间复杂度上进行了优化，<strong>主要的特点就是就是通过在链表上创建多级链表做为索引实现查询性能的提升</strong>，也就是利用空间换时间</p>
<p><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg?wh=1142*663" alt="img/md5.jpg"></p>
<p>​    通过多级索引的建立，当查找 16 这个元素时，只需要遍历 6 个节点就可以查找到，这相比在原链表上直接遍历查询要高效很多。假设每一级索引都是每两个节点去一个作为索引的节点，那么对于第一级索引的节点就 n/2，第二级索引就是 n/4，由此可见当进行查找时，<strong>时间复杂度是 O(m * logn)</strong>，而 m 最大为 3，因为每一级索引中需要遍历的只有三个节点，也就是索引区间的前后两个节点，以及中间节点和查找节点的比较</p>
<h3 id="字典底层结构"><a href="#字典底层结构" class="headerlink" title="字典底层结构"></a>字典底层结构</h3><p>​    字典的底层使用的是 hash 表（也可以称为散列表），所以在键值的查找上时间复杂度可以达到 O(1)，哈希表本身也是利用下标索引去找值，这个下标索引就是键，将键映射为下标利用算法找到对应的元素位置，所以哈希表也是数组的一种扩展。另外，<strong>哈希表 是由一个 直接寻址表 和一个 哈希函数 组成</strong></p>
<p>​    注意，<strong>hash 表的查找时间复杂读并不能完全意义上说是 O(1)，因为这与 hash 函数，装载程度，hash 冲突都有关系</strong>。当一个 hash 表的装载过多时，剩余的空位地址不足，会导致发生 hash 冲突的概率大幅提升，从而会使查找效率退化。同时，如果 hash 函数设计有问题，在遇到攻击者设计的数据后，这些数据可能会大量被经过 hash 函数后落在相同位置，从而应发冲突。如果解决冲突的方式是链表法，那么很有可能在查找时，大量时间可能会花在链表遍历上，也会导致时间复杂度退化到 O(n)</p>
<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>​    简单来说，哈希表毕竟是大小有限的，但是对于存储的数据来说，这个总量是无限的，所以势必会存在会 <strong>两个元素在使用哈希函数计算后得到同一个值，也就是两个数据最后被映射在了同一个位置，这就是 哈希冲突</strong></p>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>​    <strong>开放寻址法：</strong>如果经过哈希函数后，位置上已经有元素存在，则从该位置 <strong>往后探查</strong>，在探查到空位后将元素映射到该位置，包括以下三种探查的方式</p>
<p>​    <strong>线性探查：</strong>即如果位置 <code>i</code> 已有元素存在，则从该位置一次往后 <code>i+1，i+2，...，</code>依次一个个往后探查是否有空位来存放，遍历中有空位就在该位置存放，如果到最后没有空位则回到表头继续往后遍历。当查找时，通过 hash 函数后会按照同样的方式向后遍历查找</p>
<p>​    <strong>二次探查：</strong>即如果位置 <code>i</code> 已有元素存在，依然是从该位置往后探查，但是 <strong>步长</strong> 不同变为 二次方 <code>i + 1²，i - 1²，i + 2²，i - 2²，..</code>，即为 <code>i + 1，i - 1，i + 4，i - 4，i + 8，i - 8，...</code></p>
<p>​    <strong>双重散列：</strong>即 <strong>设置多个哈希函数</strong>，如果元素在使用第一个哈希函数后返回的值上有冲突了，就使用后续的哈希函数再次对其进行计算，然后判断是否还存在冲突，并如此重复到最后最后没有冲突</p>
<p>​    从二次探查和线性探查，可以很直接看出，使用线性探查的耗时会随数据量不断增多而增加，但也不是说线性探查就一定不好，如果数据量本身就比较少，线性探查就会比较好，如果使用二次探查可能会在扩充上有频繁的操作</p>
<p>​    使用开放寻址法方式，在删除元素时，则不能直接将值删除。因为这样做在查找时，线性探查只要找到空位就认为目标元素不存在，这样一来如果插入的值的位置在删除的元素后面，如果直接删除掉删除的元素，再去查找先前插入的元素就会有问题，所以使用线性探查的方式在删除元素时，是通过标记删除来标识，这样当查找先前插入的元素时，如果碰到被标记的 deleted 的元素，依然会向后遍历直到找到目标元素</p>
<p>​    所以线性探查的方式在 hash 表已经写入大量元素后，发生冲突的概率就会越来越高，那么在查找和删除时，时间复杂度就会退化到 O(n)</p>
<p>​    因此，<strong>当已知数据量比较小，且 hash 表的装载量也比较小（(已使用位置/表的大小) &lt; 1）的时候，使用开发寻址法是比较好的</strong></p>
<p>​    <strong>链表法：</strong></p>
<p>​    当在经过哈希函数后，两个元素在同一位置上有冲突，则在该位置上连接一个链表，原来存储的元素作为这个链表的第一个元素，如果新加入的元素位置与原来存储的元素位置冲突，新的元素就会被加在该位置的链表的最后</p>
<p>​    链表法相比开发寻址法，在 hash 表的装载量上的限制就没有那么高，即使装载量超过了 1，数据的写入只会使链表变长，虽然查找效率会降低，但这比开放寻址法的顺序查找还是要好些</p>
<p><img src="https://wei-foun.github.io/img/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" alt="img/md5.jpg"></p>
<p>​    但相对开发寻址来说，链表法需要存储指针，也就导致如果 hash 表存储的对象较少时，会占用很多的内存消耗，所以<strong>链表法更适用于存储大对象，大数据量的散列表</strong></p>
<p>​    除此之外，也可以更改链表法的存储，改为其他动态数据结构，例如跳表或红黑树，这样最后查找时间复杂度最多也是 O(logn)</p>
<h4 id="哈希表扩充"><a href="#哈希表扩充" class="headerlink" title="哈希表扩充"></a>哈希表扩充</h4><p>​    在之前的 核心技术 文章中，写到了 哈希表 的扩充，<strong>一般内部的空间会被保留 1/3 或 1/4，一旦装载量过大，这个备用的空间不足，就会触发一次扩充，需要注意一点的是，每一次的扩充都会对元素重新排列</strong></p>
<p>​    也就是说最好情况，就是插入没有触发扩容，那么时间复杂度就是 O(1)。<strong>如果触发了扩容机制，那么原 hash 表的所有数据会重新进行 hash 后散列到新 hash 表中新的位置上，这个时间复杂度就是 O(n)</strong></p>
<p>​    为了避免由于扩容导致的一次性将旧 hash 表数据全部迁移到新的 hash 表中导致的过多耗时，<strong>可以采取当扩容发生后，先将新插入的数据放入到新的 hash 表中，然后从旧 hash 表中也拿出一个数据将其放入到新 hash 表，这样每次插入新的数据，都会伴随一个旧 hash 表的数据写入，这样使用均摊的方式可以有效避免一次性迁移的耗时问题</strong></p>
<p>​    <strong>注意在使用新旧两个 hash 表后，查询先从新的 hash 表中查询，如果没有找到，再到旧 hash 表中查找</strong></p>
<h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>​    树是一种特殊的底层数据结构，树是由 n 个节点构成的一个集合，n=0 就是一棵空树，n&gt;0 时，就会有一个节点作为这棵树的根节点，根下的每一个节点来说也是一个集合</p>
<p>​    对于二叉树来说，很容易理解有两个分叉，由根节点分叉出左节点和右节点，而左右节点又可能会有各自的两个分叉，即每一个节点都可以有两个子节点，而两个子节点上的节点就是他们的父节点</p>
<p>​    在二叉树中，最顶部是单独的唯一节点，称为根节点，对于最后的节点，没有分叉的节点可以称为叶子节点</p>
<p>​    同时二叉树的深度，从根节点算起一直到最后叶子节点，根为第一层的话，根节点下的左右子节点就是第二层，以此类推</p>
<p>​    包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，<strong>第 K 层包含的节点个数就是 2^(K-1)</strong></p>
<p>​    根节点下，左右两个子节点也可以单独作为树，称为左子树和右子树</p>
<p>​    节点的度，可以理解为一个父节点下面的子节点个数，上面说到如果一个树只有根节点，那么根节点的度就是 0，如果一个子节点下只有一个左节点，没有右节点，那么这个子节点的度就是 1，所以 <strong>二叉树可以理解为是节点的度不超过 2 的树</strong></p>
<p>​    树的一些概念：</p>
<p>​    高度：节点到叶子节点的最长路径（边数），可以从节点位置往上数（从 0 开始）</p>
<p>​    深度：根节点到该节点经历的边的个数，可以从根节点向节点位置去数（同样从 0 开始）</p>
<p>​    层数：节点深度 +1，根节点的层数就是 1</p>
<p>​    树的高度：根节点的高度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                    高度     深度    层</span><br><span class="line">            A                        3        0      1</span><br><span class="line">      B           C                  2        1      2</span><br><span class="line">  D      E     F     G               1        2      3</span><br><span class="line">H   I  J                             0        3      4</span><br></pre></td></tr></table></figure>
<p>​    <strong>二叉树还有两个分类分别是：满二叉树，完全二叉树</strong></p>
<p>​    满二叉树，即二叉树的每一个节点，无论是左右子节点，他们的下面都会有两个节点，就是说每一层的节点数都达到了最大值，这就是满二叉树，就像是天秤，左右两边的 “重量” 是一样的</p>
<p>​    完全二叉树，简单理解可以认为是一棵 “不满的二叉树”，即左右子树中，可以有节点只有一个子节点，并且按照顺序，<strong>如果一个父节点只有一个子节点，这个子节点要在左侧</strong></p>
<p>​    所以 <strong>满二叉树 一定是 完全二叉树，但 完全二叉树 不是 满二叉树</strong></p>
<p>​    非完全二叉树，叶子节点并不绝对要从最左边开始，它并不遵守完全二叉树的规则</p>
<p><img src="https://wei-foun.github.io/img/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="img/md5.jpg"></p>
<p>​    <strong>二叉树的存储方式可以分为：链式存储 和 顺序存储</strong></p>
<p>​    链式存储，即每一个节点会分成三部分，左边是指向左子节点，中间是数据，右边则指向右子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  leftchild  |  data  |  rightchild  |</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure>
<p>​    顺序存储的方式可以看作是一个列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                   9</span><br><span class="line">        8                      7</span><br><span class="line">  6           5            0        1</span><br><span class="line">2   4      3</span><br><span class="line"></span><br><span class="line">[9, 8, 7, 6, 5, 0, 1, 2, 4, 3]</span><br></pre></td></tr></table></figure>
<p>​    按照列表下标是 0 开始，设父节点为 <code>i</code>，可以得到 <strong>父节点 与 左子节点 的关系是：<code>2 * i + 1</code></strong>；与 <strong>右子节点 的关系是：<code>2 * i + 2</code></strong></p>
<p>​    使用数组的顺序存储会相对要节省空间，而不完全的二叉树使用链表存储的方式</p>
<p>​    二叉树的遍历分为三种方式：前序遍历、中序遍历、后序遍历</p>
<p>​    <strong>前序遍历：对于任意节点，都是先打印当前这个节点，再去打印该节点的左子树，最后是右子树</strong></p>
<p>​    <strong>中序遍历：对于任意节点，都是先打印该节点的左子树，再是打印自身节点，最后是右子树</strong></p>
<p>​    <strong>后序遍历：对于任意节点，都是先打印该节点的左子树，然后是右子树，最后是自己</strong></p>
<p>​    <img src="https://wei-foun.github.io/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg" alt="img"></p>
<p>​    所以，整个二叉树的遍历，其实就是其中任意一种方式，利用递归思想去实现，注意三种遍历的结果是不相同的，可以根据具体场景去使用，<strong>如果想要实现倒序，那就是先去递归右边，再去递归左边</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;前序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;中序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    <span class="built_in">print</span>(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;后序遍历&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    <span class="built_in">print</span>(root.val) <span class="comment"># 根</span></span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a>二叉搜索树（Binary Search Tree）</h3><p>​    对节点的值做了规定，如果这个树结构有左右两个子树，那么 <strong>左子树 上任意的节点上的值都是小于 根节点</strong> 的，<strong>右子树 上任意的节点值也都大于 根节点</strong></p>
<p><img src="https://wei-foun.github.io/img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="img"></p>
<h3 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h3><p>​    平衡二叉树要求，<strong>树结构中的任意一个节点，它的左右两个子树的高度差不能超过 1</strong>。一个节点的高度指的是，从它所在一侧的最底层叶子节点向上数的层数，比如下图中 50 这个子节点，它的高度是 2，而 125 这个子节点的高度是 0</p>
<p>​    左右子树的高度不能大于 1，即限制住左右子树的层数差，尽可能使得这棵树的左右节点的数量能够近似平衡，这样就避免了二叉树左右失衡的最糟结构，比如二叉树某一侧的节点关联过多，使得二叉树的一侧退化成链表的结构，导致查找性能骤降</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">           10</span><br><span class="line">         /    \</span><br><span class="line">        9     12 </span><br><span class="line">       /  </span><br><span class="line">      8</span><br><span class="line">     /                             # 二叉树结构的最糟情况，使得查找的时间复杂度变成 O(n)</span><br><span class="line">    7</span><br><span class="line">   /  </span><br><span class="line">  5</span><br><span class="line"> /</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>​    这也使得平衡二叉树在搜索上可以实现和二分法查找类似的效率，而且相比二分法查找需要的是一个有序的数组，是一个元素地址连续的容器，树的结构在扩充上相对要高效</p>
<p><img src="https://wei-foun.github.io/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="img"></p>
<h4 id="平衡二叉查找树和散列表"><a href="#平衡二叉查找树和散列表" class="headerlink" title="平衡二叉查找树和散列表"></a>平衡二叉查找树和散列表</h4><p>​    <strong>平衡二叉查找树在节点的插入，删除，查找上时间复杂度可达到 O(logn)</strong>，而使用散列表的字典结构同样的操作在时间复杂度上则可以是常量级的 O(1)。但是，平衡二叉查找树相比起散列表来说，有其独特的优势</p>
<p>​    散列表的数据存储是无序的，而平衡二叉查找树得益于左右子树的设定，通过中序遍历可以在 O(n) 的时间复杂度内完成有序输出。其次，散列表在遇到哈希冲突的情况下，依赖于哈希函数以及策略，在不稳定的情况下明显会更加耗时，平衡二叉查找树相对而言要更加稳定</p>
<p>​    散列表的结构需要考虑的因素要更多，比如哈希函数，哈希冲突策略，装填比列和扩容。平衡二叉查找树则只需关注树的平衡性</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>​    R-B Tree，顾名思义在红黑树中，节点有两种颜色区分，分别是红色和黑色。红黑色是一种特殊的二叉树，是平衡二叉树的一种延伸优化，因为 <strong>平衡二叉树的要求是左右子树的高度不能超过 1，使得平衡二叉树在节点的插入和删除操作的同时对树结构的要求非常严格，可能会涉及到大量的节点和结构的调整。而红黑树相对而言对树的结构在平衡性上没有那么严格，只要结构能够趋近平衡，从而不影响在查找效率，所以相对在节点的添加和删除上实现要较容易</strong></p>
<p>​    <strong>Java 集合中的 TreeSet 和 TreeMap，C++ STL 中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的</strong></p>
<p>​    <strong>红黑树的特性：</strong></p>
<p>​    <strong>1）节点只有红和黑两种颜色，并且树的根节点颜色是黑色</strong></p>
<p>​    <strong>2）树的每一个叶子节点通过 NIL 或 NULL 表示，并且叶子节点的颜色也是黑色，即叶子节点本身不存数据</strong></p>
<p>​    <strong>3）如果一个节点的颜色是红色，那么它的两个子节点也都必须是黑色（即所有的路径上不能存在连续两个红色节点）</strong></p>
<p>​    <strong>4）从一个节点到该节点的子孙节点的所有路径上包含的黑色节点数量是相同的</strong></p>
<p>​    <img src="https://wei-foun.github.io/img/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" alt="img"></p>
<p>​    第 4 个性质，可以反推出来得到，如果一个节点存在黑子节点，那么该节点肯定有两个节点。同时，该性质的黑色节点数量，还可以理解成从任意一个叶子节点到根节点或其他其他节点，层数都是相同的，即俗称的 “黑高”</p>
<p>​    注意：红黑树并不完全是一个平衡二叉树，因为满足第 4 个性质的红黑树中，可能会有一边的子树比另一边要高的情况，但是只要满足第 4 性质，黑高是相同的，那么这个红黑树就不会完全失衡，就可以称为是黑色完美平衡，所以红黑树可以保证稳定的时间复杂度是 O(logn)</p>
<p>​    <strong>红黑树维持平衡主要有三个操作：变色，左旋，右旋</strong></p>
<p>​    变色：即红色变黑色，或者黑色变红色</p>
<p>​    左旋：向左边旋转某个节点，将该节点的右子节点上升变为该节点的父节点，同时这个右子节点的左子节点变为要旋转的节点</p>
<p><img src="https://wei-foun.github.io/img/%E5%B7%A6%E6%97%8B.gif" alt="img"></p>
<p>​    右旋：向右边旋转某个节点，将该节点的左子节点上升变为该节点的父节点，同时这个左子节点的右子节点变为要旋转的节点</p>
<p><img src="https://wei-foun.github.io/img/%E5%8F%B3%E6%97%8B.gif" alt="img"></p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>​    <strong>B 树 是一种 多路搜索树</strong>，包括以下特点：</p>
<p>​    <strong>1）根节点可以有 m 个子节点，这个 m 要至少是大于等于 2</strong></p>
<p>​    <strong>2）非叶子节点的子节点数是 [m/2，m]</strong></p>
<p>​    <strong>3）每一个节点中，最少要存放 m/2 - 1（向上取整）个关键字，最多存放 m-1 个关键字，其中每一个节点至少是要有两个关键字</strong></p>
<p>​    <strong>4）非叶子节点的关键字个数，是指向叶子节点的指针个数 - 1</strong></p>
<p>​    <strong>5）非叶子节点的关键字，排序是 k[1]，k[2]，…，k[m-1]，大小总是 k[i] &lt; k[i+1]，即是一个升序排列</strong></p>
<p>​    <strong>6）非叶子节点的指针，比如一个非叶子节点有 m 个指针，p[1] 指针指向的子节点的关键字是 小于 k[1] 的子树，p[m] 就指向大于 k[m-1]，中件的指针 p[i] 指向的子树是大于 k[i-1]，小于 k[i]</strong></p>
<p>​    <strong>7）整个 B 树 上的所有叶子节点都在同一层</strong></p>
<p><img src="https://wei-foun.github.io/img/B%E6%A0%91.jpg" alt="img"></p>
<p>​    如果是一个 5 阶 B 树，也就是说非叶子节点的关键字最大有 4 个，对应的指针就是有 5 个，即使这个节点中只有 2 个关键字，也是属于 5 阶 B 树</p>
<p>​    B 树总的来说，每个节点都会有数据和关键字的存储，而关键字则可以用来作为索引加速搜索，但是 B 树的非叶子节点相互之间没有联系，也就说 B 树结构不适合做区间的搜索，但是对于可能访问的节点，在 B 树上查找会很快，这也正是因为除了非叶子节点外，其他的节点上也会存放数据</p>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>​    实际上与 B 树 非常相似，但是最明显的区别是，<strong>B+ 树 的 非叶子节点 上并不存储数据，非叶子节点 的目的用来做叶子节点的索引，叶子节点上包含所有的关键字，指向真正的记录</strong></p>
<p>​    对于非叶子节点中每一索引项，都对应着子树结构中最大关键字和指向该子树的指针</p>
<p>​    除此之外，<strong>B+ 树 中叶子节点以单链表的形式进行关联</strong>，使得查询效率更高</p>
<p>​    另外，与 B 树 不同的是，在 B 树 中非叶子节点有 n 个关键字，则会有 n+1 个指针（分支），而在 B+ 树 中非叶子节点有 n 个关键字，就是有 n 个分支</p>
<p>​    而且，B 树 非叶子节点的关键字个数是 m/2 - 1 到 m - 1 个，而 B+ 树 上非叶子节点的关键字个数是 m/2 到 m 个</p>
<p><img src="https://wei-foun.github.io/img/B+%E6%A0%91.jpg" alt="img"></p>
<p>​    B+ 树除了只将数据存在叶子节点上，还通过顺序指针让各个叶子节点能够实现关联，这样一来 B+ 树的结构就优化了 B 树不能做区间搜索的问题，相比 B 树的非叶子节点来说，B+ 树的非叶子节点不存放数据，所以相对而言 B 树层数靠上越容易得到数据，而 B+ 树则必须要到叶子节点获取，但是 B+ 将非叶子节点的数据省去可以存放更多的指针来做索引，这样一来 <strong>对比 B 树，B+ 树的树高会更矮，搜索效率会更高</strong> </p>
<h3 id="LruCache-缓存算法"><a href="#LruCache-缓存算法" class="headerlink" title="LruCache 缓存算法"></a>LruCache 缓存算法</h3><p>​    <strong>Least Recently Used，即最近最少使用的，核心思想是将近期使用次数最少的缓存对象进行淘汰删除</strong>，将空间留给使用频繁，和最近加入的新的缓存对象</p>
<p>​    LRU 只是众多缓存提出策略中的一种，除此之外还有 LFU (优先淘汰使用次数最少的，LRU 则是时间上的概念，优先删除使用时间最久的)，随机选择剔除或是直接使用队列来做为缓存容器等等</p>
<p>​    对于 LRU 的实现来说，使用循环双端队列不断把最新的访问对象放在表头，将访问时间离得最久的则是移动末尾，python 中可以利用 OrderedDict 来实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lru</span>：</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_num=<span class="number">64</span></span>):</span><br><span class="line">		self.od = OrderedDict()</span><br><span class="line">		self.max_num = max_num</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">		<span class="keyword">if</span> key <span class="keyword">in</span> self.od:</span><br><span class="line">             val = self.od[key]    </span><br><span class="line">             self.od.move_to_end(key)</span><br><span class="line">             <span class="keyword">return</span> val</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, val</span>)：</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(self.od) == self.capacity <span class="keyword">and</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.od:</span><br><span class="line">         	self.od.popitem(last=<span class="literal">False</span>)</span><br><span class="line">         self.od[key] = value</span><br><span class="line">         self.od.move_to_end(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lru = Lru(max_num=<span class="number">4</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">lru.put(<span class="string">&#x27;d&#x27;</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3), (&#x27;d&#x27;, 4)])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lru.get(<span class="string">&#x27;c&#x27;</span>))            <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;d&#x27;, 4), (&#x27;c&#x27;, 3)])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lru.get(<span class="string">&#x27;a&#x27;</span>))            <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;b&#x27;, 2), (&#x27;d&#x27;, 4), (&#x27;c&#x27;, 3), (&#x27;a&#x27;, 1)])</span></span><br><span class="line"></span><br><span class="line">lru.put(<span class="string">&#x27;e&#x27;</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(lru.od)                  <span class="comment"># OrderedDict([(&#x27;d&#x27;, 4), (&#x27;c&#x27;, 3), (&#x27;a&#x27;, 1), (&#x27;e&#x27;, 5)])</span></span><br></pre></td></tr></table></figure>
<p>​    <strong>OrderedDict 实际上使用两种数据结构，hash 表来存储 键-值 对，保证查找和删除的时间复杂度，同时利用了双向链表，实现将 键-值 对的节点关联以此体现有序性</strong>。在 OrderedDict 的实现中，通过 root 作为 双向链表 的头部，当插入一个新节点，会将这个节点的 next 指向 root，后续插入的节点的 next 依次指向上一个插入节点</p>
<h3 id="利用内置数据结构实现更高级的数据结构"><a href="#利用内置数据结构实现更高级的数据结构" class="headerlink" title="利用内置数据结构实现更高级的数据结构"></a>利用内置数据结构实现更高级的数据结构</h3><p>​    通常情况下，随着业务需求或数据量非常大的情况下，依然去使用 python 自带的基本数据结构就会显得有些心有余而力不足，python 中内置的结构里没有 链表，队列，栈，二叉树，堆 这样更为高级的结构，但是 python 的内置库 collections 或修改 列表 也能去实现如队列和链表等结构</p>
<h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>​    链表又分三种：<strong>单链表，双向链表，循环双端链表</strong></p>
<p><img src="https://wei-foun.github.io/img/linklist.jpg" alt="img/md5.jpg"> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建节点类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">        self.data = data     <span class="comment"># 存储值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>     <span class="comment"># 作为指针，用来存储下一个节点</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linklist</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,li</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">        self.create_linklist_tail(li)     </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_linklist_tail</span>(<span class="params">self, li</span>):</span><br><span class="line">        self.head = Node(<span class="number">0</span>)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> li:</span><br><span class="line">            n = Node(v)</span><br><span class="line">            self.tail.<span class="built_in">next</span> = n</span><br><span class="line">            self.tail = n</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_linklist</span>(<span class="params">self</span>):</span><br><span class="line">        p = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span>(p.data)</span><br><span class="line">            p = p.<span class="built_in">next</span>           </span><br><span class="line"></span><br><span class="line">li = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">linklist = Linklist(li)</span><br><span class="line">linklist.print_linklist()</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<p>​    Node 类用于初始化元素作为链表中的节点，Linklist 类用于创建单向的链表，其中 create_linklist_tail 表示尾插法，该方法中首先修改类中初始化的头尾节点，头结点赋予值为 0，同时将尾结点赋为头结点，然后利用循环，将传入的列表中的每一个元素实例化为一个节点，并且实例化一个节点后，需要修改尾结点指向，将尾结点的 next 指向当前的元素节点，尾结点赋值为当前元素节点，目的是为了，下一个元素节点进来后，让前一个元素的 next 可以指向自己，并且为了将 next 去指向后面可能还有的元素节点，所以将尾结点赋值为当前加入的节点</p>
<p>​    Linklist 类中的 print_linklist 方法是为了将元素通过调用节点的 next 进行一一输出，因为在建立节点是，为了清晰一些，给 head 的头节点，也就是整个链表的第一个节点赋上 0 这个值，所以方法中做了一步 p = self.head.next，来从第二个节点去开始遍历</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>​    队列同样分好几种，常见的有先进先出，优先级队列等等，同样可以用 collections 模块和内置的 list 去实现，但是如果利用 list 去实现队列，要实现比如在最前面插入一个元素，那么就需要原来的所有元素后移，将位置让出后进行插入，相对而言就会比较麻烦</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.queue = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft()     <span class="comment"># FIFO 先进先出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">q.append(<span class="number">1</span>)</span><br><span class="line">q.append(<span class="number">2</span>)</span><br><span class="line">q.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(q.pop())      <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(q.pop())      <span class="comment"># 2 </span></span><br><span class="line"><span class="built_in">print</span>(q.pop())      <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(q.empty())    <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>​    是一种和 队列 非常相似的结构，与 FIFO 的队列不同，栈的元素存储和获取是一个 <strong>后进先出（LIFO）</strong>的效果，同样可以用内置的 list 和 collections 模块去实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = deque()    <span class="comment"># self.stack = []</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Stack()</span><br><span class="line">s.append(<span class="number">1</span>)   </span><br><span class="line">s.append(<span class="number">2</span>)</span><br><span class="line">s.append(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(s.pop())       <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(s.pop())       <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(s.pop())       <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(s.empty())     <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/3391672429/">http://example.com/3391672429/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/4093518221/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover13.JPG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">selenium 简单实例</div></div></a></div><div class="next-post pull-right"><a href="/4125439603/"><img class="next-cover" src="https://wei-foun.github.io/img/cover10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python2 与 python3 的区别</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/887545606/" title="LeetCode 原题"><img class="cover" src="https://wei-foun.github.io/img/cover18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-13</div><div class="title">LeetCode 原题</div></div></a></div><div><a href="/4125439603/" title="python2 与 python3 的区别"><img class="cover" src="https://wei-foun.github.io/img/cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-19</div><div class="title">python2 与 python3 的区别</div></div></a></div><div><a href="/864857163/" title="python基础语法-五"><img class="cover" src="https://wei-foun.github.io/img/cover19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-25</div><div class="title">python基础语法-五</div></div></a></div><div><a href="/3857016810/" title="python 基础语法-一"><img class="cover" src="https://wei-foun.github.io/img/singstreet.JPG" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-27</div><div class="title">python 基础语法-一</div></div></a></div><div><a href="/997618812/" title="python 基础语法-二"><img class="cover" src="https://wei-foun.github.io/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-30</div><div class="title">python 基础语法-二</div></div></a></div><div><a href="/1656529424/" title="python 基础语法-三"><img class="cover" src="https://wei-foun.github.io/img/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">python 基础语法-三</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">常用的内置数据结构和算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">线性结构和链式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">字典底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">4.1.</span> <span class="toc-text">哈希冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">解决方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%89%A9%E5%85%85"><span class="toc-number">4.3.</span> <span class="toc-text">哈希表扩充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Binary-Tree%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">二叉树（Binary Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Binary-Search-Tree%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">二叉搜索树（Binary Search Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL-Tree%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">平衡二叉树（AVL Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">7.1.</span> <span class="toc-text">平衡二叉查找树和散列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">B 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">10.</span> <span class="toc-text">B+ 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LruCache-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">LruCache 缓存算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.</span> <span class="toc-text">利用内置数据结构实现更高级的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.1.</span> <span class="toc-text">链表实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">12.2.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">12.3.</span> <span class="toc-text">栈</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/466764255/" title="airflow整理"><img src="https://wei-foun.github.io/img/cover47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="airflow整理"/></a><div class="content"><a class="title" href="/466764255/" title="airflow整理">airflow整理</a><time datetime="2025-07-12T07:04:30.000Z" title="发表于 2025-07-12 15:04:30">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux再学习"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux再学习"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux再学习">Linux再学习</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4075015966/" title="GO 基础"><img src="https://wei-foun.github.io/img/cover45.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO 基础"/></a><div class="content"><a class="title" href="/4075015966/" title="GO 基础">GO 基础</a><time datetime="2025-07-04T16:26:58.000Z" title="发表于 2025-07-05 00:26:58">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4209932858/" title="docker 容器网络"><img src="https://wei-foun.github.io/img/cover44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker 容器网络"/></a><div class="content"><a class="title" href="/4209932858/" title="docker 容器网络">docker 容器网络</a><time datetime="2023-07-04T16:26:58.000Z" title="发表于 2023-07-05 00:26:58">2023-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4253636491/" title="kubernetes-搭建"><img src="https://wei-foun.github.io/img/cover43.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kubernetes-搭建"/></a><div class="content"><a class="title" href="/4253636491/" title="kubernetes-搭建">kubernetes-搭建</a><time datetime="2023-03-19T10:39:02.000Z" title="发表于 2023-03-19 18:39:02">2023-03-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover11.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>