<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mysql-整理-三 | </title><meta name="keywords" content="mysql"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="性能角度：唯一索引和普通索引的选择  ​    以该图为例，从查询和更新两个角度分析两种索引的性能影响，ID 是唯一索引，k 是普通索引 查询过程1select id from T where id&#x3D;5; ​    在这个查询语句中，会从索引树的根节点开始，按层搜索到叶子节点，最后得到图中右下角的数据页，再使用二分法的在数据页中进行内部查找来定位记录 ​    1）对于普通索引来说，在数据页中查找">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql-整理-三">
<meta property="og:url" content="http://example.com/1674812330/index.html">
<meta property="og:site_name">
<meta property="og:description" content="性能角度：唯一索引和普通索引的选择  ​    以该图为例，从查询和更新两个角度分析两种索引的性能影响，ID 是唯一索引，k 是普通索引 查询过程1select id from T where id&#x3D;5; ​    在这个查询语句中，会从索引树的根节点开始，按层搜索到叶子节点，最后得到图中右下角的数据页，再使用二分法的在数据页中进行内部查找来定位记录 ​    1）对于普通索引来说，在数据页中查找">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wei-foun.github.io/img/cover31.jpg">
<meta property="article:published_time" content="2021-03-12T15:21:35.000Z">
<meta property="article:modified_time" content="2025-04-01T17:58:07.128Z">
<meta property="article:author" content="Legacy">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wei-foun.github.io/img/cover31.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/1674812330/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql-整理-三',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-02 01:58:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-foun.github.io/img/cover31.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好收集</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mysql-整理-三</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-12T15:21:35.000Z" title="发表于 2021-03-12 23:21:35">2021-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-01T17:58:07.128Z" title="更新于 2025-04-02 01:58:07">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mysql-%E6%95%B4%E7%90%86/">mysql 整理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/mysql-%E6%95%B4%E7%90%86/mysql-%E6%A0%B8%E5%BF%83/">mysql 核心</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mysql-整理-三"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="性能角度：唯一索引和普通索引的选择"><a href="#性能角度：唯一索引和普通索引的选择" class="headerlink" title="性能角度：唯一索引和普通索引的选择"></a>性能角度：唯一索引和普通索引的选择</h2><p><img src="https://static001.geekbang.org/resource/image/1e/46/1ed9536031d6698570ea175a7b7f9a46.png" alt="img"> </p>
<p>​    以该图为例，从查询和更新两个角度分析两种索引的性能影响，ID 是唯一索引，k 是普通索引</p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from T where id=5;</span><br></pre></td></tr></table></figure>
<p>​    在这个查询语句中，会从索引树的根节点开始，按层搜索到叶子节点，最后得到图中右下角的数据页，再使用二分法的在数据页中进行内部查找来定位记录</p>
<p>​    1）<strong>对于普通索引来说，在数据页中查找到满足条件的第一条记录（5,500）后，还需要往后继续查找下一个记录，直到查找到的记录不满足 k = 5 这个条件为止</strong></p>
<p>​    2）<strong>对于唯一索引，由于唯一性设置，所以在查找到满足的第一条记录后便会停止继续往后的检索</strong></p>
<p>​    在 <strong>InnoDB 中，数据是按 数据页 为单位来读写的</strong>，当要读取一条记录的时候，并不会是将记录本身从磁盘进行读取，而是通过以页为单位，将页中的所有数据读取到内存中</p>
<p>​    因此，在使用普通索引情况下，查询 k=5 时，满足条件后的下一次判断的数据很大程度会在内存中，不过如果 k=5 是在这个页中的最后一条，就会相对麻烦一些，需要将下一页从磁盘读到内存在判断第一条是否是满足查询条件。但是，如果是整型字段，一个数据页几乎存放超过千个的 key，所以对于之前那个情况出现的概览会很低</p>
<p>​    <strong>所以在查询过程中，虽然普通索引比唯一索引要多出一个判断，但两者的性能差距并没有过于明显的差距</strong></p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>​     在 <strong>更新过程中，普通索引 会使用一个叫做 “change buffer”（写缓冲） 的东西，而唯一索引则不适用</strong></p>
<p>​    当需要更新一个数据页时，如果数据页存在于内存中，就直接更新；否则，在不影响数据一致性的前提下，<strong>InnoDB 会将更新的操作缓存到 change buffer，来减少对磁盘数据页的读取提升语句执行的速度</strong></p>
<p>​    同时，<strong>change buffer 数据读入时是会占用 buffer pool（缓冲池） 的</strong>，所以不能无限增大，可以通过参数 <code>innodb_change_buffer_max_size</code> 动态地设置占用的空间阈值，因此 change buffer 可以避免对内存的直接占用，提高内存使用率</p>
<p>​    <strong>当更新操作完成后，在查询时如果需要访问这个数据页，则将数据页读入内存中，再执行 change buffer 中与这个页有关的操作，以此来保证数据逻辑的正确性，这个过程称为 merge</strong></p>
<p>​    由此 change buffer 实际是一个可以持久化的数据，除了使用 <strong>查询时会触发 merge，系统也会定期来执行 merge</strong>，包括数据库关闭前也会执行该操作</p>
<p>​    <strong><em>merge 的流程步骤：</em></strong></p>
<p>​    <em>1）从磁盘读取老版本的数据页到内存中</em></p>
<p>​    <em>2）在 change buffer 中找到该数据页的记录，将其应用来生成新版本的数据</em> </p>
<p>​    <em>3）将 数据变更 和 change buffer 的变更写入 redo log。此时，数据页和内存中 change buffer 对应磁盘的位置都还没进行修改，所以是脏页，而在这之后会各自刷自己的物理数据进行修改</em></p>
<pre><code>对于唯一索引来说，更新的操作之前会先判断该操作是否违反了唯一性的约束，因此会先将数据页读入到内存才能去判断，而仅对更新这一步而言，由于数据页已经在内存了，所以直接在内存中更新会很快，由此 **唯一索引不使用 change buffer**</code></pre><p>​    所以，对于更新的过程会有两种情况：</p>
<p>​    <strong>当前更新的数据所在数据页，在内存中</strong></p>
<p>​    1）唯一索引，找到数据插入的位置，判断是否违反约束，没有则插入值，执行结束</p>
<p>​    2）普通索引，找到数据插入的位置后，将值插入，执行结束</p>
<p>​    <strong>当前更新的数据所在数据页，不在内存中</strong></p>
<p>​    1）唯一索引，将数据页先读取到内存中，在没有冲突情况下，插入值，执行结束</p>
<p>​    2）<strong>普通索引，将更新的记录存入 change buffer ，执行结束</strong></p>
<p>​    <strong>当目标数据页在内存中时，唯一索引 和 普通索引 更新过程的效率上没有明显的区别，但是当目标数据页不在内存中时，使用 change buffer 的 普通索引 在更新上的性能会有很明显的提升</strong>，所以当执行 merge 真正做更新时，change buffer 记录下来的数据变更动作越多，更新的收益也就越大</p>
<p>​    因此对于 <strong>写多读少的业务</strong>，也就是数据写完后被立即访问的概率很小的情况下，<strong>利用 change buffer 的效果最好，类似的场景有账单类，日志类的系统</strong>；相反，如果数据更新后会被马上查询，就算使用了 change buffer 来记录变更，但由于紧随的查询语句，会立刻触发 merge 过程，从而在 随机IO 的次数并不会减少，同时还增加了 change buffer 的维护</p>
<h3 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log  和  change buffer"></a>redo log  和  change buffer</h3><p>​    <strong>redo log（重做日志）</strong>的目的是为了提高执行效率减少随机访问，对每一条执行的语句会先将操作记录到日志中，然后在适当时会按照日志记录写入进磁盘（WAL，write-ahead logging）</p>
<p>​    <strong>change buffer（写缓存）</strong>目的同样是为了减少随机访问，只不过会在内存中将操作记录起来，并且根据目标所在数据页是否在内存中，决定是直接内存中修改还是从磁盘读取后再修改</p>
<p>​    假如执行  <code>insert into t(id,k) values(id1,k1),(id2,k2);</code> 语句，并且加入查找 k 的索引树后，k1 所在的数据页是在 change buffer 中，而 k2 所在的数据页不在内存中，所以这行语句会涉及四个部分：内存，redo log（ib-log-fileX），数据表空间（t.ibd），系统表空间（ibdata1）</p>
<p><img src="https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png" alt="img"> </p>
<p>​    执行语句后会有以下的操作：</p>
<p>​    1）直接在内存中对 k1 所在的数据页 Page1 中，将数据插入</p>
<p>​    2）k2 所在的 Page2 不在内存，change buffer 将操作记录写入内存</p>
<p>​    3）redo log 将两个语句（一个是在内存中 k1 的插入，一个是数据页不在内存的 k2 使用 change_buffer 操作）操作写入到日志中，并且是按照顺序写的</p>
<p>​    虚线部分所指部分分别是：系统表空间，数据表空间，这两张表的操作都是后台完成，不会影响语句的响应时间，因此整个语句执行成本很低，只是写了两处内存，同时两处写操作被一起写磁盘到 redo log</p>
<p>​    此时，如果查询语句是发生在更新语句后不久，内存中假设数据都还存在，进行查询  <code>select * from t where k in (k1,k2);</code></p>
<p><img src="https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png" alt="img"> </p>
<p>​    图中可以看到，在读到 Page1 的时候，是直接从内存中将需要的数据进行返回，所以并不一定要从 redo log 将数据更新到磁盘上，再从磁盘读取</p>
<p>​    当在读 Page2 时，是将其读到内存中，并应用了 change buffer 里的操作记录，直接的生成正确的数据版本返回，因此只有在需要去读 Page2 中的数据时才会将其引入内存</p>
<p>​    所以，<strong>redo log 主要节省的是磁盘写入的 随机IO 消耗（转成顺序写）</strong>；<strong>change buffer 节省的则是随机读磁盘的 IO 消耗</strong></p>
<h2 id="索引有时候为什么会寻错"><a href="#索引有时候为什么会寻错" class="headerlink" title="索引有时候为什么会寻错"></a>索引有时候为什么会寻错</h2><p>​    其实在大所述的情况下，当语句来到优化器这一步时，优化器都可以选择正确的索引，但依然会有出现原本执行速度很快，但实际执行却比预期慢很多的情况</p>
<p>​    现在建一张表，除主键id外，另有a，b两个字段，分别创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`),</span><br><span class="line">  KEY `b` (`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB；</span><br></pre></td></tr></table></figure>
<p>​    接着往表中插入10万行的记录，按（1,1,1），（2,2,2）… （100000,100000,100000）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">100000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>​    接着，执行一条对 a 字段的查询语句，通过   <code>explain</code> 分析后，得到结果可以看到索引使用了 a 的索引，且强制使用索引 a 去查询得到扫描行数和这个结果是一样的都是 10001 行</p>
<p><img src="https://static001.geekbang.org/resource/image/2c/e3/2cfce769551c6eac9bfbee0563d48fe3.png" alt="img"> </p>
<p>​    但是如果使用两个事务 session A 和 session B，在 session B 中将所有数据删除后，再将数据添加回来，同时依然使用分析语句去执行查询</p>
<p><img src="https://static001.geekbang.org/resource/image/1e/1e/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" alt="img"> </p>
<p>​    通过   <strong>慢查询日志（slow log，通过 <code>long_query_time</code> 设置）</strong>去查看执行情况，并且为了对比是否出现索引选择错误，执行两个相同的查询，但是其中一个 <strong>使用 <code>force index（a）</code> 来强制让优化器使用 索引a</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">0</span>;   <span class="comment">-- 大于 0 秒的执行都会记录到慢查询日志</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t force index(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>
<p>​    <code>long_query_time=0</code> 来设置慢查询日志的阈值为 0，让这个线程接下来的语句都会被记录在慢查询日志中</p>
<p><img src="https://static001.geekbang.org/resource/image/7c/f6/7c58b9c71853b8bba1a8ad5e926de1f6.png" alt="img"> </p>
<p>​    最后的结果中，可以看出使用原来的查询语句出现了索引使用错误的问题，Q1 的查询语句扫描了 10万行，对全表进行了扫描，而 Q2 强制使用 索引a ，则和之前的一样，扫描了 10001 行，且两者的查询时间也相差近一倍，所以前一条查询优化器使用错了索引，导致查询的时间变长</p>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>​    对于优化器而言，就是选择适合的索引，找到一个最优的执行方案，用最小的代价去执行语句。在数据库里，扫描行数值影响执行代价的因素之一，<strong>扫描的行数越少，意味着对磁盘的访问会越少，对 CPU 资源的消耗就越少</strong></p>
<p>​    但是扫描行数并不是唯一的影响因素，优化器还会结合是否使用临时表，是否排序等因素进行综合判断，上面的例子中很明显问题是在扫描行数</p>
<p>​    在 MySQL 执行语句之前，其实也不能精确地知道满足条件的搜索条件的记录会有多少条，而是通过根据统计信息去估算大概的扫描记录数。至于这个统计的信息就是索引的 “区分度”，同一个索引上的值越多，这个索引的区分度就会越好，<strong>索引上不同的值的个数，称为 “基数”（cardinality），所以也就是基数越大，相对索引的区分度越好</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t；  <span class="comment">-- show index 可以查看表的中索引的基数</span></span><br></pre></td></tr></table></figure>
<p><img src="https://static001.geekbang.org/resource/image/16/d4/16dbf8124ad529fec0066950446079d4.png" alt="img"> </p>
<p>​    返回的信息可见，即使该表的三个字段的值都是一样的，但统计信息的 基数值 最后可能会出现不同的情况</p>
<h3 id="索引基数"><a href="#索引基数" class="headerlink" title="索引基数"></a>索引基数</h3><p>​    在 MySQL 中会使用采样统计的方式去计算基数，因为如果是整表每一行记录去进行统计，代价太大了，<strong>InnoDB 通过采样统计方式默认会选择 N 个 数据页，去统计这些页上的不同值，并算出一个平均值，再去乘以这个索引的页面数，来得到最后的索引的基数值</strong></p>
<p>​    由于数据表是会持续性更新的，因此索引统计信息也会随之改变，<strong>当变更的数据行数超过 1/M 的时候，会自动触发一次重新统计索引</strong>，在 MySQL 中有两种存储索引统计的方式，是可以通过参数 <code>innodb_stats_persistent</code> 来选择的：</p>
<p>​    1）设置 <strong>on</strong> 状态，<strong>表示统计信息会持久化存储，此时默认的 N 是 20，M 是 10</strong></p>
<p>​    2）设置 <strong>off</strong> 状态，<strong>表示统计信息只在内存中存储，此时默认的 N 是 8，M 是 16</strong></p>
<p>​    但是由于索引统计是采样统计方式，所以两种方式无论 N 这个数据页取多少，所得到的基数都很容易不准，而且索引的统计只是一个输入，对具体语句来说，优化器还需要判断语句本身会扫描的行数</p>
<p><img src="https://static001.geekbang.org/resource/image/e2/89/e2bc5f120858391d4accff05573e1289.png" alt="img"> </p>
<p>​    从图中可以看到第一个语句扫描行数是 104620 行，如果使用错了索引这个值是符合预期的；但是后一个语句的扫描行数从之前显示的 10001 行 变为了 37116 行，很明显出现了偏差从而误导了优化器的选择，可即使是 37116 要小于 10 万行，可是优化器最后还是选择扫描是 10 万行的执行计划</p>
<p>​    因为优化器认为选择使用扫描 10 万行的执行计划，这些都是直接在主键索引上扫描的，没有回表操作，不需要额外的代价，使用 索引a，每一次的取值都必须回到主键索引上查找整行数据，优化器认为前者在主键索引上扫描更快，但是最后看执行时间却并不这样，要多近一倍时间</p>
<p>​    但是在一开始的查询中，同样优化器会考虑到普通索引回表的代价，但还是使用了 索引a，说明策略没有问题，所以问题就是因为扫描行数的错误，所以最后统计信息不对导致没有使用 索引a</p>
<p>​    <strong>统计的索引信息出现问题，可以使用 <code>analyze</code> 命令手动地重新统计</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze <span class="keyword">table</span> t;</span><br></pre></td></tr></table></figure>
<p>​    另一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>​    很显然这个查询语句没有满足的内容返回，但是优化器内部会如何选择索引？</p>
<p><img src="https://static001.geekbang.org/resource/image/1d/b9/1d037f92063e800c3bfff3f4dbf1a2b9.png" alt="img"> </p>
<p>​    从 索引a 和 索引b 的结构中图中看，如果是使用 索引a，扫描行数只需是 索引a 前面的 1000 个值，然后用得到的主键索引去回表取行，再根据 字段b 去一一过滤得到最后的返回</p>
<p>​    如果使用 索引b，则扫描行数是 50001 行，然后执行和 索引a 后续一样的操作，所以按理来说使用 索引a 会更快</p>
<p>​    使用 explain 来分析一下后，最终优化器选择了 索引b，最后扫描行数是 50198 行，所以依然选错了索引</p>
<p><img src="https://static001.geekbang.org/resource/image/48/b8/483bcb1ef3bb902844e80d9cbdd73ab8.png" alt="img"> </p>
<h3 id="索引异常的处理方式"><a href="#索引异常的处理方式" class="headerlink" title="索引异常的处理方式"></a>索引异常的处理方式</h3><p>​    <strong>1）使用 <code>force index</code> 去指定索引</strong></p>
<p>​    强制优化器按照指定索引去选择执行语句，不让优化器去评估其他的执行代价；但是使用这个语法会有局限性，如果索引名字发生更改，这个指定也必须更改，并且如果出现数据库迁移，这个语法很可能会有不兼容的情况</p>
<p>​    <strong>2）引导优化器选择正确的索引</strong></p>
<p>​    上面的例子中，优化器放弃使用 索引a，说明 a 对于优化器来说相比 b 来说不够适合使用，可以将 <code>order by b limit 1</code> 改成 <code>order by b,a limit 1</code></p>
<p>​    之前优化器使用 索引b，因为对优化器来说   <code>order by b</code> 使用 索引b 可以避免排序，因为 b 本身是索引且有序，选择 b 就不要排序只要遍历且取出第一行，所以对优化器认为这个代价相对更小</p>
<p><img src="https://static001.geekbang.org/resource/image/14/94/14cd598e52a2b72dd334a42603e5b894.png" alt="img"> </p>
<p>​    <code>order by b,a</code> 这样的写法意味着这两个索引字段都需要排序，所以扫描行数就成了影响决策的主要条件，优化器就会选择 索引a，这样只用扫描 1000 行即可；但是这个修改依然不是通用的，之所以在这个语句里有效，因为查询语句指定了返回结果 <code>limit 1</code>，在这个表中如果有满足条件的记录，<code>order by b limit 1</code> 和 <code>order by b,a limit 1</code> 所返回的都是 b 的值是最小的那一行，只有逻辑上是一致的，才能使用这种方式</p>
<p>​    除此之外，还有另一种修改方式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">100</span>) alias limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>​    这里用了子查询做了一张虚拟表，此外还使用   <code>limit 100</code> 来让优化器知道如果使用 索引b 的代价会很高，同样这样的修改也不具有通用性</p>
<p>​    <strong>3）可以创建新的更合适的索引，或者删除本身没有用的索引</strong></p>
<h2 id="给字符串的字段加索引"><a href="#给字符串的字段加索引" class="headerlink" title="给字符串的字段加索引"></a>给字符串的字段加索引</h2><p>​    在现在的用户登录中很多都支持使用邮箱登录，由此业务中会有对邮箱账号的查询 <code>select f1,f2 from User where email=&#39;xxx&#39;;</code> 的语句，但是这样的查询由于因为 email 字段没有索引，每执行一次都是以扫描全表的方式进行搜索</p>
<p>​    在 MySQL 中可以通过设置 <strong>前缀索引，可以将字符串的一部分作为索引，默认情况下如果不指定前缀长度，则该索引将会包含整个字符串</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> index index1(email);         <span class="comment">-- 整个字符串作为索引内容</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> index index2(email(<span class="number">6</span>));      <span class="comment">-- 字符串的前6个字符作为索引内容</span></span><br></pre></td></tr></table></figure>
<p>​    使用前缀索引显然会比整字符串作为索引要更节省空间，但是由此带来的是在查询上，前缀索引相比之下会增加额外的扫描次数</p>
<p>​    如果现在执行一个查询： <code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></p>
<p>​    对整字符串的索引 index1：</p>
<p>​    1）先从 index1 的索引树上找到满足条件的索引值，得到这个索引所记录的主键索引 id</p>
<p>​    2）回表到主键索引中找到指定的 id 所在行，判断 email 的值是否正确，正确就将记录加入结果集</p>
<p>​    3）继续从 index1 的索引树上取下一个索引值，判断不满足条件，循环结束</p>
<p>​    所以，使用全部的字符串作为索引内容，整个过程只去主键索引拿了一次数据，只扫描了一行</p>
<p>​    对于前缀索引 index2：</p>
<p>​    1）从 index2 的索引树上，从条件中取出前缀长度的字符串并查询匹配该字符串的记录，得到主键索引的 id</p>
<p>​    2）到主键上找到对应 id 的行，判断是否与条件的值是一样的，不一样则丢弃，一样则加入结果集</p>
<p>​    3）再次回到 index2 的索引树，从上一次的位置往下取一条记录，并且判断是否满足指定的前缀，并再次回表从主键索引上得到对应行，然后重复第2步，    </p>
<p>​    在这个过程中，匹配前缀是否满足的情况下，很有可能会扫描多行数据，如果前几个的字符串是一致的，因此使用前缀索引容易导致最后查询的次数变多，但是如果把前缀的长度增加，可能最后并不会增加太多的次数</p>
<p>​    <strong>总结：使用前缀索引，定义好长度，是可以做到既节省占用空间，也可以不用额外的去增加太多的查询（增加查询次数是必然的，但增加的多少取决于定义前缀的长度能有多大的区分）</strong></p>
<h3 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h3><p>​    实际上在建立索引时关注的就是区分度，区分度越高，也就意味重复的键值会越少，因此可以通过统计索引上有多少个不同的值取判断使用多长的前缀</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询在索引字段上有多少个不同的值</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> <span class="keyword">User</span>;</span><br><span class="line"><span class="comment">-- 然后可以依次选取不同的长度来统计不同长度得到值，比如统计4-7个字节的前缀索引</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>) <span class="keyword">as</span> L4),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>) <span class="keyword">as</span> L5),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>) <span class="keyword">as</span> L6),</span><br><span class="line">	<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>) <span class="keyword">as</span> L7),</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">User</span>;</span><br></pre></td></tr></table></figure>
<p>​    前缀索引只是选取了局部的字符串去做匹配，所以肯定会损失区分度，因此在统计前可以预先设定一个理想化可接受的损失比例，比如 5% 等，然后在返回 L4-L7 中，找出不小于 L * 95% 的值，如果其中 L6 和 L7 都满足得到化，就可以选择 L6 做最后的前缀索引</p>
<h3 id="使用前缀索引对覆盖索引的影响"><a href="#使用前缀索引对覆盖索引的影响" class="headerlink" title="使用前缀索引对覆盖索引的影响"></a>使用前缀索引对覆盖索引的影响</h3><p>​    上面的例子中，使用了整个字符串的索引和前 6 个字符的前缀索引，在知道前缀索引是会增加扫描行数后，这已经是影响性能的一点</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,email <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;windows98@xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>​    对于这个查询语句，只要求返回的结果包含主键 id 和 email 字段，<strong>index1 使用整个字符串做 email 索引，就会利用到覆盖索引，因为在 email 索引树上找到对应的值后就可以获取到记录的主键 ID，所以就不需要回到 id 的索引上再去查询一次</strong>；而 index2 使用的前缀索引，就不得不回到 id 索引上找到对应行去判断 email 的字段的值一致</p>
<p>​    需要知道的是，就算 index2 直接使用完整的前缀索引，<strong>将整个字符串长度作为前缀值，比如将 email 索引改为 <code>email(17)</code>，但是查询时由于系统不确定前缀索引的定义是否是截断了完整信息，因此依然会回到 id 索引树进行查找</strong></p>
<p>​    简而言之，设置 前缀索引 时需要考虑到是有 覆盖索引 的优化，完整字符串做前缀索引时，如果查询字段可以在完整字符的前缀索引，就会利用到索引覆盖直接获取到字段的值</p>
<h3 id="前缀索引的多种方式"><a href="#前缀索引的多种方式" class="headerlink" title="前缀索引的多种方式"></a>前缀索引的多种方式</h3><p>​    相比对邮箱使用前缀索引来说，对于例如身份证号，不仅长度更长，且其中前6位使地址码会有大量的相同情况，如果对此使用长度是6的前缀索引，那这个区分度就相对非常低了。但是如果增加长度，需要加到12位，才能满足区分度要求的话，这个字符串索引所占用的空间就会大很多，所以可以通过其他方式去实现这样的索引</p>
<p>​    <strong>1）使用倒序存储</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询时，使用 reverse 将字符串反转</span></span><br><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card <span class="operator">=</span> reverse(<span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>​    将身份证在存储时就先将其翻转，使用倒序的值来存储，由于身份证的后六位不像前六位的地址码不会有重复的逻辑，所以这样使用 6 个字符的长度做前缀索引也能提供足够的区分度，但是在此之前依然是使用 <code>count(distinct)</code> 方法去验证</p>
<p>​    <strong>2）增加一个字段，使用 hash 值存储</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>​    在插入数据时，对身份证号使用   <code>crc32()</code> 函数得到一个校验码并存储到 hash 的字段上，但是 hash 也会有 hash 冲突的可能，由此在查询语句时 where 条件需要判断 id_card 的值是否完全一致</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> filed <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> id_card_crc <span class="operator">=</span> crc32(<span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span>)</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">id_card<span class="operator">=</span><span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>​    对比 倒序存储 和 增加 hash 字段两种方式</p>
<p>​    相同点：<strong>两者都不能支持范围的查询</strong>，只能支持等值的查询语句</p>
<p>​    不同点：</p>
<p>​        1）在占用空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，但是增加 hash 字段方式会要多出一个字段的空间；不过使用倒序索引方式前缀的长度相比 hash 后的长度可能会要大一些，这一点来说两者的消耗可能是差不多的</p>
<p>​        2）在 CPU 消耗方面，倒序存储在读和写都要使用函数 reverse，而 hash 字段的方式也会需要额外使用 crc32 这个函数，从两个函数的复杂度看，前者会比后者消耗资源少一些</p>
<p>​        3）查询效率上，hash 字段方式的查询性能会更稳定一些，即使使用 crc32 后会有冲突的概览，但是这个概率本身来说非常低，可能每次平均的扫描行数是接近 1 行的；如果是倒序存储方式，就依然是前缀索引的问题，增加扫描行数是必然的</p>
<h2 id="MySQL-刷页"><a href="#MySQL-刷页" class="headerlink" title="MySQL 刷页"></a>MySQL 刷页</h2><p>​    刷页的目的就是为了将正确的数据更新到磁盘上进行存储，但是有时候可能会出现很灵异的现象就是一个语句的执行突然间变慢且是随机性的，持续的时间也非常短，出现这个问题的可能原因就是数据库是在刷 “脏页”</p>
<p>​    <strong>脏页，即内存中的数据页和磁盘的数据页内容不一致时，该数据页就是 “脏页”</strong>，<strong>当内存数据写入到磁盘后，内存和磁盘数据页一致，此时内存中的该数据页就是 “干净页”</strong></p>
<p>​    数据库每当需要   <code>flush</code> 脏页的时候，会将内存的脏页覆盖到磁盘的数据页上，而这个过程不会涉及 redo log。对于更新而言，首先根据 WAL 技术，将操作按顺序记录到 redo log，并在内存中生成新版本数据，当触发刷脏页时，将内存的数据页刷到磁盘上，这样一来通过 WAL 实现了原本的 随机写入 改为了 顺序写入，提升了效率。</p>
<p>​    但是，WAL 虽然将随机变成了顺序，却也由此导致内存中会产生 脏页，要实现内存与磁盘的数据一致，就需要进行 <code>flush</code></p>
<p><img src="https://static001.geekbang.org/resource/image/34/da/349cfab9e4f5d2a75e07b2132a301fda.jpeg" alt="img"> </p>
<h3 id="引发数据库-flush-过程的情况"><a href="#引发数据库-flush-过程的情况" class="headerlink" title="引发数据库 flush 过程的情况"></a>引发数据库 flush 过程的情况</h3><p>​    1）redo log 文件是有空间大小限制的，<strong>一旦 redo log 写满了，系统会停止掉所有的更新操作</strong>，并且 <strong>新的操作过程想要记录，就必须擦除掉旧的记录</strong>，留出空位来保存新的记录。不过，在擦除之前必须要先将正确的数据更改到磁盘上，图中浅绿色部分即将要擦除的脏页这部分将执行 flush 到磁盘，最后 write pos - cp’ 的区域就是可以写入新的 redo log 的区域</p>
<p><img src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg" alt="img"> </p>
<p>​    2）就是系统的内存空间不足，此时需要新的内存页（即从磁盘读取新的数据页到内存），而内存不够用的时候，就会淘汰一部分数据页，将空出的内存空间给其他的数据页使用。如果淘汰的是脏页，就会先将脏页写入磁盘，这么做可以确保每一个数据页有两种状态：</p>
<ul>
<li><p>数据页在内存中存在，那内存中的肯定是正确的结果，可以直接返回</p>
</li>
<li><p>内存没有数据，那数据文件上的结果就是正确的，可以读取到内存返回，这样的效率最高</p>
<p>3）在系统认为处于 “空闲” 的状态下，会合理安排时间，每有适当的机会就刷一部分脏页</p>
<p>4）确定数据库需要关闭的情况下， MySQL 会把内存的脏页全部 flush 到磁盘上，在下一次启动 MySQL 的时候，就直接从磁盘上读数据，且启动速度会很快</p>
</li>
</ul>
<h3 id="四种情况的性能分析"><a href="#四种情况的性能分析" class="headerlink" title="四种情况的性能分析"></a>四种情况的性能分析</h3><p>​    对于上述的第三种情况，即 MySQL 空闲的时候进行刷页，这时的系统本身不会有什么压力；第四种情况是数据库关闭，这也不会产生什么性能问题，所以主要针对前两种</p>
<p>​    对于第一种 <strong>redo log 写满状态</strong> 下，进行 flush 刷页。这种情况是 InnoDB 要尽量避免的，因为发生这种情况，整个 <strong>系统就不能再接受更新了，且所有的更新都会阻塞住</strong></p>
<p>​    对于第二种内存不够用，会先将脏页写入磁盘。这是最常见的，InnoDB 用缓冲池 ( buffer pool) 来管理内存，<strong>缓存池中的内存页会有三种状态：</strong>    </p>
<p>​    <strong>1）还没有使用的；2）使用了且是干净页；3）使用了且是脏页</strong></p>
<p>​    在 InnoDB 的策略中时尽可能使用内存，因此对于一个长时间运行的库来说，未被使用的页会相对很少；而当需要读取新的数据页到内存中，就必须到缓冲池中申请一个数据页，这时内存不够用了就只能把很久不用的数据页从内存中先淘汰掉，在此之前会判断要淘汰的数据页是否是脏页还是干净页，前者在释放空间前会先写入磁盘，后者直接释放即可</p>
<p>​    通常情况下，淘汰的数据页大多会是脏页，此时进行刷页会有两种情况来影响性能，是必须要去避免的：    </p>
<p>​    1）如果需要淘汰的脏页个数太多，就会导致过程的响应时间会变长</p>
<p>​    2）另一种就是日志（redo log）写满，这就会导致更新全部堵住，写入性能降为 0</p>
<h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><p>​    在 InnoDB 中可以通过   <strong>参数 <code>innodb_io_capacity</code> 设置刷页的最大性能</strong>，这个值可以设置为磁盘的 IOPS (磁盘的每秒输入或输出的速度)，这个 IOPS 可以通过 fio 工具来测试</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio <span class="operator">-</span>filename<span class="operator">=</span>$filename <span class="operator">-</span>direct<span class="operator">=</span><span class="number">1</span> <span class="operator">-</span>iodepth <span class="number">1</span> <span class="operator">-</span>thread <span class="operator">-</span>rw<span class="operator">=</span>randrw <span class="operator">-</span>ioengine<span class="operator">=</span>psync <span class="operator">-</span>bs<span class="operator">=</span><span class="number">16</span>k <span class="operator">-</span>size<span class="operator">=</span><span class="number">500</span>M <span class="operator">-</span>numjobs<span class="operator">=</span><span class="number">10</span> <span class="operator">-</span>runtime<span class="operator">=</span><span class="number">10</span> <span class="operator">-</span>group_reporting <span class="operator">-</span>name<span class="operator">=</span>mytest </span><br></pre></td></tr></table></figure>
<p>​    对于刷页的性能来说，<code>innodb_io_capacity</code> 的值设置很重要，设置不准确很容易导致出现性能问题，比如写入很慢，但数据库 IO 的压力却不大</p>
<h3 id="刷页速度"><a href="#刷页速度" class="headerlink" title="刷页速度"></a>刷页速度</h3><p>​    <strong>对于 InnoDB 来说去刷磁盘的速度有两个因素：一个是脏页的比例，另一个是 redo log 写盘的速度</strong>；InnoDB 会分别单独算出这两个数值进行参考</p>
<p>​    <strong>脏页比例：可以通过参数 <code>innnodb_max_dirty_pages_pct</code> 设置，该值默认是 75%</strong>，InnoDB 会根据当前的脏页比例（ innodb_buffer_pool_drity /  innodb_buffer_pool_pages_total ），算出一个范围在 0 - 100 之间的数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当前的脏页比例</span><br><span class="line">select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_dirty&#x27;;</span><br><span class="line">select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME = &#x27;Innodb_buffer_pool_pages_total&#x27;;</span><br><span class="line">select @a/@b;</span><br><span class="line"></span><br><span class="line"># 脏页比例的阈值计算</span><br><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;   # 即 100%，以最大性能出进行刷页</span><br><span class="line">  return 100*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    日志的写入速度：InnoDB 会给每条日志记录给一个序号，通过当前的该序号的值与 checkpoint 对应的序号值计算一个差值，再通过一个计算公式得到一个 0 - 100 的数字，计算结果随差值的增大而增大</p>
<p>​    最后，计算得到两个值后，系统会取较大的值记为 R，再根据   <code>innodb_io_capacity</code> 的定义参数乘以 R% 来控制刷脏页的速度</p>
<p><img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" alt="img"> </p>
<p>​    所以，当 InnoDB 在后台刷脏页，将内存页写入磁盘的过程中，如果出现需要淘汰脏页或是刷脏页的逻辑占用 IO 资源都会影响到更新效率。所以需要合理设置 <code>innodb_io_capacity</code> 的值，且需要去关注脏页的动态，<strong>尽可能不要触及默认的 75% 这个阈值</strong></p>
<p>​    <strong>补充</strong></p>
<p>​    MySQL 8.0 以前的版本中，会有一个机制去判断要 flush 掉的脏页，是否相邻的数据页也是脏页，如果是的话，就会把这个相邻脏页一起刷掉。但是这个机制还会像递归一样会往下蔓延，只要相邻的是脏页，就会被加入到被刷的行列里，这对于机械硬盘来说是一个减少 IO 的优化，但对于 SSD 这种 IOPS 高的设备来说会是一个导致语句执行变慢的一个原因</p>
<p>​    在 InnoDB 中，参数   <code>innodb_flush_neighbors</code> 可以控制这个行为，参数值为 1 表示启用上述的机制，参数值为 0 则在刷页时，只会对自己进行刷页，8 的版本中已经默认设置为 0</p>
<h2 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h2><p>​    数据库中的表由两部分组成：表结构定义和数据，<strong>8.0 以前的版本，表结构都是存在 “.frm” 为后缀的文件中，从 8.0 开始，允许将表结构的定义内容放在系统数据表中</strong>，因为相比数据来说表结构定义占用的空间非常小</p>
<p>​    在   <strong>InnoDB 中，表的数据有两种方式存储：共享表空间 或者 独立的文件</strong>，可以通过 <strong>参数 <code>innodb_file_per_table</code> 来控制，自从 5.6.6 版本之后，该参数的默认值就是 ON</strong></p>
<p>​    1） 参数的值为 <strong>OFF，表示将数据放在共享表空间，也就是与数据字典放在一起</strong></p>
<p>​    2） 参数的值为 <strong>ON，会将每一个表的数据单独存储在以 “.ibd” 后缀的文件中</strong></p>
<p>​    第二种以单独文件存储的方式更加容易管理，而且如果不需要某个表，使用   <code>drop table</code> 就可以删除这个数据文件，使用第一种方式 <strong>存储在共享表空间，即使表被删除，空间也不会被回收</strong></p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p>​    InnoDB 中的数据都是以 B+树 结构来组织的，如果此时需要 <strong>删除一行记录，InnoDB 引擎只会将删除的这一行标记为删除（即 “标记删除” ），在此之后如果需要插入一行记录，又恰好是在被标记删除这一行的位置上，那么新的记录就会复用这个位置，整个过程中磁盘的大小是不会发生缩小的</strong> </p>
<p>​    同理，因为 InnoDB 中数据是存储在数据页上的，如果将一个数据页上的所有数据删除，如果有新的数据写入，那么该 <strong>数据页也同样可以复用</strong>，<strong>但是数据页的复用与记录的复用是不同的</strong></p>
<p>​    <strong>记录的复用：前提新插入的数据是需要符合范围条件</strong> 的，比如图中如果将 R4 删除，此时新加入的数据的 id 必须是 300 - 600 之间，才可以直接复用之前标记删除的空位（空间位置），如果插入的 id 是 大于 600 ，就不能对空位进行复用</p>
<p><img src="https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png" alt="img"> </p>
<p>​    <strong>数据页的复用：</strong>当一个 <strong>数据页从 B+树 上被摘除，是可以在任何位置复用的</strong>，例如图中 page A 上的所有数据被删除，page A 会被标记可复用，这个时候新插入的数据不会关注 id 的值，即使是 50 也能使用 page A，此时该数据页就被复用了</p>
<p>​    类比：记录的复用相当于你给你的车买一个固定的停车位，以后不管你换了什么车都能停在这个车位上；数据页的复用就像路边的停车位，假如一个车位是一个数据页，当别人的车离开了，你就能使用这个车位</p>
<p>​    数据页的复用除了由于数据页上的数据全部被删除情况下会被标记可复用外，当相邻的两个数据页本身在利用率很低的情况下，系统也会将其中一个数据页的数据迁移到另一个数据页上，然后被迁移数据后的那个数据页同样会被标记为可复用</p>
<p>​    在表中删除一个数据记录，使用   <code>delete</code> 命令，如果是使用这个命令将一整表的数据删除，最后导致的情况就是数据页会被标记可复用，且磁盘上看到的文件大小不会变小，所以对于数据记录的删除，<strong><code>delete</code> 命令并不能将表空间进行回收</strong>，但是这些空间是可以被复用的，就像是个隐形的空洞一样</p>
<p>​    除了数据的删除之外，插入数据也可能会造成这样的现象。数据的插入如果是按照索引递增顺序插入，那么索引的结构是紧凑的，但是如果是随机插入，就可能会造成索引的数据页分裂</p>
<p><img src="https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png" alt="img"> </p>
<p>​    图中显示即为在原数据表中插入 id 为 550 的数据，在原本的数据页上 page A 是 300 - 600，550 位于其中间，所以如果想要保存就无法使用原来的 page A ，不得不去申请一个新的数据页 page B。page A 用来存储 300 - &lt; 550 的 id，page B 则从 550 - &lt; 700，所以 page A 的 id 是 600 的 R5 会存储到 page B，此时就是数据页的分裂。分裂完成后，在 page A 中就留下一个空位</p>
<p>​    更新的操作，就类似于删除旧的 id 数据，插入一个新的 id 数据，所以同样会造成空洞效果，<strong>也因此对于一个表来说，经过大量的增删改后，都是可能存在空洞的</strong>。对于这样的现象，即数据删除了但是最后所使用的的空间却没有释放，所以要想回收表空间，就必须要将空洞给去掉</p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>​    对于 表A 如果出现很多空洞，需要将空间收缩，就可以创建与 表A 结构相同的 表B，然后按照主键 ID 自增的顺序，将 表A 的数据一行行的读取写入到 表B。这样对 表A 来说 表B 就没有了空洞且数据一样，表B 的数据页利用率相对 表A 就会更高，当数据全部导入到了 表B，用 表B 去替换 表A，就起到了对 表A 的空间进行收缩的作用</p>
<p>​    <strong><code>alter table A engine=InnoDB;</code> 的命令可以实现重建表</strong>，在 5.5 版本之前该命令的流程和上述是差不多的，区别是上面的 表B 这个临时表不用自己创建，MySQL 会自动完成创建临时表、完成数据迁移，表名交换、删除旧表的整个操作</p>
<p><img src="https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png" alt="img"> </p>
<p>​    需要知道的是上述重建表的四个步骤中，比较耗时的就是第二步将数据插入到临时表中，而且在此步骤期间，一旦有新的数据要写入 表A ，这些新的数据就会丢失，因为一致性要求，第二步时 表A 会被加上DDL 锁，因此 表A 中不能有更新，通常也说这个 DDL 不是 Online 的；不过，在 5.6 版本开始就引入了 Online DDL</p>
<h3 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h3><p>​    Online DDL 相比原来的不能进行 online 的重建表做了部分优化处理，因此重建表的流程也有所不同：</p>
<p>​    1）首先 <strong>会建立一个临时文件</strong>（原来不能 online 的则是建立临时表），并扫描 表A 中主键的所有索引数据页</p>
<p>​    2）用数据页中 表A 的记录生成 B+树，存储到临时文件中</p>
<p>​    3）生成临时文件的过程中，期间所有对 表A 的操作会被记录在一个 row log 中</p>
<p>​    4）临时文件生成后，将 row log 日志文件中记录的操作应用到临时的文件，得到一个逻辑上与 表A 相同的数据文件</p>
<p>​    5）用临时文件替换 表A 的数据文件</p>
<p><img src="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png" alt="img"> </p>
<p>​    从图中可以看到，因为有了日志文件去记录和应用操作，这使得了 表A 可以在重建表的过程中依然能够提供增删改操作，这就是 Online DDL</p>
<p>​    <strong>需要注意的：</strong>    </p>
<p>​    <strong>在 <code>alter</code> 语句启动时，会获取 DDL 表级锁，而这个锁在最一开始得到就是 MDL写锁，目的是防止其他线程也对该表进行表结构等操作</strong>，在表级锁的时候提到 MDL 有 读锁 会和 写锁 有冲突，那为什么加的是 MDL写锁 的情况下，最后还能增删改？</p>
<p>​    这是因为 <strong>在 表A 将自己的数据拷贝到 临时文件 之前，MDL 写锁 会被退化成 读锁，这样就不会阻塞期间其他线程对 表A 的增删改操作</strong></p>
<p>​    在 MySQL 5.5 及之前的版本，Online DDL  的方法是会阻塞 DML（增删改查），且对于 Online DDL 这样的重建表可以通过在业务低峰期使用，来达到对表空间的回收</p>
<p>​    上面两种重建表的方式其实本质上都差不多，都会需要对原表进行扫描表结构，并建立临时文件或临时表，再将原记录进行插入。这些操作本身是非常消耗 IO 和 CPU 资源的，所以对于线上的服务，必须控制好整个操作时间，可以通过 <code>gh-ost</code> 去进行操作会比较安全</p>
<h3 id="online-和-inplace"><a href="#online-和-inplace" class="headerlink" title="online  和  inplace"></a>online  和  inplace</h3><p>​    DDL 中 “inplace” 和 “Online” 非常相似，但两者并不同</p>
<p>​    在非 online 的重建表中，数据会被从 表A 存储到临时表，而这个表由 server层 创建</p>
<p>​    online DDL 下，使用的是临时文件，但这是由 InnoDB 内部创建的，整个 DDL 过程都由 InnoDB 内部完成，因此对于 server层 来说，整个操作数据不是移动到临时表中，而像是一个 “原地” 操作，这就是 “inplace”</p>
<p>​    因此，对应 inplace 来说这样的方式是会对空间有所占用的，只是表面上 inplace 去看待拷贝数据时，认为了表中的数据自己做了一种更新</p>
<p>​    所以如果有一个 1TB 的表，而磁盘是 1.2TB，肯定是不能使用 inplace 的 DDL，因为其中临时文件是要占空间的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重建表语法，其实用的是 ALGORITHM=inplace</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span>inplace;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 但是 inplace 的重建表则是使用拷贝表的方式 ALGORITHM=copy</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t engine<span class="operator">=</span>innodb,ALGORITHM<span class="operator">=</span><span class="keyword">copy</span>;</span><br></pre></td></tr></table></figure>
<p>​    当使用   <code>ALGORITHM=copy</code> ，即强制拷贝表， 那么重建表的流程就是最开始的那张图，通过临时表做重建</p>
<p>​    但是，假如要给表去添加   <strong>全文索引</strong> <code>alter table t FULLTEXT(field_name);</code> 这个过程则是 inplace，因为会阻塞增删改的操作，因此 <strong>重建表的过程无法对数据进行操作，那这个 DDL 就是 非online 的</strong></p>
<p>​    <strong>总结：</strong></p>
<p>​    1）<strong>DDL 过程如果是 online 的，就一定是 inplace 的</strong></p>
<p>​    2）<strong>但是使用 inplace 的 DDL，不一定是 online 的</strong>。截止到 8.0 的版本，在添加 全文索引（ FULLTEXT index）和 空间索引（SPATIAL index）的情况下就是这样</p>
<p>​    3） <strong><code>alter table t engine=InnoDb</code> 重建表，不意味着一定将表中的空洞全部整理释放掉</strong>。当执行一次重建表之后，InnoDB 不会把整张表占满，每一个页会留出 1/16 用来后续的更新操作使用。所以一张表如果刚执行过了一次重建表，或者本身表中也没有什么空洞下，重建表反而会导致表占用的空间变大</p>
<p>​    <strong>补充：</strong></p>
<p>​    <code>alter table t engine=InnoDb</code> 即 recreate，在 5.6 开始默认就是 online DDL 的</p>
<p>​    <code>analyze table t</code> 即对表的索引信息进行重新统计， 不会修改数据，但是该过程会添加 MDL 读锁</p>
<p>​    <code>optimize table t</code> 相当于上面两个的联合，即 recreate + analyze</p>
<h2 id="count-变慢"><a href="#count-变慢" class="headerlink" title="count(*) 变慢"></a>count(*) 变慢</h2><p>​    当要统计记录总数，很容易就会想到使用 <code>select count(*) from t</code> 这个语句，但是这个语句往往随着系统中数据的增多，而执行的时间也会变长，并且对于 <code>count(*)</code> 的实现不同引擎也有所不同</p>
<h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)  的实现方式"></a>count(*)  的实现方式</h3><ul>
<li><p><strong>MyISAM 引擎会把表的总行数记录在磁盘上</strong>，所以对执行 <code>count(*)</code> 的时候会直接返回这个记录值，因此效率很高；如果这个语句加了 <code>where</code> 条件的话，依然不会很快地将值返回</p>
</li>
<li><p><strong>InnoDB 引擎在执行 <code>count(*)</code> 的时候，需要将数据一行行从引擎里面读出来，然后累积计数</strong></p>
<p><strong>注意：</strong>之所以 InnoDB 不像 MyISAM 一样记录一个总值，是因为 InnoDB 由于多版本并发控制（MVCC）的缘故，使得 InnoDB 的表在决定返回的具体行数是多少并不确定。比如，现在使用三个线程各自去执行统计行数，B 和 C 会在统计前各自插入一行记录在进行统计，但是两者执行插入的时间不同</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png" alt="img"> </p>
<p>​    这个例子默认以可重复读（RR）的隔离级别，即每一个事务的数据只会对自己的视图可见，因此最后三个线程完成后得到的统计值都不一样，但却是同一时刻执行查询统计。正是因为每一行记录被读取后都需要判断自己是否对当前会话可见，只有其中可见的行才会被加入进行计算得到最后表的总行数</p>
<p>​    不过 InnoDB 在执行 <code>count(*)</code> 的时候还是做了优化的，<strong>InnoDB 的主键索引树的叶子节点存储的都是数据，而普通索引树上的叶子节点存储的是主键值，所以相对而言普通索引树要主键索引树小很多</strong>，对于 <code>count(*)</code> 来说，遍历哪一个索引树得到的结果逻辑上都是一致的，所以优化器在选择时会使用最小的那一棵索引树进行遍历。<strong>保证逻辑正确的前提，尽量少的扫描数据量，是数据库系统设计的通用法则之一</strong></p>
<h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a>show table status</h3><p>​    使用 <code>show table status</code> 可以显示库中所有表的相关信息，其中会有一个记录行数的 <code>Rows</code> 的字段，但是这个数并不能准确表示该表的总记录数，因为这个值是一个估值，是有误差的</p>
<p>​    <strong>对于 MyISAM 来说，count(*) 在使用条件过滤情况下很快，但是该引擎不支持事务</strong></p>
<p>​    <strong>show table status 命令返回很快，但其中的行数统计并不准确</strong></p>
<p>​    <strong>InnoDB 的 count(*) 需拿全表来统计，结果准确但同时性能上会慢</strong></p>
<h3 id="缓存保存计数方式的可行性"><a href="#缓存保存计数方式的可行性" class="headerlink" title="缓存保存计数方式的可行性"></a>缓存保存计数方式的可行性</h3><p>​    通常情况下，对于一个更新频繁的服务，使用缓存来支持效率要高很多，但是使用 redis 去保存一个表的总行数是否真的可行？</p>
<p>​    首先，因为是缓存，那对其来说最主要的一点就是数据会丢失，也因此 redis 才会有数据持久化来将数据进行物理保存，但依然会有丢失的情况。如果在数据表中插入一行数据，redis 中对保存的总行数进行 +1 ，假如这时 redis 出现异常重启了，之后再去到 redis 中把该值读取时，会发现刚才的计数操作却丢失了</p>
<p>​    当然，对于这样的情况，可以在 redis 重启后，数据库单独执行一次   <code>count(*)</code> 来获取正确的行数并将该值交给 redis 保存。本身 redis 对于异常重启的情况概率就小，因此单独使用一次全表扫描，任然是可以接受的</p>
<p>​    其次，实际工作中即使在 redis 正常工作下，对于总行数的值依然会有逻辑不正确。对于 redis 来说，当有数据行插入后进行 +1 操作，或者是先自己 +1，然后数据库再写数据</p>
<p>​    但是对于并发下出现在 redis 操作之前，数据行已经插入之后，如果有事务执行了查询 redis 计数，就会导致这个值与实际不符</p>
<p><img src="https://static001.geekbang.org/resource/image/39/33/39898af053695dad37227d71ae288e33.png" alt="img"></p>
<p><img src="https://static001.geekbang.org/resource/image/5c/db/5c2f786beae1d8917cdc5033b7bf0bdb.png" alt="img"></p>
<p>​    反过来，如果只是将 会话A 的执行顺序互换，最后的结果也显而易见，会话B 返回的  redis 计数是正确了，但是最近的记录中，则没有了会话A 插入的记录</p>
<p>​    这就是因为使用两种不同存储的结构的系统，无法支撑分布式事务，因此不能拿到精确一致的视图</p>
<h3 id="直接数据库保存计数"><a href="#直接数据库保存计数" class="headerlink" title="直接数据库保存计数"></a>直接数据库保存计数</h3><p>​    通过上面使用缓存来存储总行数，可以发现依然会有数据丢失或计数不准确的情况，那就直接在数据中用一张表记录表的总行数，这样首先解决了崩溃丢失的问题，因为 InnoDB 支持崩溃恢复且不丢失数据，接下来就是考虑数据正确的问题</p>
<p>​    InnoDB 因为支持事务，导致表不能把 <code>count(*)</code> 直接保存，再通过查询去得到这个值。但利用事务的特性，可以解决掉之前 redis 因为执行先后问题出现返回不准确的情况</p>
<p><img src="https://static001.geekbang.org/resource/image/9e/e3/9e4170e2dfca3524eb5e92adb8647de3.png" alt="img"></p>
<p>​    在可重复读的隔离级别下，事务执行前会创建自己的视图，且视图中的操作记录未提交前都是只自己可见，所以图中 会话B 的返回的计数值读到的是 会话A 操作之前的数据，最新的记录也是一样</p>
<h3 id="count-的不同用法"><a href="#count-的不同用法" class="headerlink" title="count 的不同用法"></a>count 的不同用法</h3><p>​    <code>count()</code> 本身作为聚合函数，对于返回的结果集，会一行行去判断，如果 count 函数的参数不是 NULL，累计数就 +1，最后将累计数返回</p>
<p>​    <strong><code>count(*)</code>， <code>count(id)</code>，<code>count(1)</code> 都表示返回满足条件的结果集的总行数；count(字段)，则表示返回满足条件的数据里，参数 “字段” 不为 NULL 的总个数</strong></p>
<p>​    <code>count(id)</code> ：<strong>InnoDB 会遍历整张表，把每一行的 id 取出来交给 server 层</strong>，server 层得到后，判断 id 不可能为空的，就按行进行累加计数</p>
<p>​    <code>count(1)</code>：同样会 <strong>遍历整表，但是并不取值</strong>，server 层对于返回的 <strong>每一行，会放一个数字 “1” 进去</strong>，然后判断不可能为空的，按行累加</p>
<p>​    <code>count(字段)</code>：会 <strong>有两种情况判断</strong></p>
<p>​    1）<strong>参数字段的定义是 “not null”</strong>，server 层会一行行从记录中读取这个字段，判断不能为 null，就累加</p>
<p>​    2）<strong>参数字段的定义是允许为 “null”</strong>，在执行时判断到有可能是 null 的行，还要 <strong>把值取出来再判断一次，不是 null 的话才累加</strong></p>
<p>​    <strong><code>count(*)</code> ：不会取出全部字段</strong>，而专门做了优化（<strong>选择最少的索引树遍历</strong>），判断肯定不是 null 的，就按行累加</p>
<p>​    所以，按照效率排序的话，<strong>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/1674812330/">http://example.com/1674812330/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"><div class="social-share" data-image="https://wei-foun.github.io/img/cover31.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/882465098/"><img class="prev-cover" src="https://wei-foun.github.io/img/cover32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript 基础</div></div></a></div><div class="next-post pull-right"><a href="/3714377604/"><img class="next-cover" src="https://wei-foun.github.io/img/cover30.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis 整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/1772758044/" title="关于MySQL的一些问题"><img class="cover" src="https://wei-foun.github.io/img/cover41.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-26</div><div class="title">关于MySQL的一些问题</div></div></a></div><div><a href="/1895144058/" title="Mysql 整理"><img class="cover" src="https://wei-foun.github.io/img/cover9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-15</div><div class="title">Mysql 整理</div></div></a></div><div><a href="/3927654560/" title="Mysql-整理-二"><img class="cover" src="https://wei-foun.github.io/img/cover26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-22</div><div class="title">Mysql-整理-二</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Legacy</div><div class="author-info__description">冒险的生涯在召唤！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Live a life you will remember</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%A7%92%E5%BA%A6%EF%BC%9A%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.</span> <span class="toc-text">性能角度：唯一索引和普通索引的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">更新过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E5%92%8C-change-buffer"><span class="toc-number">1.3.</span> <span class="toc-text">redo log  和  change buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BB%E9%94%99"><span class="toc-number">2.</span> <span class="toc-text">索引有时候为什么会寻错</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.</span> <span class="toc-text">优化器的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">索引基数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">索引异常的处理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">给字符串的字段加索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E9%95%BF%E5%BA%A6"><span class="toc-number">3.1.</span> <span class="toc-text">前缀长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.2.</span> <span class="toc-text">使用前缀索引对覆盖索引的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">前缀索引的多种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E5%88%B7%E9%A1%B5"><span class="toc-number">4.</span> <span class="toc-text">MySQL 刷页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%8F%91%E6%95%B0%E6%8D%AE%E5%BA%93-flush-%E8%BF%87%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.1.</span> <span class="toc-text">引发数据库 flush 过程的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">四种情况的性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E5%88%B7%E8%84%8F%E9%A1%B5%E7%9A%84%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.</span> <span class="toc-text">InnoDB 刷脏页的控制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E9%A1%B5%E9%80%9F%E5%BA%A6"><span class="toc-number">4.4.</span> <span class="toc-text">刷页速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6"><span class="toc-number">5.</span> <span class="toc-text">数据库表的空间回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">数据删除流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%BB%BA%E8%A1%A8"><span class="toc-number">5.2.</span> <span class="toc-text">重建表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Online-DDL"><span class="toc-number">5.3.</span> <span class="toc-text">Online DDL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#online-%E5%92%8C-inplace"><span class="toc-number">5.4.</span> <span class="toc-text">online  和  inplace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E5%8F%98%E6%85%A2"><span class="toc-number">6.</span> <span class="toc-text">count(*) 变慢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#count-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">count(*)  的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#show-table-status"><span class="toc-number">6.2.</span> <span class="toc-text">show table status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BF%9D%E5%AD%98%E8%AE%A1%E6%95%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">缓存保存计数方式的可行性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E5%AD%98%E8%AE%A1%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">直接数据库保存计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">count 的不同用法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/466764255/" title="airflow整理"><img src="https://wei-foun.github.io/img/cover47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="airflow整理"/></a><div class="content"><a class="title" href="/466764255/" title="airflow整理">airflow整理</a><time datetime="2025-07-12T07:04:30.000Z" title="发表于 2025-07-12 15:04:30">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2133446919/" title="Linux再学习"><img src="https://wei-foun.github.io/img/cover46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux再学习"/></a><div class="content"><a class="title" href="/2133446919/" title="Linux再学习">Linux再学习</a><time datetime="2025-07-12T06:58:04.000Z" title="发表于 2025-07-12 14:58:04">2025-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4075015966/" title="GO 基础"><img src="https://wei-foun.github.io/img/cover45.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GO 基础"/></a><div class="content"><a class="title" href="/4075015966/" title="GO 基础">GO 基础</a><time datetime="2025-07-04T16:26:58.000Z" title="发表于 2025-07-05 00:26:58">2025-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4209932858/" title="容器网络"><img src="https://wei-foun.github.io/img/cover44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="容器网络"/></a><div class="content"><a class="title" href="/4209932858/" title="容器网络">容器网络</a><time datetime="2023-07-04T16:26:58.000Z" title="发表于 2023-07-05 00:26:58">2023-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/4253636491/" title="kubernetes-搭建"><img src="https://wei-foun.github.io/img/cover43.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kubernetes-搭建"/></a><div class="content"><a class="title" href="/4253636491/" title="kubernetes-搭建">kubernetes-搭建</a><time datetime="2023-03-19T10:39:02.000Z" title="发表于 2023-03-19 18:39:02">2023-03-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://wei-foun.github.io/img/cover31.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Legacy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
      appKey: 'K3d5HK6zRMD2BINwstEANt7H',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_親親":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再見":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_發怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_發財":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可愛":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_嘔吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_壞笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尷尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_驚嚇":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>